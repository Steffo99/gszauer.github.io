{"version":3,"names":[],"sources":["animator.cpp","../platform/assert.h","../platform/memory.cpp","../platform/window.cpp","../framework/sort.cpp","../framework/draw2d.cpp","../platform/graphics.h","../framework/vector.h","../framework/vec4.h","../debt/stb_truetype.h","../debt/stb_rect_pack.h","../platform/math.h","../framework/vec2.h","../framework/vec2.cpp","../framework/draw2d.h","../debt/stb_sprintf.h","imgui.cpp","imgui.h","../platform/window.h","Node2D.cpp","Document.cpp","Document.h"],"sourcesContent":["#include \"../platform/memory.h\"\n#include \"../platform/assert.h\"\n#if MEM_PLATFORM_WASM\n// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    __wasm_call_ctors();\n}\n\nextern \"C\" void _cxa_pure_virtual() {\n    PlatformAssert(false, __LOCATION__);\n}\n\nextern \"C\" void __cxa_pure_virtual() {\n    PlatformAssert(false, __LOCATION__);\n}\n\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\" \n#else\n#define export extern \"C\"\n#endif\n\n#include \"../platform/platform.h\"\n#include \"../platform/memory.h\"\n#include \"../debt/stb_vorbis.h\"\n#include \"../debt/stb_image.h\"\n#include \"../debt/stb_truetype.h\"\n#include \"../framework/vec2.h\"\n#include \"../framework/vec3.h\"\n#include \"../framework/vec2.h\"\n#include \"../debt/fast_obj.h\"\n#include \"../framework/vector.h\"\n#include \"../framework/draw2d.h\"\n#include \"../debt/stb_sprintf.h\"\n#include \"imgui.h\"\n#include \"Node2D.h\"\n#include \"Document.h\"\n\n#if MEM_PLATFORM_WASM\n#include \"../platform/memory.cpp\"\n#include \"../platform/window.cpp\"\n#include \"../framework/sort.cpp\"\n#include \"../framework/draw2d.cpp\"\n#include \"../framework/vec2.cpp\"\n#include \"../debt/stb_vorbis.cpp\"\n#include \"../debt/stb_image.cpp\"\n#include \"../debt/stb_truetype.cpp\"\n#include \"../debt/stb_rect_pack.cpp\"\n#include \"../debt/stb_sprintf.cpp\"\n#include \"imgui.cpp\"\n#include \"Node2D.cpp\"\n#include \"Document.cpp\"\n\nWASM_LOADER_ENABLE_CALLBACKS\n#endif\n\n#define FONT_LOAD_ARENA_BYTES (1024 * 1024)\n\n#if _WIN32 & _DEBUG\n#define DOCUMENT_NUM_UNDO_STEPS 100\n#else\n#define DOCUMENT_NUM_UNDO_STEPS 1000\n#endif\n\nstruct Application {\n    Document* document;\n    StyleSheet style;\n\n    u32 iconFont;\n    u32 labelFont;\n    u32 interfaceFont;\n\n    u32 numFilesLoading;\n\n    float inspectorWidth;\n    float inspectorSplit;\n    float animationSplit;\n    float drawerHeight;\n\n    float hierarchyScroll;\n    u32 hierarchyTab;\n};\n\nstruct FontUserData {\n    Application* app;\n    u32* target;\n    const char* path;\n    void* data;\n};\n\nvoid LoadFont(Application* app, u32* target, const char* path) {\n    app->numFilesLoading += 1;\n\n    void* loadArena = MemAlloc(FONT_LOAD_ARENA_BYTES + sizeof(FontUserData));\n    FontUserData* fontData = (FontUserData*)((u8*)loadArena + FONT_LOAD_ARENA_BYTES);\n    fontData->app = app;\n    fontData->target = target;\n    fontData->path = path;\n    fontData->data = fontData + 1;\n\n    LoadFileAsynch(path, loadArena, FONT_LOAD_ARENA_BYTES, [](const char* path, void* data, unsigned int bytes, void* userData) {\n        FontUserData* fontData = (FontUserData*)((u8*)data + FONT_LOAD_ARENA_BYTES);\n        Application* app = (Application*)userData;\n        u32* target = fontData->target;\n\n        PlatformAssert(data != 0, __LOCATION__);\n        PlatformAssert(bytes != 0, __LOCATION__);\n\n        *target = Draw2D::LoadFont(data, bytes, true);\n        app->numFilesLoading -= 1;\n\n        /*if (app->numFilesLoading == 0) {\n            Imgui::Initialize(app->interfaceFont, app->iconFont);\n        }*/\n        }, app);\n}\n\n\nexport void* Initialize() {\n    WindowUpdateTitle(\"Animation tool\");\n    Draw2D::Initialize();\n\n    Application* app = (Application*)MemAlloc(sizeof(Application));\n    MemClear(app, sizeof(Application));\n    app->document = (Document*)MemAlloc(sizeof(Document));\n    MemClear(app->document, sizeof(Document));\n    new (app->document) Document(DOCUMENT_NUM_UNDO_STEPS);\n\n    app->style.menuBarHeight = 30.0f;\n    app->style.footerHeight = 25.0f;\n    app->style.toolbarWidth = 40.0f;\n    app->style.inspectorMinWidth = 300;\n    app->style.animatorMinHeight = 300;\n    app->style.menuTextLineHeight = 16;\n    app->style.headerHeight = 27;\n    app->style.headerFontSize = 14;\n    app->style.listBoxItemHeight = 20;\n    app->style.hierarchyLabelFontSize = 14;\n\n    app->style.menuBarBg = ColorRGB8(60);\n    app->style.footerBg = ColorRGB8(60);\n\n    app->style.toolBarBg = ColorRGB8(66);\n    app->style.tooltipIconBGColor = ColorRGB8(10, 10, 10);\n    app->style.tooltipIconFGColor = ColorRGB8(240, 240, 240);\n\n    app->style.tooltipTextColor = ColorRGB8(40);\n    app->style.tooltipTextBGColor = ColorRGB8(180);\n\n    app->style.documentBGColor = ColorRGB8(40, 40, 40); // Checker board can be 50, or 45\n    app->style.panelBgColor = ColorRGB8(70);\n    app->style.dividerAColor = ColorRGB8(55);\n    app->style.dividerBColor = ColorRGB8(85);\n    app->style.dividerHotTint = 1.1f;\n    app->style.dividerActiveTint = 0.8f;\n\n    app->style.headerBgColor = ColorRGB8(50);\n    app->style.hierarchyFooterBg = ColorRGB8(60);\n\n    app->style.HeaderBGHotColor = ColorRGB8(55);\n    app->style.HeaderBGActiveColor = ColorRGB8(60);\n\n    app->style.hierarchyToggleHot = ColorRGB8(210);\n    app->style.hierarchyToggleNormal = ColorRGB8(150);\n\n    app->style.headerFontColor = ColorRGB8(190);\n    app->style.hierarchyFooterButtonBG_Hot = ColorRGB8(60, 60, 60);\n    app->style.hierarchyFooterButtonBorder_Hot = ColorRGB8(50, 50, 50);\n    app->style.hierarchyFooterButtonBG_Active = ColorRGB8(70, 70, 70);\n    app->style.hierarchyFooterButtonBorder_Active = ColorRGB8(40, 40, 40);\n    app->style.hierarchyFooterButtonIcon = ColorRGB8(200, 200, 200);\n    app->style.hierarchyFooterDisabledIconColor = ColorRGB8(40, 40, 40);\n    app->style.scrollBarTrackBG = ColorRGB8(55);\n    app->style.scrollBarHotButtonBg = ColorRGB8(150, 150, 150);\n    app->style.scrollBarIconNormal = ColorRGB8(200, 200, 200);\n    app->style.scrollBarIconHot = ColorRGB8(50, 50, 50);\n    app->style.scrollGrabberNormal = ColorRGB8(120);\n    app->style.scrollGrabberHot = ColorRGB8(180);\n    app->style.karratColor = ColorRGB8(200);\n\n    app->style.hierarchyLabel = ColorRGB8(200, 200, 200);\n    app->style.hierarchyItemBG_A = ColorRGB8(70);\n    app->style.hierarchyItemBG_B = ColorRGB8(65);\n    app->style.hierarchyItemBG_Selected = ColorRGB8(10, 90, 130);\n    app->style.hierarchyItemBG_Movable = ColorRGB8(130, 90, 10);\n\n    app->style.hierarchyLabelDisabled = ColorRGB8(70);\n    app->style.hierarchyItemBGDisabled = ColorRGB8(100);\n\n    app->style.textAreaBg_Normal = ColorRGB8(65);\n    app->style.textAreaBg_Hot = ColorRGB8(75);\n    app->style.textAreaBg_Active = ColorRGB8(60);\n    app->style.textAreaBg_Disabled = app->style.panelBgColor;\n\n    app->style.textAreaFont_Normal = ColorRGB8(190);\n    app->style.textAreaFont_Hot = ColorRGB8(210);\n    app->style.textAreaFont_Active = ColorRGB8(170);\n    app->style.textAreaFont_Disabled = ColorRGB8(120);\n\n    app->style.textAreaOutline_Normal = ColorRGB8(40);\n    app->style.textAreaOutline_Hot = ColorRGB8(40);\n    app->style.textAreaOutline_Active = ColorRGB8(20);\n    app->style.textAreaOutline_Disabled = ColorRGB8(110);\n\n    app->style.textAreaLabel_Normal = ColorRGB8(170);\n    app->style.textAreaLabel_Hot = ColorRGB8(190);\n    app->style.textAreaLabel_Active = ColorRGB8(30);\n    app->style.textAreaLabel_Disabled = ColorRGB8(120);\n\n    app->style.toggleButtonBorder = app->style.textAreaOutline_Normal;\n    app->style.toggleButtonDisabledBorder = app->style.textAreaOutline_Disabled;\n\n    app->style.toggleButtonNormal = app->style.textAreaBg_Normal;\n    app->style.toggleButtonHot = app->style.textAreaBg_Hot;\n    app->style.toggleButtonActive = app->style.textAreaBg_Active;\n    app->style.toggleButtonDisabled = app->style.textAreaBg_Disabled;\n\n    app->style.textAreaSelectionColor = ColorRGB8(10, 90, 130);\n    app->style.labelFontColorNormal = app->style.textAreaLabel_Normal;\n    app->style.labelFontColorDisabled = app->style.textAreaLabel_Disabled;\n\n    app->inspectorWidth = app->style.inspectorMinWidth;\n    app->inspectorSplit = 0.9f; // Making these big is an easy way to make sure they have enough space.\n    app->animationSplit = 0.9f;\n    app->drawerHeight = app->style.animatorMinHeight;\n    app->style.hierarchyFooterHeight = app->style.headerHeight;\n    app->style.hierarchyFooterButtonSize = 20;\n    app->style.scrollBarSize = 20;\n    app->style.scrollIconSize = 18;\n    app->style.scrollBarHandleSize = 30;\n\n    app->style.txtAreaHeight = 20;\n    app->style.textAreaFontSize = 14;\n    app->style.textAreaLabelSize = 9;\n\n    app->numFilesLoading += 1; // Increase so none of the load functions end\n    LoadFont(app, &app->interfaceFont, \"assets/Inter-Light.ttf\");\n    LoadFont(app, &app->iconFont, \"assets/MaterialSymbols-Custom.ttf\");\n    LoadFont(app, &app->labelFont, \"assets/FreePixel.ttf\");\n\n    return app;\n}\n\nexport void Update(float dt, void* userData) {\n    Application* app = (Application*)userData;\n\n    if (app->numFilesLoading == 1) {\n        Imgui::Initialize(app->interfaceFont, app->iconFont, app->labelFont);\n        app->numFilesLoading -= 1; // Artificial file i added in init.\n    }\n    if (app->numFilesLoading != 0) {\n        return;\n    }\n\n    Imgui::TickFrame(dt);\n}\n\nfloat FigureOutScrollBarHeight(float contentHeight, float scrollAreaHeight) {\n    float scrollerHeight = 0.0f;\n    if (contentHeight > scrollAreaHeight) {\n        float ratio = MathFloor(contentHeight / scrollAreaHeight);\n\n        if (ratio >= 5.0f) {\n            scrollerHeight = scrollAreaHeight * 0.1f;\n        }\n        else if (ratio >= 4.0f) {\n            scrollerHeight = scrollAreaHeight * 0.2f;\n        }\n        else if (ratio >= 3.0f) {\n            scrollerHeight = scrollAreaHeight * 0.35f;\n        }\n        else if (ratio >= 2.0f) {\n            scrollerHeight = scrollAreaHeight * 0.5f;\n        }\n        else if (ratio >= 1.0f) {\n            scrollerHeight = scrollAreaHeight * 0.75f;\n        }\n        else {\n            PlatformAssert(false, __LOCATION__);\n        }\n        if (scrollerHeight < 30.0f) {\n            scrollerHeight = 30.0f;\n        }\n    }\n    return scrollerHeight;\n}\n\nstatic void ImguiHierarchy(const Imgui::Rect& scrollArea, Application* a) {\n    // Draw scroll list\n    StyleSheet* s = &a->style;\n    Imgui::Rect listItemKarrat = scrollArea;\n    listItemKarrat.h = s->listBoxItemHeight;\n\n    Node2D* hierarchyRearrangeDragging = 0;\n    Imgui::Rect hierarchyInsertIndicator;\n\n    u32 visibleNodeCount = a->document->GetVisibleNodeCount();\n    Imgui::Point mousePos = Imgui::GetPointer();\n\n    listItemKarrat.y -= (visibleNodeCount * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n    Node2D* itr = a->document->DepthFirstExpandedOnly(0); // Root is guaranteed to exist\n    itr = a->document->DepthFirstExpandedOnly(itr); // First one to draw\n\n    bool even = true;\n    while (itr != 0) {\n        Imgui::HierarchyListItemResult listItem = Imgui::HierarchyListItem(listItemKarrat, scrollArea, itr->name,\n            (itr->depth - 1) * 18, even, a->document->GetSelectedNode() == itr, itr->uiExpanded, itr->firstChild == 0);\n\n        itr->uiExpanded = listItem.expanded;\n\n        if (listItem.dragging) {\n            hierarchyRearrangeDragging = itr;\n        }\n\n        if (listItem.activated) {\n            a->document->SelectNode(itr);\n        }\n\n        even = !even;\n        listItemKarrat.y += s->listBoxItemHeight;\n        itr = a->document->DepthFirstExpandedOnly(itr);\n    }\n\n    if (hierarchyRearrangeDragging != 0) {\n        float mouseInScrollSpace = (mousePos.y - scrollArea.y);\n        if (mouseInScrollSpace < 0.0f) {\n            mouseInScrollSpace = 0.0f;\n        }\n        else if (mouseInScrollSpace > scrollArea.h) {\n            mouseInScrollSpace = scrollArea.h;\n        }\n        // Content goes up, so mouse goes down\n        mouseInScrollSpace += (visibleNodeCount * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n        i32 index = mouseInScrollSpace / s->listBoxItemHeight;\n        PlatformAssert(index >= 0, __LOCATION__);\n\n        if (index >= visibleNodeCount && visibleNodeCount >= 1) {\n            index = visibleNodeCount - 1;\n        }\n\n        if (visibleNodeCount > 0) {\n            PlatformAssert(index < visibleNodeCount, __LOCATION__);\n        }\n\n        Node2D* dropTarget = a->document->DepthFirstExpandedOnly(0);\n        dropTarget = a->document->DepthFirstExpandedOnly(dropTarget);\n        for (i32 i = 0; i < index; ++i) {\n            dropTarget = a->document->DepthFirstExpandedOnly(dropTarget);\n        }\n        PlatformAssert(dropTarget != 0, __LOCATION__);\n\n        bool above = false;\n        float midPoint = (index * s->listBoxItemHeight + s->listBoxItemHeight / 2.0f);\n        if (mouseInScrollSpace < midPoint) {\n            above = true;\n        }\n\n        hierarchyInsertIndicator = Imgui::Rect(\n            scrollArea.x, scrollArea.y + midPoint,\n            scrollArea.w, 2\n        );\n\n        if (above) {\n            hierarchyInsertIndicator.y -= s->listBoxItemHeight / 2.0f;\n\n            if (dropTarget->depth >= 1) {\n                hierarchyInsertIndicator.x += (dropTarget->depth - 1) * 18 + s->hierarchyLabelFontSize + 3;\n                hierarchyInsertIndicator.w -= (dropTarget->depth - 1) * 18 + s->hierarchyLabelFontSize + 3;\n            }\n        }\n        else {\n            hierarchyInsertIndicator.y += s->listBoxItemHeight / 2.0f;\n            hierarchyInsertIndicator.x += (dropTarget->depth) * 18 + s->hierarchyLabelFontSize + 3;\n            hierarchyInsertIndicator.w -= (dropTarget->depth) * 18 + s->hierarchyLabelFontSize + 3;\n        }\n        hierarchyInsertIndicator.y -= (visibleNodeCount * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n        if (Imgui::PointerReleased() && Imgui::Contains(scrollArea, mousePos)) {\n            if (dropTarget != hierarchyRearrangeDragging) {\n                if (above) {\n                    Node2D* parent = dropTarget->parent;\n                    Node2D* prev = 0;\n                    Node2D* iter = parent->firstChild;\n                    while (iter != 0) {\n                        if (iter == dropTarget) {\n                            break;\n                        }\n                        prev = iter;\n                        iter = iter->next;\n                    }\n                    a->document->RearrangeNode(*hierarchyRearrangeDragging, *parent, prev);\n                }\n                else {\n                    a->document->RearrangeNode(*hierarchyRearrangeDragging, *dropTarget, 0);\n                }\n            }\n        }\n    }\n\n    // Fill any missing space\n    float bottom = scrollArea.y + scrollArea.h;\n    float delta = bottom - (listItemKarrat.y);\n    if (delta > 0.0f) {\n        Imgui::Rect fillMissing = listItemKarrat;\n        fillMissing.h = delta;\n\n        Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        if (Imgui::ClickArea(fillMissing)) {\n            a->document->SelectNode(0);\n        }\n    }\n\n    // Draw scroll bar\n    Imgui::Rect hierarchyScrollBar = scrollArea;\n    hierarchyScrollBar.x = scrollArea.x + scrollArea.w;\n    hierarchyScrollBar.w = s->scrollBarSize;\n    float contentHeight = visibleNodeCount * s->listBoxItemHeight;\n\n    // Move scroll bar if re-arranging hierarchy\n    if (hierarchyRearrangeDragging != 0) {\n        Imgui::Rect scrollUp = scrollArea;\n        scrollUp.h = s->scrollBarSize;\n        Imgui::Rect scrollDown = scrollUp;\n        scrollDown.y += scrollArea.h - scrollUp.h;\n\n        if (Imgui::GetPulse()) {\n            if (Imgui::Contains(scrollUp, mousePos)) {\n                a->hierarchyScroll -= 0.05f;\n            }\n            if (Imgui::Contains(scrollDown, mousePos)) {\n                a->hierarchyScroll += 0.05f;\n            }\n\n            if (a->hierarchyScroll < 0.0f) {\n                a->hierarchyScroll = 0.0f;\n            }\n            if (a->hierarchyScroll > 1.0f) {\n                a->hierarchyScroll = 1.0f;\n            }\n        }\n    }\n\n    float scrollerHeight = FigureOutScrollBarHeight(contentHeight, scrollArea.h);\n    a->hierarchyScroll = Imgui::VScroll(hierarchyScrollBar, a->hierarchyScroll, scrollerHeight, Imgui::HandleScroll(scrollArea));\n\n    // Draw footer\n    Imgui::Rect hierarchyFooter = scrollArea;\n    hierarchyFooter.y = scrollArea.y + scrollArea.h;\n    hierarchyFooter.h = s->hierarchyFooterHeight;\n    hierarchyFooter.w = scrollArea.w + s->scrollBarSize;\n\n    {\n        // Footer BG\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, hierarchyFooter.h,\n            s->hierarchyFooterBg.r, s->hierarchyFooterBg.g, s->hierarchyFooterBg.b);\n        // Footer divider\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y + 1, hierarchyFooter.w, 1,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, 1,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        Imgui::Rect footerKarrat = hierarchyFooter;\n        footerKarrat.x = hierarchyFooter.x + hierarchyFooter.w - s->hierarchyFooterButtonSize - 3;\n        footerKarrat.y = hierarchyFooter.y + 5;\n        footerKarrat.w = s->hierarchyFooterButtonSize;\n        footerKarrat.h = s->hierarchyFooterButtonSize;\n\n        { // New / delete node\n            if (a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific offset\n                iconRect.y += 3; // Footer specific offset\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_TRASHCAN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_TRASHCAN, \"Delete selected node\")) {\n                    a->document->DeleteNode(a->document->GetSelectedNode());\n                }\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_NEWLAYER, \"Create new node\")) {\n                a->document->CreateNode(a->document->GetSelectedNode());\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_DESELECT, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_DESELECT, \"Deselect node\")) {\n                    a->document->SelectNode(0);\n                }\n            }\n        }\n\n        // Draw dividers\n        footerKarrat.x -= 5;\n        Draw2D::DrawRect((footerKarrat.x), hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect((footerKarrat.x) + 1, hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        { // Add Sprite Add Ik\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (true || a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_NEWSPRITE, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_NEWSPRITE, \"Add sprite component\");\n            }\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (true || a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_NEWCHAIN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_NEWCHAIN, \"Add ik chain\");\n            }\n        }\n\n        footerKarrat.x -= 5;\n        Draw2D::DrawRect((footerKarrat.x), hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect((footerKarrat.x) + 1, hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        { // Key / unkey\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (true || a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_KEY, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_KEY, \"Keyframe node property\")) {\n\n                }\n            }\n        }\n\n        { // Node Count Label\n            char printString[12] = { 0 };\n            stbsp_snprintf(printString, 12, \"Count: %d\", a->document->GetNodeCount());\n            Draw2D::DrawString(a->interfaceFont, 12, hierarchyFooter.x + 5, hierarchyFooter.y + 20, printString,\n                s->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n        }\n    }\n\n    // Draw re-arrange indicator\n    if (a->hierarchyTab == 0) { // Hierarchy re-arrange indicator (needs to draw above footer)\n        if (hierarchyRearrangeDragging != 0) {\n            Draw2D::DrawRect(hierarchyInsertIndicator.x, hierarchyInsertIndicator.y, hierarchyInsertIndicator.w, hierarchyInsertIndicator.h, s->hierarchyItemBG_Movable.r, s->hierarchyItemBG_Movable.g, s->hierarchyItemBG_Movable.b);\n        }\n    }\n}\n\nstatic void ImguiUndoStack(const Imgui::Rect& scrollArea, Application* a) {\n    // Draw scroll list\n    StyleSheet* s = &a->style;\n    Imgui::Rect listItemKarrat = scrollArea;\n    listItemKarrat.h = s->listBoxItemHeight;\n\n    listItemKarrat.y -= (a->document->GetNumUndoSteps() * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n    bool do_undo = false;\n    u32 undoIndex = 0;\n\n    u32 currentUndoStep = a->document->GetUndoStackCurrent();\n    u32 currentUndoIndex = currentUndoStep;\n    if (currentUndoIndex != 0) {\n        currentUndoIndex -= 1;\n    }\n\n    for (u32 i = 0, numUndoSteps = a->document->GetNumUndoSteps(); i < numUndoSteps; ++i) {\n        const char* name = a->document->GetUndoStepName(i);\n\n        if (Imgui::UndoListItem(listItemKarrat, scrollArea, name, i % 2, currentUndoStep < i + 1, i + 1 == currentUndoStep)) {\n            if (!do_undo) {\n                do_undo = true;\n                undoIndex = i;\n            }\n        }\n\n        listItemKarrat.y += s->listBoxItemHeight;\n    }\n\n    if (do_undo) {\n        if (undoIndex < currentUndoIndex) { // Undo x times\n            u32 numUndoSteps = currentUndoIndex - undoIndex;\n            for (u32 i = 0; i < numUndoSteps; ++i) {\n                if (a->document->CanUndo()) {\n                    a->document->Undo();\n                }\n            }\n        }\n        else if (undoIndex > currentUndoIndex) { // Redo x times\n            u32 numRedoSteps = undoIndex - currentUndoIndex;\n            for (u32 i = 0; i < numRedoSteps; ++i) {\n                if (a->document->CanRedo()) {\n                    a->document->Redo();\n                }\n            }\n        }\n    }\n\n    // Fill any missing space\n    float bottom = scrollArea.y + scrollArea.h;\n    float delta = bottom - (listItemKarrat.y);\n    if (delta > 0.0f) {\n        Imgui::Rect fillMissing = listItemKarrat;\n        fillMissing.h = delta;\n\n        Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n    }\n\n    // Draw scroll bar\n    Imgui::Rect hierarchyScrollBar = scrollArea;\n    hierarchyScrollBar.x = scrollArea.x + scrollArea.w;\n    hierarchyScrollBar.w = s->scrollBarSize;\n    float contentHeight = a->document->GetNumUndoSteps() * s->listBoxItemHeight;\n    float scrollerHeight = FigureOutScrollBarHeight(contentHeight, scrollArea.h);\n\n    a->hierarchyScroll = Imgui::VScroll(hierarchyScrollBar, a->hierarchyScroll, scrollerHeight, Imgui::HandleScroll(scrollArea));\n\n    // Draw footer\n    Imgui::Rect hierarchyFooter = scrollArea;\n    hierarchyFooter.y = scrollArea.y + scrollArea.h;\n    hierarchyFooter.h = s->hierarchyFooterHeight;\n    hierarchyFooter.w = scrollArea.w + s->scrollBarSize;\n\n    // Draw footer\n    {\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, hierarchyFooter.h,\n            s->hierarchyFooterBg.r, s->hierarchyFooterBg.g, s->hierarchyFooterBg.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y + 1, hierarchyFooter.w, 1,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, 1,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        Imgui::Rect footerKarrat = hierarchyFooter;\n        footerKarrat.x = hierarchyFooter.x + hierarchyFooter.w - s->hierarchyFooterButtonSize - 3;\n        footerKarrat.y = hierarchyFooter.y + 5;\n        footerKarrat.w = s->hierarchyFooterButtonSize;\n        footerKarrat.h = s->hierarchyFooterButtonSize;\n\n        { // Clear Stack / Debug View\n            if (a->document->GetNumUndoSteps() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific offset\n                iconRect.y += 3; // Footer specific offset\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_TRASHCAN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_TRASHCAN, \"Clear undo history\")) {\n                    a->document->ClearUndoHistory();\n                }\n            }\n\n            footerKarrat.x -= 5;\n            Draw2D::DrawRect((footerKarrat.x), hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n                s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n            Draw2D::DrawRect((footerKarrat.x) + 1, hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n                s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (!a->document->CanRedo()) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_REDO, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_REDO, \"Redo\")) {\n                    a->document->Redo();\n                }\n            }\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (!a->document->CanUndo()) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_UNDO, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_UNDO, \"Undo\")) {\n                    a->document->Undo();\n                }\n            }\n\n            { // History Label\n                char printString[36] = { 0 };\n                stbsp_snprintf(printString, 36, \"History: %d, Max: %d\", a->document->GetUndoStackCurrent(), a->document->GetMaxUndoSteps());\n                Draw2D::DrawString(a->interfaceFont, 12, hierarchyFooter.x + 5, hierarchyFooter.y + 20, printString,\n                    s->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n            }\n        }\n    }\n}\n\nstatic void ImguiTransformEditor(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n    // Draw BG\n    Draw2D::DrawRect(area.x, area.y, area.w, area.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);\n\n    // Draw text boxes\n\n    Imgui::Rect karrat(area.x + 10, area.y + 13, area.w - 20, 0);\n\n    Imgui::Rect textArea = karrat;\n    textArea.h = s->txtAreaHeight;\n\n    const char* oldName = \"\";\n    Node2D* selectedNode = a->document->GetSelectedNode();\n    if (selectedNode != 0) {\n        oldName = selectedNode->name;\n    }\n\n    const char* newName = Imgui::TextArea(textArea, oldName, \"Name\", selectedNode == 0, false);\n    if (selectedNode != 0 && newName != oldName) {\n        a->document->RenameNode(selectedNode, newName);\n    }\n\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n\n    char num_buffer[64] = { 0 };\n\n    float trippleWidth = (textArea.w - 20) / 3.0f;\n    textArea.w = trippleWidth;\n\n    {\n        if (selectedNode != 0) {\n            stbsp_snprintf(num_buffer, 64, \"%.3f\", selectedNode->position.x);\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Position.x\", selectedNode == 0, true);\n        if (selectedNode != 0 && newNumber != num_buffer) {\n            vec2 newPos = selectedNode->position;\n            newPos.x = MathAToF(newNumber);\n            a->document->UpdateNodeTransform(selectedNode, newPos, selectedNode->rotation, selectedNode->scale);\n        }\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    {\n        if (selectedNode != 0) {\n            stbsp_snprintf(num_buffer, 64, \"%.3f\", selectedNode->position.y);\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Position.y\", selectedNode == 0, true);\n        if (selectedNode != 0 && newNumber != num_buffer) {\n            vec2 newPos = selectedNode->position;\n            newPos.y = MathAToF(newNumber);\n            a->document->UpdateNodeTransform(selectedNode, newPos, selectedNode->rotation, selectedNode->scale);\n        }\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    {\n        if (selectedNode != 0) {\n            stbsp_snprintf(num_buffer, 64, \"%.3f\", selectedNode->rotation);\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Rotation\", selectedNode == 0, true);\n        if (selectedNode != 0 && newNumber != num_buffer) {\n            float newRot = MathAToF(newNumber);\n            a->document->UpdateNodeTransform(selectedNode, selectedNode->position, newRot, selectedNode->scale);\n        }\n\n        if (newNumber != num_buffer) {\n            float newVal = MathAToF(newNumber);\n            while (newVal < -360.0f) {\n                newVal += 360.0f;\n            }\n            while (newVal > 360.0f) {\n                newVal -= 360.0f;\n            }\n            selectedNode->rotation = newVal;\n        }\n    }\n\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    textArea.x = karrat.x;\n\n    { // Uniform lock\n        f32 areaSize = 22;\n        Imgui::Rect toggleArea(textArea.x + trippleWidth - areaSize, textArea.y - 1, areaSize, areaSize);\n\n        bool toggleState = false;\n        if (selectedNode != 0) {\n            toggleState = selectedNode->uiScaleLock;\n        }\n        bool newState = Imgui::IconToggle(toggleArea, IMGUI_ICON_CODEPOINT_LOCK_OPEN, IMGUI_ICON_CODEPOINT_LOCK_CLOSED,\n            toggleState, selectedNode == 0);\n        if (selectedNode != 0 && newState != toggleState) {\n            a->document->ToggleUniformScale(selectedNode);\n        }\n\n        Imgui::Rect labelRect(textArea.x + trippleWidth - areaSize - 62, textArea.y, 150, 16);\n        Imgui::Label(labelRect, \"Uniform\", selectedNode == 0);\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    {\n        if (selectedNode != 0) {\n            stbsp_snprintf(num_buffer, 64, \"%.3f\", selectedNode->scale.x);\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Scale.x\", selectedNode == 0, true);\n        if (selectedNode != 0 && newNumber != num_buffer) {\n            vec2 newScale = selectedNode->scale;\n            newScale.x = MathAToF(newNumber);\n            if (selectedNode->uiScaleLock) {\n                newScale.y = newScale.x;\n            }\n            a->document->UpdateNodeTransform(selectedNode, selectedNode->position, selectedNode->rotation, newScale);\n        }\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    {\n        if (selectedNode != 0) {\n            if (selectedNode->uiScaleLock) {\n                num_buffer[0] = '\\0';\n            }\n            else {\n                stbsp_snprintf(num_buffer, 64, \"%.3f\", selectedNode->scale.y);\n            }\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Scale.y\", selectedNode == 0 || (selectedNode != 0 && selectedNode->uiScaleLock), true);\n        if (selectedNode != 0 && newNumber != num_buffer) {\n            if (!selectedNode->uiScaleLock) {\n                vec2 newScale = selectedNode->scale;\n                newScale.y = MathAToF(newNumber);\n                a->document->UpdateNodeTransform(selectedNode, selectedNode->position, selectedNode->rotation, newScale);\n            }\n        }\n    }\n\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    textArea.x = karrat.x;\n}\n\nexport void Render(unsigned int x, unsigned int y, unsigned int __w, unsigned int __h, float dpi, void* userData) {\n    Application* app = (Application*)userData;\n    GfxClearColor(0, 0, 0.5f, 0.6, 0.7f); // TODO: Fast path is usually to clear black!\n\n    float w = (float)__w / dpi;\n    float h = (float)__h / dpi;\n    StyleSheet* s = &app->style;\n\n    if (app->numFilesLoading != 0) {\n        Draw2D::Begin(1920, 1080, dpi, __w, __h);\n\n        Draw2D::DrawRect(w / 2 - 200, h / 2 - 100, 400, 200, s->menuBarBg.r, s->menuBarBg.g, s->menuBarBg.b, 1.0f);\n        // TODO: Draw loading indicator\n\n        Draw2D::End();\n        return;\n    }\n\n    Draw2D::Begin(1920, 1080, dpi, __w, __h);\n    Imgui::BeginFrame(dpi, app->style);\n    Draw2D::EnableAlphaBlending();\n\n    Imgui::Rect inspectorArea; // The entire inspector (game + hierarchy + anim + inspector)\n    Imgui::Rect inspectorLeft; // Left side only (game / anim)\n    Imgui::Rect inspectorRight; // Right side only (inspector / hierarchy)\n    Imgui::Rect animationArea; // Split up / down. Game view & anim view\n    Imgui::Rect animationTop; // Game view only (top)\n    Imgui::Rect animationBottom; // Anim view only (bottom)\n    Imgui::Rect menuBar;\n    Imgui::Rect toolBar;\n    Imgui::Rect hierarchySchrollArea;\n    Imgui::Rect hierarchyScrollBar;\n    Imgui::Rect hierarchyFooter;\n\n    u32 visibleNodeCount = app->document->GetVisibleNodeCount();\n    Imgui::Point mousePos = Imgui::GetPointer();\n\n    { // Menu bar\n        menuBar.w = w;\n        menuBar.h = s->menuBarHeight;\n        Draw2D::DrawRect(menuBar.x, menuBar.y, menuBar.w, menuBar.h, s->menuBarBg.r, s->menuBarBg.g, s->menuBarBg.b, 1.0f);\n    }\n\n    { // Toolbar\n        toolBar.y = s->menuBarHeight;\n        toolBar.w = s->toolbarWidth;\n        toolBar.h = h - s->menuBarHeight - s->footerHeight;\n        Draw2D::DrawRect(toolBar.x, toolBar.y, toolBar.w, toolBar.h, s->toolBarBg.r, s->toolBarBg.g, s->toolBarBg.b, 1.0f);\n    }\n\n    { // Inspector Splitter (Game / anim on left, inspector / hierarchy right)\n        inspectorArea.x = s->toolbarWidth;\n        inspectorArea.y = s->menuBarHeight;\n        inspectorArea.w = w - s->toolbarWidth;\n        inspectorArea.h = toolBar.h;\n        app->inspectorSplit = Imgui::VSplit(inspectorArea, s->inspectorMinWidth, app->inspectorSplit);\n        inspectorLeft = Imgui::VSplitFirstArea(inspectorArea, app->inspectorSplit);\n        inspectorRight = Imgui::VSplitSecondArea(inspectorArea, app->inspectorSplit);\n\n        // TODO: Draw ref at inspector left & right to confirm that the splitter is not drawn over\n        //Draw2D::DrawRect(inspectorArea.x, inspectorArea.y, inspectorArea.w, inspectorArea.h, 0, 0, 1);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        //Draw2D::DrawRect(inspectorLeft.x, inspectorLeft.y, inspectorLeft.w, inspectorLeft.h, 1, 0, 0);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        //Draw2D::DrawRect(inspectorRight.x, inspectorRight.y, inspectorRight.w, inspectorRight.h, 0, 1, 0);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n\n        {\n            { // Animation Splitter\n                animationArea = inspectorLeft;\n                //Draw2D::DrawRect(animationArea.x, animationArea.y + 30, animationArea.w, animationArea.h, 0, 1, 0);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n                app->animationSplit = Imgui::HSplit(animationArea, s->animatorMinHeight, app->animationSplit);\n                animationTop = Imgui::HSplitFirstArea(animationArea, app->animationSplit);\n                animationBottom = Imgui::HSplitSecondArea(animationArea, app->animationSplit);\n\n                //Draw2D::DrawRect(animationArea.x, animationArea.y, animationArea.w, animationArea.h, 0, 0, 1);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n                Draw2D::DrawRect(animationTop.x, animationTop.y, animationTop.w, animationTop.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b, 1.0f);\n                Draw2D::DrawRect(animationBottom.x, animationBottom.y, animationBottom.w, animationBottom.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b, 1.0f);\n\n\n                { // TODO: Game\n\n                }\n\n                { // TODO: Animation\n\n                }\n            }\n        }\n\n        { // InspectorPanel\n            const char* title[4] = { 0 };\n\n#if 0\n            title = \"Transform\";\n            Imgui::Header(header, &title, 1, &ignoreSelection);\n            header.y += s->headerHeight;\n\n            title = \"Sprite\";\n            Imgui::Header(header, &title, 1, &ignoreSelection);\n            header.y += s->headerHeight;\n\n            title = \"IK Chain\";\n            Imgui::Header(header, &title, 1, &ignoreSelection);\n            header.y += s->headerHeight;\n\n            title = \"IK Link\";\n            Imgui::Header(header, &title, 1, &ignoreSelection);\n            header.y += s->headerHeight;\n#endif\n\n            f32 inspectorStack = inspectorArea.y;\n\n            { // Transform\n                Imgui::Rect transformHeader = inspectorRight;\n                transformHeader.h = s->headerHeight;\n                transformHeader.y = inspectorStack;\n                inspectorStack += transformHeader.h;\n\n                Imgui::Rect transformEditor = transformHeader;\n                transformEditor.y = transformHeader.y + transformHeader.h;\n                transformEditor.h = IMGUI_TRANSFORM_HEIGHT;\n                inspectorStack += IMGUI_TRANSFORM_HEIGHT;\n\n                ImguiTransformEditor(transformEditor, app);\n\n                title[0] = \"Transform\"; // Header\n                title[1] = \"Sprite\"; // Header\n                Imgui::Header(transformHeader, title, 1, 0);\n\n            }\n\n            if (false) { // Sprite\n                Imgui::Rect spriteHeader = inspectorRight;\n                spriteHeader.h = s->headerHeight;\n                spriteHeader.y = inspectorStack;\n                inspectorStack += spriteHeader.h;\n\n                Imgui::Rect spriteEditor = spriteHeader;\n                spriteEditor.y = spriteHeader.y + spriteHeader.h;\n                spriteEditor.h = IMGUI_TRANSFORM_HEIGHT;\n                inspectorStack += IMGUI_TRANSFORM_HEIGHT;\n\n                title[0] = \"Sprite\"; // Header\n                Imgui::Header(spriteHeader, title, 1, 0);\n            }\n\n            { // Hierarchy and undo stack\n                Imgui::Rect hierarchyHeader = inspectorRight;\n                hierarchyHeader.h = s->headerHeight;\n                hierarchyHeader.y = inspectorStack;\n\n                f32 hiearchyHeight = inspectorRight.h - s->footerHeight - s->headerHeight - (inspectorStack - inspectorArea.y) - 2;\n                if (hiearchyHeight < 0.0f) {\n                    hiearchyHeight = 0.0f;\n                }\n\n                hierarchySchrollArea = hierarchyHeader;\n                hierarchySchrollArea.y = hierarchyHeader.y + hierarchyHeader.h;\n                hierarchySchrollArea.w = inspectorRight.w - s->scrollBarSize;\n                hierarchySchrollArea.h = hiearchyHeight;\n\n                if (hierarchySchrollArea.w < 0.0f) {\n                    hierarchySchrollArea = 0.0f;\n                }\n\n\n                if (app->hierarchyTab == 0) {\n                    ImguiHierarchy(hierarchySchrollArea, app);\n                }\n                else {\n                    ImguiUndoStack(hierarchySchrollArea, app);\n                }\n\n                // Draw header\n                title[0] = \"Hierarchy\";\n                title[1] = \"Undo History\";\n\n                u32 oldTab = app->hierarchyTab;\n                app->hierarchyTab = Imgui::Header(hierarchyHeader, title, 2, app->hierarchyTab);\n                if (app->hierarchyTab != oldTab) {\n                    app->hierarchyScroll = 0.0f;\n                }\n            }\n        }\n    }\n\n#if 0\n    Draw2D::Size slen = Draw2D::MeasureString(app->labelFont, s->textAreaLabelSize, \"Node Name\");\n    Draw2D::DrawRect(150, 150, slen.w, slen.h, 0.8, 0.3, 0.3);\n    Draw2D::Rect rlen = Draw2D::MeasureSubString(app->labelFont, s->textAreaLabelSize, \"Node Name\", 1, 7);\n    Draw2D::DrawRect(150 + rlen.x, 150 + rlen.y, rlen.w, rlen.h, 0.3, 0.8, 0.3);\n    Draw2D::DrawString(app->labelFont, s->textAreaLabelSize, 150, 150 + rlen.h, \"Node Name\", 1, 1, 1);\n#endif\n\n    Draw2D::DrawRect(0, h - s->footerHeight, w, s->footerHeight, s->footerBg.r, s->footerBg.g, s->footerBg.b, 1.0f);\n    //Draw2D::DrawString(app->interfaceFont, s->menuTextLineHeight, 10, 5 + s->menuTextLineHeight, \"File    Edit    Hierarchy    Component    Window    Help\");\n\n    Imgui::EndFrame(__w, __h);\n    Draw2D::DisableAlphaBlending();\n    Draw2D::End();\n}\n\nexport void Shutdown(void* userData) {\n    Application* app = (Application*)userData;\n    app->document->~Document();\n\n    Imgui::Shutdown();\n    Draw2D::Shutdown();\n\n    MemRelease(app->document);\n    MemRelease(app);\n}","#ifndef _H_PLATFORMASSERT_\n#define _H_PLATFORMASSERT_\n\n// Mirrored from memory.h\n#if defined(__APPLE__) && defined(__MACH__)\n#define MEM_PLATFORM_APPLE 1\n#define platform_t unsigned long long\n#elif defined(WIN64) || defined(_WIN64) || defined(__WIN64) || defined(__WIN64__)\n#define MEM_PLATFORM_WINDOWS 1\n#define platform_t unsigned long long\n#elif defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)\n#define MEM_PLATFORM_WINDOWS 1\n#define platform_t unsigned long\n#elif defined(__linux__)\n#define MEM_PLATFORM_LINUX 1\n#define platform_t unsigned long long\n#else\n#define MEM_PLATFORM_WASM 1\n#define platform_t unsigned long\n#endif\n\n#if _DEBUG\n#ifndef PLATFORM_DEBUG\n#define PLATFORM_DEBUG 1\n#endif\n#else\n#ifndef PLATFORM_DEBUG\n#define PLATFORM_DEBUG 0\n#endif\n#endif\n\n#if _DEBUG\ninline int PlatformAssert(bool cond, const char* msg) { // Always returns 0\n#if MEM_PLATFORM_WASM\n\tif (!cond) {\n\t\t\tPrintDebugString(msg);\n            __builtin_trap();\n\t\t}\n#else\n\tif (!cond) {\n\t\tunsigned char* ptr = (unsigned char*)0;\n\t\t*ptr = 0;\n\t}\n#endif\n\treturn 0;\n}\n\n#else\n#define PlatformAssert(x, m)\n#endif\n\n#ifndef __LOCATION__\n#define mem_xstr(a) mem_str(a)\n#define mem_str(a) #a\n#if _DEBUG\n#define __LOCATION__ (\"On line \" mem_xstr(__LINE__) \", in \" __FILE__)\n#else\n#define __LOCATION__ ((const char*)0)\n#endif\n#endif // !__LOCATION__\n\n#endif // !_H_ASSERT_\n","#include \"memory.h\"\n#include \"assert.h\"\n\n#if defined(MEM_PLATFORM_WINDOWS)\n    #include <windows.h>\n    mem_cfunc void PrintDebugString(const char* str) {\n        OutputDebugStringA(str);\n    }\n#elif defined(MEM_PLATFORM_WASM)\n    extern unsigned char __heap_base;\n    extern unsigned char __data_end;\n\n    __attribute__ (( visibility( \"default\" ) )) extern \"C\" void MemWasmTriggerCallback(fpAllocationInfo callback, u32 index, void* mem, u32 firstPage, u32 numPages, void* tag, void* userData) {\n        if (callback != 0) {\n        callback(index, mem, firstPage, numPages, tag, userData);\n        }\n    }\n#endif\n\n// Don't disable these\n#define MEM_ENABLE_SUBALLOCATORS        1\n\nvoid* gHeap = 0;\n\n\n#if MEM_ENABLE_ALLOCGUARD\n#define MEM_ALLOCATION_magicHead        0\n#define MEM_ALLOCATION_startPage        4\n#define MEM_ALLOCATION_pageCount        6\n#define MEM_ALLOCATION_allocPrev        8\n#define MEM_ALLOCATION_allocNext        12\n#define MEM_ALLOCATION_tag              16\n#define MEM_ALLOCATION_magicTail        24\n#define MEM_ALLOCATION_padding          28\n#else\n#define MEM_ALLOCATION_startPage        0\n#define MEM_ALLOCATION_pageCount        2\n#define MEM_ALLOCATION_allocPrev        4\n#define MEM_ALLOCATION_allocNext        8\n#define MEM_ALLOCATION_tag              12\n#define MEM_ALLOCATION_padding          20\n#endif\n\n#define MEM_ALLOCATOR_heapSizeBytes     0\n#define MEM_ALLOCATOR_overheadPages     4\n#define MEM_ALLOCATOR_firstPage         8\n#define MEM_ALLOCATOR_activeAllocs      12\n#define MEM_ALLOCATOR_subAllocFree1     16\n#define MEM_ALLOCATOR_subAllocSize1     20\n#define MEM_ALLOCATOR_subAllocFree2     24\n#define MEM_ALLOCATOR_subAllocSize2     28\n#define MEM_ALLOCATOR_subAllocFree3     32\n#define MEM_ALLOCATOR_subAllocSize3     36\n#define MEM_ALLOCATOR_activePages       40\n#define MEM_ALLOCATOR_mostActivePages   44\n\n#define MEM_ALLOCACTION_MAGIC_MAIN       (((u32)'m' << 0) | ((u32)'e' << 8) | ((u32)'m' << 16) | ((u32)'_' << 24))    // 1601004909\n#define MEM_ALLOCACTION_MAGIC_SUB_ACTIVE (((u32)'s' << 0) | ((u32)'u' << 8) | ((u32)'b' << 16) | ((u32)'a' << 24))    // \n#define MEM_ALLOCACTION_MAGIC_SUB_FREE   (((u32)'s' << 0) | ((u32)'u' << 8) | ((u32)'b' << 16) | ((u32)'f' << 24))    // \n#define MEM_ALLOCACTION_MAGIC_RELEASED   (((u32)'f' << 0) | ((u32)'r' << 8) | ((u32)'e' << 16) | ((u32)'e' << 24))    // 1701147238\n\n\n#if 1\n#define MEM_READU16(ptr, offset)        (*(u16*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU16(ptr, offset, val)  (*(u16*)((u8*)(ptr) + (offset)) = (u16)(val))\n\n#define MEM_READU32(ptr, offset)        (*(u32*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU32(ptr, offset, val)  (*(u32*)((u8*)(ptr) + (offset)) = (u32)(val))\n\n#define MEM_READU64(ptr, offset)        (*(u64*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU64(ptr, offset, val)  (*(u64*)((u8*)(ptr) + (offset)) = (u64)(val))\n\n#define MEM_SUBALLOCSIZE(ptr, index)    (*(u32*)((u8*)(ptr) + 20 + ((index) * 8)))\n#define MEM_GETSUBALLOCOFFSET(ptr, idx) (*(u32*)((u8*)(ptr) + 16 + ((idx) * 8)))\n#define MEM_SETSUBALLOCOFFSET(ptr,i,v)  (*(u32*)((u8*)(ptr) + 16 + ((i) * 8)) = (u32)(v))\n#define MEM_PAGEMASKPTR(ptr)            ( (u32*)((u8*)(ptr) + MEM_ALLOCATOR_SIZE))\n#define MEM_HEAPSIZE(ptr)               (*(u32*)((u8*)(ptr) + 0 ))\n#define MEM_ACTIVEALLOCSOFFSET(ptr)     (*(u32*)((u8*)(ptr) + 12))\n#define MEM_FIRSTPAGEOFFSET(ptr)        (*(u32*)((u8*)(ptr) + 8 ))\n#define MEM_FIRSTPAGEPTR(ptr)           (       ((u8*)(ptr) + MEM_FIRSTPAGEOFFSET(ptr)))\n#define MEM_GETPAGEPTR(ptr, page)       ((u8*)MEM_FIRSTPAGEPTR(ptr) + (MEM_PAGE_SIZE * (page)))\n\n#else\n\ninline u16 MEM_READU16(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u16 low =  u8_ptr[offset];\n    u16 high = u8_ptr[offset + 1];\n\n    return low | (high << 8);\n}\n\ninline void MEM_WRITEU16(void* ptr, u32 offset, u16 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u8 b1 = (val & (255));\n    u8 b2 = (val & (255 << 8)) >> 8;\n\n    u8_ptr[offset] = b1;\n    u8_ptr[offset + 1] = b2;\n}\n\ninline u32 MEM_READU32(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u32 b1 = u8_ptr[offset + 0];\n    u32 b2 = u8_ptr[offset + 1];\n    u32 b3 = u8_ptr[offset + 2];\n    u32 b4 = u8_ptr[offset + 3];\n\n    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);\n}\n\ninline void MEM_WRITEU32(void* ptr, u32 offset, u32 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u8 b1 = (val & (255));\n    u8 b2 = (val & (255 << 8)) >> 8;\n    u8 b3 = (val & (255 << 16)) >> 16;\n    u8 b4 = (val & (255 << 24)) >> 24;\n\n    u8_ptr[offset + 0] = b1;\n    u8_ptr[offset + 1] = b2;\n    u8_ptr[offset + 2] = b3;\n    u8_ptr[offset + 3] = b4;\n}\n\ninline u64 MEM_READU64(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u64 b1 = u8_ptr[offset + 0];\n    u64 b2 = u8_ptr[offset + 1];\n    u64 b3 = u8_ptr[offset + 2];\n    u64 b4 = u8_ptr[offset + 3];\n    u64 b5 = u8_ptr[offset + 4];\n    u64 b6 = u8_ptr[offset + 5];\n    u64 b7 = u8_ptr[offset + 6];\n    u64 b8 = u8_ptr[offset + 7];\n\n    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24) | (b5 << 32) | (b6 << 40) | (b7 << 48) || (b8 << 56);\n}\n\ninline void MEM_WRITEU64(void* ptr, u32 offset, u64 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u32 a = (val << 32) >> 32;\n    u32 b = val >> 32;\n\n    MEM_WRITEU32(ptr, offset, a);\n    MEM_WRITEU32(ptr, offset + sizeof(u32), b);\n}\n\ninline u32 MEM_SUBALLOCSIZE(void* ptr, u32 index) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_subAllocSize1 + index * 8);\n}\n\ninline u32 MEM_GETSUBALLOCOFFSET(void* ptr, u32 index) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_subAllocFree1 + index * 8);\n}\n\ninline void MEM_SETSUBALLOCOFFSET(void* ptr, u32 index, u32 value) {\n    MEM_WRITEU32(ptr, MEM_ALLOCATOR_subAllocFree1 + index * 8, value);\n}\n\ninline u32* MEM_PAGEMASKPTR(void* ptr) {\n    u8* target = (u8*)ptr + MEM_ALLOCATOR_SIZE;\n    return (u32*)target;\n}\n\ninline u32 MEM_HEAPSIZE(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_heapSizeBytes);\n}\n\ninline u32 MEM_ACTIVEALLOCSOFFSET(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_activeAllocs);\n}\n\ninline u32 MEM_FIRSTPAGEOFFSET(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_firstPage);\n}\n\ninline u8* MEM_FIRSTPAGEPTR(void* ptr) {\n    return (u8*)ptr + MEM_FIRSTPAGEOFFSET(ptr);\n}\n\ninline u8* MEM_GETPAGEPTR(void* ptr, u32 page) {\n    return MEM_FIRSTPAGEPTR(ptr) + (MEM_PAGE_SIZE * page);\n}\n#endif\n\nvoid* operator new(platform_t, void* p) {\n    return p;\n}\n\n#if MEM_PLATFORM_WASM\nvoid operator delete(void* p)  throw() {\n    PlatformAssert(false, __LOCATION__);\n}\n#endif\n\nstatic void MemInternal_ActivePagesAdded(u8* heap, u32 delta) {\n    u32 activePages = MEM_READU32(heap, MEM_ALLOCATOR_activePages);\n    u32 maxPages = MEM_READU32(heap, MEM_ALLOCATOR_mostActivePages);\n    activePages += delta;\n    if (activePages > maxPages) {\n        maxPages = activePages;\n        MEM_WRITEU32(heap, MEM_ALLOCATOR_mostActivePages, maxPages);\n    }\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activePages, activePages);\n}\n\nstatic void MemInternal_ActivePagesRemoved(u8* heap, u32 delta) {\n    u32 activePages = MEM_READU32(heap, MEM_ALLOCATOR_activePages);\n    PlatformAssert(activePages >= delta, __LOCATION__);\n    activePages -= delta;\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activePages, activePages);\n}\n\nmem_cfunc u32 MemGetCurrentNumPages(void* heap) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n    u32 activePages = MEM_READU32(heap, MEM_ALLOCATOR_activePages);\n    return activePages;\n}\n\nmem_cfunc u32 MemGetMostPagesUsedAtOne(void* heap) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n    u32 maxPages = MEM_READU32(heap, MEM_ALLOCATOR_mostActivePages);\n    return maxPages;\n}\n\n\nmem_cfunc i32 MemRelease(void* target) {\n    return MemReleaseFromHeap(gHeap, target);\n}\n\nmem_cfunc void* MemAllocate(u32 bytes, u32 alignment, void* tag) {\n    return MemAllocateOnHeap(gHeap, bytes, alignment, tag);\n}\n\nmem_cfunc void* MemReallocate(void* src, u32 newBytes, void* newTag) {\n    return MemReallocateOnHeap(gHeap, src, newBytes, newTag);\n}\n\nmem_cfunc u32 MemForEachAllocation(fpAllocationInfo callback, void* userData) {\n    return MemForEachAllocationOnHeap(gHeap, callback, userData);\n}\n\nmem_cfunc void* MemPlatformAllocate(u32 bytes) {\n#if defined(MEM_PLATFORM_WINDOWS)\n    return VirtualAlloc(0, bytes, MEM_COMMIT, PAGE_READWRITE);\n#elif defined(MEM_PLATFORM_WASM)\n    return &__heap_base;\n#endif\n}\n\nmem_cfunc void MemPlatformRelease(void* mem) {\n#if defined(MEM_PLATFORM_WINDOWS)\n    VirtualFree(mem, 0, MEM_RELEASE);\n#endif\n}\n\n// Can only manage up to 4 GiB of RAM. This is because internally pointers are keps as offsets\n// and each offset is stored as a u32\nmem_cfunc void* MemInitializeHeap(void* heap, u32 heapSize) {\n    PlatformAssert(heapSize > MEM_PAGE_SIZE * 3, __LOCATION__); // Arbitrary\n\n    // Align to be on a 4 byte boundary. This will cause all masks to be on a 4 byte boundary as well\n    // and will make sure that the page mask is 4 byte aligned (since the header is 40 bytes, and the mask starts right after)\n    u64 alignment = sizeof(u32); // 4\n    u8* align_heap = (u8*)heap;\n    if ((u64)align_heap % alignment != 0) {\n        u64 remainder = (u64)align_heap % alignment;\n        align_heap += (u32)alignment - (u32)remainder;\n        heapSize -= (u32)alignment - (u32)remainder;\n    }\n    gHeap = align_heap;\n\n    u32 numPages = heapSize / MEM_PAGE_SIZE;\n    u32 pageMaskCount = (numPages / 32) + (numPages % 32 != 0 ? 1 : 0);\n\n    PlatformAssert(numPages >= 0, __LOCATION__);\n\n    u32 overheadBytes = (MEM_ALLOCATOR_SIZE + pageMaskCount * sizeof(u32));\n\n    u32 overheadPageCount = (overheadBytes / MEM_PAGE_SIZE) + (overheadBytes % MEM_PAGE_SIZE != 0 ? 1 : 0);\n    u32 firstPageOffset = overheadPageCount * MEM_PAGE_SIZE; // 0 = 0, 1 = 4096, etc...\n\n    // As arguments, you pass in how big each sub-alloctors chunks should be. IE, i want this sub-allocator\n    // to allocate 72 byte chunks. Then there would be \"pageSize / (72 + sizeof(header))\" blocks in each page\n\n    // If you request an allocation that's MemAlloc(72, 4), it wouldn't fit into the allocator, because that\n    // allocation needs 72 + 4 bytes. So it would bucket over to the next allocator.\n\n    // In the above examples, 72 would be written to the allocator struct as a sub allocator size.\n    u32 subAlloc1Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 8)) / 8;\n    u32 subAlloc2Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 4)) / 4;\n    u32 subAlloc3Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 2)) / 2;\n\n    // struct Allocator (40 bytes)\n    /* u32 heapSizeBytes */ MEM_WRITEU32(align_heap, sizeof(u32) * 0, heapSize);             // 0\n    /* u32 overheadPages */ MEM_WRITEU32(align_heap, sizeof(u32) * 1, overheadPageCount);    // 4\n    /* u32 firstPage     */ MEM_WRITEU32(align_heap, sizeof(u32) * 2, firstPageOffset);      // 8\n    /* u32 activeAllocs  */ MEM_WRITEU32(align_heap, sizeof(u32) * 3, 0);                    // 12\n    /* u32 subAllocFree1 */ MEM_WRITEU32(align_heap, sizeof(u32) * 4, 0);                    // 16\n    /* u32 subAllocSize1 */ MEM_WRITEU32(align_heap, sizeof(u32) * 5, subAlloc1Size);        // 20\n    /* u32 subAllocFree2 */ MEM_WRITEU32(align_heap, sizeof(u32) * 6, 0);                    // 24\n    /* u32 subAllocSize2 */ MEM_WRITEU32(align_heap, sizeof(u32) * 7, subAlloc2Size);        // 28\n    /* u32 subAllocFree3 */ MEM_WRITEU32(align_heap, sizeof(u32) * 8, 0);                    // 32\n    /* u32 subAllocSize3 */ MEM_WRITEU32(align_heap, sizeof(u32) * 9, subAlloc3Size);        // 36\n    /* u32 usedPages     */ MEM_WRITEU32(align_heap, sizeof(u32) * 10, overheadPageCount);   // 40\n    /* u32 maxUedAtOnce  */ MEM_WRITEU32(align_heap, sizeof(u32) * 11, overheadPageCount);   // 44\n\n    // Clear page mask (and set overhead pages)\n    for (u32 page = 0; page < pageMaskCount; ++page) {\n        MEM_WRITEU32(align_heap, MEM_ALLOCATOR_SIZE + page * sizeof(u32), (page < overheadPageCount));\n    }\n\n    return align_heap;\n}\n\n// Returns true if all memory has been released. \nmem_cfunc int MemShutdownHeap(void* heap) {\n#if _DEBUG\n    u32 allocationOffset = MEM_ACTIVEALLOCSOFFSET(heap);\n    u32 numUnreleasedAllocations = 0;\n    while (allocationOffset != 0) {\n        u8* header = (u8*)heap + allocationOffset;\n\n        u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n        u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n        u64 _label = MEM_READU64(header, MEM_ALLOCATION_tag);\n        const char* label = (const char*)_label;\n\n#if MEM_ENABLE_ALLOCGUARD\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED, __LOCATION__);\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED, __LOCATION__);\n#endif\n\n        allocationOffset = MEM_READU32(header, MEM_ALLOCATION_allocNext); // Iterate to next element\n        numUnreleasedAllocations += 1;\n    }\n#endif\n\n    bool allAllocationsReleased = MEM_ACTIVEALLOCSOFFSET(heap) == 0;\n    bool subAllocPool0Empty = MEM_GETSUBALLOCOFFSET(heap, 0) == 0;\n    bool subAllocPool1Empty = MEM_GETSUBALLOCOFFSET(heap, 1) == 0;\n    bool subAllocPool2Empty = MEM_GETSUBALLOCOFFSET(heap, 2) == 0;\n\n    PlatformAssert(allAllocationsReleased && subAllocPool0Empty && subAllocPool1Empty && subAllocPool2Empty, __LOCATION__);\n    return allAllocationsReleased && subAllocPool0Empty && subAllocPool1Empty && subAllocPool2Empty;\n}\n\nmem_cfunc u32 MemGetPageSize() {\n    return MEM_PAGE_SIZE;\n}\n\nmem_cfunc u32* MemGetPageMask() {\n    return (u32*)((u8*)gHeap + MEM_ALLOCATOR_SIZE);\n}\n\nmem_cfunc u32 MemGetHeapSize() {\n    return MEM_READU32(gHeap, MEM_ALLOCATOR_heapSizeBytes);\n}\n\nmem_cfunc u32 MemGetNumOverheadPages() {\n    return MEM_READU32(gHeap, MEM_ALLOCATOR_overheadPages);\n}\n\nmem_cfunc u64 MemGetTag64(void* _mem) {\n    u8* mem = (u8*)_mem;\n    u16 padding = MEM_READU16((u8*)_mem - 2, 0);\n    u8* header = mem - padding - MEM_ALLOCATION_HEADER_SIZE;\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    return MEM_READU64(header, MEM_ALLOCATION_tag);\n}\n\nmem_cfunc void MemSetTag64(void* _mem, u64 tag) {\n    u8* mem = (u8*)_mem;\n    u16 padding = MEM_READU16((u8*)_mem - 2, 0);\n    u8* header = mem - padding - MEM_ALLOCATION_HEADER_SIZE;\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    MEM_WRITEU64(header, MEM_ALLOCATION_tag, tag);\n}\n\nmem_cfunc u32 MemGetTag32(void* _mem) {\n    return (u32)MemGetTag64(_mem);\n}\n\nmem_cfunc void MemSetTag32(void* _mem, u32 tag) {\n    MemSetTag64(_mem, tag);\n}\n\n// Returns 0 on error, or the index of the page where a range of numPages starts\nstatic u32 MemInternal_FindFreePages(void* heap, u32 numPages) {\n    PlatformAssert(heap != 0, __LOCATION__);\n    PlatformAssert(numPages >= 1, __LOCATION__);\n\n    // Find the required number of pages\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    u32 heapNumPages = MEM_HEAPSIZE(heap) / MEM_PAGE_SIZE;\n\n    // Find available pages\n    u32 startPage = 0; // Page 0 is invalid. First page must be reserved for overhead\n    u32 pageCount = 0;\n    for (u32 i = 1; i < heapNumPages; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n\n        if (pageMask[index] & (1 << bit)) { // Page is in use\n            startPage = 0;\n            pageCount = 0;\n        }\n        else { // Free page\n            if (startPage == 0) { // New range\n                startPage = i;\n                pageCount = 1;\n                if (numPages == 1) {\n                    break;\n                }\n            }\n            else { // Expand range\n                pageCount += 1;\n                if (pageCount == numPages) {\n                    break;\n                }\n            }\n        }\n    }\n\n    PlatformAssert(startPage != 0, __LOCATION__);\n    PlatformAssert(pageCount == numPages, __LOCATION__);\n\n    return startPage;\n}\n\nstatic bool MemInternal_ClaimPages(void* heap, u32 startPage, u32 pageCount) {\n    if (startPage == 0 || pageCount == 0) {\n        return false;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    for (u32 i = startPage, count = startPage + pageCount; i < count; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n        if ((pageMask[index] & (1 << bit))) {\n            PlatformAssert(false, __LOCATION__);\n            return false; // Error\n        }\n        pageMask[index] |= (1 << bit);\n    }\n\n    return true;\n}\n\nstatic bool MemInternal_ReleasePages(void* heap, u32 startPage, u32 pageCount) {\n    if (startPage == 0 || pageCount == 0) {\n        return false;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    for (u32 i = startPage, count = startPage + pageCount; i < count; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n        if (!(pageMask[index] & (1 << bit))) {\n            PlatformAssert(false, __LOCATION__);\n            return false; // Error\n        }\n        pageMask[index] &= ~(1 << bit);\n    }\n\n    return true;\n}\n\nstatic void MemInternal_WriteAllocationHeader(void* header, u32 startPage, u32 pageCount, u32 allocPrev, u32 allocNext, u64 tag) {\n    PlatformAssert(header != 0, __LOCATION__);\n\n    // struct Allocation\n#if MEM_ENABLE_ALLOCGUARD\n    /* u32 magic        */ MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, pageCount == 0 ? (MEM_ALLOCACTION_MAGIC_SUB_ACTIVE) : (MEM_ALLOCACTION_MAGIC_MAIN));\n#endif\n    /* u16 startPage    */ MEM_WRITEU16(header, MEM_ALLOCATION_startPage, startPage);   // 0\n    /* u16 pageCount    */ MEM_WRITEU16(header, MEM_ALLOCATION_pageCount, pageCount);   // 2\n    /* u32 allocPrev    */ MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, allocPrev);   // 4\n    /* u32 allocNext    */ MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, allocNext);   // 8\n    /* u64 tag          */ MEM_WRITEU64(header, MEM_ALLOCATION_tag, tag);               // 12\n#if MEM_ENABLE_ALLOCGUARD\n    /* u32 magic        */ MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, pageCount == 0 ? (MEM_ALLOCACTION_MAGIC_SUB_ACTIVE) : (MEM_ALLOCACTION_MAGIC_MAIN));\n#endif\n    /* u16 padding      */ MEM_WRITEU16(header, MEM_ALLOCATION_padding, 0);// Only sub-allocators use padding\n}\n\nstatic void MemInternal_AddAllocationToActiveListList(void* heap, void* header) {\n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    PlatformAssert(heap != 0, __LOCATION__);\n    PlatformAssert(header != 0, __LOCATION__);\n    PlatformAssert(header > heap, __LOCATION__);\n\n    u32 offset = (u8*)header - (u8*)heap;\n\n    u32 headOffset = MEM_READU32(heap, MEM_ALLOCATOR_activeAllocs);\n    if (headOffset != 0) {\n        u8* headHeader = (u8*)heap + headOffset;\n        // Replace the prev \"pointer\" (really offset), which should be 0 (assert?) with our own\n        MEM_WRITEU32(headHeader, MEM_ALLOCATION_allocPrev, offset); // Set the prev pointer of the old head to the current allocation\n    }\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, headOffset); // Set the next ptr of current allocation to old head\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, 0);\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activeAllocs, offset); // Set the current allocation as the new head\n}\n\n#if MEM_ENABLE_ALLOCGUARD\nstatic void MemInternal_RemoveAllocationFromActiveList(void* heap, void* header, u32 magic) {\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead == magic);\n    PlatformAssert(magicTail == magic);\n#else\nstatic void MemInternal_RemoveAllocationFromActiveList(void* heap, void* header) {\n#endif\n\n    u32 offset = (u8*)header - (u8*)heap;\n    u32 prev = MEM_READU32(header, MEM_ALLOCATION_allocPrev);\n    u32 next = MEM_READU32(header, MEM_ALLOCATION_allocNext);\n\n    if (next != 0) { // Reling next\n        u8* nextPtr = (u8*)heap + next;\n        MEM_WRITEU32(nextPtr, MEM_ALLOCATION_allocPrev, prev);\n    }\n\n    if (prev != 0) { // Relink prev\n        u8* prevPtr = (u8*)heap + prev;\n        MEM_WRITEU32(prevPtr, MEM_ALLOCATION_allocNext, next);\n    }\n\n    u32 headOffset = MEM_READU32(heap, MEM_ALLOCATOR_activeAllocs);\n    if (headOffset == offset) { // Update list head\n        MEM_WRITEU32(heap, MEM_ALLOCATOR_activeAllocs, next); // Head was detached, next is new head\n    }\n\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, 0);\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, 0);\n\n    // Header magic is expected to be set to free by caller\n}\n\nstatic void MemInternal_RemoveSubAllocationsFromFreeList(void* heap, u8 * header) {\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    PlatformAssert(magicTail == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n    u8* allocPtr = (u8*)(mask + 2);\n\n    u32 numAllocationsInBlock = (MEM_PAGE_SIZE - sizeof(u32)) / (u32)stride;\n    for (u32 i = 0; i < numAllocationsInBlock; ++i) {\n        u32 offset = (u8*)allocPtr - (u8*)heap;\n        u32 prev = MEM_READU32(allocPtr, MEM_ALLOCATION_allocPrev);\n        u32 next = MEM_READU32(allocPtr, MEM_ALLOCATION_allocNext);\n\n        if (next != 0) { // Relink next\n            u8* nextPtr = (u8*)heap + next;\n            MEM_WRITEU32(nextPtr, MEM_ALLOCATION_allocPrev, prev);\n        }\n\n        if (prev != 0) { // Relink prev\n            u8* prevPtr = (u8*)heap + prev;\n            MEM_WRITEU32(prevPtr, MEM_ALLOCATION_allocNext, next);\n        }\n\n        // Remove any list headers\n        if (offset == MEM_GETSUBALLOCOFFSET(heap, 0)) {\n            MEM_SETSUBALLOCOFFSET(heap, 0, next);\n        }\n        else if (offset == MEM_GETSUBALLOCOFFSET(heap, 1)) {\n            MEM_SETSUBALLOCOFFSET(heap, 1, next);\n        }\n        else if (offset == MEM_GETSUBALLOCOFFSET(heap, 2)) {\n            MEM_SETSUBALLOCOFFSET(heap, 2, next);\n        }\n\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_allocPrev, 0);\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_allocNext, 0);\n\n#if MEM_ENABLE_ALLOCGUARD\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_RELEASED);\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_RELEASED);\n\n        u8* write = allocPtr + MEM_ALLOCATION_magicTail + sizeof(u32);\n        *write = '\\0'; // Null out bit after magic\n        write = allocPtr + MEM_ALLOCATION_magicHead + sizeof(u32);\n        *write = '\\0'; // Null out bit after magic\n#endif\n\n        allocPtr = allocPtr + stride;\n    }\n}\n\nstatic void MemInternal_AddSubAllocationToFreeList(void* heap, u8 * header) {\n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n\n    u32 subAllocatorIndex = 0;\n    u32 subAlloc1Stride = MEM_SUBALLOCSIZE(heap, 0) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 subAlloc2Stride = MEM_SUBALLOCSIZE(heap, 1) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 subAlloc3Stride = MEM_SUBALLOCSIZE(heap, 2) + MEM_ALLOCATION_HEADER_SIZE;\n    if (stride == (u16)subAlloc1Stride) {\n        subAllocatorIndex = 0;\n    }\n    else if (stride == (u16)subAlloc2Stride) {\n        subAllocatorIndex = 1;\n    }\n    else if (stride == (u16)subAlloc3Stride) {\n        subAllocatorIndex = 2;\n    }\n    else {\n        PlatformAssert(false, __LOCATION__);//  Stride should be one of the known sub-allocator strides\n    }\n\n    u32 prev = 0; // Adding as head, always 0\n    u32 next = MEM_GETSUBALLOCOFFSET(heap, subAllocatorIndex); // Current head\n\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, prev);\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, next);\n\n    u32 headerOffset = header - (u8*)heap;\n    if (next != 0) { // Set next prev to this\n        u8* nextHeader = (u8*)heap + next;\n        MEM_WRITEU32(nextHeader, MEM_ALLOCATION_allocPrev, headerOffset);\n    }\n\n    MEM_SETSUBALLOCOFFSET(heap, subAllocatorIndex, headerOffset); // Set list head to this\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n}\n\nstatic void* MemInternal_SubAllocate(void* heap, u32 subAlloctorIndex, u32 bytes, u32 alignment, u64 tag) {\n    PlatformAssert(subAlloctorIndex <= 2, __LOCATION__);\n    PlatformAssert(heap != 0, __LOCATION__);\n    PlatformAssert(bytes != 0, __LOCATION__);\n\n    u32 subAllocHeaderStride = MEM_SUBALLOCSIZE(heap, subAlloctorIndex) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 numAllocationsInBlock = (MEM_PAGE_SIZE - sizeof(u32)) / subAllocHeaderStride; // First 32 bits in sub-alloc page is a flags mask.\n    PlatformAssert(numAllocationsInBlock >= 2, __LOCATION__);\n    u32 freeListOffset = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex);\n\n    // If free blocks for this sub-allocator don't exist, create some.\n    if (freeListOffset == 0) {\n        u32 page = MemInternal_FindFreePages(heap, 1);\n        PlatformAssert(page > 0, __LOCATION__);\n        if (!MemInternal_ClaimPages(heap, page, 1)) {\n            PlatformAssert(false, __LOCATION__);\n            return 0;\n        }\n        MemInternal_ActivePagesAdded((u8*)heap, 1);\n\n        u8* header = MEM_GETPAGEPTR(heap, page);\n        u16* subAllocationMask = (u16*)header;\n        *subAllocationMask = 0;\n        u16* subAllocationStride = subAllocationMask + 1;\n        *subAllocationStride = subAllocHeaderStride;\n\n        header += sizeof(u32);\n\n        for (u32 i = 0; i < numAllocationsInBlock; ++i) { // struct Allocation\n            u32 prev = 0; // Adding as head, always 0\n            u32 next = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex); // Current head\n\n            MemInternal_WriteAllocationHeader(header, page, 0, prev, next, (u64)\"uninitialized\"); // Sub allocation fence is active\n            //\n            MemInternal_AddSubAllocationToFreeList(heap, header); // Sub allocation fence is free\n\n            header += subAllocHeaderStride;\n        }\n    }\n\n    // Free block is guaranteed to exist. Grab one.\n    u32 head = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex); // Current head\n    u8* allocHeader = (u8*)heap + head;\n\n    // Align the allocation (if needed)\n    u8* allocation = allocHeader + MEM_ALLOCATION_HEADER_SIZE;\n    u64 address = (u64)allocation; // Align the allocation\n    u16 padding = 0;\n    if (alignment != 0 && address % alignment != 0) {\n        u64 remainder = address % alignment;\n        padding = (u16)(alignment - (u32)remainder);\n        allocation += padding;\n    }\n\n    // Update header data\n    MEM_WRITEU64(allocHeader, MEM_ALLOCATION_tag, tag); // Update tag\n    MEM_WRITEU16(allocHeader, MEM_ALLOCATION_padding, padding);\n    MEM_WRITEU16(allocation - 2, 0, padding);\n    \n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(allocHeader, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    PlatformAssert(MEM_READU32(allocHeader, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n\n    // Get the pointer to the current pages used bitmask, and find the right bit\n    u32 page = MEM_READU16(allocHeader, MEM_ALLOCATION_startPage);//head / MEM_PAGE_SIZE; // Also stored in allocHeader\n    u16* mask = (u16*)MEM_GETPAGEPTR(heap, page);\n    u8* firstAllocPtr = (u8*)mask + sizeof(u16) + sizeof(u16);\n\n    // Claim the allocation as used\n    u32 index = (allocHeader - firstAllocPtr) / subAllocHeaderStride;\n    u16 _mask = *mask;\n    PlatformAssert(!(_mask & (1 << index)), __LOCATION__); // Assume it was off before\n    _mask |= (1 << index);\n    *mask = _mask;\n\n    // If there is a next pointer, unhook this from it's prev, and set it as the new sub-alloc header\n    u32 next = MEM_READU32(allocHeader, MEM_ALLOCATION_allocNext);\n    if (next != 0) {\n        u8* nextHeader = (u8*)heap + next;\n        MEM_WRITEU32(nextHeader, MEM_ALLOCATION_allocPrev, 0); // Set next prev to 0 (unlink head)\n    }\n    MEM_SETSUBALLOCOFFSET(heap, subAlloctorIndex, next); // Set next to be the new head\n\n    MemInternal_AddAllocationToActiveListList(heap, allocHeader); // Will reset allocHeader prev and next pointers\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(allocHeader, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    MEM_WRITEU32(allocHeader, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    return allocation;\n}\n\nstatic i32 MemInternal_SubRelease(void* heap, void* target) {\n    PlatformAssert(target != 0, __LOCATION__);\n\n    u8* allocation = (u8*)target;\n    u16 padding = MEM_READU16(allocation - 2, 0);\n    u8* header = allocation - padding - MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    PlatformAssert(magicTail == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n    u8* firstAllocPtr = (u8*)(mask + 2);\n    u32 index = (header - firstAllocPtr) / (u32)stride;\n\n    u64 _tag = MEM_READU64(header, MEM_ALLOCATION_tag);\n    const char* tag = (const char*)_tag;\n    PlatformAssert(MEM_READU16(header, MEM_ALLOCATION_pageCount) == 0, __LOCATION__);\n\n    // Release (sub allocation) mask\n    u16 _mask = *mask;\n    if (!(_mask & (1 << index))) {  // Assume it was on before\n        PlatformAssert(false, __LOCATION__);\n        return 0;\n    }\n    _mask &= ~(1 << index);\n    *mask = _mask;\n\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_RemoveAllocationFromActiveList(heap, header, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#else\n    MemInternal_RemoveAllocationFromActiveList(heap, header);\n#endif\n    MemInternal_AddSubAllocationToFreeList(heap, header);\n\n    if (_mask == 0) { // Page is empty, release it\n        MemInternal_RemoveSubAllocationsFromFreeList(heap, header);  // Sets header magic\n        MemInternal_ReleasePages(heap, page, 1);\n        MemInternal_ActivePagesRemoved((u8*)heap, 1);\n    }\n\n    return 1;\n}\n\nmem_cfunc void* MemAllocateOnHeap(void* heap, u32 bytes, u32 alignment, void* _tag) {\n    u64 tag = (u64)_tag;\n\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    if (bytes == 0) {\n        return 0;\n    }\n\n    // Early out for any sub-allocators\n#if MEM_ENABLE_SUBALLOCATORS\n    if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 0)) {\n        return MemInternal_SubAllocate(heap, 0, bytes, alignment, tag);\n    }\n    else if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 1)) {\n        return MemInternal_SubAllocate(heap, 1, bytes, alignment, tag);\n    }\n    else if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 2)) {\n        return MemInternal_SubAllocate(heap, 2, bytes, alignment, tag);\n    }\n#endif\n\n    u32 totalAllocationSize = bytes + alignment + MEM_ALLOCATION_HEADER_SIZE;\n    u32 pageCount = totalAllocationSize / MEM_PAGE_SIZE + (totalAllocationSize % MEM_PAGE_SIZE == 0 ? 0 : 1);\n\n    // Find and claim available pages\n    u32 startPage = MemInternal_FindFreePages(heap, pageCount);\n    PlatformAssert(startPage != 0, __LOCATION__);\n    if (!MemInternal_ClaimPages(heap, startPage, pageCount)) {\n        PlatformAssert(false, __LOCATION__);\n        return 0; // Error\n    }\n\n    // Create allocation header\n    u8* memory = MEM_GETPAGEPTR(heap, startPage);\n    u8* allocation = memory + MEM_ALLOCATION_HEADER_SIZE;\n    u64 address = (u64)allocation; // Align the allocation\n    if (alignment != 0 && address % alignment != 0) {\n        u64 remainder = address % alignment;\n        allocation += alignment - (u32)remainder;\n    }\n    u8* header = allocation - MEM_ALLOCATION_HEADER_SIZE;\n\n    MemInternal_WriteAllocationHeader(header, startPage, pageCount, 0, 0, tag);\n    MemInternal_AddAllocationToActiveListList(heap, header); // Will set header prev and next pointers\n    MemInternal_ActivePagesAdded((u8*)heap, pageCount);\n\n    return allocation;\n}\n\n// Returns true if the memory was successfully released\n// Returns true if the memory being passed in is NULL\nmem_cfunc i32 MemReleaseFromHeap(void* heap, void* target) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    if (target == 0) { // Sage release\n        return true;\n    }\n\n    u16 padding = MEM_READU16((u8*)target - 2, 0);\n    u8* header = (u8*)target - padding - MEM_ALLOCATION_HEADER_SIZE;\n    u32 offset = header - (u8*)heap;\n\n    u16 startPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16 pageCount = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n\n    // Delegate to sub-allocator\n#if MEM_ENABLE_SUBALLOCATORS\n    if (pageCount == 0) { // No page count means it's a sub-allocator\n        return MemInternal_SubRelease(heap, target);\n    }\n#endif\n\n\n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_MAIN);\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_MAIN);\n#endif\n\n    // Clear the pages that where in use\n    MemInternal_ReleasePages(heap, startPage, pageCount);\n    MemInternal_ActivePagesRemoved((u8*)heap, pageCount);\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_RemoveAllocationFromActiveList(heap, header, MEM_ALLOCACTION_MAGIC_MAIN);\n#else\n    MemInternal_RemoveAllocationFromActiveList(heap, header);\n#endif\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_RELEASED);\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_RELEASED);\n\n    u8* write = header + MEM_ALLOCATION_magicHead + sizeof(u32);\n    *write = '\\0';\n    write = header + MEM_ALLOCATION_magicTail + sizeof(u32);\n    *write = '\\0';\n#endif\n\n    return 1;\n}\n\nmem_cfunc u32 MemForEachAllocationOnHeap(void* heap, fpAllocationInfo callback, void* userData) {\n    u32 numAllocations = 0;\n\n    u32 allocationOffset = MEM_ACTIVEALLOCSOFFSET(heap);\n    while (allocationOffset != 0) {\n        u8* header = (u8*)heap + allocationOffset;\n        u8* mem = header + MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n        u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n        u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n        allocationOffset = MEM_READU32(header, MEM_ALLOCATION_allocNext); // Iterate to next element\n        u64 _label = MEM_READU64(header, MEM_ALLOCATION_tag);\n        const char* loc = (const char*)_label;\n\n        if (callback != 0) {\n            callback(numAllocations, mem, firstPage, numPages, (void*)_label, userData);\n        }\n        numAllocations += 1;\n    }\n\n    return numAllocations;\n}\n\nmem_cfunc void* MemClear(void* dst, u32 bytes) {\n    return MemSet(dst, 0, bytes);\n}\n\nmem_cfunc void* MemReallocateOnHeap(void* heap, void* src, u32 newBytes, void* newTag) {\n    if (src == 0) {\n        return MemAllocateOnHeap(heap, newBytes, 4, newTag);\n    }\n    u16 padding = MEM_READU16((u8*)src - 2, 0);\n    u8* header = (u8*)src - padding - MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n    if (numPages == 0) {\n        numPages = 1;\n    }\n\n    u8* lastByte = MEM_GETPAGEPTR(heap, firstPage);\n    lastByte += numPages * MEM_PAGE_SIZE;\n    u32 maxAllocBytes = lastByte - (u8*)src;\n\n    u32 bytesToCopy = newBytes;\n    if (maxAllocBytes < bytesToCopy) {\n        bytesToCopy = maxAllocBytes;\n    }\n\n    void* newMem = MemAllocateOnHeap(heap, newBytes, 4, newTag); // Realloc is always 4 byte aligned. Consider storing alignment in each allocation as well?\n    if (bytesToCopy < newBytes) {\n        MemSet((u8*)newMem + bytesToCopy, 0, newBytes - bytesToCopy);\n    }\n    MemCopy(newMem, src, bytesToCopy);\n    MemRelease(src);\n\n    return newMem;\n}\n\nmem_cfunc void* MemCopy(void* _dst, const void* _src, u32 bytes) {\n    u8* dst = (u8*)_dst;\n    const u8* src = (const u8*)_src;\n\n    u32 delta = 0; // Check for overlap\n    if ((u32)dst < (u32)src) {\n        delta = (u32)src - (u32)dst;\n    }\n    else {\n        delta = (u32)dst - (u32)src;\n    }\n    PlatformAssert(delta >= bytes, __LOCATION__);\n\n    for (unsigned int b = 0; b < bytes; ++b) {\n        dst[b] = src[b];\n    }\n\n    return dst;\n}\n\nmem_cfunc void* MemSet(void* _dst, u8 val, u32 bytes) {\n    u8* dst = (u8*)_dst;\n\n    for (unsigned int b = 0; b < bytes; ++b) {\n        dst[b] = val;\n    }\n\n    return dst;\n}\n\nmem_cfunc i32 MemCompare(const void* _a, const void* _b, u32 bytes) {\n    const u8* a = (const u8*)_a;\n    const u8* b = (const u8*)_b;\n    for (u32 i = 0; i < bytes; ++i) {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        else if (b[i] < a[i]) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nmem_cfunc void* MemMove(void* destination, const void* source, u32 num) {\n    void* tmp = MemAlloc(num);\n    MemCopy(tmp, source, num);\n    MemCopy(destination, tmp, num);\n    MemRelease(tmp);\n    return destination;\n}","#include \"window.h\"\n\nextern \"C\" u32 AsciiToScancode(char val) {\n\tif (val >= 'a' && val <= 'z') {\n\t\treturn KeyboardCodeA + (val = 'a');\n\t}\n\tif (val >= 'A' && val <= 'Z') {\n\t\treturn KeyboardCodeA + (val = 'A');\n\t}\n\tif (val >= '0' && val <= '9') {\n\t\treturn KeyboardCode0 + (val = '0');\n\t}\n\n\tswitch (val) {\n\tcase '\\t': return KeyboardCodeTab;\n\tcase '\\\\': return KeyboardCodeBackslash;\n\tcase '\\'': return KeyboardCodeQoute;\n\tcase '`': return KeyboardCodeTick;\n\tcase '~': return KeyboardCodeTilde;\n\tcase '!': return KeyboardCode1;\n\tcase '@': return KeyboardCode2;\n\tcase '#': return KeyboardCode3;\n\tcase '$': return KeyboardCode4;\n\tcase '%': return KeyboardCode5;\n\tcase '^': return KeyboardCode6;\n\tcase '&': return KeyboardCode7;\n\tcase '*': return KeyboardCode8;\n\tcase '(': return KeyboardCode9;\n\tcase ')': return KeyboardCode0;\n\tcase '_': return KeyboardCodeUnderscore;\n\tcase '+': return KeyboardCodePlus;\n\tcase '-': return KeyboardCodeMinus;\n\tcase '=': return KeyboardCodeEquals;\n\tcase '[': return KeyboardCodeLBracket;\n\tcase '{': return KeyboardCodeLBrace;\n\tcase ']': return KeyboardCodeRbracket;\n\tcase '}': return KeyboardCodeRBrace;\n\tcase '|': return KeyboardCodeCarray;\n\tcase ';': return KeyboardCodeSemicolon;\n\tcase ':': return KeyboardCodeColon;\n\tcase '\"': return KeyboardCodeQoute;\n\tcase ',': return KeyboardCodeComma;\n\tcase '<': return KeyboardCodeLess;\n\tcase '.': return KeyboardCodePeriod;\n\tcase '>': return KeyboardCodeGreater;\n\tcase '/': return KeyboardCodeSlash;\n\tcase '?': return KeyboardCodeQuestionmark;\n\tdefault: return 0;\n\t}\n\n\treturn 0;\n}\n\nextern \"C\" char ScanCodeToAscii(u32 scanCode, bool shift) {\n\tif (scanCode >= KeyboardCodeA && scanCode <= KeyboardCodeZ) {\n\t\tif (shift) {\n\t\t\treturn 'A' + (scanCode - KeyboardCodeA);\n\t\t}\n\t\telse {\n\t\t\treturn 'a' + (scanCode - KeyboardCodeA);\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeDelete) {\n\t\treturn '\\a'; // Hacky at best :(\n\t}\n\telse if (scanCode == KeyboardCodeBackspace) { //    3\n\t\treturn '\\b';\n\t}\n\telse if (scanCode == KeyboardCodeReturn) { //    5\n\t\treturn '\\n';\n\t}\n\telse if (scanCode == KeyboardCodeSpace) { //   11\n\t\treturn ' ';\n\t}\n\telse if (scanCode == KeyboardCode0) { //   17\n\t\tif (shift) {\n\t\t\treturn ')';\n\t\t}\n\t\telse {\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode1) { //   18\n\t\tif (shift) {\n\t\t\treturn '!';\n\t\t}\n\t\telse {\n\t\t\treturn '1';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode2) { //   19\n\t\tif (shift) {\n\t\t\treturn '@';\n\t\t}\n\t\telse {\n\t\t\treturn '2';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode3) { //   20\n\t\tif (shift) {\n\t\t\treturn '#';\n\t\t}\n\t\telse {\n\t\t\treturn '3';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode4) { //   21\n\t\tif (shift) {\n\t\t\treturn '$';\n\t\t}\n\t\telse {\n\t\t\treturn '4';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode5) { //   22\n\t\tif (shift) {\n\t\t\treturn '%';\n\t\t}\n\t\telse {\n\t\t\treturn '5';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode6) { //   23\n\t\tif (shift) {\n\t\t\treturn '^';\n\t\t}\n\t\telse {\n\t\t\treturn '6';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode7) { //   24\n\t\tif (shift) {\n\t\t\treturn '&';\n\t\t}\n\t\telse {\n\t\t\treturn '7';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode8) { //   25\n\t\tif (shift) {\n\t\t\treturn '*';\n\t\t}\n\t\telse {\n\t\t\treturn '8';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode9) { //   26\n\t\tif (shift) {\n\t\t\treturn '(';\n\t\t}\n\t\telse {\n\t\t\treturn '9';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeColon) { //   53\n\t\tif (shift) {\n\t\t\treturn ':';\n\t\t}\n\t\telse {\n\t\t\treturn ';';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeEquals) { //   54\n\t\tif (shift) {\n\t\t\treturn '+';\n\t\t}\n\t\telse {\n\t\t\treturn '=';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeLess) { //   55\n\t\tif (shift) {\n\t\t\treturn '<';\n\t\t}\n\t\telse {\n\t\t\treturn ',';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeUnderscore) { //   56\n\t\tif (shift) {\n\t\t\treturn '_';\n\t\t}\n\t\telse {\n\t\t\treturn '-';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeGreater) { //   57\n\t\tif (shift) {\n\t\t\treturn '>';\n\t\t}\n\t\telse {\n\t\t\treturn '.';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeQuestionmark) { //   58\n\t\tif (shift) {\n\t\t\treturn '?';\n\t\t}\n\t\telse {\n\t\t\treturn '/';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeTick) { //   59\n\t\tif (shift) {\n\t\t\treturn '~';\n\t\t}\n\t\telse {\n\t\t\treturn '`';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeLBrace) { //   60\n\t\tif (shift) {\n\t\t\treturn '{';\n\t\t}\n\t\telse {\n\t\t\treturn '[';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeCarray) { //   61\n\t\tif (shift) {\n\t\t\treturn '|';\n\t\t}\n\t\telse {\n\t\t\treturn '\\\\';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeRBrace) { //   62\n\t\tif (shift) {\n\t\t\treturn '}';\n\t\t}\n\t\telse {\n\t\t\treturn ']';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeQoute) { //   63\n\t\tif (shift) {\n\t\t\treturn '\"';\n\t\t}\n\t\telse {\n\t\t\treturn '\\'';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeTab) { //   64\n\t\treturn '\\t';\n\t}\n\n\treturn 0;\n}","#include \"sort.h\"\n#include \"../debt/qsort.h\"\n\nstatic void SortInternal_Swap(void* a, void* b, unsigned int bytes) {\n\tunsigned char* x = (unsigned char*)a;\n\tunsigned char* y = (unsigned char*)b;\n\tunsigned char z = 0;\n\tfor (unsigned int b = 0; b < bytes; ++b) {\n\t\tz = x[b];\n\t\tx[b] = y[b];\n\t\ty[b] = z;\n\t}\n}\n\nvoid QSort(void* base, unsigned int nitems, unsigned int size, int (*compare)(const void*, const void*)) {\n\tunsigned char* m = (unsigned char*)base;\n\n#define QSRT_LESS(x, y) (compare(m + (x) * size, m + (y) * size) < 0)\n#define QSRT_SWAP(i, j) SortInternal_Swap(m + (i) * size, m + (j) * size, size)\n\tQSORT(nitems, QSRT_LESS, QSRT_SWAP);\n#undef QSRT_LESS\n#undef QSRT_SWAP\n}","#include \"draw2d.h\"\n\n#include \"../platform/memory.h\"\n#include \"../platform/math.h\"\n#include \"../framework/mat4.h\"\n#include \"../platform/graphics.h\"\n#include \"../debt/stb_image.h\"\n#include \"../platform/loader.h\"\n#include \"../debt/stb_truetype.h\"\n#include \"../debt/stb_rect_pack.h\"\n#include \"../debt/stb_sprintf.h\"\n#include \"vector.h\"\n\n#define DRAW2D_MAXVERTS 30000\n#define DRAW2D_MAXINDICES 100000\n#define DRAW2D_MAX_IMAGES 5\n#define DRAW2D_TEXTURE_PACKER_ATLAS_SIZE 1024\n#define DRAW2D_FONT_MAX_LINE_HEIGHT 512\n#define DRAW2D_NUM_ELLIPSE_SEGMENTS 45\n\nnamespace Draw2D {\n    namespace Internal {\n        struct Image {\n            u32 id; // Graphics System Texture ID\n            u32 width;\n            u32 height;\n        };\n\n        struct Vertex { // 36\n            vec2 position;\n            vec2 uv;\n            vec4 color;\n            u16 texture;\n            u16 padding;\n        };\n\n        struct Buffer {\n            u32 vboId;\n            u32 iboId;\n            u32 vaoId;\n        };\n\n        struct AsciiFontInstance {\n            u32 lineHeight;\n            f32 stbScale;\n            f32 scaledLineGap;\n            int advances[256];\n            ivec4 renderRects[256];\n            stbrp_rect packedGlyphs[256];\n            struct AsciiFont* prototype;\n        };\n\n        struct AsciiFont {\n            stbtt_fontinfo fontInfo;\n            i32 unscaledLineGap;\n            bool ownsMemory; // NOTE: Could stuff this into stbtt_fontinfo::userdata\n            bool active; // NOTE: Same as above, make the pointer into a bit mask.\n            Vector<AsciiFontInstance> instances;\n        };\n\n        struct State {\n            Vector<vec4> clipStack;\n            vec4 activeClip;\n\n            Vector<AsciiFont> loadedFonts;\n            Vector<Image> loadedImages;\n\n            u32 fontAtlas;\n            stbrp_context fontPacker;\n            stbrp_node* fontPackerNodes;\n            unsigned char* glyphBuffer;\n\n            u32 designWidth;\n            u32 designHeight;\n            f32 designDpi;\n            u32 displayWidth;\n            u32 displayHeight;\n\n            // Flushable\n            Vertex* vertices;\n            u32   numVertices;\n\n            u16* indices;\n            u32   numIndices;\n\n            u32 boundImages[DRAW2D_MAX_IMAGES];\n            u32 imgUniformSlots[DRAW2D_MAX_IMAGES];\n            u32 numBoundImages;\n\n            Buffer displayBuffer;\n\n            u32 imageShader; // Draw a tinted image.\n            //u32 imageShaderScreenSizeUniform;\n            u32 imageShaderAttribPosition;\n            u32 imageShaderAttribTexCoord;\n            u32 imageShaderAttribBlendColor;\n            u32 imageShaderAttribTexIndex;\n\n            u32 shaderToDraw; // Originally, i was going to support a shape only shader, etc. Keeping this here, but not using it for anything\n        };\n\n        State* gState;\n\n        inline vec2 MakeVertex(const vec2& position, const vec2& rotationPivot, float cosTheta, float sinTheta, const vec2& scale) {\n            vec2 vertex = (position - rotationPivot) * scale;\n\n            float x = (vertex.x * cosTheta) - (vertex.y * sinTheta);\n            float y = (vertex.x * sinTheta) + (vertex.y * cosTheta);\n\n            return vec2(x, y);\n        }\n\n        inline void SetVertexAttribs(Internal::Vertex* verts, u32 count, const vec2& uv, u16 texture, const vec4& color) {\n            for (u32 i = 0; i < count; ++i) {\n                verts[i].uv = uv;\n                verts[i].texture = texture;\n                verts[i].color = color;\n            }\n        }\n\n        inline vec4 UpdateClipStack() {\n            u32 globalClipLeft = 0;\n            u32 globalClipTop = 0;\n            u32 globalClipRight = gState->displayWidth;\n            u32 globalClipBottom = gState->displayHeight;\n\n            for (u32 i = 0, size = gState->clipStack.Count(); i < size; ++i) {\n                vec4 clipRect = gState->clipStack[i];\n\n                globalClipLeft = MathMaxF(clipRect.x, globalClipLeft);\n                globalClipTop = MathMaxF(clipRect.y, globalClipTop);\n                globalClipRight = MathMinF(globalClipLeft + clipRect.z, globalClipRight);\n                globalClipBottom = MathMinF(globalClipTop + clipRect.w, globalClipBottom);\n            }\n\n            vec4 clip(globalClipLeft, globalClipTop, globalClipRight - globalClipLeft, globalClipBottom - globalClipTop);\n\n            gState->activeClip = clip;\n            return clip;\n        }\n\n        void FlushAllDrawCommands() {\n            // Early out if there is nothing to flush\n            if (gState->numIndices == 0) {\n                return;\n            }\n\n            PlatformAssert(gState->numVertices != 0, __LOCATION__);\n            if (gState->shaderToDraw == 0) {\n                // No shader is bound, we shouldn't really get here....\n                // Try to recover gracefully, but break in debug\n                gState->numIndices = 0;\n                gState->numVertices = 0;\n                PlatformAssert(false, __LOCATION__);\n                return;\n            }\n\n            // Grab an iter from the free list\n            Buffer* iter = &gState->displayBuffer;\n\n            // Update Vertex and index data\n            GfxFillArrayBuffer(iter->vboId, gState->vertices, sizeof(Vertex) * gState->numVertices, false);\n            GfxFillIndexBuffer(iter->iboId, gState->indices, gState->numIndices * sizeof(u16), GfxIndexTypeShort, false);\n\n            float screenSize[3] = { (float)gState->displayWidth, (float)gState->displayHeight, (float)gState->designHeight };\n            PlatformAssert(gState->numBoundImages < 10, __LOCATION__); // Can only do single digits\n\n            // Fill out array objects for buffer, depending on what is being drawn\n            if (gState->shaderToDraw == gState->imageShader) {\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribPosition, iter->vboId, 2, sizeof(Vertex), GfxBufferTypeFloat32, 0);\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribTexCoord, iter->vboId, 2, sizeof(Vertex), GfxBufferTypeFloat32, sizeof(float) * 2);\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribBlendColor, iter->vboId, 4, sizeof(Vertex), GfxBufferTypeFloat32, sizeof(float) * (2 + 2));\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribTexIndex, iter->vboId, 1, sizeof(Vertex), GfxBufferTypeInt16, sizeof(float) * (2 + 2 + 4));\n                GfxAddIndexBufferToLayout(iter->vaoId, iter->iboId);\n\n                //GfxSetUniform(gState->shaderToDraw, gState->imageShaderScreenSizeUniform, screenSize, GfxUniformTypeFloat3, 1);\n                for (u32 i = 0; i < gState->numBoundImages; ++i) {\n                    GfxSetUniformTexture(gState->shaderToDraw, gState->imgUniformSlots[i], gState->boundImages[i]);\n                }\n            }\n            else {\n                PlatformAssert(false, __LOCATION__);\n            }\n\n            // Submit the finalized draw call\n            GfxDraw(0, 0, iter->vaoId, GfxDrawModeTriangles, 0, gState->numIndices, 1);\n\n            // Reset the CPU side buffers now that the data lives on the GPU\n            gState->numVertices = 0;\n            gState->numIndices = 0;\n            Internal::gState->numBoundImages = 1; // Bind font atlas always\n            Internal::gState->boundImages[0] = Internal::gState->loadedImages[0].id;\n        }\n\n        void FlushIfNeeded(u32 numNewVerts, u32 numNewIndices, u32 shaderId) {\n            // Flush if at vertex limit\n            if (Internal::gState->numVertices + numNewVerts >= DRAW2D_MAXVERTS) {\n                Internal::FlushAllDrawCommands(); // Will reset numRenderCommands to 0\n            }\n\n            // Flush if at index limit\n            else if (Internal::gState->numIndices + numNewIndices >= DRAW2D_MAXINDICES) {\n                Internal::FlushAllDrawCommands(); // Will reset numRenderCommands to 0\n            }\n\n            // Flush if the image shader isn't bound\n            else if (Internal::gState->shaderToDraw != shaderId) {\n                if (Internal::gState->shaderToDraw != 0) {\n                    Internal::FlushAllDrawCommands();\n                }\n            }\n            // Next flush will happen with the image shader\n            Internal::gState->shaderToDraw = shaderId;\n        }\n\n        void ClearCodePoints(Internal::AsciiFontInstance* instance) {\n            stbtt_fontinfo* info = &instance->prototype->fontInfo;\n            for (u32 i = 0; i < 256; ++i) {\n                instance->packedGlyphs[i].id = i;\n                instance->packedGlyphs[i].was_packed = 0;\n\n                instance->packedGlyphs[i].x = 0;\n                instance->packedGlyphs[i].y = 0;\n                instance->packedGlyphs[i].w = 0;\n                instance->packedGlyphs[i].h = 0;\n\n                instance->advances[i] = 0;\n                instance->renderRects[i] = ivec4(0, 0, 0, 0);\n            }\n        }\n\n        inline Internal::AsciiFontInstance* GetFontInstance(u32 fontIndex, u32 lineHeight) {\n            Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n            PlatformAssert(font->active, __LOCATION__);\n\n            Internal::AsciiFontInstance* instance = 0;\n            for (u32 i = 0, size = font->instances.Count(); i < size; ++i) {\n                if (font->instances[i].lineHeight == lineHeight) {\n                    instance = &font->instances[i];\n                    break;\n                }\n            }\n\n            if (instance == 0) {\n                u32 index = font->instances.Count();\n                stbtt_fontinfo* info = &font->fontInfo;\n\n                font->instances.PushBack();\n                instance = &font->instances[index];\n                instance->prototype = font;\n                instance->lineHeight = lineHeight;\n                instance->stbScale = stbtt_ScaleForPixelHeight(info, (float)lineHeight);\n                instance->scaledLineGap = (float)font->unscaledLineGap * instance->stbScale;\n                Internal::ClearCodePoints(instance);\n            }\n\n            return instance;\n        }\n\n        AsciiFontInstance* MakeSureGlyphIsCached(Internal::AsciiFontInstance* instance, unsigned char codePoint) {\n            Internal::AsciiFont* font = instance->prototype;\n            f32 stbScale = instance->stbScale;\n            u32 lineHeight = instance->lineHeight;\n            f32 dpi = gState->designDpi;\n\n            stbrp_rect packedRect = instance->packedGlyphs[codePoint];\n            if (!packedRect.was_packed) { // Glyph does not exist\n                PlatformAssert(packedRect.id == codePoint, __LOCATION__);\n\n                int ix0, ix1, iy0, iy1;\n                stbtt_GetCodepointBitmapBox(&font->fontInfo, codePoint, stbScale, stbScale, &ix0, &iy0, &ix1, &iy1);\n                int bitmapWidth = instance->packedGlyphs[codePoint].w = f32(ix1 - ix0) * dpi;\n                int bitmapHeight = instance->packedGlyphs[codePoint].h = f32(iy1 - iy0) * dpi;\n                instance->renderRects[codePoint] = ivec4(ix0, iy0, ix1, iy1);\n\n                // Pad out by 1 pixel on left and right\n                bitmapWidth += 2;\n                bitmapHeight += 2;\n                // Pad row to 4 bytes for openGL. \n                int alignTo4Bytes = (4 - (bitmapWidth % 4));\n                bitmapWidth += alignTo4Bytes;\n\n                int advance = 0;\n                int leftBearing = 0;\n                stbtt_GetCodepointHMetrics(&font->fontInfo, codePoint, &advance, &leftBearing);\n                instance->advances[codePoint] = advance;\n\n                instance->packedGlyphs[codePoint].w = bitmapWidth;\n                instance->packedGlyphs[codePoint].h = bitmapHeight;\n                packedRect.x = packedRect.y = packedRect.was_packed = 0;\n                int result = stbrp_pack_rects(&Internal::gState->fontPacker, &instance->packedGlyphs[codePoint], 1);\n                packedRect = instance->packedGlyphs[codePoint];\n\n                if (!result) { // Reset all cache\n                    FlushAllDrawCommands();\n                    stbrp_init_target(&Internal::gState->fontPacker, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, Internal::gState->fontPackerNodes, 4096);\n\n                    for (u32 i = 0, size = gState->loadedFonts.Count(); i < size; ++i) {\n                        Internal::AsciiFont* clearFont = &gState->loadedFonts[i];\n                        clearFont->instances.~Vector(); // Reset instances\n                        new (&clearFont->instances) Vector<Internal::AsciiFontInstance>();\n                    }\n\n                    PlatformAssert(font->instances.Count() == 0, __LOCATION__);\n                    font->instances.PushBack();\n                    instance = &font->instances[0];\n                    instance->prototype = font;\n                    instance->lineHeight = lineHeight;\n                    instance->stbScale = stbScale = stbtt_ScaleForPixelHeight(&font->fontInfo, (float)lineHeight);\n                    instance->scaledLineGap = (float)font->unscaledLineGap * stbScale;\n                    ClearCodePoints(instance);\n\n                    instance->packedGlyphs[codePoint].w = bitmapWidth;\n                    instance->packedGlyphs[codePoint].h = bitmapHeight;\n                    instance->packedGlyphs[codePoint].x = 0;\n                    instance->packedGlyphs[codePoint].y = 0;\n                    instance->packedGlyphs[codePoint].was_packed = 0;\n                    int result = stbrp_pack_rects(&Internal::gState->fontPacker, &instance->packedGlyphs[codePoint], 1);\n                    packedRect = instance->packedGlyphs[codePoint];\n                }\n\n                // Remove padding now that it's packed\n                packedRect.w -= 2;\n                packedRect.h -= 2;\n                packedRect.w -= alignTo4Bytes;\n                instance->packedGlyphs[codePoint] = packedRect;\n\n                PlatformAssert(result == 1, __LOCATION__);\n\n                stbtt_MakeCodepointBitmap(&font->fontInfo, gState->glyphBuffer,\n                    bitmapWidth, bitmapHeight, bitmapWidth,\n                    stbScale * dpi, stbScale * dpi, codePoint);\n\n#if 0\n                int bytes = 0; // Debug code to make sure stbtt_MakeCodepointBitmap drew each glyph properly\n                unsigned char* png = stbi_write_png_to_mem(gState->glyphBuffer, bitmapWidth, bitmapWidth, bitmapHeight, 1, &bytes);\n                char path[6] = { codePoint, '.', 'p', 'n', 'g', '\\0' };\n                WriteDebugFile(path, png, bytes);\n                MemRelease(png); // It did\n#endif\n\n                GfxWriteToTexture(gState->fontAtlas, gState->glyphBuffer, GfxTextureFormatR8,\n                    packedRect.x, packedRect.y, bitmapWidth, bitmapHeight);\n\n            }\n\n            PlatformAssert(packedRect.was_packed, __LOCATION__);\n\n            return instance;\n        }\n    }\n\n    void Initialize() {\n        Internal::gState = (Internal::State*)MemAlloc(sizeof(Internal::State));\n        MemSet(Internal::gState, 0, sizeof(Internal::State));\n\n        Internal::gState->vertices = (Internal::Vertex*)MemAlloc(sizeof(Internal::Vertex) * DRAW2D_MAXVERTS);\n        Internal::gState->indices = (u16*)MemAlloc(sizeof(u16) * DRAW2D_MAXINDICES);\n        Internal::gState->numVertices = 0;\n        Internal::gState->numIndices = 0;\n\n        new (&Internal::gState->clipStack) Vector<vec4>(); // Just allocated, do what the constructor does\n        new (&Internal::gState->loadedFonts) Vector<Internal::AsciiFont>(); // Just allocated, do what the constructor does\n        new (&Internal::gState->loadedImages) Vector<Internal::Image>(); // Just allocated, do what the constructor does\n\n        Internal::gState->fontAtlas = GfxCreateTexture(0, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, GfxTextureFormatR8, GfxTextureFormatR8, false);\n        GfxSetTextureSampler(Internal::gState->fontAtlas, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear, GfxFilterNone, GfxFilterLinear);\n        Internal::Image fontImage;\n        fontImage.width = DRAW2D_TEXTURE_PACKER_ATLAS_SIZE;\n        fontImage.height = DRAW2D_TEXTURE_PACKER_ATLAS_SIZE;\n        fontImage.id = Internal::gState->fontAtlas;\n        Internal::gState->loadedImages.PushBack(fontImage);\n        Internal::gState->numBoundImages = 1; // Bind font atlas always\n        Internal::gState->boundImages[0] = Internal::gState->loadedImages[0].id;\n\n        Internal::gState->fontPackerNodes = (stbrp_node*)MemAlloc(sizeof(stbrp_node) * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * 2);\n        stbrp_init_target(&Internal::gState->fontPacker, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, Internal::gState->fontPackerNodes, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * 2);\n        Internal::gState->glyphBuffer = (unsigned char*)MemAlloc(sizeof(unsigned char) * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE);\n        MemSet(Internal::gState->glyphBuffer, 0, sizeof(unsigned char) * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE);\n\n        Internal::UpdateClipStack();\n\n        const char* vShader =\n            \"#version 300 es  \\n\"\n            \"precision highp float;\\n\"\n            \"precision highp int;\\n\"\n            \"in vec2 position;\\n\"\n            \"in vec2 texCoord;\\n\"\n            \"in vec4 blendColor;\\n\"\n            \"in int texIndex;\\n\"\n            \"out vec2 vTexCoord;\\n\"\n            \"out vec4 vBlendColor;\\n\"\n            \"flat out int vTexIndex;\\n\"\n            \"void main() {\\n\"\n            \"    vec2 ndc = vec2(position.x, 1.0 - position.y);\\n\"\n            \"    ndc = ndc * 2.0 - 1.0;\\n\"\n            \"    gl_Position = vec4(ndc, 0.0, 1.0);\\n\"\n            \"    vTexCoord = texCoord;\\n\"\n            \"    vBlendColor = blendColor;\\n\"\n            \"    vTexIndex = texIndex;\\n\"\n            \"}\\n\";\n\n        // Note, consider making variations of this shader that have less in the switch satatments\n        const char* fShader =\n            \"#version 300 es  \\n\"\n            \"precision highp float;\\n\"\n            \"precision highp int;\\n\"\n            \"flat in int vTexIndex;\\n\"\n            \"in vec2 vTexCoord;\\n\"\n            \"in vec4 vBlendColor;\\n\"\n            \"uniform sampler2D tex0;\\n\"\n            \"uniform sampler2D tex1;\\n\"\n            \"uniform sampler2D tex2;\\n\"\n            \"uniform sampler2D tex3;\\n\"\n            \"uniform sampler2D tex4;\\n\"\n            \"uniform sampler2D tex5;\\n\"\n            \"uniform sampler2D tex6;\\n\"\n            \"uniform sampler2D tex7;\\n\"\n            \"out vec4 outputColor;\\n\"\n            \"void main() {\\n\"\n            \"   vec4 texColor = vec4(0, 0, 0, 1);\\n\"\n            \"   switch (vTexIndex) {\\n\"\n            \"      case 0: texColor = vec4(vBlendColor.rgb, vBlendColor.a * texture(tex0, vTexCoord).r); break;\\n\"\n            \"      case 1: texColor = texture(tex1, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 2: texColor = texture(tex2, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 3: texColor = texture(tex3, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 4: texColor = texture(tex4, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 5: texColor = texture(tex5, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 6: texColor = texture(tex6, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 7: texColor = texture(tex7, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 8: texColor = vBlendColor; break;\\n\"\n            \"   }\\n\"\n            \"   outputColor = texColor;\\n\"\n            \"}\\n\";\n\n        Internal::gState->imageShader = GfxCreateShader(vShader, fShader);\n        //Internal::gState->imageShaderScreenSizeUniform = GfxGetUniformSlot(Internal::gState->imageShader, \"screenSize\");\n        Internal::gState->imageShaderAttribPosition = GfxGetAttributeSlot(Internal::gState->imageShader, \"position\");\n        Internal::gState->imageShaderAttribTexCoord = GfxGetAttributeSlot(Internal::gState->imageShader, \"texCoord\");\n        Internal::gState->imageShaderAttribBlendColor = GfxGetAttributeSlot(Internal::gState->imageShader, \"blendColor\");\n        Internal::gState->imageShaderAttribTexIndex = GfxGetAttributeSlot(Internal::gState->imageShader, \"texIndex\");\n\n        PlatformAssert(DRAW2D_MAX_IMAGES < 10, __LOCATION__);\n        char uniformName[] = { 't', 'e', 'x', '0', '\\0' };\n        for (u32 i = 0; i < DRAW2D_MAX_IMAGES; ++i) {\n            uniformName[3] = '0' + i;\n            Internal::gState->imgUniformSlots[i] = GfxGetUniformSlot(Internal::gState->imageShader, uniformName);\n        }\n\n        Internal::gState->displayBuffer.vboId = GfxCreateBuffer();\n        Internal::gState->displayBuffer.iboId = GfxCreateBuffer();\n        Internal::gState->displayBuffer.vaoId = GfxCreateVertexLayout(Internal::gState->imageShader);\n    }\n\n    void Shutdown() {\n        GfxDestroyBuffer(Internal::gState->displayBuffer.vboId);\n        GfxDestroyBuffer(Internal::gState->displayBuffer.iboId);\n        GfxDestroyShaderVertexLayout(Internal::gState->displayBuffer.vaoId);\n\n        MemRelease(Internal::gState->fontPackerNodes);\n        MemRelease(Internal::gState->glyphBuffer);\n\n        GfxDestroyShader(Internal::gState->imageShader);\n\n        // Destroy font\n        GfxDestroyTexture(Internal::gState->fontAtlas);\n        for (u32 i = 0, size = Internal::gState->loadedFonts.Count(); i < size; ++i) {\n            DestroyFont(i);\n        }\n        Internal::gState->loadedFonts.~Vector();\n\n        // Cleanup textures\n        // Image 0 is always the texture atlas, which is managed manually. Skip it.\n        for (u32 i = 1, size = Internal::gState->loadedImages.Count(); i < size; ++i) {\n            PlatformAssert(Internal::gState->loadedImages[i].id == 0, __LOCATION__);\n            if (Internal::gState->loadedImages[i].id != 0) {\n                GfxDestroyTexture(Internal::gState->loadedImages[i].id);\n            }\n        }\n        Internal::gState->loadedImages.~Vector();\n        Internal::gState->clipStack.~Vector();\n\n        MemRelease(Internal::gState->vertices);\n        MemRelease(Internal::gState->indices);\n        MemRelease(Internal::gState);\n    }\n\n    u32 LoadImage(void* memory, u32 bytes, Interpolation interp) {\n        i32 width = 0;\n        i32 height = 0;\n        i32 components = 0;\n\n        unsigned char* img_data = stbi_load_from_memory((unsigned char*)memory, bytes, &width, &height, &components, 0);\n        unsigned int format = (components == 4) ? GfxTextureFormatRGBA8 : GfxTextureFormatRGB8;\n        u32 imageId = GfxCreateTexture(img_data, width, height, format, format, true);\n        MemRelease(img_data);\n\n        Vector<Draw2D::Internal::Image>& loadedImages = Internal::gState->loadedImages;\n        // Loaded image 0 is always the texture atlas, skip it\n        for (u32 i = 1, size = loadedImages.Count(); i < size; ++i) {\n            if (loadedImages[i].id == 0) {\n                loadedImages[i].id = imageId;\n                loadedImages[i].width = width;\n                loadedImages[i].height = height;\n\n                return i;\n            }\n        }\n\n        if (interp == Interpolation::Step) {\n            GfxSetTextureSampler(imageId, GfxWrapClamp, GfxWrapClamp, GfxFilterNearest, GfxFilterNearest, GfxFilterNearest);\n        }\n\n        Internal::Image result = { imageId, (u32)width, (u32)height };\n        Internal::gState->loadedImages.PushBack(result);\n        return Internal::gState->loadedImages.Count() - 1;\n    }\n\n    void DestroyImage(u32 imageId) {\n        u32 textureId = Internal::gState->loadedImages[imageId].id;\n        GfxDestroyTexture(textureId);\n        Internal::gState->loadedImages[imageId].id = 0;\n    }\n\n    void DrawImage(u32 image, f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 sourceX, f32 sourceY, f32 sourceW, f32 sourceH, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotationRadians, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        if (scaleX * scaleY == 0.0f) {\n            return;\n        }\n\n        Internal::FlushIfNeeded(4, 6, Internal::gState->imageShader);\n\n\n        // Flush if no more images can be bound\n        u32 textureId = Internal::gState->loadedImages[image].id;\n        PlatformAssert(textureId != 0, __LOCATION__);\n        float textureWidth = (float)Internal::gState->loadedImages[image].width;\n        float textureHeight = (float)Internal::gState->loadedImages[image].height;\n\n        bool found = false;\n        u32 imageIndex = 0;\n        for (u32 i = 0, size = Internal::gState->numBoundImages; i < size; ++i) {\n            if (Internal::gState->boundImages[i] == textureId) {\n                imageIndex = i;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (Internal::gState->numBoundImages >= DRAW2D_MAX_IMAGES) {\n                Internal::FlushAllDrawCommands(); // Will reset numBoundImages to 0\n            }\n            imageIndex = Internal::gState->numBoundImages++;\n        }\n        Internal::gState->boundImages[imageIndex] = textureId;\n\n        float designScale = Internal::gState->designDpi;\n\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 4;\n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 screenSize(screenW, screenH);\n        vec2 screenPos(screenX, screenY);\n\n        float cosTheta = MathCos(rotationRadians);\n        float sinTheta = MathSin(rotationRadians);\n\n        SetVertexAttribs(verts, 4, vec2(), imageIndex, vec4(blendR, blendG, blendB, blendA));\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[0].uv = vec2(sourceX / textureWidth, sourceY / textureHeight);\n        vec2 p1 = (Internal::MakeVertex(vec2(screenSize.x, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[1].uv = vec2((sourceX + sourceW) / textureWidth, sourceY / textureHeight);\n        vec2 p2 = (Internal::MakeVertex(vec2(screenSize.x, screenSize.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[2].uv = vec2((sourceX + sourceW) / textureWidth, (sourceY + sourceH) / textureHeight);\n        vec2 p3 = (Internal::MakeVertex(vec2(0, screenSize.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[3].uv = vec2(sourceX / textureWidth, (sourceY + sourceH) / textureHeight);\n\n        if (Internal::gState->clipStack.Count() > 0) { // Clip bounding box against screen bounds\n            f32 left = MathMinF(MathMinF(MathMinF(p0.x, p1.x), p2.x), p3.x);\n            f32 top = MathMinF(MathMinF(MathMinF(p0.y, p1.y), p2.y), p3.y);\n            f32 right = MathMaxF(MathMaxF(MathMaxF(p0.x, p1.x), p2.x), p3.x);\n            f32 bottom = MathMaxF(MathMaxF(MathMaxF(p0.y, p1.y), p2.y), p3.y);\n\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x; // This prob needs to be scaled\n            f32 clipTop = clip.y;\n            f32 clipRight = (clip.x + clip.z);\n            f32 clipBotom = (clip.y + clip.w);\n\n            // If any of these are true, the box is invisible\n            if (left > clipRight || right < clipLeft || top > clipBotom || bottom < clipTop) {\n                Internal::gState->numVertices -= 4;\n                return; // Reset and early out\n            }\n        }\n\n        { //  After culling, move into design space, and then normalize to prep for shader\n            vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n            verts[0].position = p0 * designScale / screenSize;\n            verts[1].position = p1 * designScale / screenSize;\n            verts[2].position = p2 * designScale / screenSize;\n            verts[3].position = p3 * designScale / screenSize;\n        }\n\n        if (scaleX < 0.0f) {\n            float tmp = verts[0].uv.x;\n            verts[0].uv.x = verts[1].uv.x;\n            verts[1].uv.x = tmp;\n\n            tmp = verts[2].uv.x;\n            verts[2].uv.x = verts[3].uv.x;\n            verts[3].uv.x = tmp;\n        }\n\n        if (scaleY < 0.0f) {\n            float tmp = verts[0].uv.y;\n            verts[0].uv.y = verts[2].uv.y;\n            verts[2].uv.y = tmp;\n\n            tmp = verts[1].uv.y;\n            verts[1].uv.y = verts[3].uv.y;\n            verts[3].uv.y = tmp;\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 6;\n\n        bool ccw = true;\n        /* This no longer matters. I made scale be always positive, and flip uv coords instead\n        if ((scaleX < 0 && scaleY > 0) || (scaleY < 0 && scaleX > 0)) {\n            ccw = false;\n        }*/\n\n        if (ccw) { // default\n            indices[0] = firstVertex + 1;\n            indices[1] = firstVertex + 3;\n            indices[2] = firstVertex + 2;\n\n            indices[3] = firstVertex + 1;\n            indices[4] = firstVertex + 0;\n            indices[5] = firstVertex + 3;\n        }\n        else {\n            indices[0] = firstVertex + 1;\n            indices[1] = firstVertex + 2;\n            indices[2] = firstVertex + 3;\n\n            indices[3] = firstVertex + 1;\n            indices[4] = firstVertex + 3;\n            indices[5] = firstVertex + 0;\n        }\n    }\n\n    void Begin(u32 designWidth, u32 designHeight, f32 designScale, u32 screenWidth, u32 screenHeight){\n        GfxDisableDepthTest();\n        GfxSetViewport(0, 0, screenWidth, screenHeight);\n\n        PlatformAssert(Internal::gState->numVertices == 0, __LOCATION__);\n        PlatformAssert(Internal::gState->numIndices == 0, __LOCATION__);\n        Internal::gState->numBoundImages = 1; // Bind font atlas always\n        Internal::gState->boundImages[0] = Internal::gState->loadedImages[0].id;\n\n        Internal::gState->displayWidth = screenWidth;\n        Internal::gState->displayHeight = screenHeight;\n\n        Internal::gState->designWidth = designWidth;\n        Internal::gState->designHeight = designHeight;\n        Internal::gState->designDpi = designScale;\n\n        Internal::UpdateClipStack();\n    }\n\n    void End()                                                                                                                                                {\n        PlatformAssert(Internal::gState->clipStack.Count() == 0, __LOCATION__);\n        while (Internal::gState->clipStack.Count() != 0) {\n            PopClip();\n        }\n\n        Internal::FlushAllDrawCommands();\n    }\n\n    void EnableAlphaBlending() {\n        Internal::FlushAllDrawCommands();\n        u32 src = GfxBlendFuncSrcAlpha;\n        u32 dst = GfxBlendFuncOneMinusSrcAlpha;\n        u32 blend = GfxBlendEquationAdd;\n        GfxSetBlendState(true, 0, dst, dst, blend, blend, src, src);\n    }\n\n    void DisableAlphaBlending() {\n        Internal::FlushAllDrawCommands();\n        u32 src = GfxBlendFuncSrcAlpha;\n        u32 dst = GfxBlendFuncOneMinusSrcAlpha;\n        u32 blend = GfxBlendEquationAdd;\n        GfxSetBlendState(false, 0, dst, dst, blend, blend, src, src);\n    }\n\n    void PushClip(f32 x, f32 y, f32 w, f32 h) {\n        Internal::FlushAllDrawCommands();\n        Internal::gState->clipStack.PushBack(vec4(x, y, w, h));\n        vec4 clip = Internal::UpdateClipStack();\n        \n        // Modify clip to be in window space\n        float dpi = Internal::gState->designDpi;\n        clip.y = Internal::gState->displayHeight - clip.y * dpi;\n        clip.y -= clip.w * dpi; // And be bottom left coordinates\n\n        GfxSetClipState(true, clip.x * dpi, clip.y, clip.z * dpi, clip.w * dpi);\n    }\n\n    void PopClip() {\n        Internal::FlushAllDrawCommands();\n        Internal::gState->clipStack.PopBack();\n        vec4 clip = Internal::UpdateClipStack();\n        \n        // Modify clip to be in window space\n        float dpi = Internal::gState->designDpi;\n        clip.y = Internal::gState->displayHeight - clip.y * dpi;\n        clip.y -= clip.w * dpi; // And be bottom left coordinates\n        \n        GfxSetClipState(Internal::gState->clipStack.Count() != 0, clip.x, clip.y, clip.z, clip.w);\n    }\n\n    u32 LoadFont(void* memory, u32 bytes, bool own) {\n        Internal::AsciiFont* font = 0;\n        u32 size = size = Internal::gState->loadedFonts.Count();\n        for (u32 i = 0; i < size; ++i) { // The only place it's actually used as size\n            if (!Internal::gState->loadedFonts[i].active) {\n                font = &Internal::gState->loadedFonts[i];\n                size = i; // Font index, not size.\n                break;\n            }\n        }\n        if (font == 0) {\n            Internal::gState->loadedFonts.PushBack();\n            font = &Internal::gState->loadedFonts[size]; // Used as font index, not size\n        }\n\n        PlatformAssert(font != 0, __LOCATION__);\n\n        font->active = stbtt_InitFont(&font->fontInfo, (const unsigned char*)memory, 0) != 0;\n        PlatformAssert(font->active, __LOCATION__);\n        new (&font->instances) Vector<Internal::AsciiFontInstance>(); // Initialize vector\n        font->ownsMemory = own; // If the memory is owned, DestroyFont calls free on stbtt_fontinfo::data, which is the memory argument being passed in.\n\n        i32 ascent = 0;\n        i32 descent = 0;\n        i32 linegap = 0;\n        stbtt_GetFontVMetrics(&font->fontInfo, &ascent, &descent, &linegap);\n        font->unscaledLineGap = ascent - descent + linegap;\n\n        return size; // It's the font index, not size. Just re-using the variable.\n    }\n\n    void DestroyFont(u32 fontIndex) {\n        Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n        PlatformAssert(font->active, __LOCATION__);\n        font->active = false;\n\n        if (font->ownsMemory) {\n            MemRelease(font->fontInfo.data);\n            font->fontInfo.data = 0;\n            font->ownsMemory = false;\n        }\n        font->instances.~Vector();\n    }\n\n    Rect MeasureSubString(u32 font, u32 pixelHeight, const char* string, u32 startIndex, u32 len) {\n        if (string == 0) {\n            return Rect();\n        }\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(font, pixelHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        vec2 carrat;\n        vec2 reference;\n\n        int kern = 0;\n        float maxX = 0.0f;\n        u32 index = 0;\n        for (const char* iter = string; *iter != '\\0'; ++iter, ++index) {\n            char codePoint = *iter;\n\n            if (index == startIndex) {\n                reference = carrat;\n            }\n\n            if (index >= startIndex + len) {\n                break;\n            }\n\n            if (codePoint == '\\n') {\n                if (carrat.x > maxX) {\n                    maxX = carrat.x;\n                }\n                carrat.x = 0;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n\n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n\n        if (carrat.x > maxX) {\n            maxX = carrat.x;\n        }\n\n        return Rect(reference.x, reference.y, MathMaxF(maxX - reference.x, 0.0f),MathMaxF(carrat.y - reference.y + instance->scaledLineGap, 0.0f));\n    }\n\n    int FindStringIndex(u32 font, u32 pixelHeight, const char* string, const vec2& relativePoint) {\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(font, pixelHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n\n        vec2 carrat;\n        int kern = 0;\n        int index = 0;\n        for (const char* iter = string; *iter != '\\0'; ++iter, ++index) {\n            char codePoint = *iter;\n\n            if (codePoint == '\\n') {\n                carrat.x = 0;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n\n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            \n            if (relativePoint.x >= carrat.x && relativePoint.x <= carrat.x + f32(advance + kern) * stbScale) {\n                if (relativePoint.y >= carrat.y && relativePoint.y <= carrat.y + instance->scaledLineGap) {\n                    float midPoint = carrat.x + (f32(advance + kern) * stbScale) * 0.5f;\n                    return relativePoint.x < midPoint? index : index + 1;\n                }\n            }\n\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n\n        return -1;\n    }\n\n    Size MeasureString(u32 font, u32 pixelHeight, const char* string) {\n        if (string == 0) {\n            return Size();\n        }\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(font, pixelHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        \n        vec2 carrat;\n        int kern = 0;\n        float maxX = 0.0f;\n        for (const char* iter = string; *iter != '\\0'; ++iter) {\n            char codePoint = *iter;\n\n            if (codePoint == '\\n') {\n                if (carrat.x > maxX) {\n                    maxX = carrat.x;\n                }\n                carrat.x = 0;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n\n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            if (!instance->packedGlyphs[codePoint].was_packed) { // TODO: remove, debug only\n                char string[64] = { 0 };\n                stbsp_snprintf(string, 64, \"Could not pack glyph %c, %d\", codePoint, codePoint);\n                PrintDebugString(string);\n            }\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n\n        if (carrat.x > maxX) {\n            maxX = carrat.x;\n        }\n\n        return Size(maxX, carrat.y + instance->scaledLineGap);\n    }\n\n    void DrawCodePoint(u32 fontIndex, u32 lineHeight, f32 x, f32 y, unsigned char codePoint, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        PlatformAssert(lineHeight <= DRAW2D_FONT_MAX_LINE_HEIGHT, __LOCATION__);\n        if (lineHeight > DRAW2D_FONT_MAX_LINE_HEIGHT) {\n            lineHeight = DRAW2D_FONT_MAX_LINE_HEIGHT; // Enforce a max line height...\n        }\n        Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n        PlatformAssert(font->active, __LOCATION__);\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(fontIndex, lineHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        PlatformAssert(stbScale > 0.0f, __LOCATION__);\n\n        stbtt_fontinfo* info = &font->fontInfo;\n        u32 fontAtlas = 0; // The font atlas is always bound to slot 0 of loaded images\n\n        instance = MakeSureGlyphIsCached(instance, codePoint);\n        PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n        stbrp_rect packedGlyph = instance->packedGlyphs[codePoint];\n\n        f32 displayX = x + instance->renderRects[codePoint].x;\n        f32 displayY = y + instance->renderRects[codePoint].y;\n        f32 displayW = (instance->renderRects[codePoint].z - instance->renderRects[codePoint].x);\n        f32 displayH = (instance->renderRects[codePoint].w - instance->renderRects[codePoint].y);\n\n        f32 scale = 1.0f;\n\n        DrawImage(fontAtlas,\n            displayX, displayY, displayW, displayH,\n            packedGlyph.x, packedGlyph.y, packedGlyph.w, packedGlyph.h,\n            scale, scale, 0, 0, 0, blendR, blendG, blendB, blendA);\n    }\n\n    void DrawString(u32 fontIndex, u32 lineHeight, f32 x, f32 y, const char* string, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        if (string == 0) {\n            return;\n        }\n        PlatformAssert(lineHeight <= DRAW2D_FONT_MAX_LINE_HEIGHT, __LOCATION__);\n        if (lineHeight > DRAW2D_FONT_MAX_LINE_HEIGHT) {\n            lineHeight = DRAW2D_FONT_MAX_LINE_HEIGHT; // Enforce a max line height...\n        }\n        Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n        PlatformAssert(font->active, __LOCATION__);\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(fontIndex, lineHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        PlatformAssert(stbScale > 0.0f, __LOCATION__);\n        \n        stbtt_fontinfo* info = &font->fontInfo;\n\n        vec2 carrat(x, y);\n        u32 fontAtlas = 0; // The font atlas is always bound to slot 0 of loaded images\n\n        //char last = '\\0';\n        for (const char* iter = string; *iter != '\\0'; ++iter) {\n            char codePoint = *iter;\n\n            if (codePoint == '\\n') {\n                carrat.x = x;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n            \n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            int kern = 0;// Disabled kerning to make font easier to measure. // stbtt_GetCodepointKernAdvance(info, last, codePoint);\n\n            stbrp_rect packedGlyph = instance->packedGlyphs[codePoint];\n            \n            f32 displayX = carrat.x + instance->renderRects[codePoint].x;\n            f32 displayY = carrat.y + instance->renderRects[codePoint].y;\n            f32 displayW = (instance->renderRects[codePoint].z - instance->renderRects[codePoint].x);\n            f32 displayH = (instance->renderRects[codePoint].w - instance->renderRects[codePoint].y);\n\n            f32 scale = 1.0f;\n\n            DrawImage(fontAtlas, \n                displayX, displayY, displayW, displayH,\n                packedGlyph.x, packedGlyph.y, packedGlyph.w, packedGlyph.h,\n                scale, scale, 0, 0, 0, blendR, blendG, blendB, blendA);\n\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n    }\n\n    void DrawRect(f32 _x, f32 _y, f32 _w, f32 _h, f32 blendR, f32 blendG, f32 blendB, f32 blendA, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotationRadians) {\n        if (scaleX * scaleY == 0.0f) {\n            return;\n        }\n\n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        Internal::FlushIfNeeded(4, 6, Internal::gState->imageShader);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 4;\n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 size(_w, _h);\n        vec2 screenPos(_x, _y);\n\n        float cosTheta = MathCos(rotationRadians);\n        float sinTheta = MathSin(rotationRadians);\n\n        SetVertexAttribs(verts, 4, vec2(), 8, vec4(blendR, blendG, blendB, blendA));\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p1 = (Internal::MakeVertex(vec2(size.x, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p2 = (Internal::MakeVertex(vec2(size.x, size.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p3 = (Internal::MakeVertex(vec2(0, size.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        \n        if (Internal::gState->clipStack.Count() > 0) { // Clip bounding box against screen bounds\n            f32 left =   MathMinF(MathMinF(MathMinF(p0.x, p1.x), p2.x), p3.x);\n            f32 top =    MathMinF(MathMinF(MathMinF(p0.y, p1.y), p2.y), p3.y);\n            f32 right =  MathMaxF(MathMaxF(MathMaxF(p0.x, p1.x), p2.x), p3.x);\n            f32 bottom = MathMaxF(MathMaxF(MathMaxF(p0.y, p1.y), p2.y), p3.y);\n\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x; // This prob needs to be scaled\n            f32 clipTop = clip.y;\n            f32 clipRight = (clip.x + clip.z);\n            f32 clipBotom = (clip.y + clip.w);\n\n            // If any of these are true, the box is invisible\n            if (left > clipRight || right < clipLeft || top > clipBotom || bottom < clipTop) {\n                Internal::gState->numVertices -= 4;\n                return; // Reset and early out\n            }\n        }\n\n        { //  After culling, move into design space, and then normalize to prep for shader\n            verts[0].position = p0 * designScale / screenSize;\n            verts[1].position = p1 * designScale / screenSize;\n            verts[2].position = p2 * designScale / screenSize;\n            verts[3].position = p3 * designScale / screenSize;\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 6;\n        \n        indices[0] = firstVertex + 1;\n        indices[1] = firstVertex + 3;\n        indices[2] = firstVertex + 2;\n\n        indices[3] = firstVertex + 1;\n        indices[4] = firstVertex + 0;\n        indices[5] = firstVertex + 3;\n    }\n    \n    void DrawEllipse(f32 x, f32 y, f32 radiusX, f32 radiusY, f32 blendR, f32 blendG, f32 blendB, f32 blendA, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotationRadians) {\n        if (scaleX * scaleY == 0.0f) {\n            return;\n        }\n\n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        Internal::FlushIfNeeded(DRAW2D_NUM_ELLIPSE_SEGMENTS + 1, DRAW2D_NUM_ELLIPSE_SEGMENTS * 3, Internal::gState->imageShader);\n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 screenPos(x, y);\n\n        float cosTheta = MathCos(rotationRadians);\n        float sinTheta = MathSin(rotationRadians);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* vertices = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += DRAW2D_NUM_ELLIPSE_SEGMENTS + 1;\n\n        SetVertexAttribs(vertices, DRAW2D_NUM_ELLIPSE_SEGMENTS + 1, vec2(), 8, vec4(blendR, blendG, blendB, blendA));\n\n        vertices[0].position = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos) * designScale / screenSize;\n\n        for (u32 i = 1; i < DRAW2D_NUM_ELLIPSE_SEGMENTS + 1; ++i) {\n            float theta = 2.0f * MathPI * float(i - 1) / float(DRAW2D_NUM_ELLIPSE_SEGMENTS - 1);\n            float xPos = radiusX * MathCos(theta);\n            float yPos = radiusY * MathSin(theta);\n\n            vertices[i].position = (Internal::MakeVertex(vec2(xPos, yPos), pivot, cosTheta, sinTheta, scale) + screenPos) * designScale / screenSize;\n        }\n\n        if (Internal::gState->clipStack.Count() > 0) {\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x;\n            f32 clipTop =  clip.y;\n            f32 clipRight = clipLeft + clip.z;\n            f32 clipBotom =  clipTop + clip.w;\n\n            f32 boundsLeft = (x - radiusX);\n            f32 boundsTop = (y - radiusY);\n            f32 boundsRight = (x + radiusX);\n            f32 boundsBottom = (y + radiusY);\n\n            // If any of these are true, the box is invisible\n            if (boundsLeft > clipRight || boundsRight < clipLeft || boundsTop > clipBotom || boundsBottom < clipTop) {\n                Internal::gState->numVertices -= DRAW2D_NUM_ELLIPSE_SEGMENTS + 1;\n                return; // Reset and early out\n            }\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += DRAW2D_NUM_ELLIPSE_SEGMENTS * 3;\n        u32 pivotVertex = firstVertex;\n        for (u32 i = 0; i < DRAW2D_NUM_ELLIPSE_SEGMENTS; ++i) {\n            u32 vertex = (firstVertex + 1) + i;\n            u32 nextVertex = (firstVertex + 2) + i;\n            if (i + 1 >= DRAW2D_NUM_ELLIPSE_SEGMENTS) {\n                nextVertex = firstVertex + 1;\n            }\n            indices[i * 3 + 0] = pivotVertex;\n            indices[i * 3 + 1] = nextVertex;\n            indices[i * 3 + 2] = vertex;\n        }\n    }\n\n    // https://forum.libcinder.org/topic/smooth-thick-lines-using-geometry-shader\n    void DrawLine(f32* points, u32 numPoints, f32 thickness, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        thickness *= 0.5f;\n\n        PlatformAssert(numPoints >= 2, __LOCATION__);\n        const u32 numVertsNeeded = numPoints * 2;\n        const u32 numIndicesNeeded = (numPoints - 1) * 6;\n        Internal::FlushIfNeeded(numVertsNeeded, numIndicesNeeded, Internal::gState->imageShader);\n        \n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        vec4 color(blendR, blendG, blendB, blendA);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* vertices = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += numVertsNeeded;\n\n        SetVertexAttribs(vertices, numVertsNeeded, vec2(), 8, vec4(blendR, blendG, blendB, blendA));\n\n        vec2 p0(points[0], points[1]);\n        vec2 p1(points[2], points[3]);\n        vec2 line01 = p1 - p0;\n        vec2 dir01 = normalized(line01);\n        vec2 norm01(-dir01.y, dir01.x);\n\n        vec2 debug1 = p0 - norm01 * thickness;\n        vec2 debug2 = p0 + norm01 * thickness;\n        vertices[0].position = (p0 - norm01 * thickness) * designScale / screenSize;\n        vertices[1].position = (p0 + norm01 * thickness) * designScale / screenSize;\n\n        vec2 min = vertices[0].position;\n        vec2 max = min;\n\n        if (vertices[1].position.x < min.x) {\n            min.x = vertices[1].position.x;\n        }\n        if (vertices[1].position.y < min.y) {\n            min.y = vertices[1].position.y;\n        }\n        if (vertices[1].position.x > max.x) {\n            max.x = vertices[1].position.x;\n        }\n        if (vertices[1].position.y > max.y) {\n            max.y = vertices[1].position.y;\n        }\n\n        for (u32 i = 1; i < numPoints - 1; ++i) {\n            p0 = vec2(points[(i - 1) * 2 + 0], points[(i - 1) * 2 + 1]);\n            p1 = vec2(points[i * 2 + 0], points[i * 2 + 1]);\n            vec2 p2(points[(i + 1) * 2 + 0], points[(i + 1) * 2 + 1]);\n            \n            line01 = p1 - p0;\n            dir01 = normalized(line01);\n            norm01 = vec2(-dir01.y, dir01.x);\n\n            vec2 line12 = p2 - p1;\n            vec2 dir12 = normalized(line12);\n            vec2 norm12(-dir12.y, dir12.x);\n\n            vec2 tangent = normalized(dir01 + dir12);\n            vec2 miter(-tangent.y, tangent.x);\n            f32 length = thickness;\n            f32 dt = dot(miter, norm01);\n            if (dt != 0.0f) {\n                length = thickness / dot(miter, norm01);\n            }\n\n            vertices[i * 2 + 0].position = (p1 - miter * length) * designScale / screenSize;\n            vertices[i * 2 + 1].position = (p1 + miter * length) * designScale / screenSize;\n\n            if (vertices[i * 2 + 0].position.x < min.x) {\n                min.x = vertices[i * 2 + 0].position.x;\n            }\n            if (vertices[i * 2 + 0].position.y < min.y) {\n                min.y = vertices[i * 2 + 0].position.y;\n            }\n            if (vertices[i * 2 + 0].position.x > max.x) {\n                max.x = vertices[i * 2 + 0].position.x;\n            }\n            if (vertices[i * 2 + 0].position.y > max.y) {\n                max.y = vertices[i * 2 + 0].position.y;\n            }\n\n            if (vertices[i * 2 + 1].position.x < min.x) {\n                min.x = vertices[i * 2 + 1].position.x;\n            }\n            if (vertices[i * 2 + 1].position.y < min.y) {\n                min.y = vertices[i * 2 + 1].position.y;\n            }\n            if (vertices[i * 2 + 1].position.x > max.x) {\n                max.x = vertices[i * 2 + 1].position.x;\n            }\n            if (vertices[i * 2 + 1].position.y > max.y) {\n                max.y = vertices[i * 2 + 1].position.y;\n            }\n        }\n\n        // This is acutally p1 and p2. I just didn't want to declare new vartiables here for these\n        p0 = vec2(points[(numPoints - 2) * 2 + 0], points[(numPoints - 2) * 2 + 1]);\n        p1 = vec2(points[(numPoints - 1) * 2 + 0], points[(numPoints - 1) * 2 + 1]);\n        line01 = p1 - p0;\n        dir01 = normalized(line01);\n        norm01 = vec2(-dir01.y, dir01.x);\n\n        vertices[numPoints * 2 - 2].position = (p1 - norm01 * thickness) * designScale / screenSize;\n        vertices[numPoints * 2 - 1].position = (p1 + norm01 * thickness) * designScale / screenSize;\n\n        if (vertices[numPoints * 2 - 2].position.x < min.x) {\n            min.x = vertices[numPoints * 2 - 2].position.x;\n        }\n        if (vertices[numPoints * 2 - 2].position.y < min.y) {\n            min.y = vertices[numPoints * 2 - 2].position.y;\n        }\n        if (vertices[numPoints * 2 - 2].position.x > max.x) {\n            max.x = vertices[numPoints * 2 - 2].position.x;\n        }\n        if (vertices[numPoints * 2 - 2].position.y > max.y) {\n            max.y = vertices[numPoints * 2 - 2].position.y;\n        }\n\n        if (vertices[numPoints * 2 - 1].position.x < min.x) {\n            min.x = vertices[numPoints * 2 - 1].position.x;\n        }\n        if (vertices[numPoints * 2 - 1].position.y < min.y) {\n            min.y = vertices[numPoints * 2 - 1].position.y;\n        }\n        if (vertices[numPoints * 2 - 1].position.x > max.x) {\n            max.x = vertices[numPoints * 2 - 1].position.x;\n        }\n        if (vertices[numPoints * 2 - 1].position.y > max.y) {\n            max.y = vertices[numPoints * 2 - 1].position.y;\n        }\n        \n        if (Internal::gState->clipStack.Count() > 0) { \n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x * designScale / screenSize.x;\n            f32 clipTop = clip.y * designScale / screenSize.y;\n            f32 clipRight = (clip.x + clip.z) * designScale / screenSize.x;\n            f32 clipBotom = (clip.y +  clip.w) * designScale / screenSize.y;\n\n            f32 boundsLeft = min.x;\n            f32 boundsTop = min.y;\n            f32 boundsRight = max.x;\n            f32 boundsBottom = (max.y);\n\n            // If any of these are true, the box is invisible\n            if (boundsLeft > clipRight || boundsRight < clipLeft || boundsTop > clipBotom || boundsBottom < clipTop) {\n                Internal::gState->numVertices -= numPoints * 2;\n                return; // Reset and early out\n            }\n        }\n\n        // Generate indices\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += numIndicesNeeded;\n\n        u32 idx = 0;\n        for (u32 i = 0; i < (numPoints - 1); ++i) {\n            indices[idx++] = firstVertex + (2 * i) + 3;\n            indices[idx++] = firstVertex + (2 * i) + 2;\n            indices[idx++] = firstVertex + (2 * i) + 1;\n\n            indices[idx++] = firstVertex + (2 * i) + 1;\n            indices[idx++] = firstVertex + (2 * i) + 2;\n            indices[idx++] = firstVertex + (2 * i) + 0;\n        }\n    }\n}","#ifndef _H_GRAPHICS_\n#define _H_GRAPHICS_\n\ntypedef unsigned int u32;\ntypedef int i32;\ntypedef float f32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(f32) == 4, \"f32 should be a 4 byte type\");\nstatic_assert (sizeof(void*) >= 4, \"pointer should be >= 4 byte type\");\n\n#define GfxBufferTypeFloat32            0\n#define GfxBufferTypeInt16              3\n#define GfxBufferTypeInt32              5\n\n#define GfxIndexTypeByte                1\n#define GfxIndexTypeShort               2\n#define GfxIndexTypeInt                 4\n\n#define GfxTextureFormatRGB8            0\n#define GfxTextureFormatRGBA8           1\n#define GfxTextureFormatR32F            2\n#define GfxTextureFormatRGB32F          3\n#define GfxTextureFormatDepth           4\n#define GfxTextureFormatR8              5 \n// GfxTextureFormatDepth is only a target format, not a source format\n\n#define GfxFilterNearest                0\n#define GfxFilterLinear                 1\n#define GfxFilterNone                   2\n\n#define GfxWrapRepeat                   0\n#define GfxWrapClamp                    1\n\n#define GfxUniformTypeInt1              0\n#define GfxUniformTypeInt2              1\n#define GfxUniformTypeInt3              2\n#define GfxUniformTypeInt4              3\n#define GfxUniformTypeFloat1            4\n#define GfxUniformTypeFloat2            5\n#define GfxUniformTypeFloat3            6\n#define GfxUniformTypeFloat4            7\n#define GfxUniformTypeFloat9            8\n#define GfxUniformTypeFloat16           9\n#define GfxUniformTypeTexture           10\n\n#define GfxDepthFuncAlways              0\n#define GfxDepthFuncNever               1\n#define GfxDepthFuncEqual               2\n#define GfxDepthFuncLEqual              3\n#define GfxDepthFuncGreater             4\n#define GfxDepthFuncGEqual              5\n#define GfxDepthFuncNotEqual            6\n#define GfxDepthFuncLess                7\n\n#define GfxCullFaceOff                  0\n#define GfxCullFaceBack                 1\n#define GfxCullFaceFront                2\n#define GfxCullFaceFrontAndBack         3\n\n#define GfxFaceWindCounterClockwise     0\n#define GfxFaceWindClockwise            1\n\n#define GfxBlendFuncZero                1\n#define GfxBlendFuncOne                 2\n#define GfxBlendFuncSrcColor            3\n#define GfxBlendFuncOneMinusSrcColor    4\n#define GfxBlendFuncDstColor            5\n#define GfxBlendFuncOneMinusDstColor    6\n#define GfxBlendFuncSrcAlpha            7\n#define GfxBlendFuncOneMinusSrcAlpha    8\n#define GfxBlendFuncDstAlpha            9\n#define GfxBlendFuncOneMinusDstAlpha    10\n#define GfxBlendFuncConstColor          11\n#define GfxBlendFuncOneMinusConstColor  12\n#define GfxBlendFuncConstAlpha          13\n#define GfxBlendFuncOneMinusconstAlpha  14\n#define GfxBlendFuncSrcAlphaSaturate    15\n\n#define GfxBlendEquationAdd             0\n#define GfxBlendEquationSubtract        1\n#define GfxBlendEquationReverseSubtract 2\n#define GfxBlendEquationMin             3\n#define GfxBlendEquationMax             4\n\n#define GfxDrawModePoints               0\n#define GfxDrawModeLines                1\n#define GfxDrawModeLineStrip            2\n#define GfxDrawModeTriangles            3\n#define GfxDrawModeTriangleStrip        4\n#define GfxDrawModeTriangleFan          5\n\nextern \"C\" u32 GfxCreateBuffer();\nextern \"C\" void GfxDestroyBuffer(u32 bufferId);\n\nextern \"C\" void GfxFillArrayBuffer(u32 bufferId, void* input, u32 bytes, bool _static);\nextern \"C\" void GfxFillIndexBuffer(u32 bufferId, void* input, u32 bytes, u32 indexType, bool _static);\n\ninline u32 GfxCreateArrayBuffer(void* input, u32 bytes, bool _static) {\n    u32 buffer = GfxCreateBuffer();\n    GfxFillArrayBuffer(buffer, input, bytes, _static);\n    return buffer;\n}\n\ninline u32 GfxCreateIndexBuffer(void* input, u32 bytes, u32 indexType, bool _static = true) {\n    u32 buffer = GfxCreateBuffer();\n    GfxFillIndexBuffer(buffer, input, bytes, indexType, _static);\n    return buffer;\n}\n\nextern \"C\" u32 GfxCreateShader(const char* vsource, const char* fsource);\nextern \"C\" void GfxDestroyShader(u32 shaderId);\n\nextern \"C\" i32 GfxGetUniformSlot(u32 shaderId, const char* name);\nextern \"C\" i32 GfxGetAttributeSlot(u32 shaderId, const char* name);\n\nextern \"C\" u32 GfxCreateShaderVertexLayout(u32 shaderId);\n#define GfxCreateVertexLayout GfxCreateShaderVertexLayout\nextern \"C\" void GfxAddBufferToLayout(u32 layoutId, i32 attribSlot, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\nextern \"C\" void GfxAddBufferToLayoutByName(u32 layoutId, const char* name, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\nextern \"C\" void GfxDestroyShaderVertexLayout(u32 layoutId);\n\ninline void GfxAddIndexBufferToLayout(u32 layoutId, u32 bufferId) {\n    GfxAddBufferToLayout(layoutId, -1, bufferId, 1, 0, GfxBufferTypeInt16, 0);\n}\n\nextern \"C\" u32 GfxCreateTexture(void* data, u32 width, u32 height, u32 sourceFormat, u32 targetFormat, bool genMips);\ninline u32 GfxCreateDepthTexture(u32 width, u32 height) {\n    return GfxCreateTexture(0, width, height, GfxTextureFormatDepth, GfxTextureFormatDepth, false);\n}\nextern \"C\" void GfxSetTextureSampler(u32 textureId, u32 wrapS, u32 wrapT, u32 minFilter, u32 mipFilter, u32 magFilter);\nextern \"C\" void GfxDestroyTexture(u32 textureId);\n\n// Data and texture format must match. IE, can't upload RGBA to an RGB texture\nextern \"C\" void GfxWriteToTexture(u32 textureId, void* data, u32 dataAndTextureFormat, u32 x, u32 y, u32 w, u32 h);\n\nextern \"C\" void GfxSetUniform(u32 shaderId, u32 uniformSlot, void* data, u32 uniformType, u32 count); \ninline void GfxSetUniformTexture(u32 shaderId, u32 uniformSlot, u32 textureId) {\n    GfxSetUniform(shaderId, uniformSlot, (void*)textureId, 10, 1);\n}\n\nextern \"C\" void GfxClearAll(u32 colorTargetId, u32 depthTargetId, float r, float g, float b, float d);\nextern \"C\" void GfxClearColor(u32 colorTargetTextureId, u32 depthTargetTextureId, float r, float g, float b);\nextern \"C\" void GfxClearDepth(u32 colorTargetTextureId, u32 depthTargetTextureId, float depth);\nextern \"C\" void GfxDraw(u32 colorTargetTextureId, u32 depthTargetTextureId, u32 vertexLayoutId, u32 drawMode, u32 startIndex, u32 indexCount, u32 instanceCount);\n\nextern \"C\" void GfxSetBlendState(bool blend, f32* optBlendColor, u32 blendDstRgb, u32 blendDstAlpha, u32 blendEquationRgb, u32 blendEquationAlpha, u32 blendSrcRgb, u32 blendSrcAlpha);\ninline void GfxEnableAlphaBlending() {\n\n}\nextern \"C\" void GfxSetCullState(u32 cullFace, u32 faceWind);\nextern \"C\" void GfxSetDepthState(bool enable, u32 depthFunc, f32* depthRange);\ninline void GfxEnableDepthTest() {\n    GfxSetDepthState(true, GfxDepthFuncLess, 0);\n}\ninline void GfxDisableDepthTest() {\n    GfxSetDepthState(false, GfxDepthFuncLess, 0);\n}\n\n// OpenGL style, bottom left / width and height\nextern \"C\" void GfxSetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\n#define GfxSetClipState GfxSetScissorState\nextern \"C\" void GfxSetWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void GfxSetViewport(u32 x, u32 y, u32 w, u32 h);\n\n// Initialize and shutdown functions exist, but you don't call them\n// the platform does. The void* that's being passed in is platform\n// specific, it contains whatever we need for OpenGL rendering \nextern \"C\" int GfxInitialize(void* in, void* out);\nextern \"C\" void GfxShutdown(void* userData);\nextern \"C\" void GfxFinish(); // This just calls glFinish, used to wait for vsynch on windows\n\n#endif","#ifndef _H_VECTOR_\n#define _H_VECTOR_\n\n#include \"../platform/memory.h\"\n#include \"../platform/assert.h\"\n\ntemplate<typename T>\nclass Vector {\n    T* mData;\n    u32 mCount;\n    u32 mCapacity;\npublic:\n    inline Vector() {\n        mData = 0;\n        mCount = 0;\n        mCapacity = 0;\n    }\n\n    inline Vector(u32 capacity) {\n        mData = (T*)MemAlloc(sizeof(T) * capacity);\n        mCount = 0;\n        mCapacity = capacity;\n    }\n\n\n    inline Vector(T* array, u32 count) {\n        mData = (T*)MemAlloc(sizeof(T) * count);\n        MemCopy(mData, array, count * sizeof(T));\n        mCount = count;\n        mCapacity = count;\n    }\n\n    inline Vector(const Vector<T>& other) {\n        mCapacity = other.mCapacity;\n        mCount = other.mCount;\n        mData = (T*)MemAlloc(sizeof(T) * mCapacity);\n        MemCopy(mData, other.mData, mCapacity * sizeof(T));\n    }\n\n    inline Vector<T>& operator=(const Vector<T>& other) {\n        PlatformAssert(this != &other, __LOCATION__);\n        if (this != &other) {\n            if (mData != 0) {\n                MemRelease(mData);\n            }\n            mCapacity = other.mCapacity;\n            mCount = other.mCount;\n            mData = (T*)MemAlloc(sizeof(T) * mCapacity);\n            MemCopy(mData, other.mData, mCapacity * sizeof(T));\n        }\n\n        return *this;\n    }\n\n    inline ~Vector() {\n        if (mData != 0) {\n            MemRelease(mData);\n        }\n        mData = 0;\n        mCount = 0;\n        mCapacity = 0;\n    }\npublic:\n    T& operator[](u32 i) { \n        PlatformAssert(i < mCount, __LOCATION__);\n        PlatformAssert(mData != 0, __LOCATION__);\n        return mData[i]; \n    }\n\n    const T& operator[](u32 i) const { \n        PlatformAssert(i < mCount, __LOCATION__);\n        PlatformAssert(mData != 0, __LOCATION__);\n        return mData[i];\n    }\n\n    inline void Reserve(u32 count) {\n        if (count < 1) {\n            count = 1;\n        }\n\n        if (count > mCapacity) {\n            T* newData = (T*)MemAlloc(sizeof(T) * count);\n            if (mCapacity > 0) {\n                MemCopy(newData, mData, mCapacity * sizeof(T));\n            }\n            mCapacity = count;\n            if (mData != 0) {\n                MemRelease(mData);\n            }\n            mData = newData;\n        }\n    }\n\n    inline void Resize(u32 count) {\n        Reserve(count);\n        mCount = count;\n    }\n    \n    inline void PushBack() {\n        if (mCapacity == 0) {\n            Reserve(2);\n        }\n\n        if (mCapacity - mCount == 0) {\n            Reserve(mCapacity * 2);\n        }\n\n        MemSet(&mData[mCount++], 0, sizeof(T));\n    }\n\n    inline void PushBack(const T& val) {\n        if (mCapacity == 0) {\n            Reserve(2);\n        }\n        \n        if (mCapacity - mCount == 0) {\n            Reserve(mCapacity * 2);\n        }\n\n        MemCopy(&mData[mCount++], &val, sizeof(T));\n    }\n\n    inline void PopBack() {\n        if (mCount > 0) {\n            mCount -= 1;\n        }\n    }\n\n    inline void Append(const T* array, u32 size) {\n        Reserve(mCount + size);\n        MemCopy(&mData[mCount], array, sizeof(T) * size);\n        mCount += size;\n    }\n\n    inline T* PeekHead() {\n        if (mCount != 0) {\n            return &mData[0];\n        }\n        return 0;\n    }\n\n    inline T* PeekTail() {\n        if (mCount != 0) {\n            return &mData[mCount - 1];\n        }\n        return 0;\n    }\n\n    inline u32 Count() {\n        return mCount;\n    }\n\n    inline u32 Capacity() {\n        return mCapacity;\n    }\n};\n\n#endif","#ifndef _H_VEC4_\n#define _H_VEC4_\n\ntemplate<typename T>\nstruct TVec4 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t\tT z;\n\t\t\tT w;\n\t\t};\n\t\tT v[4];\n\t};\n\tinline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n\tinline TVec4(T _x, T _y, T _z, T _w) :\n\t\tx(_x), y(_y), z(_z), w(_w) { }\n\tinline TVec4(T* fv) :\n\t\tx(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n};\n\ntypedef TVec4<float> vec4;\ntypedef TVec4<int> ivec4;\ntypedef TVec4<unsigned int> uivec4;\n\n#endif","// stb_truetype.h - v1.26 - public domain\n// authored from 2009-2021 by Sean Barrett / RAD Game Tools\n//\n// =======================================================================\n//\n//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES\n//\n// This library does no range checking of the offsets found in the file,\n// meaning an attacker can use it to read arbitrary memory.\n//\n// =======================================================================\n//\n//   This library processes TrueType files:\n//        parse files\n//        extract glyph metrics\n//        extract glyph shapes\n//        render glyphs to one-channel bitmaps with antialiasing (box filter)\n//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)\n//\n// ADDITIONAL CONTRIBUTORS\n//\n//   Mikko Mononen: compound shape support, more cmap formats\n//   Tor Andersson: kerning, subpixel rendering\n//   Dougall Johnson: OpenType / Type 2 font handling\n//   Daniel Ribeiro Maciel: basic GPOS-based kerning\n//\n//   Misc other:\n//       Ryan Gordon\n//       Simon Glass\n//       github:IntellectualKitty\n//       Imanol Celaya\n//       Daniel Ribeiro Maciel\n//\n//   Bug/warning reports/fixes:\n//       \"Zer\" on mollyrocket       Fabian \"ryg\" Giesen   github:NiLuJe\n//       Cass Everitt               Martins Mozeiko       github:aloucks\n//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam\n//       Brian Hook                 Omar Cornut           github:vassvik\n//       Walter van Niftrik         Ryan Griege\n//       David Gow                  Peter LaValle\n//       David Given                Sergey Popov\n//       Ivan-Assen Ivanov          Giumo X. Clanjor\n//       Anthony Pesch              Higor Euripedes\n//       Johan Duparc               Thomas Fields\n//       Hou Qiming                 Derek Vinyard\n//       Rob Loach                  Cort Stratton\n//       Kenney Phillis Jr.         Brian Costabile\n//       Ken Voskuil (kaesve)\n//\n// VERSION HISTORY\n//\n//   1.26 (2021-08-28) fix broken rasterizer\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     variant PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//\n//   Full history can be found at the end of this file.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// USAGE\n//\n//   Include this file in whatever places need to refer to it. In ONE C/C++\n//   file, write:\n//      #define STB_TRUETYPE_IMPLEMENTATION\n//   before the include of this file. This expands out the actual\n//   implementation into that C/C++ file.\n//\n//   To make the implementation private to the file that generates the implementation,\n//      #define STBTT_STATIC\n//\n//   Simple 3D API (don't ship this, but it's fine for tools and quick start)\n//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture\n//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char\n//\n//   Improved 3D API (more shippable):\n//            \"stb_rect_pack.h\"           -- optional, but you really want it\n//           stbtt_PackBegin()\n//           stbtt_PackSetOversampling()          -- for improved quality on small fonts\n//           stbtt_PackFontRanges()               -- pack and renders\n//           stbtt_PackEnd()\n//           stbtt_GetPackedQuad()\n//\n//   \"Load\" a font file from a memory buffer (you have to keep the buffer loaded)\n//           stbtt_InitFont()\n//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections\n//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections\n//\n//   Render a unicode codepoint to a bitmap\n//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap\n//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide\n//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be\n//\n//   Character advance/positioning\n//           stbtt_GetCodepointHMetrics()\n//           stbtt_GetFontVMetrics()\n//           stbtt_GetFontVMetricsOS2()\n//           stbtt_GetCodepointKernAdvance()\n//\n//   Starting with version 1.06, the rasterizer was replaced with a new,\n//   faster and generally-more-precise rasterizer. The new rasterizer more\n//   accurately measures pixel coverage for anti-aliasing, except in the case\n//   where multiple shapes overlap, in which case it overestimates the AA pixel\n//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If\n//   this turns out to be a problem, you can re-enable the old rasterizer with\n//        #define STBTT_RASTERIZER_VERSION 1\n//   which will incur about a 15% speed hit.\n//\n// ADDITIONAL DOCUMENTATION\n//\n//   Immediately after this block comment are a series of sample programs.\n//\n//   After the sample programs is the \"header file\" section. This section\n//   includes documentation for each API function.\n//\n//   Some important concepts to understand to use this library:\n//\n//      Codepoint\n//         Characters are defined by unicode codepoints, e.g. 65 is\n//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is\n//         the hiragana for \"ma\".\n//\n//      Glyph\n//         A visual character shape (every codepoint is rendered as\n//         some glyph)\n//\n//      Glyph index\n//         A font-specific integer ID representing a glyph\n//\n//      Baseline\n//         Glyph shapes are defined relative to a baseline, which is the\n//         bottom of uppercase characters. Characters extend both above\n//         and below the baseline.\n//\n//      Current Point\n//         As you draw text to the screen, you keep track of a \"current point\"\n//         which is the origin of each character. The current point's vertical\n//         position is the baseline. Even \"baked fonts\" use this model.\n//\n//      Vertical Font Metrics\n//         The vertical qualities of the font, used to vertically position\n//         and space the characters. See docs for stbtt_GetFontVMetrics.\n//\n//      Font Size in Pixels or Points\n//         The preferred interface for specifying font sizes in stb_truetype\n//         is to specify how tall the font's vertical extent should be in pixels.\n//         If that sounds good enough, skip the next paragraph.\n//\n//         Most font APIs instead use \"points\", which are a common typographic\n//         measurement for describing font size, defined as 72 points per inch.\n//         stb_truetype provides a point API for compatibility. However, true\n//         \"per inch\" conventions don't make much sense on computer displays\n//         since different monitors have different number of pixels per\n//         inch. For example, Windows traditionally uses a convention that\n//         there are 96 pixels per inch, thus making 'inch' measurements have\n//         nothing to do with inches, and thus effectively defining a point to\n//         be 1.333 pixels. Additionally, the TrueType font data provides\n//         an explicit scale factor to scale a given font's glyphs to points,\n//         but the author has observed that this scale factor is often wrong\n//         for non-commercial fonts, thus making fonts scaled in points\n//         according to the TrueType spec incoherently sized in practice.\n//\n// DETAILED USAGE:\n//\n//  Scale:\n//    Select how high you want the font to be, in points or pixels.\n//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute\n//    a scale factor SF that will be used by all other functions.\n//\n//  Baseline:\n//    You need to select a y-coordinate that is the baseline of where\n//    your text will appear. Call GetFontBoundingBox to get the baseline-relative\n//    bounding box for all characters. SF*-y0 will be the distance in pixels\n//    that the worst-case character could extend above the baseline, so if\n//    you want the top edge of characters to appear at the top of the\n//    screen where y=0, then you would set the baseline to SF*-y0.\n//\n//  Current point:\n//    Set the current point where the first character will appear. The\n//    first character could extend left of the current point; this is font\n//    dependent. You can either choose a current point that is the leftmost\n//    point and hope, or add some padding, or check the bounding box or\n//    left-side-bearing of the first character to be displayed and set\n//    the current point based on that.\n//\n//  Displaying a character:\n//    Compute the bounding box of the character. It will contain signed values\n//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,\n//    then the character should be displayed in the rectangle from\n//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).\n//\n//  Advancing for the next character:\n//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.\n//\n//\n// ADVANCED USAGE\n//\n//   Quality:\n//\n//    - Use the functions with Subpixel at the end to allow your characters\n//      to have subpixel positioning. Since the font is anti-aliased, not\n//      hinted, this is very import for quality. (This is not possible with\n//      baked fonts.)\n//\n//    - Kerning is now supported, and if you're supporting subpixel rendering\n//      then kerning is worth using to give your text a polished look.\n//\n//   Performance:\n//\n//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;\n//      if you don't do this, stb_truetype is forced to do the conversion on\n//      every call.\n//\n//    - There are a lot of memory allocations. We should modify it to take\n//      a temp buffer and allocate from the temp buffer (without freeing),\n//      should help performance a lot.\n//\n// NOTES\n//\n//   The system uses the raw data found in the .ttf file without changing it\n//   and without building auxiliary data structures. This is a bit inefficient\n//   on little-endian systems (the data is big-endian), but assuming you're\n//   caching the bitmaps or glyph shapes this shouldn't be a big deal.\n//\n//   It appears to be very hard to programmatically determine what font a\n//   given file is in a general way. I provide an API for this, but I don't\n//   recommend it.\n//\n//\n// PERFORMANCE MEASUREMENTS FOR 1.06:\n//\n//                      32-bit     64-bit\n//   Previous release:  8.83 s     7.68 s\n//   Pool allocations:  7.72 s     6.34 s\n//   Inline sort     :  6.54 s     5.65 s\n//   New rasterizer  :  5.63 s     5.00 s\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////  SAMPLE PROGRAMS\n////\n//\n//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.\n//  See \"tests/truetype_demo_win32.c\" for a complete version.\n//\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program (this compiles): get a single bitmap, print as ASCII art\n//\n//\n// Output:\n//\n//     .ii.\n//    @@@@@@.\n//   V@Mio@@o\n//   :i.  V@V\n//     :oM@@M\n//   :@@@MM@M\n//   @@o  o@M\n//  :@@.  M@M\n//   @@@o@@@@\n//   :M@@V:@@.\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program: print \"Hello World!\" banner, with bugs\n//\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////   INTEGRATION WITH YOUR CODEBASE\n////\n////   The following sections allow you to supply alternate definitions\n////   of C library functions used by stb_truetype, e.g. if you don't\n////   link with the C runtime library.\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n   // #define your own (u)stbtt_int8/16/32 before including to override this\n   #ifndef stbtt_uint8\n   typedef unsigned char   stbtt_uint8;\n   typedef signed   char   stbtt_int8;\n   typedef unsigned short  stbtt_uint16;\n   typedef signed   short  stbtt_int16;\n   typedef unsigned int    stbtt_uint32;\n   typedef signed   int    stbtt_int32;\n   #endif\n\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\n\n   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h\n   #ifndef STBTT_ifloor\n   #define STBTT_ifloor(x)   ((int) floor(x))\n   #define STBTT_iceil(x)    ((int) ceil(x))\n   #endif\n\n   #ifndef STBTT_sqrt\n   #define STBTT_sqrt(x)      sqrt(x)\n   #define STBTT_pow(x,y)     pow(x,y)\n   #endif\n\n   #ifndef STBTT_fmod\n   #define STBTT_fmod(x,y)    fmod(x,y)\n   #endif\n\n   #ifndef STBTT_cos\n   #define STBTT_cos(x)       cos(x)\n   #define STBTT_acos(x)      acos(x)\n   #endif\n\n   #ifndef STBTT_fabs\n   #define STBTT_fabs(x)      fabs(x)\n   #endif\n\n   // #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h\n   #ifndef STBTT_malloc\n   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))\n   #define STBTT_free(x,u)    ((void)(u),free(x))\n   #endif\n\n   #ifndef STBTT_assert\n   #define STBTT_assert(x)    assert(x)\n   #endif\n\n   #ifndef STBTT_strlen\n   #define STBTT_strlen(x)    strlen(x)\n   #endif\n\n   #ifndef STBTT_memcpy\n   #define STBTT_memcpy       memcpy\n   #define STBTT_memset       memset\n   #endif\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   INTERFACE\n////\n////\n\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\n#define __STB_INCLUDE_STB_TRUETYPE_H__\n\n#ifdef STBTT_STATIC\n#define STBTT_DEF static\n#else\n#define STBTT_DEF extern\n#endif\n\n\n// private structure\ntypedef struct\n{\n   unsigned char *data;\n   int cursor;\n   int size;\n} stbtt__buf;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// TEXTURE BAKING API\n//\n// If you use this API, you only have to call two functions ever.\n//\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n} stbtt_bakedchar;\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long\n// if return is positive, the first unused row of the bitmap\n// if return is negative, returns the negative of the number of characters that fit\n// if return is 0, no characters fit and no rows were used\n// This uses a very crappy packing.\n\ntypedef struct\n{\n   float x0,y0,s0,t0; // top-left\n   float x1,y1,s1,t1; // bottom-right\n} stbtt_aligned_quad;\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier\n// Call GetBakedQuad with char_index = 'character - first_char', and it\n// creates the quad you need to draw and advances the current position.\n//\n// The coordinate system used assumes y increases downwards.\n//\n// Characters will extend both above and below the current position;\n// see discussion of \"BASELINE\" above.\n//\n// It's inefficient; you might want to c&p it and optimize it.\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);\n// Query the font vertical metrics without having to create a font first.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// NEW TEXTURE BAKING API\n//\n// This provides options for packing multiple fonts into one atlas, not\n// perfectly but better than nothing.\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n   float xoff2,yoff2;\n} stbtt_packedchar;\n\ntypedef struct stbtt_pack_context stbtt_pack_context;\ntypedef struct stbtt_fontinfo stbtt_fontinfo;\n#ifndef STB_RECT_PACK_VERSION\ntypedef struct stbrp_rect stbrp_rect;\n#endif\n\nSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);\n// Initializes a packing context stored in the passed-in stbtt_pack_context.\n// Future calls using this context will pack characters into the bitmap passed\n// in here: a 1-channel bitmap that is width * height. stride_in_bytes is\n// the distance from one row to the next (or 0 to mean they are packed tightly\n// together). \"padding\" is the amount of padding to leave between each\n// character (normally you want '1' for bitmaps you'll use as textures with\n// bilinear filtering).\n//\n// Returns 0 on failure, 1 on success.\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);\n// Cleans up the packing context and frees all memory.\n\n#define STBTT_POINT_SIZE(x)   (-(x))\n\nSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);\n// Creates character bitmaps from the font_index'th font found in fontdata (use\n// font_index=0 if you don't know what that is). It creates num_chars_in_range\n// bitmaps for characters with unicode values starting at first_unicode_char_in_range\n// and increasing. Data for how to render them is stored in chardata_for_range;\n// pass these to stbtt_GetPackedQuad to get back renderable quads.\n//\n// font_size is the full height of the character from ascender to descender,\n// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed\n// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()\n// and pass that result as 'font_size':\n//       ...,                  20 , ... // font max minus min y is 20 pixels tall\n//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall\n\ntypedef struct\n{\n   float font_size;\n   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint\n   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints\n   int num_chars;\n   stbtt_packedchar *chardata_for_range; // output\n   unsigned char h_oversample, v_oversample; // don't set these, they're used internally\n} stbtt_pack_range;\n\nSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);\n// Creates character bitmaps from multiple ranges of characters stored in\n// ranges. This will usually create a better-packed bitmap than multiple\n// calls to stbtt_PackFontRange. Note that you can call this multiple\n// times within a single PackBegin/PackEnd.\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);\n// Oversampling a font increases the quality by allowing higher-quality subpixel\n// positioning, and is especially valuable at smaller text sizes.\n//\n// This function sets the amount of oversampling for all following calls to\n// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given\n// pack context. The default (no oversampling) is achieved by h_oversample=1\n// and v_oversample=1. The total number of pixels required is\n// h_oversample*v_oversample larger than the default; for example, 2x2\n// oversampling requires 4x the storage of 1x1. For best results, render\n// oversampled textures with bilinear filtering. Look at the readme in\n// stb/tests/oversample for information about oversampled fonts\n//\n// To use with PackFontRangesGather etc., you must set it before calls\n// call to PackFontRangesGatherRects.\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);\n// If skip != 0, this tells stb_truetype to skip any codepoints for which\n// there is no corresponding glyph. If skip=0, which is the default, then\n// codepoints without a glyph recived the font's \"missing character\" glyph,\n// typically an empty box by convention.\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int align_to_integer);\n\nSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);\nSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\n// Calling these functions in sequence is roughly equivalent to calling\n// stbtt_PackFontRanges(). If you more control over the packing of multiple\n// fonts, or if you want to pack custom data into a font texture, take a look\n// at the source to of stbtt_PackFontRanges() and create a custom version\n// using these functions, e.g. call GatherRects multiple times,\n// building up a single array of rects, then call PackRects once,\n// then call RenderIntoRects repeatedly. This may result in a\n// better packing than calling PackFontRanges multiple times\n// (or it may not).\n\n// this is an opaque structure that you shouldn't mess with which holds\n// all the context needed from PackBegin to PackEnd.\nstruct stbtt_pack_context {\n   void *user_allocator_context;\n   void *pack_info;\n   int   width;\n   int   height;\n   int   stride_in_bytes;\n   int   padding;\n   int   skip_missing;\n   unsigned int   h_oversample, v_oversample;\n   unsigned char *pixels;\n   void  *nodes;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// FONT LOADING\n//\n//\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);\n// This function will determine the number of fonts in a font file.  TrueType\n// collection (.ttc) files may contain multiple fonts, while TrueType font\n// (.ttf) files only contain one font. The number of fonts can be used for\n// indexing with the previous function where the index is between zero and one\n// less than the total fonts. If an error occurs, -1 is returned.\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\n// Each .ttf/.ttc file may have more than one font. Each font has a sequential\n// index number starting from 0. Call this function to get the font offset for\n// a given index; it returns -1 if the index is out of range. A regular .ttf\n// file will only define one font and it always be at offset 0, so it will\n// return '0' for index 0, and -1 for all other indices.\n\n// The following structure is defined publicly so you can declare one on\n// the stack or as a global or etc, but you should treat it as opaque.\nstruct stbtt_fontinfo\n{\n   void           * userdata;\n   unsigned char  * data;              // pointer to .ttf file\n   int              fontstart;         // offset of start of font\n\n   int numGlyphs;                     // number of glyphs, needed for range checking\n\n   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf\n   int index_map;                     // a cmap mapping for our chosen character encoding\n   int indexToLocFormat;              // format needed to map from glyph index to glyph\n\n   stbtt__buf cff;                    // cff font data\n   stbtt__buf charstrings;            // the charstring index\n   stbtt__buf gsubrs;                 // global charstring subroutines index\n   stbtt__buf subrs;                  // private charstring subroutines index\n   stbtt__buf fontdicts;              // array of font dicts\n   stbtt__buf fdselect;               // map from glyph to fontdict\n};\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\n// Given an offset into the file that defines a font, this function builds\n// the necessary cached info for the rest of the system. You must allocate\n// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't\n// need to do anything special to free it, because the contents are pure\n// value data with no additional data structures. Returns 0 on failure.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER TO GLYPH-INDEX CONVERSIOn\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\n// If you're going to perform multiple operations on the same character\n// and you want a speed-up, call this function with the character you're\n// going to process, then use glyph-based functions instead of the\n// codepoint-based functions.\n// Returns 0 if the character codepoint is not defined in the font.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER PROPERTIES\n//\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose \"height\" is 'pixels' tall.\n// Height is measured as the distance from the highest ascender to the lowest\n// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics\n// and computing:\n//       scale = pixels / (ascent - descent)\n// so if you prefer to measure height by the ascent only, use a similar calculation.\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose EM size is mapped to\n// 'pixels' tall. This is probably what traditional APIs compute, but\n// I'm not positive.\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\n// ascent is the coordinate above the baseline the font extends; descent\n// is the coordinate below the baseline the font extends (i.e. it is typically negative)\n// lineGap is the spacing between one row's descent and the next row's ascent...\n// so you should advance the vertical position by \"*ascent - *descent + *lineGap\"\n//   these are expressed in unscaled coordinates, so you must multiply by\n//   the scale factor for a given size\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);\n// analogous to GetFontVMetrics, but returns the \"typographic\" values from the OS/2\n// table (specific to MS/Windows TTF files).\n//\n// Returns 1 on success (table present), 0 on failure.\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\n// the bounding box around all possible characters\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\n// leftSideBearing is the offset from the current horizontal position to the left edge of the character\n// advanceWidth is the offset from the current horizontal position to the next horizontal position\n//   these are expressed in unscaled coordinates\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\n// an additional amount to add to the 'advance' value between ch1 and ch2\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\n// Gets the bounding box of the visible part of the glyph, in unscaled coordinates\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\nSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n// as above, but takes one or more glyph indices for greater efficiency\n\ntypedef struct stbtt_kerningentry\n{\n   int glyph1; // use stbtt_FindGlyphIndex\n   int glyph2;\n   int advance;\n} stbtt_kerningentry;\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);\nSTBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);\n// Retrieves a complete list of all of the kerning pairs provided by the font\n// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.\n// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// GLYPH SHAPES (you probably don't need these, but they have to go before\n// the bitmaps for C declaration-order reasons)\n//\n\n#ifndef STBTT_vmove // you can predefine these to use different values (but why?)\n   enum {\n      STBTT_vmove=1,\n      STBTT_vline,\n      STBTT_vcurve,\n      STBTT_vcubic\n   };\n#endif\n\n#ifndef stbtt_vertex // you can predefine this to use different values\n                   // (we share this with other code at RAD)\n   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file\n   typedef struct\n   {\n      stbtt_vertex_type x,y,cx,cy,cx1,cy1;\n      unsigned char type,padding;\n   } stbtt_vertex;\n#endif\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\n// returns non-zero if nothing is drawn for this glyph\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\n// returns # of vertices and fills *vertices with the pointer to them\n//   these are expressed in \"unscaled\" coordinates\n//\n// The shape is a series of contours. Each one starts with\n// a STBTT_moveto, then consists of a series of mixed\n// STBTT_lineto and STBTT_curveto segments. A lineto\n// draws a line from previous endpoint to its x,y; a curveto\n// draws a quadratic bezier from previous endpoint to\n// its x,y, using cx,cy as the bezier control point.\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\n// frees the data allocated above\n\nSTBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);\n// fills svg with the character's SVG data.\n// returns data size or 0 if SVG not found.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// BITMAP RENDERING\n//\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\n// frees the bitmap allocated below\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// allocates a large-enough single-channel 8bpp bitmap and renders the\n// specified character/glyph at the specified scale into it, with\n// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).\n// *width & *height are filled out with the width & height of the bitmap,\n// which is stored left-to-right, top-to-bottom.\n//\n// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\n// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap\n// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap\n// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the\n// width and height and positioning info for it first.\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\n// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);\n// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering\n// is performed (see stbtt_PackSetOversampling)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// get the bbox of the bitmap centered around the glyph origin; so the\n// bitmap width is ix1-ix0, height is iy1-iy0, and location to place\n// the bitmap top left is (leftSideBearing*scale,iy0).\n// (Note that the bitmap uses y-increases-down, but the shape uses\n// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel\n// shift for the character\n\n// the following functions are equivalent to the above functions, but operate\n// on glyph indices instead of Unicode codepoints (for efficiency)\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n\n\ntypedef struct\n{\n   int w,h,stride;\n   unsigned char *pixels;\n} stbtt__bitmap;\n\n// rasterize a shape with quadratic beziers into a bitmap\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into\n                               float flatness_in_pixels,     // allowable error of curve in pixels\n                               stbtt_vertex *vertices,       // array of vertices defining shape\n                               int num_verts,                // number of vertices in above array\n                               float scale_x, float scale_y, // scale applied to input vertices\n                               float shift_x, float shift_y, // translation applied to input vertices\n                               int x_off, int y_off,         // another translation applied to input\n                               int invert,                   // if non-zero, vertically flip shape\n                               void *userdata);              // context for to STBTT_MALLOC\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Signed Distance Function (or Field) rendering\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);\n// frees the SDF bitmap allocated below\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\n// These functions compute a discretized SDF field for a single character, suitable for storing\n// in a single-channel texture, sampling with bilinear filtering, and testing against\n// larger than some threshold to produce scalable fonts.\n//        info              --  the font\n//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap\n//        glyph/codepoint   --  the character to generate the SDF for\n//        padding           --  extra \"pixels\" around the character which are filled with the distance to the character (not 0),\n//                                 which allows effects like bit outlines\n//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)\n//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF \"pixel\" away from the edge (on the 0..255 scale)\n//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside\n//        width,height      --  output height & width of the SDF bitmap (including padding)\n//        xoff,yoff         --  output origin of the character\n//        return value      --  a 2D array of bytes 0..255, width*height in size\n//\n// pixel_dist_scale & onedge_value are a scale & bias that allows you to make\n// optimal use of the limited 0..255 for your application, trading off precision\n// and special effects. SDF values outside the range 0..255 are clamped to 0..255.\n//\n// Example:\n//      scale = stbtt_ScaleForPixelHeight(22)\n//      padding = 5\n//      onedge_value = 180\n//      pixel_dist_scale = 180/5.0 = 36.0\n//\n//      This will create an SDF bitmap in which the character is about 22 pixels\n//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled\n//      shape, sample the SDF at each pixel and fill the pixel if the SDF value\n//      is greater than or equal to 180/255. (You'll actually want to antialias,\n//      which is beyond the scope of this example.) Additionally, you can compute\n//      offset outlines (e.g. to stroke the character border inside & outside,\n//      or only outside). For example, to fill outside the character up to 3 SDF\n//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above\n//      choice of variables maps a range from 5 pixels outside the shape to\n//      2 pixels inside the shape to 0..255; this is intended primarily for apply\n//      outside effects only (the interior range is needed to allow proper\n//      antialiasing of the font at *smaller* sizes)\n//\n// The function computes the SDF analytically at each SDF pixel, not by e.g.\n// building a higher-res bitmap and approximating it. In theory the quality\n// should be as high as possible for an SDF of this size & representation, but\n// unclear if this is true in practice (perhaps building a higher-res bitmap\n// and computing from that can allow drop-out prevention).\n//\n// The algorithm has not been optimized at all, so expect it to be slow\n// if computing lots of characters or very large sizes.\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Finding the right font...\n//\n// You should really just solve this offline, keep your own tables\n// of what font is what, and don't try to get it out of the .ttf file.\n// That's because getting it out of the .ttf file is really hard, because\n// the names in the file can appear in many possible encodings, in many\n// possible languages, and e.g. if you need a case-insensitive comparison,\n// the details of that depend on the encoding & language in a complex way\n// (actually underspecified in truetype, but also gigantic).\n//\n// But you can use the provided functions in two possible ways:\n//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on\n//             unicode-encoded names to try to find the font you want;\n//             you can run this before calling stbtt_InitFont()\n//\n//     stbtt_GetFontNameString() lets you get any of the various strings\n//             from the file yourself and do your own comparisons on them.\n//             You have to have called stbtt_InitFont() first.\n\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\n// returns the offset (not index) of the font that matches, or -1 if none\n//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\".\n//   if you use any other flag, use a font name like \"Arial\"; this checks\n//     the 'macStyle' header field; i don't know if fonts set this consistently\n#define STBTT_MACSTYLE_DONTCARE     0\n#define STBTT_MACSTYLE_BOLD         1\n#define STBTT_MACSTYLE_ITALIC       2\n#define STBTT_MACSTYLE_UNDERSCORE   4\n#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\n// returns 1/0 whether the first string interpreted as utf8 is identical to\n// the second string interpreted as big-endian utf16... useful for strings from next func\n\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\n// returns the string (which may be big-endian double byte, e.g. for unicode)\n// and puts the length in bytes in *length.\n//\n// some of the values for the IDs are below; for more see the truetype spec:\n//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html\n//     http://www.microsoft.com/typography/otspec/name.htm\n\nenum { // platformID\n   STBTT_PLATFORM_ID_UNICODE   =0,\n   STBTT_PLATFORM_ID_MAC       =1,\n   STBTT_PLATFORM_ID_ISO       =2,\n   STBTT_PLATFORM_ID_MICROSOFT =3\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_UNICODE\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\n   STBTT_UNICODE_EID_ISO_10646      =2,\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT\n   STBTT_MS_EID_SYMBOL        =0,\n   STBTT_MS_EID_UNICODE_BMP   =1,\n   STBTT_MS_EID_SHIFTJIS      =2,\n   STBTT_MS_EID_UNICODE_FULL  =10\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...\n       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MAC\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\n};\n\n#endif // __STB_INCLUDE_STB_TRUETYPE_H__\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   IMPLEMENTATION\n////\n////\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n\n#ifndef STBTT_MAX_OVERSAMPLE\n#define STBTT_MAX_OVERSAMPLE   8\n#endif\n\n#if STBTT_MAX_OVERSAMPLE > 255\n#error \"STBTT_MAX_OVERSAMPLE cannot be > 255\"\n#endif\n\ntypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];\n\n#ifndef STBTT_RASTERIZER_VERSION\n#define STBTT_RASTERIZER_VERSION 2\n#endif\n\n#ifdef _MSC_VER\n#define STBTT__NOTUSED(v)  (void)(v)\n#else\n#define STBTT__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n//////////////////////////////////////////////////////////////////////////\n//\n// stbtt__buf helpers to parse data from file\n//\n\nstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}\n\nstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}\n\nstatic void stbtt__buf_seek(stbtt__buf *b, int o)\n{\n   STBTT_assert(!(o > b->size || o < 0));\n   b->cursor = (o > b->size || o < 0) ? b->size : o;\n}\n\nstatic void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}\n\nstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}\n\nstatic stbtt__buf stbtt__new_buf(const void *p, unsigned int size)\n{\n   stbtt__buf r;\n   STBTT_assert(size < 0x40000000);\n   r.data = (stbtt_uint8*) p;\n   r.size = (int) size;\n   r.cursor = 0;\n   return r;\n}\n\n#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)\n#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)\n\nstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(0, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}\n\nstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)\n{\n   int count, start, offsize;\n   start = b->cursor;\n   count = stbtt__buf_get16(b);\n   if (count) {\n      offsize = stbtt__buf_get8(b);\n      STBTT_assert(offsize >= 1 && offsize <= 4);\n      stbtt__buf_skip(b, offsize * count);\n      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);\n   }\n   return stbtt__buf_range(b, start, b->cursor - start);\n}\n\nstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)\n{\n   int b0 = stbtt__buf_get8(b);\n   if (b0 >= 32 && b0 <= 246)       return b0 - 139;\n   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;\n   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;\n   else if (b0 == 28)               return stbtt__buf_get16(b);\n   else if (b0 == 29)               return stbtt__buf_get32(b);\n   STBTT_assert(0);\n   return 0;\n}\n\nstatic void stbtt__cff_skip_operand(stbtt__buf *b) {\n   int v, b0 = stbtt__buf_peek8(b);\n   STBTT_assert(b0 >= 28);\n   if (b0 == 30) {\n      stbtt__buf_skip(b, 1);\n      while (b->cursor < b->size) {\n         v = stbtt__buf_get8(b);\n         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)\n            break;\n      }\n   } else {\n      stbtt__cff_int(b);\n   }\n}\n\nstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)\n{\n   stbtt__buf_seek(b, 0);\n   while (b->cursor < b->size) {\n      int start = b->cursor, end, op;\n      while (stbtt__buf_peek8(b) >= 28)\n         stbtt__cff_skip_operand(b);\n      end = b->cursor;\n      op = stbtt__buf_get8(b);\n      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;\n      if (op == key) return stbtt__buf_range(b, start, end-start);\n   }\n   return stbtt__buf_range(b, 0, 0);\n}\n\nstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)\n{\n   int i;\n   stbtt__buf operands = stbtt__dict_get(b, key);\n   for (i = 0; i < outcount && operands.cursor < operands.size; i++)\n      out[i] = stbtt__cff_int(&operands);\n}\n\nstatic int stbtt__cff_index_count(stbtt__buf *b)\n{\n   stbtt__buf_seek(b, 0);\n   return stbtt__buf_get16(b);\n}\n\nstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)\n{\n   int count, offsize, start, end;\n   stbtt__buf_seek(&b, 0);\n   count = stbtt__buf_get16(&b);\n   offsize = stbtt__buf_get8(&b);\n   STBTT_assert(i >= 0 && i < count);\n   STBTT_assert(offsize >= 1 && offsize <= 4);\n   stbtt__buf_skip(&b, i*offsize);\n   start = stbtt__buf_get(&b, offsize);\n   end = stbtt__buf_get(&b, offsize);\n   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);\n}\n\n//////////////////////////////////////////////////////////////////////////\n//\n// accessors to parse data from file\n//\n\n// on platforms that don't allow misaligned reads, if we want to allow\n// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE\n\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\n#define ttFixed(p)    ttLONG(p)\n\nstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }\nstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\nstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\nstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\n\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\n\nstatic int stbtt__isfont(stbtt_uint8 *font)\n{\n   // check the version number\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1\n   if (stbtt_tag(font, \"typ1\"))   return 1; // TrueType with type 1 font -- we don't support this!\n   if (stbtt_tag(font, \"OTTO\"))   return 1; // OpenType with CFF\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0\n   if (stbtt_tag(font, \"true\"))   return 1; // Apple specification for TrueType fonts\n   return 0;\n}\n\n// @OPTIMIZE: binary search\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\n{\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\n   stbtt_uint32 tabledir = fontstart + 12;\n   stbtt_int32 i;\n   for (i=0; i < num_tables; ++i) {\n      stbtt_uint32 loc = tabledir + 16*i;\n      if (stbtt_tag(data+loc+0, tag))\n         return ttULONG(data+loc+8);\n   }\n   return 0;\n}\n\nstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)\n{\n   // if it's just a font, there's only one valid index\n   if (stbtt__isfont(font_collection))\n      return index == 0 ? 0 : -1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         stbtt_int32 n = ttLONG(font_collection+8);\n         if (index >= n)\n            return -1;\n         return ttULONG(font_collection+12+index*4);\n      }\n   }\n   return -1;\n}\n\nstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)\n{\n   // if it's just a font, there's only one valid font\n   if (stbtt__isfont(font_collection))\n      return 1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         return ttLONG(font_collection+8);\n      }\n   }\n   return 0;\n}\n\nstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)\n{\n   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };\n   stbtt__buf pdict;\n   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);\n   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(0, 0);\n   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);\n   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);\n   if (!subrsoff) return stbtt__new_buf(0, 0);\n   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);\n   return stbtt__cff_get_index(&cff);\n}\n\n// since most people won't use this, find this table the first time it's needed\nstatic int stbtt__get_svg(stbtt_fontinfo *info)\n{\n   stbtt_uint32 t;\n   if (info->svg < 0) {\n      t = stbtt__find_table(info->data, info->fontstart, \"SVG \");\n      if (t) {\n         stbtt_uint32 offset = ttULONG(info->data + t + 2);\n         info->svg = t + offset;\n      } else {\n         info->svg = 0;\n      }\n   }\n   return info->svg;\n}\n\nstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)\n{\n   stbtt_uint32 cmap, t;\n   stbtt_int32 i,numTables;\n\n   info->data = data;\n   info->fontstart = fontstart;\n   info->cff = stbtt__new_buf(0, 0);\n\n   cmap = stbtt__find_table(data, fontstart, \"cmap\");       // required\n   info->loca = stbtt__find_table(data, fontstart, \"loca\"); // required\n   info->head = stbtt__find_table(data, fontstart, \"head\"); // required\n   info->glyf = stbtt__find_table(data, fontstart, \"glyf\"); // required\n   info->hhea = stbtt__find_table(data, fontstart, \"hhea\"); // required\n   info->hmtx = stbtt__find_table(data, fontstart, \"hmtx\"); // required\n   info->kern = stbtt__find_table(data, fontstart, \"kern\"); // not required\n   info->gpos = stbtt__find_table(data, fontstart, \"GPOS\"); // not required\n\n   if (!cmap || !info->head || !info->hhea || !info->hmtx)\n      return 0;\n   if (info->glyf) {\n      // required for truetype\n      if (!info->loca) return 0;\n   } else {\n      // initialization for CFF / Type2 fonts (OTF)\n      stbtt__buf b, topdict, topdictidx;\n      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;\n      stbtt_uint32 cff;\n\n      cff = stbtt__find_table(data, fontstart, \"CFF \");\n      if (!cff) return 0;\n\n      info->fontdicts = stbtt__new_buf(0, 0);\n      info->fdselect = stbtt__new_buf(0, 0);\n\n      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);\n      b = info->cff;\n\n      // read the header\n      stbtt__buf_skip(&b, 2);\n      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize\n\n      // but we just use the first one.\n      stbtt__cff_get_index(&b);  // name INDEX\n      topdictidx = stbtt__cff_get_index(&b);\n      topdict = stbtt__cff_index_get(topdictidx, 0);\n      stbtt__cff_get_index(&b);  // string INDEX\n      info->gsubrs = stbtt__cff_get_index(&b);\n\n      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);\n      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);\n      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);\n      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);\n      info->subrs = stbtt__get_subrs(b, topdict);\n\n      // we only support Type 2 charstrings\n      if (cstype != 2) return 0;\n      if (charstrings == 0) return 0;\n\n      if (fdarrayoff) {\n         // looks like a CID font\n         if (!fdselectoff) return 0;\n         stbtt__buf_seek(&b, fdarrayoff);\n         info->fontdicts = stbtt__cff_get_index(&b);\n         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);\n      }\n\n      stbtt__buf_seek(&b, charstrings);\n      info->charstrings = stbtt__cff_get_index(&b);\n   }\n\n   t = stbtt__find_table(data, fontstart, \"maxp\");\n   if (t)\n      info->numGlyphs = ttUSHORT(data+t+4);\n   else\n      info->numGlyphs = 0xffff;\n\n   info->svg = -1;\n\n   // find a cmap encoding table we understand *now* to avoid searching\n   // later. \n   // the same regardless of glyph.\n   numTables = ttUSHORT(data + cmap + 2);\n   info->index_map = 0;\n   for (i=0; i < numTables; ++i) {\n      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;\n      // find an encoding we understand:\n      switch(ttUSHORT(data+encoding_record)) {\n         case STBTT_PLATFORM_ID_MICROSOFT:\n            switch (ttUSHORT(data+encoding_record+2)) {\n               case STBTT_MS_EID_UNICODE_BMP:\n               case STBTT_MS_EID_UNICODE_FULL:\n                  // MS/Unicode\n                  info->index_map = cmap + ttULONG(data+encoding_record+4);\n                  break;\n            }\n            break;\n        case STBTT_PLATFORM_ID_UNICODE:\n            // Mac/iOS has these\n            // all the encodingIDs are unicode, so we don't bother to check it\n            info->index_map = cmap + ttULONG(data+encoding_record+4);\n            break;\n      }\n   }\n   if (info->index_map == 0)\n      return 0;\n\n   info->indexToLocFormat = ttUSHORT(data+info->head + 50);\n   return 1;\n}\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint32 index_map = info->index_map;\n\n   stbtt_uint16 format = ttUSHORT(data + index_map + 0);\n   if (format == 0) { // apple byte encoding\n      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);\n      if (unicode_codepoint < bytes-6)\n         return ttBYTE(data + index_map + 6 + unicode_codepoint);\n      return 0;\n   } else if (format == 6) {\n      stbtt_uint32 first = ttUSHORT(data + index_map + 6);\n      stbtt_uint32 count = ttUSHORT(data + index_map + 8);\n      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)\n         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);\n      return 0;\n   } else if (format == 2) {\n      STBTT_assert(0); \n      return 0;\n   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges\n      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;\n      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;\n      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);\n      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;\n\n      // do a binary search of the segments\n      stbtt_uint32 endCount = index_map + 14;\n      stbtt_uint32 search = endCount;\n\n      if (unicode_codepoint > 0xffff)\n         return 0;\n\n      // they lie from endCount .. endCount + segCount\n      // but searchRange is the nearest power of two, so...\n      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))\n         search += rangeShift*2;\n\n      // now decrement to bias correctly to find smallest\n      search -= 2;\n      while (entrySelector) {\n         stbtt_uint16 end;\n         searchRange >>= 1;\n         end = ttUSHORT(data + search + searchRange*2);\n         if (unicode_codepoint > end)\n            search += searchRange*2;\n         --entrySelector;\n      }\n      search += 2;\n\n      {\n         stbtt_uint16 offset, start, last;\n         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);\n\n         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);\n         last = ttUSHORT(data + endCount + 2*item);\n         if (unicode_codepoint < start || unicode_codepoint > last)\n            return 0;\n\n         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);\n         if (offset == 0)\n            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));\n\n         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);\n      }\n   } else if (format == 12 || format == 13) {\n      stbtt_uint32 ngroups = ttULONG(data+index_map+12);\n      stbtt_int32 low,high;\n      low = 0; high = (stbtt_int32)ngroups;\n      // Binary search the right group.\n      while (low < high) {\n         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high\n         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);\n         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);\n         if ((stbtt_uint32) unicode_codepoint < start_char)\n            high = mid;\n         else if ((stbtt_uint32) unicode_codepoint > end_char)\n            low = mid+1;\n         else {\n            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);\n            if (format == 12)\n               return start_glyph + unicode_codepoint-start_char;\n            else // format == 13\n               return start_glyph;\n         }\n      }\n      return 0; // not found\n   }\n   STBTT_assert(0);\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\n{\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\n}\n\nstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\n{\n   v->type = type;\n   v->x = (stbtt_int16) x;\n   v->y = (stbtt_int16) y;\n   v->cx = (stbtt_int16) cx;\n   v->cy = (stbtt_int16) cy;\n}\n\nstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)\n{\n   int g1,g2;\n\n   STBTT_assert(!info->cff.size);\n\n   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range\n   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format\n\n   if (info->indexToLocFormat == 0) {\n      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;\n      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;\n   } else {\n      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);\n      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);\n   }\n\n   return g1==g2 ? -1 : g1; // if length is 0, return -1\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n\nSTBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   if (info->cff.size) {\n      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);\n   } else {\n      int g = stbtt__GetGlyfOffset(info, glyph_index);\n      if (g < 0) return 0;\n\n      if (x0) *x0 = ttSHORT(info->data + g + 2);\n      if (y0) *y0 = ttSHORT(info->data + g + 4);\n      if (x1) *x1 = ttSHORT(info->data + g + 6);\n      if (y1) *y1 = ttSHORT(info->data + g + 8);\n   }\n   return 1;\n}\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\n{\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\n}\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt_int16 numberOfContours;\n   int g;\n   if (info->cff.size)\n      return stbtt__GetGlyphInfoT2(info, glyph_index, 0, 0, 0, 0) == 0;\n   g = stbtt__GetGlyfOffset(info, glyph_index);\n   if (g < 0) return 1;\n   numberOfContours = ttSHORT(info->data + g);\n   return numberOfContours == 0;\n}\n\nstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,\n    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)\n{\n   if (start_off) {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);\n      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);\n   } else {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);\n      else\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);\n   }\n   return num_vertices;\n}\n\nstatic int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   stbtt_int16 numberOfContours;\n   stbtt_uint8 *endPtsOfContours;\n   stbtt_uint8 *data = info->data;\n   stbtt_vertex *vertices=0;\n   int num_vertices=0;\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\n\n   *pvertices = 0;\n\n   if (g < 0) return 0;\n\n   numberOfContours = ttSHORT(data + g);\n\n   if (numberOfContours > 0) {\n      stbtt_uint8 flags=0,flagcount;\n      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;\n      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;\n      stbtt_uint8 *points;\n      endPtsOfContours = (data + g + 10);\n      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);\n      points = data + g + 10 + numberOfContours * 2 + 2 + ins;\n\n      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);\n\n      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need\n      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);\n      if (vertices == 0)\n         return 0;\n\n      next_move = 0;\n      flagcount=0;\n\n      // in first pass, we load uninterpreted data into the allocated array\n      // above, shifted to the end of the array so we won't overwrite it when\n      // we create our final data starting from the front\n\n      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated\n\n      // first load flags\n\n      for (i=0; i < n; ++i) {\n         if (flagcount == 0) {\n            flags = *points++;\n            if (flags & 8)\n               flagcount = *points++;\n         } else\n            --flagcount;\n         vertices[off+i].type = flags;\n      }\n\n      // now load x coordinates\n      x=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 2) {\n            stbtt_int16 dx = *points++;\n            x += (flags & 16) ? dx : -dx; // ???\n         } else {\n            if (!(flags & 16)) {\n               x = x + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].x = (stbtt_int16) x;\n      }\n\n      // now load y coordinates\n      y=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 4) {\n            stbtt_int16 dy = *points++;\n            y += (flags & 32) ? dy : -dy; // ???\n         } else {\n            if (!(flags & 32)) {\n               y = y + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].y = (stbtt_int16) y;\n      }\n\n      // now convert them to our format\n      num_vertices=0;\n      sx = sy = cx = cy = scx = scy = 0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         x     = (stbtt_int16) vertices[off+i].x;\n         y     = (stbtt_int16) vertices[off+i].y;\n\n         if (next_move == i) {\n            if (i != 0)\n               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n\n            // now start the new one\n            start_off = !(flags & 1);\n            if (start_off) {\n               // if we start off with an off-curve point, then when we need to find a point on the curve\n               // where we can start, and we need to save some state for when we wraparound.\n               scx = x;\n               scy = y;\n               if (!(vertices[off+i+1].type & 1)) {\n                  // next point is also a curve point, so interpolate an on-point curve\n                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n               } else {\n                  // otherwise just use the next point as our start point\n                  sx = (stbtt_int32) vertices[off+i+1].x;\n                  sy = (stbtt_int32) vertices[off+i+1].y;\n                  ++i; // we're using point i+1 as the starting point, so skip it\n               }\n            } else {\n               sx = x;\n               sy = y;\n            }\n            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);\n            was_off = 0;\n            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);\n            ++j;\n         } else {\n            if (!(flags & 1)) { // if it's a curve\n               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n               cx = x;\n               cy = y;\n               was_off = 1;\n            } else {\n               if (was_off)\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);\n               else\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);\n               was_off = 0;\n            }\n         }\n      }\n      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n   } else if (numberOfContours < 0) {\n      // Compound shapes.\n      int more = 1;\n      stbtt_uint8 *comp = data + g + 10;\n      num_vertices = 0;\n      vertices = 0;\n      while (more) {\n         stbtt_uint16 flags, gidx;\n         int comp_num_verts = 0, i;\n         stbtt_vertex *comp_verts = 0, *tmp = 0;\n         float mtx[6] = {1,0,0,1,0,0}, m, n;\n\n         flags = ttSHORT(comp); comp+=2;\n         gidx = ttSHORT(comp); comp+=2;\n\n         if (flags & 2) { // XY values\n            if (flags & 1) { // shorts\n               mtx[4] = ttSHORT(comp); comp+=2;\n               mtx[5] = ttSHORT(comp); comp+=2;\n            } else {\n               mtx[4] = ttCHAR(comp); comp+=1;\n               mtx[5] = ttCHAR(comp); comp+=1;\n            }\n         }\n         else {\n            STBTT_assert(0);\n         }\n         if (flags & (1<<3)) { // WE_HAVE_A_SCALE\n            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         }\n\n         // Find transformation scales.\n         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);\n         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);\n\n         // Get indexed glyph.\n         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);\n         if (comp_num_verts > 0) {\n            // Transform vertices.\n            for (i = 0; i < comp_num_verts; ++i) {\n               stbtt_vertex* v = &comp_verts[i];\n               stbtt_vertex_type x,y;\n               x=v->x; y=v->y;\n               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n               x=v->cx; y=v->cy;\n               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n            }\n            // Append vertices.\n            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);\n            if (!tmp) {\n               if (vertices) STBTT_free(vertices, info->userdata);\n               if (comp_verts) STBTT_free(comp_verts, info->userdata);\n               return 0;\n            }\n            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));\n            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));\n            if (vertices) STBTT_free(vertices, info->userdata);\n            vertices = tmp;\n            STBTT_free(comp_verts, info->userdata);\n            num_vertices += comp_num_verts;\n         }\n         // More components ?\n         more = flags & (1<<5);\n      }\n   } else {\n      // numberOfCounters == 0, do nothing\n   }\n\n   *pvertices = vertices;\n   return num_vertices;\n}\n\ntypedef struct\n{\n   int bounds;\n   int started;\n   float first_x, first_y;\n   float x, y;\n   stbtt_int32 min_x, max_x, min_y, max_y;\n\n   stbtt_vertex *pvertices;\n   int num_vertices;\n} stbtt__csctx;\n\n#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, 0, 0}\n\nstatic void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)\n{\n   if (x > c->max_x || !c->started) c->max_x = x;\n   if (y > c->max_y || !c->started) c->max_y = y;\n   if (x < c->min_x || !c->started) c->min_x = x;\n   if (y < c->min_y || !c->started) c->min_y = y;\n   c->started = 1;\n}\n\nstatic void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)\n{\n   if (c->bounds) {\n      stbtt__track_vertex(c, x, y);\n      if (type == STBTT_vcubic) {\n         stbtt__track_vertex(c, cx, cy);\n         stbtt__track_vertex(c, cx1, cy1);\n      }\n   } else {\n      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);\n      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;\n      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;\n   }\n   c->num_vertices++;\n}\n\nstatic void stbtt__csctx_close_shape(stbtt__csctx *ctx)\n{\n   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)\n      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   stbtt__csctx_close_shape(ctx);\n   ctx->first_x = ctx->x = ctx->x + dx;\n   ctx->first_y = ctx->y = ctx->y + dy;\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   ctx->x += dx;\n   ctx->y += dy;\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)\n{\n   float cx1 = ctx->x + dx1;\n   float cy1 = ctx->y + dy1;\n   float cx2 = cx1 + dx2;\n   float cy2 = cy1 + dy2;\n   ctx->x = cx2 + dx3;\n   ctx->y = cy2 + dy3;\n   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);\n}\n\nstatic stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)\n{\n   int count = stbtt__cff_index_count(&idx);\n   int bias = 107;\n   if (count >= 33900)\n      bias = 32768;\n   else if (count >= 1240)\n      bias = 1131;\n   n += bias;\n   if (n < 0 || n >= count)\n      return stbtt__new_buf(0, 0);\n   return stbtt__cff_index_get(idx, n);\n}\n\nstatic stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt__buf fdselect = info->fdselect;\n   int nranges, start, end, v, fmt, fdselector = -1, i;\n\n   stbtt__buf_seek(&fdselect, 0);\n   fmt = stbtt__buf_get8(&fdselect);\n   if (fmt == 0) {\n      // untested\n      stbtt__buf_skip(&fdselect, glyph_index);\n      fdselector = stbtt__buf_get8(&fdselect);\n   } else if (fmt == 3) {\n      nranges = stbtt__buf_get16(&fdselect);\n      start = stbtt__buf_get16(&fdselect);\n      for (i = 0; i < nranges; i++) {\n         v = stbtt__buf_get8(&fdselect);\n         end = stbtt__buf_get16(&fdselect);\n         if (glyph_index >= start && glyph_index < end) {\n            fdselector = v;\n            break;\n         }\n         start = end;\n      }\n   }\n   if (fdselector == -1) stbtt__new_buf(0, 0);\n   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));\n}\n\nstatic int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)\n{\n   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;\n   int has_subrs = 0, clear_stack;\n   float s[48];\n   stbtt__buf subr_stack[10], subrs = info->subrs, b;\n   float f;\n\n#define STBTT__CSERR(s) (0)\n\n   // this currently ignores the initial width value, which isn't needed if we have hmtx\n   b = stbtt__cff_index_get(info->charstrings, glyph_index);\n   while (b.cursor < b.size) {\n      i = 0;\n      clear_stack = 1;\n      b0 = stbtt__buf_get8(&b);\n      switch (b0) {\n      case 0x13: // hintmask\n      case 0x14: // cntrmask\n         if (in_header)\n            maskbits += (sp / 2); // implicit \"vstem\"\n         in_header = 0;\n         stbtt__buf_skip(&b, (maskbits + 7) / 8);\n         break;\n\n      case 0x01: // hstem\n      case 0x03: // vstem\n      case 0x12: // hstemhm\n      case 0x17: // vstemhm\n         maskbits += (sp / 2);\n         break;\n\n      case 0x15: // rmoveto\n         in_header = 0;\n         if (sp < 2) return STBTT__CSERR(\"rmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);\n         break;\n      case 0x04: // vmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"vmoveto stack\");\n         stbtt__csctx_rmove_to(c, 0, s[sp-1]);\n         break;\n      case 0x16: // hmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"hmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-1], 0);\n         break;\n\n      case 0x05: // rlineto\n         if (sp < 2) return STBTT__CSERR(\"rlineto stack\");\n         for (; i + 1 < sp; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical\n      // starting from a different place.\n\n      case 0x07: // vlineto\n         if (sp < 1) return STBTT__CSERR(\"vlineto stack\");\n         goto vlineto;\n      case 0x06: // hlineto\n         if (sp < 1) return STBTT__CSERR(\"hlineto stack\");\n         for (;;) {\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, s[i], 0);\n            i++;\n      vlineto:\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, 0, s[i]);\n            i++;\n         }\n         break;\n\n      case 0x1F: // hvcurveto\n         if (sp < 4) return STBTT__CSERR(\"hvcurveto stack\");\n         goto hvcurveto;\n      case 0x1E: // vhcurveto\n         if (sp < 4) return STBTT__CSERR(\"vhcurveto stack\");\n         for (;;) {\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);\n            i += 4;\n      hvcurveto:\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);\n            i += 4;\n         }\n         break;\n\n      case 0x08: // rrcurveto\n         if (sp < 6) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x18: // rcurveline\n         if (sp < 8) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp - 2; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         if (i + 1 >= sp) return STBTT__CSERR(\"rcurveline stack\");\n         stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      case 0x19: // rlinecurve\n         if (sp < 8) return STBTT__CSERR(\"rlinecurve stack\");\n         for (; i + 1 < sp - 6; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         if (i + 5 >= sp) return STBTT__CSERR(\"rlinecurve stack\");\n         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x1A: // vvcurveto\n      case 0x1B: // hhcurveto\n         if (sp < 4) return STBTT__CSERR(\"(vv|hh)curveto stack\");\n         f = 0.0;\n         if (sp & 1) { f = s[i]; i++; }\n         for (; i + 3 < sp; i += 4) {\n            if (b0 == 0x1B)\n               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);\n            else\n               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);\n            f = 0.0;\n         }\n         break;\n\n      case 0x0A: // callsubr\n         if (!has_subrs) {\n            if (info->fdselect.size)\n               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);\n            has_subrs = 1;\n         }\n         // FALLTHROUGH\n      case 0x1D: // callgsubr\n         if (sp < 1) return STBTT__CSERR(\"call(g|)subr stack\");\n         v = (int) s[--sp];\n         if (subr_stack_height >= 10) return STBTT__CSERR(\"recursion limit\");\n         subr_stack[subr_stack_height++] = b;\n         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);\n         if (b.size == 0) return STBTT__CSERR(\"subr not found\");\n         b.cursor = 0;\n         clear_stack = 0;\n         break;\n\n      case 0x0B: // return\n         if (subr_stack_height <= 0) return STBTT__CSERR(\"return outside subr\");\n         b = subr_stack[--subr_stack_height];\n         clear_stack = 0;\n         break;\n\n      case 0x0E: // endchar\n         stbtt__csctx_close_shape(c);\n         return 1;\n\n      case 0x0C: { // two-byte escape\n         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;\n         float dx, dy;\n         int b1 = stbtt__buf_get8(&b);\n         switch (b1) {\n         // and always draw beziers.\n         case 0x22: // hflex\n            if (sp < 7) return STBTT__CSERR(\"hflex stack\");\n            dx1 = s[0];\n            dx2 = s[1];\n            dy2 = s[2];\n            dx3 = s[3];\n            dx4 = s[4];\n            dx5 = s[5];\n            dx6 = s[6];\n            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);\n            break;\n\n         case 0x23: // flex\n            if (sp < 13) return STBTT__CSERR(\"flex stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = s[10];\n            dy6 = s[11];\n            //fd is s[12]\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         case 0x24: // hflex1\n            if (sp < 9) return STBTT__CSERR(\"hflex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dx4 = s[5];\n            dx5 = s[6];\n            dy5 = s[7];\n            dx6 = s[8];\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));\n            break;\n\n         case 0x25: // flex1\n            if (sp < 11) return STBTT__CSERR(\"flex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = dy6 = s[10];\n            dx = dx1+dx2+dx3+dx4+dx5;\n            dy = dy1+dy2+dy3+dy4+dy5;\n            if (STBTT_fabs(dx) > STBTT_fabs(dy))\n               dy6 = -dy;\n            else\n               dx6 = -dx;\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         default:\n            return STBTT__CSERR(\"unimplemented\");\n         }\n      } break;\n\n      default:\n         if (b0 != 255 && b0 != 28 && b0 < 32)\n            return STBTT__CSERR(\"reserved operator\");\n\n         // push immediate\n         if (b0 == 255) {\n            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;\n         } else {\n            stbtt__buf_skip(&b, -1);\n            f = (float)(stbtt_int16)stbtt__cff_int(&b);\n         }\n         if (sp >= 48) return STBTT__CSERR(\"push stack overflow\");\n         s[sp++] = f;\n         clear_stack = 0;\n         break;\n      }\n      if (clear_stack) sp = 0;\n   }\n   return STBTT__CSERR(\"no endchar\");\n\n#undef STBTT__CSERR\n}\n\nstatic int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   // runs the charstring twice, once to count and once to output (to avoid realloc)\n   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);\n   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);\n   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {\n      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);\n      output_ctx.pvertices = *pvertices;\n      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {\n         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);\n         return output_ctx.num_vertices;\n      }\n   }\n   *pvertices = 0;\n   return 0;\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   stbtt__csctx c = STBTT__CSCTX_INIT(1);\n   int r = stbtt__run_charstring(info, glyph_index, &c);\n   if (x0)  *x0 = r ? c.min_x : 0;\n   if (y0)  *y0 = r ? c.min_y : 0;\n   if (x1)  *x1 = r ? c.max_x : 0;\n   if (y1)  *y1 = r ? c.max_y : 0;\n   return r ? c.num_vertices : 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   if (!info->cff.size)\n      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);\n   else\n      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);\n}\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);\n   if (glyph_index < numOfLongHorMetrics) {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);\n   } else {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));\n   }\n}\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   return ttUSHORT(data+10);\n}\n\nSTBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   int k, length;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   length = ttUSHORT(data+10);\n   if (table_length < length)\n      length = table_length;\n\n   for (k = 0; k < length; k++)\n   {\n      table[k].glyph1 = ttUSHORT(data+18+(k*6));\n      table[k].glyph2 = ttUSHORT(data+20+(k*6));\n      table[k].advance = ttSHORT(data+22+(k*6));\n   }\n\n   return length;\n}\n\nstatic int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   stbtt_uint32 needle, straw;\n   int l, r, m;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   l = 0;\n   r = ttUSHORT(data+10) - 1;\n   needle = glyph1 << 16 | glyph2;\n   while (l <= r) {\n      m = (l + r) >> 1;\n      straw = ttULONG(data+18+(m*6)); // note: unaligned read\n      if (needle < straw)\n         r = m - 1;\n      else if (needle > straw)\n         l = m + 1;\n      else\n         return ttSHORT(data+22+(m*6));\n   }\n   return 0;\n}\n\nstatic stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)\n{\n   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);\n   switch (coverageFormat) {\n      case 1: {\n         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);\n\n         // Binary search.\n         stbtt_int32 l=0, r=glyphCount-1, m;\n         int straw, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *glyphArray = coverageTable + 4;\n            stbtt_uint16 glyphID;\n            m = (l + r) >> 1;\n            glyphID = ttUSHORT(glyphArray + 2 * m);\n            straw = glyphID;\n            if (needle < straw)\n               r = m - 1;\n            else if (needle > straw)\n               l = m + 1;\n            else {\n               return m;\n            }\n         }\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);\n         stbtt_uint8 *rangeArray = coverageTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=rangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *rangeRecord;\n            m = (l + r) >> 1;\n            rangeRecord = rangeArray + 6 * m;\n            strawStart = ttUSHORT(rangeRecord);\n            strawEnd = ttUSHORT(rangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else {\n               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);\n               return startCoverageIndex + glyph - strawStart;\n            }\n         }\n         break;\n      }\n\n      default: return -1; // unsupported\n   }\n\n   return -1;\n}\n\nstatic stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)\n{\n   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);\n   switch (classDefFormat)\n   {\n      case 1: {\n         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);\n         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);\n         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;\n\n         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)\n            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);\n         stbtt_uint8 *classRangeRecords = classDefTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=classRangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *classRangeRecord;\n            m = (l + r) >> 1;\n            classRangeRecord = classRangeRecords + 6 * m;\n            strawStart = ttUSHORT(classRangeRecord);\n            strawEnd = ttUSHORT(classRangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else\n               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);\n         }\n         break;\n      }\n\n      default:\n         return -1; // Unsupported definition type, return an error.\n   }\n\n   // \"All glyphs not assigned to a class fall into class 0\". (OpenType spec)\n   return 0;\n}\n\n// Define to STBTT_assert(x) if you want to break on unimplemented formats.\n#define STBTT_GPOS_TOD_assert(x)\n\nstatic stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint16 lookupListOffset;\n   stbtt_uint8 *lookupList;\n   stbtt_uint16 lookupCount;\n   stbtt_uint8 *data;\n   stbtt_int32 i, sti;\n\n   if (!info->gpos) return 0;\n\n   data = info->data + info->gpos;\n\n   if (ttUSHORT(data+0) != 1) return 0; // Major version 1\n   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0\n\n   lookupListOffset = ttUSHORT(data+8);\n   lookupList = data + lookupListOffset;\n   lookupCount = ttUSHORT(lookupList);\n\n   for (i=0; i<lookupCount; ++i) {\n      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);\n      stbtt_uint8 *lookupTable = lookupList + lookupOffset;\n\n      stbtt_uint16 lookupType = ttUSHORT(lookupTable);\n      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);\n      stbtt_uint8 *subTableOffsets = lookupTable + 6;\n      if (lookupType != 2) // Pair Adjustment Positioning Subtable\n         continue;\n\n      for (sti=0; sti<subTableCount; sti++) {\n         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);\n         stbtt_uint8 *table = lookupTable + subtableOffset;\n         stbtt_uint16 posFormat = ttUSHORT(table);\n         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);\n         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);\n         if (coverageIndex == -1) continue;\n\n         switch (posFormat) {\n            case 1: {\n               stbtt_int32 l, r, m;\n               int straw, needle;\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_int32 valueRecordPairSizeInBytes = 2;\n                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);\n                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);\n                  stbtt_uint8 *pairValueTable = table + pairPosOffset;\n                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);\n                  stbtt_uint8 *pairValueArray = pairValueTable + 2;\n\n                  if (coverageIndex >= pairSetCount) return 0;\n\n                  needle=glyph2;\n                  r=pairValueCount-1;\n                  l=0;\n\n                  // Binary search.\n                  while (l <= r) {\n                     stbtt_uint16 secondGlyph;\n                     stbtt_uint8 *pairValue;\n                     m = (l + r) >> 1;\n                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;\n                     secondGlyph = ttUSHORT(pairValue);\n                     straw = secondGlyph;\n                     if (needle < straw)\n                        r = m - 1;\n                     else if (needle > straw)\n                        l = m + 1;\n                     else {\n                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);\n                        return xAdvance;\n                     }\n                  }\n               } else\n                  return 0;\n               break;\n            }\n\n            case 2: {\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);\n                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);\n                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);\n                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);\n\n                  stbtt_uint16 class1Count = ttUSHORT(table + 12);\n                  stbtt_uint16 class2Count = ttUSHORT(table + 14);\n                  stbtt_uint8 *class1Records, *class2Records;\n                  stbtt_int16 xAdvance;\n\n                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed\n                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed\n\n                  class1Records = table + 16;\n                  class2Records = class1Records + 2 * (glyph1class * class2Count);\n                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);\n                  return xAdvance;\n               } else\n                  return 0;\n               break;\n            }\n\n            default:\n               return 0; // Unsupported position format\n         }\n      }\n   }\n\n   return 0;\n}\n\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\n{\n   int xAdvance = 0;\n\n   if (info->gpos)\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\n   else if (info->kern)\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\n\n   return xAdvance;\n}\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\n{\n   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs\n      return 0;\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\n}\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\n}\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\n{\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\n}\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\n{\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS/2\");\n   if (!tab)\n      return 0;\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\n   return 1;\n}\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)\n{\n   *x0 = ttSHORT(info->data + info->head + 36);\n   *y0 = ttSHORT(info->data + info->head + 38);\n   *x1 = ttSHORT(info->data + info->head + 40);\n   *y1 = ttSHORT(info->data + info->head + 42);\n}\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)\n{\n#if 0\n    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);\n    return (float)height / fheight;\n#endif\n    int fheight = ttSHORT(info->data + info->hhea + 4) ; // Gabor: Taking the descent out of the calculation made the pixel height match what i need much closer\n    return (float)height / fheight;\n}\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)\n{\n   int unitsPerEm = ttUSHORT(info->data + info->head + 18);\n   return pixels / unitsPerEm;\n}\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)\n{\n   STBTT_free(v, info->userdata);\n}\n\nSTBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)\n{\n   int i;\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);\n\n   int numEntries = ttUSHORT(svg_doc_list);\n   stbtt_uint8 *svg_docs = svg_doc_list + 2;\n\n   for(i=0; i<numEntries; i++) {\n      stbtt_uint8 *svg_doc = svg_docs + (12 * i);\n      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))\n         return svg_doc;\n   }\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc;\n\n   if (info->svg == 0)\n      return 0;\n\n   svg_doc = stbtt_FindSVGDoc(info, gl);\n   if (svg_doc != 0) {\n      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);\n      return ttULONG(svg_doc + 8);\n   } else {\n      return 0;\n   }\n}\n\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)\n{\n   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// antialiasing software rasterizer\n//\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning\n   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {\n      // e.g. space character\n      if (ix0) *ix0 = 0;\n      if (iy0) *iy0 = 0;\n      if (ix1) *ix1 = 0;\n      if (iy1) *iy1 = 0;\n   } else {\n      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?\n      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);\n      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);\n      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);\n      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);\n   }\n}\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Rasterizer\n\ntypedef struct stbtt__hheap_chunk\n{\n   struct stbtt__hheap_chunk *next;\n} stbtt__hheap_chunk;\n\ntypedef struct stbtt__hheap\n{\n   struct stbtt__hheap_chunk *head;\n   void   *first_free;\n   int    num_remaining_in_head_chunk;\n} stbtt__hheap;\n\nstatic void *stbtt__hheap_alloc(stbtt__hheap *hh, unsigned int size, void *userdata)\n{\n   if (hh->first_free) {\n      void *p = hh->first_free;\n      hh->first_free = * (void **) p;\n      return p;\n   } else {\n      if (hh->num_remaining_in_head_chunk == 0) {\n         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);\n         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);\n         if (c == 0)\n            return 0;\n         c->next = hh->head;\n         hh->head = c;\n         hh->num_remaining_in_head_chunk = count;\n      }\n      --hh->num_remaining_in_head_chunk;\n      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;\n   }\n}\n\nstatic void stbtt__hheap_free(stbtt__hheap *hh, void *p)\n{\n   *(void **) p = hh->first_free;\n   hh->first_free = p;\n}\n\nstatic void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\n{\n   stbtt__hheap_chunk *c = hh->head;\n   while (c) {\n      stbtt__hheap_chunk *n = c->next;\n      STBTT_free(c, userdata);\n      c = n;\n   }\n}\n\ntypedef struct stbtt__edge {\n   float x0,y0, x1,y1;\n   int invert;\n} stbtt__edge;\n\n\ntypedef struct stbtt__active_edge\n{\n   struct stbtt__active_edge *next;\n   #if STBTT_RASTERIZER_VERSION==1\n   int x,dx;\n   float ey;\n   int direction;\n   #elif STBTT_RASTERIZER_VERSION==2\n   float fx,fdx,fdy;\n   float direction;\n   float sy;\n   float ey;\n   #else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n   #endif\n} stbtt__active_edge;\n\n#if STBTT_RASTERIZER_VERSION == 1\n#define STBTT_FIXSHIFT   10\n#define STBTT_FIX        (1 << STBTT_FIXSHIFT)\n#define STBTT_FIXMASK    (STBTT_FIX-1)\n\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != 0);\n   if (!z) return z;\n\n   // round dx down to avoid overshooting\n   if (dxdy < 0)\n      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);\n   else\n      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);\n\n   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount\n   z->x -= off_x * STBTT_FIX;\n\n   z->ey = e->y1;\n   z->next = 0;\n   z->direction = e->invert ? 1 : -1;\n   return z;\n}\n#elif STBTT_RASTERIZER_VERSION == 2\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != 0);\n   //STBTT_assert(e->y0 <= start_point);\n   if (!z) return z;\n   z->fdx = dxdy;\n   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;\n   z->fx = e->x0 + dxdy * (start_point - e->y0);\n   z->fx -= off_x;\n   z->direction = e->invert ? 1.0f : -1.0f;\n   z->sy = e->y0;\n   z->ey = e->y1;\n   z->next = 0;\n   return z;\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#if STBTT_RASTERIZER_VERSION == 1\n// note: this routine clips fills that extend off the edges... ideally this\n// wouldn't happen, but it could happen if the truetype glyph bounding boxes\n// are wrong, or if the user supplies a too-small bitmap\nstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)\n{\n   // non-zero winding fill\n   int x0=0, w=0;\n\n   while (e) {\n      if (w == 0) {\n         // if we're currently at zero, we need to record the edge start point\n         x0 = e->x; w += e->direction;\n      } else {\n         int x1 = e->x; w += e->direction;\n         // if we went to zero, we need to draw\n         if (w == 0) {\n            int i = x0 >> STBTT_FIXSHIFT;\n            int j = x1 >> STBTT_FIXSHIFT;\n\n            if (i < len && j >= 0) {\n               if (i == j) {\n                  // x0,x1 are the same pixel, so compute combined coverage\n                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);\n               } else {\n                  if (i >= 0) // add antialiasing for x0\n                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     i = -1; // clip\n\n                  if (j < len) // add antialiasing for x1\n                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     j = len; // clip\n\n                  for (++i; i < j; ++i) // fill pixels between x0 and x1\n                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;\n               }\n            }\n         }\n      }\n\n      e = e->next;\n   }\n}\n\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = 0;\n   int y,j=0;\n   int max_weight = (255 / vsubsample);  // weight per vertical scanline\n   int s; // vertical subsample index\n   unsigned char scanline_data[512], *scanline;\n\n   if (result->w > 512)\n      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);\n   else\n      scanline = scanline_data;\n\n   y = off_y * vsubsample;\n   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;\n\n   while (j < result->h) {\n      STBTT_memset(scanline, 0, result->w);\n      for (s=0; s < vsubsample; ++s) {\n         // find center of pixel for this scanline\n         float scan_y = y + 0.5f;\n         stbtt__active_edge **step = &active;\n\n         // update all active edges;\n         // remove all active edges that terminate before the center of this scanline\n         while (*step) {\n            stbtt__active_edge * z = *step;\n            if (z->ey <= scan_y) {\n               *step = z->next; \n               STBTT_assert(z->direction);\n               z->direction = 0;\n               stbtt__hheap_free(&hh, z);\n            } else {\n               z->x += z->dx; // advance to position for current scanline\n               step = &((*step)->next); // advance through list\n            }\n         }\n\n         // resort the list if needed\n         for(;;) {\n            int changed=0;\n            step = &active;\n            while (*step && (*step)->next) {\n               if ((*step)->x > (*step)->next->x) {\n                  stbtt__active_edge *t = *step;\n                  stbtt__active_edge *q = t->next;\n\n                  t->next = q->next;\n                  q->next = t;\n                  *step = q;\n                  changed = 1;\n               }\n               step = &(*step)->next;\n            }\n            if (!changed) break;\n         }\n\n         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline\n         while (e->y0 <= scan_y) {\n            if (e->y1 > scan_y) {\n               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);\n               if (z != 0) {\n                  // find insertion point\n                  if (active == 0)\n                     active = z;\n                  else if (z->x < active->x) {\n                     // insert at front\n                     z->next = active;\n                     active = z;\n                  } else {\n                     // find thing to insert AFTER\n                     stbtt__active_edge *p = active;\n                     while (p->next && p->next->x < z->x)\n                        p = p->next;\n                     // at this point, p->next->x is NOT < z->x\n                     z->next = p->next;\n                     p->next = z;\n                  }\n               }\n            }\n            ++e;\n         }\n\n         // now process all active edges in XOR fashion\n         if (active)\n            stbtt__fill_active_edges(scanline, result->w, active, max_weight);\n\n         ++y;\n      }\n      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n\n#elif STBTT_RASTERIZER_VERSION == 2\n\n// the edge passed in here does not cross the vertical line at x or the vertical line at x+1\n// (i.e. it has already been clipped to those)\nstatic void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)\n{\n   if (y0 == y1) return;\n   STBTT_assert(y0 < y1);\n   STBTT_assert(e->sy <= e->ey);\n   if (y0 > e->ey) return;\n   if (y1 < e->sy) return;\n   if (y0 < e->sy) {\n      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);\n      y0 = e->sy;\n   }\n   if (y1 > e->ey) {\n      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);\n      y1 = e->ey;\n   }\n\n   if (x0 == x)\n      STBTT_assert(x1 <= x+1);\n   else if (x0 == x+1)\n      STBTT_assert(x1 >= x);\n   else if (x0 <= x)\n      STBTT_assert(x1 <= x);\n   else if (x0 >= x+1)\n      STBTT_assert(x1 >= x+1);\n   else\n      STBTT_assert(x1 >= x && x1 <= x+1);\n\n   if (x0 <= x && x1 <= x)\n      scanline[x] += e->direction * (y1-y0);\n   else if (x0 >= x+1 && x1 >= x+1)\n      ;\n   else {\n      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);\n      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position\n   }\n}\n\nstatic float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)\n{\n   STBTT_assert(top_width >= 0);\n   STBTT_assert(bottom_width >= 0);\n   return (top_width + bottom_width) / 2.0f * height;\n}\n\nstatic float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)\n{\n   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);\n}\n\nstatic float stbtt__sized_triangle_area(float height, float width)\n{\n   return height * width / 2;\n}\n\nstatic void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)\n{\n   float y_bottom = y_top+1;\n\n   while (e) {\n      // brute force every pixel\n\n      // compute intersection points with top & bottom\n      STBTT_assert(e->ey >= y_top);\n\n      if (e->fdx == 0) {\n         float x0 = e->fx;\n         if (x0 < len) {\n            if (x0 >= 0) {\n               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);\n               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);\n            } else {\n               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);\n            }\n         }\n      } else {\n         float x0 = e->fx;\n         float dx = e->fdx;\n         float xb = x0 + dx;\n         float x_top, x_bottom;\n         float sy0,sy1;\n         float dy = e->fdy;\n         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);\n\n         // compute endpoints of line segment clipped to this scanline (if the\n         // line segment starts on this scanline. x0 is the intersection of the\n         // line with y_top, but that may be off the line segment.\n         if (e->sy > y_top) {\n            x_top = x0 + dx * (e->sy - y_top);\n            sy0 = e->sy;\n         } else {\n            x_top = x0;\n            sy0 = y_top;\n         }\n         if (e->ey < y_bottom) {\n            x_bottom = x0 + dx * (e->ey - y_top);\n            sy1 = e->ey;\n         } else {\n            x_bottom = xb;\n            sy1 = y_bottom;\n         }\n\n         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {\n            // from here on, we don't have to range check x values\n\n            if ((int) x_top == (int) x_bottom) {\n               float height;\n               // simple case, only spans one pixel\n               int x = (int) x_top;\n               height = (sy1 - sy0) * e->direction;\n               STBTT_assert(x >= 0 && x < len);\n               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);\n               scanline_fill[x] += height; // everything right of this pixel is filled\n            } else {\n               int x,x1,x2;\n               float y_crossing, y_final, step, sign, area;\n               // covers 2+ pixels\n               if (x_top > x_bottom) {\n                  // flip scanline vertically; signed area is the same\n                  float t;\n                  sy0 = y_bottom - (sy0 - y_top);\n                  sy1 = y_bottom - (sy1 - y_top);\n                  t = sy0, sy0 = sy1, sy1 = t;\n                  t = x_bottom, x_bottom = x_top, x_top = t;\n                  dx = -dx;\n                  dy = -dy;\n                  t = x0, x0 = xb, xb = t;\n               }\n               STBTT_assert(dy >= 0);\n               STBTT_assert(dx >= 0);\n\n               x1 = (int) x_top;\n               x2 = (int) x_bottom;\n               // compute intersection with y axis at x1+1\n               y_crossing = y_top + dy * (x1+1 - x0);\n\n               // compute intersection with y axis at x2\n               y_final = y_top + dy * (x2 - x0);\n\n               //           x1    x_top                            x2    x_bottom\n               //     y_top  +------|-----+------------+------------+--------|---+------------+\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //       sy0  |      Txxxxx|............|............|............|............|\n               // y_crossing |            *xxxxx.......|............|............|............|\n               //            |            |     xxxxx..|............|............|............|\n               //            |            |     /-   xx*xxxx........|............|............|\n               //            |            | dy <       |    xxxxxx..|............|............|\n               //   y_final  |            |     \\-     |          xx*xxx.........|............|\n               //       sy1  |            |            |            |   xxxxxB...|............|\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //  y_bottom  +------------+------------+------------+------------+------------+\n               //\n               // goal is to measure the area covered by '.' in each pixel\n\n               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057\n               if (y_crossing > y_bottom)\n                  y_crossing = y_bottom;\n\n               sign = e->direction;\n\n               // area of the rectangle covered from sy0..y_crossing\n               area = sign * (y_crossing-sy0);\n\n               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)\n               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);\n\n               // check if final y_crossing is blown up; no test case for this\n               if (y_final > y_bottom) {\n                  y_final = y_bottom;\n                  dy = (y_final - y_crossing ) / (x2 - (x1+1)); // if denom=0, y_final = y_crossing, so y_final <= y_bottom\n               }\n\n               // in second pixel, area covered by line segment found in first pixel\n               // is always a rectangle 1 wide * the height of that line segment; this\n               // is exactly what the variable 'area' stores. it also gets a contribution\n               // from the line segment within it. the THIRD pixel will get the first\n               // pixel's rectangle contribution, the second pixel's rectangle contribution,\n               // and its own contribution. the 'own contribution' is the same in every pixel except\n               // the leftmost and rightmost, a trapezoid that slides down in each pixel.\n               // the second pixel's contribution to the third pixel will be the\n               // rectangle 1 wide times the height change in the second pixel, which is dy.\n\n               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,\n               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x\n               // so the area advances by 'step' every time\n\n               for (x = x1+1; x < x2; ++x) {\n                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2\n                  area += step;\n               }\n               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down\n               STBTT_assert(sy1 > y_final-0.01f);\n\n               // area covered in the last pixel is the rectangle from all the pixels to the left,\n               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge\n               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);\n\n               // the rest of the line is filled based on the total height of the line segment in this pixel\n               scanline_fill[x2] += sign * (sy1-sy0);\n            }\n         } else {\n            // if edge goes outside of box we're drawing, we require\n            // clipping logic. since this does not match the intended use\n            // of this library, we use a different, very slow brute\n            // force implementation\n            // note though that this does happen some of the time because\n            // x_top and x_bottom can be extrapolated at the top & bottom of\n            // the shape and actually lie outside the bounding box\n            int x;\n            for (x=0; x < len; ++x) {\n               // cases:\n               //\n               // there can be up to two intersections with the pixel. any intersection\n               // with left or right edges can be handled by splitting into two (or three)\n               // regions. intersections with top & bottom do not necessitate case-wise logic.\n               //\n               // the old way of doing this found the intersections with the left & right edges,\n               // then used some simple logic to produce up to three segments in sorted order\n               // from top-to-bottom. however, this had a problem: if an x edge was epsilon\n               // across the x border, then the corresponding y position might not be distinct\n               // from the other y segment, and it might ignored as an empty segment. to avoid\n               // that, we need to explicitly produce segments based on x positions.\n\n               // rename variables to clearly-defined pairs\n               float y0 = y_top;\n               float x1 = (float) (x);\n               float x2 = (float) (x+1);\n               float x3 = xb;\n               float y3 = y_bottom;\n\n               // x = e->x + e->dx * (y-y_top)\n               // (y-y_top) = (x - e->x) / e->dx\n               // y = (x - e->x) / e->dx + y_top\n               float y1 = (x - x0) / dx + y_top;\n               float y2 = (x+1 - x0) / dx + y_top;\n\n               if (x0 < x1 && x3 > x2) {         // three segments descending down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else {  // one segment\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);\n               }\n            }\n         }\n      }\n      e = e->next;\n   }\n}\n\n// directly AA rasterize edges w/o supersampling\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = 0;\n   int y,j=0, i;\n   float scanline_data[129], *scanline, *scanline2;\n\n   STBTT__NOTUSED(vsubsample);\n\n   if (result->w > 64)\n      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);\n   else\n      scanline = scanline_data;\n\n   scanline2 = scanline + result->w;\n\n   y = off_y;\n   e[n].y0 = (float) (off_y + result->h) + 1;\n\n   while (j < result->h) {\n      // find center of pixel for this scanline\n      float scan_y_top    = y + 0.0f;\n      float scan_y_bottom = y + 1.0f;\n      stbtt__active_edge **step = &active;\n\n      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));\n      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));\n\n      // update all active edges;\n      // remove all active edges that terminate before the top of this scanline\n      while (*step) {\n         stbtt__active_edge * z = *step;\n         if (z->ey <= scan_y_top) {\n            *step = z->next; \n            STBTT_assert(z->direction);\n            z->direction = 0;\n            stbtt__hheap_free(&hh, z);\n         } else {\n            step = &((*step)->next); // advance through list\n         }\n      }\n\n      // insert all edges that start before the bottom of this scanline\n      while (e->y0 <= scan_y_bottom) {\n         if (e->y0 != e->y1) {\n            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);\n            if (z != 0) {\n               if (j == 0 && off_y != 0) {\n                  if (z->ey < scan_y_top) {\n                     // this can happen due to subpixel positioning and some kind of fp rounding error i think\n                     z->ey = scan_y_top;\n                  }\n               }\n               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds\n               // insert at front\n               z->next = active;\n               active = z;\n            }\n         }\n         ++e;\n      }\n\n      // now process all active edges\n      if (active)\n         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);\n\n      {\n         float sum = 0;\n         for (i=0; i < result->w; ++i) {\n            float k;\n            int m;\n            sum += scanline2[i];\n            k = scanline[i] + sum;\n            k = (float) STBTT_fabs(k)*255 + 0.5f;\n            m = (int) k;\n            if (m > 255) m = 255;\n            result->pixels[j*result->stride + i] = (unsigned char) m;\n         }\n      }\n      // advance all the edges\n      step = &active;\n      while (*step) {\n         stbtt__active_edge *z = *step;\n         z->fx += z->fdx; // advance to position for current scanline\n         step = &((*step)->next); // advance through list\n      }\n\n      ++y;\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)\n\nstatic void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)\n{\n   int i,j;\n   for (i=1; i < n; ++i) {\n      stbtt__edge t = p[i], *a = &t;\n      j = i;\n      while (j > 0) {\n         stbtt__edge *b = &p[j-1];\n         int c = STBTT__COMPARE(a,b);\n         if (!c) break;\n         p[j] = p[j-1];\n         --j;\n      }\n      if (i != j)\n         p[j] = t;\n   }\n}\n\nstatic void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)\n{\n   /* threshold for transitioning to insertion sort */\n   while (n > 12) {\n      stbtt__edge t;\n      int c01,c12,c,m,i,j;\n\n      /* compute median of three */\n      m = n >> 1;\n      c01 = STBTT__COMPARE(&p[0],&p[m]);\n      c12 = STBTT__COMPARE(&p[m],&p[n-1]);\n      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */\n      if (c01 != c12) {\n         /* otherwise, we'll need to swap something else to middle */\n         int z;\n         c = STBTT__COMPARE(&p[0],&p[n-1]);\n         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */\n         /* 0<mid && mid>n:  0>n => 0; 0<n => n */\n         z = (c == c12) ? 0 : n-1;\n         t = p[z];\n         p[z] = p[m];\n         p[m] = t;\n      }\n      /* now p[m] is the median-of-three */\n      /* swap it to the beginning so it won't move around */\n      t = p[0];\n      p[0] = p[m];\n      p[m] = t;\n\n      /* partition loop */\n      i=1;\n      j=n-1;\n      for(;;) {\n         /* handling of equality is crucial here */\n         /* for sentinels & efficiency with duplicates */\n         for (;;++i) {\n            if (!STBTT__COMPARE(&p[i], &p[0])) break;\n         }\n         for (;;--j) {\n            if (!STBTT__COMPARE(&p[0], &p[j])) break;\n         }\n         /* make sure we haven't crossed */\n         if (i >= j) break;\n         t = p[i];\n         p[i] = p[j];\n         p[j] = t;\n\n         ++i;\n         --j;\n      }\n      /* recurse on smaller side, iterate on larger */\n      if (j < (n-i)) {\n         stbtt__sort_edges_quicksort(p,j);\n         p = p+i;\n         n = n-i;\n      } else {\n         stbtt__sort_edges_quicksort(p+i, n-i);\n         n = j;\n      }\n   }\n}\n\nstatic void stbtt__sort_edges(stbtt__edge *p, int n)\n{\n   stbtt__sort_edges_quicksort(p, n);\n   stbtt__sort_edges_ins_sort(p, n);\n}\n\ntypedef struct\n{\n   float x,y;\n} stbtt__point;\n\nstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)\n{\n   float y_scale_inv = invert ? -scale_y : scale_y;\n   stbtt__edge *e;\n   int n,i,j,k,m;\n#if STBTT_RASTERIZER_VERSION == 1\n   int vsubsample = result->h < 8 ? 15 : 5;\n#elif STBTT_RASTERIZER_VERSION == 2\n   int vsubsample = 1;\n#else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity\n\n   // now we have to blow out the windings into explicit edge lists\n   n = 0;\n   for (i=0; i < windings; ++i)\n      n += wcount[i];\n\n   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel\n   if (e == 0) return;\n   n = 0;\n\n   m=0;\n   for (i=0; i < windings; ++i) {\n      stbtt__point *p = pts + m;\n      m += wcount[i];\n      j = wcount[i]-1;\n      for (k=0; k < wcount[i]; j=k++) {\n         int a=k,b=j;\n         // skip the edge if horizontal\n         if (p[j].y == p[k].y)\n            continue;\n         // add edge from j to k to the list\n         e[n].invert = 0;\n         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {\n            e[n].invert = 1;\n            a=j,b=k;\n         }\n         e[n].x0 = p[a].x * scale_x + shift_x;\n         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;\n         e[n].x1 = p[b].x * scale_x + shift_x;\n         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;\n         ++n;\n      }\n   }\n\n   // now sort the edges by their highest point (should snap to integer, and then by x)\n   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);\n   stbtt__sort_edges(e, n);\n\n   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule\n   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);\n\n   STBTT_free(e, userdata);\n}\n\nstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)\n{\n   if (!points) return; // during first pass, it's unallocated\n   points[n].x = x;\n   points[n].y = y;\n}\n\nstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)\n{\n   // midpoint\n   float mx = (x0 + 2*x1 + x2)/4;\n   float my = (y0 + 2*y1 + y2)/4;\n   // versus directly drawn line\n   float dx = (x0+x2)/2 - mx;\n   float dy = (y0+y2)/2 - my;\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return 1;\n   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA\n      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x2,y2);\n      *num_points = *num_points+1;\n   }\n   return 1;\n}\n\nstatic void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)\n{\n   float dx0 = x1-x0;\n   float dy0 = y1-y0;\n   float dx1 = x2-x1;\n   float dy1 = y2-y1;\n   float dx2 = x3-x2;\n   float dy2 = y3-y2;\n   float dx = x3-x0;\n   float dy = y3-y0;\n   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));\n   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);\n   float flatness_squared = longlen*longlen-shortlen*shortlen;\n\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return;\n\n   if (flatness_squared > objspace_flatness_squared) {\n      float x01 = (x0+x1)/2;\n      float y01 = (y0+y1)/2;\n      float x12 = (x1+x2)/2;\n      float y12 = (y1+y2)/2;\n      float x23 = (x2+x3)/2;\n      float y23 = (y2+y3)/2;\n\n      float xa = (x01+x12)/2;\n      float ya = (y01+y12)/2;\n      float xb = (x12+x23)/2;\n      float yb = (y12+y23)/2;\n\n      float mx = (xa+xb)/2;\n      float my = (ya+yb)/2;\n\n      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x3,y3);\n      *num_points = *num_points+1;\n   }\n}\n\n// returns number of contours\nstatic stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)\n{\n   stbtt__point *points=0;\n   int num_points=0;\n\n   float objspace_flatness_squared = objspace_flatness * objspace_flatness;\n   int i,n=0,start=0, pass;\n\n   // count how many \"moves\" there are to get the contour count\n   for (i=0; i < num_verts; ++i)\n      if (vertices[i].type == STBTT_vmove)\n         ++n;\n\n   *num_contours = n;\n   if (n == 0) return 0;\n\n   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);\n\n   if (*contour_lengths == 0) {\n      *num_contours = 0;\n      return 0;\n   }\n\n   // make two passes through the points so we don't need to realloc\n   for (pass=0; pass < 2; ++pass) {\n      float x=0,y=0;\n      if (pass == 1) {\n         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);\n         if (points == 0) goto error;\n      }\n      num_points = 0;\n      n= -1;\n      for (i=0; i < num_verts; ++i) {\n         switch (vertices[i].type) {\n            case STBTT_vmove:\n               // start the next contour\n               if (n >= 0)\n                  (*contour_lengths)[n] = num_points - start;\n               ++n;\n               start = num_points;\n\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x,y);\n               break;\n            case STBTT_vline:\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x, y);\n               break;\n            case STBTT_vcurve:\n               stbtt__tesselate_curve(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n            case STBTT_vcubic:\n               stbtt__tesselate_cubic(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].cx1, vertices[i].cy1,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n         }\n      }\n      (*contour_lengths)[n] = num_points - start;\n   }\n\n   return points;\nerror:\n   STBTT_free(points, userdata);\n   STBTT_free(*contour_lengths, userdata);\n   *contour_lengths = 0;\n   *num_contours = 0;\n   return 0;\n}\n\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)\n{\n   float scale            = scale_x > scale_y ? scale_y : scale_x;\n   int winding_count      = 0;\n   int *winding_lengths   = 0;\n   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);\n   if (windings) {\n      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);\n      STBTT_free(winding_lengths, userdata);\n      STBTT_free(windings, userdata);\n   }\n}\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   int ix0,iy0,ix1,iy1;\n   stbtt__bitmap gbm;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n\n   if (scale_x == 0) scale_x = scale_y;\n   if (scale_y == 0) {\n      if (scale_x == 0) {\n         STBTT_free(vertices, info->userdata);\n         return 0;\n      }\n      scale_y = scale_x;\n   }\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);\n\n   // now we get the size\n   gbm.w = (ix1 - ix0);\n   gbm.h = (iy1 - iy0);\n   gbm.pixels = 0; // in case we error\n\n   if (width ) *width  = gbm.w;\n   if (height) *height = gbm.h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   if (gbm.w && gbm.h) {\n      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);\n      if (gbm.pixels) {\n         gbm.stride = gbm.w;\n\n         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);\n      }\n   }\n   STBTT_free(vertices, info->userdata);\n   return gbm.pixels;\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)\n{\n   int ix0,iy0;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n   stbtt__bitmap gbm;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);\n   gbm.pixels = output;\n   gbm.w = out_w;\n   gbm.h = out_h;\n   gbm.stride = out_stride;\n\n   if (gbm.w && gbm.h)\n      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);\n\n   STBTT_free(vertices, info->userdata);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)\n{\n   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-CRAPPY packing to keep source code small\n\nstatic int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata)\n{\n   float scale;\n   int x,y,bottom_y, i;\n   stbtt_fontinfo f;\n   f.userdata = 0;\n   if (!stbtt_InitFont(&f, data, offset))\n      return -1;\n   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n   x=y=1;\n   bottom_y = 1;\n\n   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);\n\n   for (i=0; i < num_chars; ++i) {\n      int advance, lsb, x0,y0,x1,y1,gw,gh;\n      int g = stbtt_FindGlyphIndex(&f, first_char + i);\n      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);\n      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);\n      gw = x1-x0;\n      gh = y1-y0;\n      if (x + gw + 1 >= pw)\n         y = bottom_y, x = 1; // advance to next row\n      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row\n         return -i;\n      STBTT_assert(x+gw < pw);\n      STBTT_assert(y+gh < ph);\n      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);\n      chardata[i].x0 = (stbtt_int16) x;\n      chardata[i].y0 = (stbtt_int16) y;\n      chardata[i].x1 = (stbtt_int16) (x + gw);\n      chardata[i].y1 = (stbtt_int16) (y + gh);\n      chardata[i].xadvance = scale * advance;\n      chardata[i].xoff     = (float) x0;\n      chardata[i].yoff     = (float) y0;\n      x = x + gw + 1;\n      if (y+gh+1 > bottom_y)\n         bottom_y = y+gh+1;\n   }\n   return bottom_y;\n}\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)\n{\n   float d3d_bias = opengl_fillrule ? 0 : -0.5f;\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_bakedchar *b = chardata + char_index;\n   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n\n   q->x0 = round_x + d3d_bias;\n   q->y0 = round_y + d3d_bias;\n   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;\n   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// rectangle packing replacement routines if you don't have stb_rect_pack.h\n//\n\n#ifndef STB_RECT_PACK_VERSION\n\ntypedef int stbrp_coord;\n\n////////////////////////////////////////////////////////////////////////////////////\n//                                                                                //\n//                                                                                //\n// COMPILER WARNING ?!?!?                                                         //\n//                                                                                //\n//                                                                                //\n// if you get a compile warning due to these symbols being defined more than      //\n// once, move include \"stb_rect_pack.h\" before include \"stb_truetype.h\"         //\n//                                                                                //\n////////////////////////////////////////////////////////////////////////////////////\n\ntypedef struct\n{\n   int width,height;\n   int x,y,bottom_y;\n} stbrp_context;\n\ntypedef struct\n{\n   unsigned char x;\n} stbrp_node;\n\nstruct stbrp_rect\n{\n   stbrp_coord x,y;\n   int id,w,h,was_packed;\n};\n\nstatic void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\n{\n   con->width  = pw;\n   con->height = ph;\n   con->x = 0;\n   con->y = 0;\n   con->bottom_y = 0;\n   STBTT__NOTUSED(nodes);\n   STBTT__NOTUSED(num_nodes);\n}\n\nstatic void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)\n{\n   int i;\n   for (i=0; i < num_rects; ++i) {\n      if (con->x + rects[i].w > con->width) {\n         con->x = 0;\n         con->y = con->bottom_y;\n      }\n      if (con->y + rects[i].h > con->height)\n         break;\n      rects[i].x = con->x;\n      rects[i].y = con->y;\n      rects[i].was_packed = 1;\n      con->x += rects[i].w;\n      if (con->y + rects[i].h > con->bottom_y)\n         con->bottom_y = con->y + rects[i].h;\n   }\n   for (   ; i < num_rects; ++i)\n      rects[i].was_packed = 0;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If\n// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.\n\nSTBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)\n{\n   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);\n   int            num_nodes = pw - padding;\n   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);\n\n   if (context == 0 || nodes == 0) {\n      if (context != 0) STBTT_free(context, alloc_context);\n      if (nodes   != 0) STBTT_free(nodes  , alloc_context);\n      return 0;\n   }\n\n   spc->user_allocator_context = alloc_context;\n   spc->width = pw;\n   spc->height = ph;\n   spc->pixels = pixels;\n   spc->pack_info = context;\n   spc->nodes = nodes;\n   spc->padding = padding;\n   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;\n   spc->h_oversample = 1;\n   spc->v_oversample = 1;\n   spc->skip_missing = 0;\n\n   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);\n\n   if (pixels)\n      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n\n   return 1;\n}\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)\n{\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\n}\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)\n{\n   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);\n   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);\n   if (h_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->h_oversample = h_oversample;\n   if (v_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->v_oversample = v_oversample;\n}\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)\n{\n   spc->skip_missing = skip;\n}\n\n#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)\n\nstatic void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_w = w - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < h; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < w; ++i) {\n         STBTT_assert(pixels[i] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += stride_in_bytes;\n   }\n}\n\nstatic void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_h = h - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < w; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < h; ++i) {\n         STBTT_assert(pixels[i*stride_in_bytes] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += 1;\n   }\n}\n\nstatic float stbtt__oversample_shift(int oversample)\n{\n   if (!oversample)\n      return 0.0f;\n\n   // The prefilter is a box filter of width \"oversample\",\n   // which shifts phase by (oversample - 1)/2 pixels in\n   // oversampled space. We want to shift in the opposite\n   // direction to counter this.\n   return (float)-(oversample - 1) / (2.0f * (float)oversample);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k;\n   int missing_glyph_added = 0;\n\n   k=0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      ranges[i].h_oversample = (unsigned char) spc->h_oversample;\n      ranges[i].v_oversample = (unsigned char) spc->v_oversample;\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         int x0,y0,x1,y1;\n         int codepoint = ranges[i].array_of_unicode_codepoints == 0 ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n         int glyph = stbtt_FindGlyphIndex(info, codepoint);\n         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {\n            rects[k].w = rects[k].h = 0;\n         } else {\n            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,\n                                            scale * spc->h_oversample,\n                                            scale * spc->v_oversample,\n                                            0,0,\n                                            &x0,&y0,&x1,&y1);\n            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);\n            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);\n            if (glyph == 0)\n               missing_glyph_added = 1;\n         }\n         ++k;\n      }\n   }\n\n   return k;\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info,\n                                 output,\n                                 out_w - (prefilter_x - 1),\n                                 out_h - (prefilter_y - 1),\n                                 out_stride,\n                                 scale_x,\n                                 scale_y,\n                                 shift_x,\n                                 shift_y,\n                                 glyph);\n\n   if (prefilter_x > 1)\n      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);\n\n   if (prefilter_y > 1)\n      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);\n\n   *sub_x = stbtt__oversample_shift(prefilter_x);\n   *sub_y = stbtt__oversample_shift(prefilter_y);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k, missing_glyph = -1, return_value = 1;\n\n   // save current values\n   int old_h_over = spc->h_oversample;\n   int old_v_over = spc->v_oversample;\n\n   k = 0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      float recip_h,recip_v,sub_x,sub_y;\n      spc->h_oversample = ranges[i].h_oversample;\n      spc->v_oversample = ranges[i].v_oversample;\n      recip_h = 1.0f / spc->h_oversample;\n      recip_v = 1.0f / spc->v_oversample;\n      sub_x = stbtt__oversample_shift(spc->h_oversample);\n      sub_y = stbtt__oversample_shift(spc->v_oversample);\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         stbrp_rect *r = &rects[k];\n         if (r->was_packed && r->w != 0 && r->h != 0) {\n            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];\n            int advance, lsb, x0,y0,x1,y1;\n            int codepoint = ranges[i].array_of_unicode_codepoints == 0 ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n            int glyph = stbtt_FindGlyphIndex(info, codepoint);\n            stbrp_coord pad = (stbrp_coord) spc->padding;\n\n            // pad on left and top\n            r->x += pad;\n            r->y += pad;\n            r->w -= pad;\n            r->h -= pad;\n            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);\n            stbtt_GetGlyphBitmapBox(info, glyph,\n                                    scale * spc->h_oversample,\n                                    scale * spc->v_oversample,\n                                    &x0,&y0,&x1,&y1);\n            stbtt_MakeGlyphBitmapSubpixel(info,\n                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                          r->w - spc->h_oversample+1,\n                                          r->h - spc->v_oversample+1,\n                                          spc->stride_in_bytes,\n                                          scale * spc->h_oversample,\n                                          scale * spc->v_oversample,\n                                          0,0,\n                                          glyph);\n\n            if (spc->h_oversample > 1)\n               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->h_oversample);\n\n            if (spc->v_oversample > 1)\n               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->v_oversample);\n\n            bc->x0       = (stbtt_int16)  r->x;\n            bc->y0       = (stbtt_int16)  r->y;\n            bc->x1       = (stbtt_int16) (r->x + r->w);\n            bc->y1       = (stbtt_int16) (r->y + r->h);\n            bc->xadvance =                scale * advance;\n            bc->xoff     =       (float)  x0 * recip_h + sub_x;\n            bc->yoff     =       (float)  y0 * recip_v + sub_y;\n            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;\n            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;\n\n            if (glyph == 0)\n               missing_glyph = j;\n         } else if (spc->skip_missing) {\n            return_value = 0;\n         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {\n            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];\n         } else {\n            return_value = 0; // if any fail, report failure\n         }\n\n         ++k;\n      }\n   }\n\n   // restore original values\n   spc->h_oversample = old_h_over;\n   spc->v_oversample = old_v_over;\n\n   return return_value;\n}\n\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)\n{\n   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);\n}\n\nSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)\n{\n   stbtt_fontinfo info;\n   int i,j,n, return_value = 1;\n   //stbrp_context *context = (stbrp_context *) spc->pack_info;\n   stbrp_rect    *rects;\n\n   // flag all characters as NOT packed\n   for (i=0; i < num_ranges; ++i)\n      for (j=0; j < ranges[i].num_chars; ++j)\n         ranges[i].chardata_for_range[j].x0 =\n         ranges[i].chardata_for_range[j].y0 =\n         ranges[i].chardata_for_range[j].x1 =\n         ranges[i].chardata_for_range[j].y1 = 0;\n\n   n = 0;\n   for (i=0; i < num_ranges; ++i)\n      n += ranges[i].num_chars;\n\n   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);\n   if (rects == 0)\n      return 0;\n\n   info.userdata = spc->user_allocator_context;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));\n\n   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);\n\n   stbtt_PackFontRangesPackRects(spc, rects, n);\n\n   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);\n\n   STBTT_free(rects, spc->user_allocator_context);\n   return return_value;\n}\n\nSTBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)\n{\n   stbtt_pack_range range;\n   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;\n   range.array_of_unicode_codepoints = 0;\n   range.num_chars                   = num_chars_in_range;\n   range.chardata_for_range          = chardata_for_range;\n   range.font_size                   = font_size;\n   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);\n}\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)\n{\n   int i_ascent, i_descent, i_lineGap;\n   float scale;\n   stbtt_fontinfo info;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));\n   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);\n   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);\n   *ascent  = (float) i_ascent  * scale;\n   *descent = (float) i_descent * scale;\n   *lineGap = (float) i_lineGap * scale;\n}\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)\n{\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_packedchar *b = chardata + char_index;\n\n   if (align_to_integer) {\n      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n      q->x0 = x;\n      q->y0 = y;\n      q->x1 = x + b->xoff2 - b->xoff;\n      q->y1 = y + b->yoff2 - b->yoff;\n   } else {\n      q->x0 = *xpos + b->xoff;\n      q->y0 = *ypos + b->yoff;\n      q->x1 = *xpos + b->xoff2;\n      q->y1 = *ypos + b->yoff2;\n   }\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// sdf computation\n//\n\n#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))\n#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))\n\nstatic int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])\n{\n   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];\n   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];\n   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];\n   float roperp = orig[1]*ray[0] - orig[0]*ray[1];\n\n   float a = q0perp - 2*q1perp + q2perp;\n   float b = q1perp - q0perp;\n   float c = q0perp - roperp;\n\n   float s0 = 0., s1 = 0.;\n   int num_s = 0;\n\n   if (a != 0.0) {\n      float discr = b*b - a*c;\n      if (discr > 0.0) {\n         float rcpna = -1 / a;\n         float d = (float) STBTT_sqrt(discr);\n         s0 = (b+d) * rcpna;\n         s1 = (b-d) * rcpna;\n         if (s0 >= 0.0 && s0 <= 1.0)\n            num_s = 1;\n         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {\n            if (num_s == 0) s0 = s1;\n            ++num_s;\n         }\n      }\n   } else {\n      // 2*b*s + c = 0\n      // s = -c / (2*b)\n      s0 = c / (-2 * b);\n      if (s0 >= 0.0 && s0 <= 1.0)\n         num_s = 1;\n   }\n\n   if (num_s == 0)\n      return 0;\n   else {\n      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);\n      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;\n\n      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;\n      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;\n      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;\n      float rod = orig[0]*rayn_x + orig[1]*rayn_y;\n\n      float q10d = q1d - q0d;\n      float q20d = q2d - q0d;\n      float q0rd = q0d - rod;\n\n      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;\n      hits[0][1] = a*s0+b;\n\n      if (num_s > 1) {\n         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;\n         hits[1][1] = a*s1+b;\n         return 2;\n      } else {\n         return 1;\n      }\n   }\n}\n\nstatic int equal(float *a, float *b)\n{\n   return (a[0] == b[0] && a[1] == b[1]);\n}\n\nstatic int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)\n{\n   int i;\n   float orig[2], ray[2] = { 1, 0 };\n   float y_frac;\n   int winding = 0;\n\n   // make sure y never passes through a vertex of the shape\n   y_frac = (float) STBTT_fmod(y, 1.0f);\n   if (y_frac < 0.01f)\n      y += 0.01f;\n   else if (y_frac > 0.99f)\n      y -= 0.01f;\n\n   orig[0] = x;\n   orig[1] = y;\n\n   // test a ray from (-infinity,y) to (x,y)\n   for (i=0; i < nverts; ++i) {\n      if (verts[i].type == STBTT_vline) {\n         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;\n         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;\n         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n            if (x_inter < x)\n               winding += (y0 < y1) ? 1 : -1;\n         }\n      }\n      if (verts[i].type == STBTT_vcurve) {\n         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;\n         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;\n         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;\n         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));\n         int by = STBTT_max(y0,STBTT_max(y1,y2));\n         if (y > ay && y < by && x > ax) {\n            float q0[2],q1[2],q2[2];\n            float hits[2][2];\n            q0[0] = (float)x0;\n            q0[1] = (float)y0;\n            q1[0] = (float)x1;\n            q1[1] = (float)y1;\n            q2[0] = (float)x2;\n            q2[1] = (float)y2;\n            if (equal(q0,q1) || equal(q1,q2)) {\n               x0 = (int)verts[i-1].x;\n               y0 = (int)verts[i-1].y;\n               x1 = (int)verts[i  ].x;\n               y1 = (int)verts[i  ].y;\n               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n                  if (x_inter < x)\n                     winding += (y0 < y1) ? 1 : -1;\n               }\n            } else {\n               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);\n               if (num_hits >= 1)\n                  if (hits[0][0] < 0)\n                     winding += (hits[0][1] < 0 ? -1 : 1);\n               if (num_hits >= 2)\n                  if (hits[1][0] < 0)\n                     winding += (hits[1][1] < 0 ? -1 : 1);\n            }\n         }\n      }\n   }\n   return winding;\n}\n\nstatic float stbtt__cuberoot( float x )\n{\n   if (x<0)\n      return -(float) STBTT_pow(-x,1.0f/3.0f);\n   else\n      return  (float) STBTT_pow( x,1.0f/3.0f);\n}\n\n// x^3 + a*x^2 + b*x + c = 0\nstatic int stbtt__solve_cubic(float a, float b, float c, float* r)\n{\n   float s = -a / 3;\n   float p = b - a*a / 3;\n   float q = a * (2*a*a - 9*b) / 27 + c;\n   float p3 = p*p*p;\n   float d = q*q + 4*p3 / 27;\n   if (d >= 0) {\n      float z = (float) STBTT_sqrt(d);\n      float u = (-q + z) / 2;\n      float v = (-q - z) / 2;\n      u = stbtt__cuberoot(u);\n      v = stbtt__cuberoot(v);\n      r[0] = s + u + v;\n      return 1;\n   } else {\n      float u = (float) STBTT_sqrt(-p/3);\n      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative\n      float m = (float) STBTT_cos(v);\n      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;\n      r[0] = s + u * 2 * m;\n      r[1] = s - u * (m + n);\n      r[2] = s - u * (m - n);\n\n      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?\n      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);\n      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);\n      return 3;\n   }\n}\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   float scale_x = scale, scale_y = scale;\n   int ix0,iy0,ix1,iy1;\n   int w,h;\n   unsigned char *data;\n\n   if (scale == 0) return 0;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);\n\n   // if empty, return 0\n   if (ix0 == ix1 || iy0 == iy1)\n      return 0;\n\n   ix0 -= padding;\n   iy0 -= padding;\n   ix1 += padding;\n   iy1 += padding;\n\n   w = (ix1 - ix0);\n   h = (iy1 - iy0);\n\n   if (width ) *width  = w;\n   if (height) *height = h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   // invert for y-downwards bitmaps\n   scale_y = -scale_y;\n\n   {\n      int x,y,i,j;\n      float *precompute;\n      stbtt_vertex *verts;\n      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);\n      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);\n      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);\n\n      for (i=0,j=num_verts-1; i < num_verts; j=i++) {\n         if (verts[i].type == STBTT_vline) {\n            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;\n            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));\n            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;\n         } else if (verts[i].type == STBTT_vcurve) {\n            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;\n            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;\n            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;\n            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n            float len2 = bx*bx + by*by;\n            if (len2 != 0.0f)\n               precompute[i] = 1.0f / (bx*bx + by*by);\n            else\n               precompute[i] = 0.0f;\n         } else\n            precompute[i] = 0.0f;\n      }\n\n      for (y=iy0; y < iy1; ++y) {\n         for (x=ix0; x < ix1; ++x) {\n            float val;\n            float min_dist = 999999.0f;\n            float sx = (float) x + 0.5f;\n            float sy = (float) y + 0.5f;\n            float x_gspace = (sx / scale_x);\n            float y_gspace = (sy / scale_y);\n\n            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path\n\n            for (i=0; i < num_verts; ++i) {\n               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n\n               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {\n                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;\n\n                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                  if (dist2 < min_dist*min_dist)\n                     min_dist = (float) STBTT_sqrt(dist2);\n\n                  // coarse culling against bbox\n                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&\n                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)\n                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];\n                  STBTT_assert(i != 0);\n                  if (dist < min_dist) {\n                     // check position along line\n                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)\n                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)\n                     float dx = x1-x0, dy = y1-y0;\n                     float px = x0-sx, py = y0-sy;\n                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy\n                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve\n                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);\n                     if (t >= 0.0f && t <= 1.0f)\n                        min_dist = dist;\n                  }\n               } else if (verts[i].type == STBTT_vcurve) {\n                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;\n                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;\n                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);\n                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);\n                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);\n                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);\n                  // coarse culling against bbox to avoid computing cubic unnecessarily\n                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {\n                     int num=0;\n                     float ax = x1-x0, ay = y1-y0;\n                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n                     float mx = x0 - sx, my = y0 - sy;\n                     float res[3] = {0.f,0.f,0.f};\n                     float px,py,t,it,dist2;\n                     float a_inv = precompute[i];\n                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula\n                        float a = 3*(ax*bx + ay*by);\n                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);\n                        float c = mx*ax+my*ay;\n                        if (a == 0.0) { // if a is 0, it's linear\n                           if (b != 0.0) {\n                              res[num++] = -c/b;\n                           }\n                        } else {\n                           float discriminant = b*b - 4*a*c;\n                           if (discriminant < 0)\n                              num = 0;\n                           else {\n                              float root = (float) STBTT_sqrt(discriminant);\n                              res[0] = (-b - root)/(2*a);\n                              res[1] = (-b + root)/(2*a);\n                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work\n                           }\n                        }\n                     } else {\n                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point\n                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;\n                        float d = (mx*ax+my*ay) * a_inv;\n                        num = stbtt__solve_cubic(b, c, d, res);\n                     }\n                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                     if (dist2 < min_dist*min_dist)\n                        min_dist = (float) STBTT_sqrt(dist2);\n\n                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {\n                        t = res[0], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {\n                        t = res[1], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {\n                        t = res[2], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                  }\n               }\n            }\n            if (winding == 0)\n               min_dist = -min_dist;  // if outside the shape, value is negative\n            val = onedge_value + pixel_dist_scale * min_dist;\n            if (val < 0)\n               val = 0;\n            else if (val > 255)\n               val = 255;\n            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;\n         }\n      }\n      STBTT_free(precompute, info->userdata);\n      STBTT_free(verts, info->userdata);\n   }\n   return data;\n}\n\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// font name matching -- recommended not to use this\n//\n\n// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string\nstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)\n{\n   stbtt_int32 i=0;\n\n   // convert utf16 to utf8 and compare the results while converting\n   while (len2) {\n      stbtt_uint16 ch = s2[0]*256 + s2[1];\n      if (ch < 0x80) {\n         if (i >= len1) return -1;\n         if (s1[i++] != ch) return -1;\n      } else if (ch < 0x800) {\n         if (i+1 >= len1) return -1;\n         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;\n         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;\n      } else if (ch >= 0xd800 && ch < 0xdc00) {\n         stbtt_uint32 c;\n         stbtt_uint16 ch2 = s2[2]*256 + s2[3];\n         if (i+3 >= len1) return -1;\n         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;\n         if (s1[i++] != 0xf0 + (c >> 18)) return -1;\n         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;\n         s2 += 2; // plus another 2 below\n         len2 -= 2;\n      } else if (ch >= 0xdc00 && ch < 0xe000) {\n         return -1;\n      } else {\n         if (i+2 >= len1) return -1;\n         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;\n         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;\n      }\n      s2 += 2;\n      len2 -= 2;\n   }\n   return i;\n}\n\nstatic int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)\n{\n   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);\n}\n\n// returns results in whatever encoding you request... but note that 2-byte encodings\n// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)\n{\n   stbtt_int32 i,count,stringOffset;\n   stbtt_uint8 *fc = font->data;\n   stbtt_uint32 offset = font->fontstart;\n   stbtt_uint32 nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return 0;\n\n   count = ttUSHORT(fc+nm+2);\n   stringOffset = nm + ttUSHORT(fc+nm+4);\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)\n          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {\n         *length = ttUSHORT(fc+loc+8);\n         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));\n      }\n   }\n   return 0;\n}\n\nstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)\n{\n   stbtt_int32 i;\n   stbtt_int32 count = ttUSHORT(fc+nm+2);\n   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);\n\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      stbtt_int32 id = ttUSHORT(fc+loc+6);\n      if (id == target_id) {\n         // find the encoding\n         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);\n\n         // is this a Unicode encoding?\n         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {\n            stbtt_int32 slen = ttUSHORT(fc+loc+8);\n            stbtt_int32 off = ttUSHORT(fc+loc+10);\n\n            // check if there's a prefix match\n            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);\n            if (matchlen >= 0) {\n               // check for target_id+1 immediately following, with same encoding & language\n               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {\n                  slen = ttUSHORT(fc+loc+12+8);\n                  off = ttUSHORT(fc+loc+12+10);\n                  if (slen == 0) {\n                     if (matchlen == nlen)\n                        return 1;\n                  } else if (matchlen < nlen && name[matchlen] == ' ') {\n                     ++matchlen;\n                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))\n                        return 1;\n                  }\n               } else {\n                  // if nothing immediately following\n                  if (matchlen == nlen)\n                     return 1;\n               }\n            }\n         }\n\n      }\n   }\n   return 0;\n}\n\nstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)\n{\n   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);\n   stbtt_uint32 nm,hd;\n   if (!stbtt__isfont(fc+offset)) return 0;\n\n   // check italics/bold/underline flags in macStyle...\n   if (flags) {\n      hd = stbtt__find_table(fc, offset, \"head\");\n      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;\n   }\n\n   nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return 0;\n\n   if (flags) {\n      // if we checked the macStyle flags, then just check the family and ignore the subfamily\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   } else {\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   }\n\n   return 0;\n}\n\nstatic int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)\n{\n   stbtt_int32 i;\n   for (i=0;;++i) {\n      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);\n      if (off < 0) return off;\n      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))\n         return off;\n   }\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,\n                                float pixel_height, unsigned char *pixels, int pw, int ph,\n                                int first_char, int num_chars, stbtt_bakedchar *chardata)\n{\n   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);\n}\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\n{\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);\n}\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)\n{\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\n}\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\n{\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\n}\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)\n{\n   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);\n}\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)\n{\n   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif // STB_TRUETYPE_IMPLEMENTATION\n\n\n// FULL VERSION HISTORY\n//\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) allow user-defined fabs() replacement\n//                     fix memory leak if fontsize=0.0\n//                     fix warning from duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     allow PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)\n//                     also more precise AA rasterizer, except if shapes overlap\n//                     remove need for STBTT_sort\n//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC\n//   1.04 (2015-04-15) typo in example\n//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes\n//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++\n//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match\n//                        non-oversampled; STBTT_POINT_SIZE for packed case only\n//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling\n//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)\n//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID\n//   0.8b (2014-07-07) fix a warning\n//   0.8  (2014-05-25) fix a few more warnings\n//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back\n//   0.6c (2012-07-24) improve documentation\n//   0.6b (2012-07-20) fix a few more warnings\n//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,\n//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty\n//   0.5  (2011-12-09) bugfixes:\n//                        subpixel glyph renderer computed wrong bounding box\n//                        first vertex of shape can be off-curve (FreeSans)\n//   0.4b (2011-12-03) fixed an error in the font baking example\n//   0.4  (2011-12-01) kerning, subpixel rendering (tor)\n//                    bugfixes for:\n//                        codepoint-to-glyph conversion using table fmt=12\n//                        codepoint-to-glyph conversion using table fmt=4\n//                        stbtt_GetBakedQuad with non-square texture (Zer)\n//                    updated Hello World! sample to use kerning and subpixel\n//                    fixed some warnings\n//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)\n//                    userdata, malloc-from-userdata, non-zero fill (stb)\n//   0.2  (2009-03-11) Fix unsigned/signed char warnings\n//   0.1  (2009-03-09) First public release\n//\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","// stb_rect_pack.h - v1.01 - public domain - rectangle packing\n// Sean Barrett 2014\n//\n// Useful for e.g. packing rectangular textures into an atlas.\n// Does not do rotation.\n//\n// Before #including,\n//\n//    #define STB_RECT_PACK_IMPLEMENTATION\n//\n// in the file that you want to have the implementation.\n//\n// Not necessarily the awesomest packing method, but better than\n// the totally naive one in stb_truetype (which is primarily what\n// this is meant to replace).\n//\n// Has only had a few tests run, may have issues.\n//\n// More docs to come.\n//\n// No memory allocations; uses qsort() and assert() from stdlib.\n// Can override those by defining STBRP_SORT and STBRP_ASSERT.\n//\n// This library currently uses the Skyline Bottom-Left algorithm.\n//\n// Please note: better rectangle packers are welcome! Please\n// implement them to the same API, but with a different init\n// function.\n//\n// Credits\n//\n//  Library\n//    Sean Barrett\n//  Minor features\n//    Martins Mozeiko\n//    github:IntellectualKitty\n//\n//  Bugfixes / warning fixes\n//    Jeremy Jaussaud\n//    Fabian Giesen\n//\n// Version history:\n//\n//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section\n//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles\n//     0.99  (2019-02-07)  warning fixes\n//     0.11  (2017-03-03)  return packing success/fail result\n//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings\n//     0.09  (2016-08-27)  fix compiler warnings\n//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)\n//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)\n//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort\n//     0.05:  added STBRP_ASSERT to allow replacing assert\n//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support\n//     0.01:  initial release\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//       INCLUDE SECTION\n//\n\n#ifndef STB_INCLUDE_STB_RECT_PACK_H\n#define STB_INCLUDE_STB_RECT_PACK_H\n\n#define STB_RECT_PACK_VERSION  1\n\n#ifdef STBRP_STATIC\n#define STBRP_DEF static\n#else\n#define STBRP_DEF extern\n#endif\n\ntypedef struct stbrp_context stbrp_context;\ntypedef struct stbrp_node    stbrp_node;\ntypedef struct stbrp_rect    stbrp_rect;\n\ntypedef int            stbrp_coord;\n\n#define STBRP__MAXVAL  0x7fffffff\n// Mostly for internal use, but this is the maximum supported coordinate value.\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context* context, stbrp_rect* rects, int num_rects);\n// Assign packed locations to rectangles. The rectangles are of type\n// 'stbrp_rect' defined below, stored in the array 'rects', and there\n// are 'num_rects' many of them.\n//\n// Rectangles which are successfully packed have the 'was_packed' flag\n// set to a non-zero value and 'x' and 'y' store the minimum location\n// on each axis (i.e. bottom-left in cartesian coordinates, top-left\n// if you imagine y increasing downwards). Rectangles which do not fit\n// have the 'was_packed' flag set to 0.\n//\n// You should not try to access the 'rects' array from another thread\n// while this function is running, as the function temporarily reorders\n// the array while it executes.\n//\n// To pack into another rectangle, you need to call stbrp_init_target\n// again. To continue packing into the same rectangle, you can call\n// this function again. Calling this multiple times with multiple rect\n// arrays will probably produce worse packing results than calling it\n// a single time with the full rectangle array, but the option is\n// available.\n//\n// The function returns 1 if all of the rectangles were successfully\n// packed and 0 otherwise.\n\nstruct stbrp_rect\n{\n    // reserved for your use:\n    int            id;\n\n    // input:\n    stbrp_coord    w, h;\n\n    // output:\n    stbrp_coord    x, y;\n    int            was_packed;  // non-zero if valid packing\n\n}; // 16 bytes, nominally\n\n\nSTBRP_DEF void stbrp_init_target(stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes);\n// Initialize a rectangle packer to:\n//    pack a rectangle that is 'width' by 'height' in dimensions\n//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long\n//\n// You must call this function every time you start packing into a new target.\n//\n// There is no \"shutdown\" function. The 'nodes' memory must stay valid for\n// the following stbrp_pack_rects() call (or calls), but can be freed after\n// the call (or calls) finish.\n//\n// Note: to guarantee best results, either:\n//       1. make sure 'num_nodes' >= 'width'\n//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'\n//\n// If you don't do either of the above things, widths will be quantized to multiples\n// of small integers to guarantee the algorithm doesn't run out of temporary storage.\n//\n// If you do #2, then the non-quantized algorithm will be used, but the algorithm\n// may run out of temporary storage and be unable to pack some rectangles.\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context* context, int allow_out_of_mem);\n// Optionally call this function after init but before doing any packing to\n// change the handling of the out-of-temp-memory scenario, described above.\n// If you call init again, this will be reset to the default (false).\n\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context* context, int heuristic);\n// Optionally select which packing heuristic the library should use. Different\n// heuristics will produce better/worse results for different data sets.\n// If you call init again, this will be reset to the default.\n\nenum\n{\n    STBRP_HEURISTIC_Skyline_default = 0,\n    STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,\n    STBRP_HEURISTIC_Skyline_BF_sortHeight\n};\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// the details of the following structures don't matter to you, but they must\n// be visible so you can handle the memory allocations for them\n\nstruct stbrp_node\n{\n    stbrp_coord  x, y;\n    stbrp_node* next;\n};\n\nstruct stbrp_context\n{\n    int width;\n    int height;\n    int align;\n    int init_mode;\n    int heuristic;\n    int num_nodes;\n    stbrp_node* active_head;\n    stbrp_node* free_head;\n    stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'\n};\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//     IMPLEMENTATION SECTION\n//\n\n#ifdef STB_RECT_PACK_IMPLEMENTATION\n#ifndef STBRP_SORT\n#include <stdlib.h>\n#define STBRP_SORT qsort\n#endif\n\n#ifndef STBRP_ASSERT\n#include <assert.h>\n#define STBRP_ASSERT assert\n#endif\n\n#ifdef _MSC_VER\n#define STBRP__NOTUSED(v)  (void)(v)\n#define STBRP__CDECL       __cdecl\n#else\n#define STBRP__NOTUSED(v)  (void)sizeof(v)\n#define STBRP__CDECL\n#endif\n\nenum\n{\n    STBRP__INIT_skyline = 1\n};\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context* context, int heuristic)\n{\n    switch (context->init_mode) {\n    case STBRP__INIT_skyline:\n        STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);\n        context->heuristic = heuristic;\n        break;\n    default:\n        STBRP_ASSERT(0);\n    }\n}\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context* context, int allow_out_of_mem)\n{\n    if (allow_out_of_mem)\n        // if it's ok to run out of memory, then don't bother aligning them;\n        // this gives better packing, but may fail due to OOM (even though\n        // the rectangles easily fit).  a smarter approach would be to only\n        // quantize once we've hit OOM, then we could get rid of this parameter.\n        context->align = 1;\n    else {\n        // if it's not ok to run out of memory, then quantize the widths\n        // so that num_nodes is always enough nodes.\n        //\n        // I.e. num_nodes * align >= width\n        //                  align >= width / num_nodes\n        //                  align = ceil(width/num_nodes)\n\n        context->align = (context->width + context->num_nodes - 1) / context->num_nodes;\n    }\n}\n\nSTBRP_DEF void stbrp_init_target(stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes)\n{\n    int i;\n\n    for (i = 0; i < num_nodes - 1; ++i)\n        nodes[i].next = &nodes[i + 1];\n    nodes[i].next = 0;\n    context->init_mode = STBRP__INIT_skyline;\n    context->heuristic = STBRP_HEURISTIC_Skyline_default;\n    context->free_head = &nodes[0];\n    context->active_head = &context->extra[0];\n    context->width = width;\n    context->height = height;\n    context->num_nodes = num_nodes;\n    stbrp_setup_allow_out_of_mem(context, 0);\n\n    // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)\n    context->extra[0].x = 0;\n    context->extra[0].y = 0;\n    context->extra[0].next = &context->extra[1];\n    context->extra[1].x = (stbrp_coord)width;\n    context->extra[1].y = (1 << 30);\n    context->extra[1].next = 0;\n}\n\n// find minimum y position if it starts at x1\nstatic int stbrp__skyline_find_min_y(stbrp_context* c, stbrp_node* first, int x0, int width, int* pwaste)\n{\n    stbrp_node* node = first;\n    int x1 = x0 + width;\n    int min_y, visited_width, waste_area;\n\n    STBRP__NOTUSED(c);\n\n    STBRP_ASSERT(first->x <= x0);\n\n#if 0\n    // skip in case we're past the node\n    while (node->next->x <= x0)\n        ++node;\n#else\n    STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency\n#endif\n\n    STBRP_ASSERT(node->x <= x0);\n\n    min_y = 0;\n    waste_area = 0;\n    visited_width = 0;\n    while (node->x < x1) {\n        if (node->y > min_y) {\n            // raise min_y higher.\n            // we've accounted for all waste up to min_y,\n            // but we'll now add more waste for everything we've visted\n            waste_area += visited_width * (node->y - min_y);\n            min_y = node->y;\n            // the first time through, visited_width might be reduced\n            if (node->x < x0)\n                visited_width += node->next->x - x0;\n            else\n                visited_width += node->next->x - node->x;\n        }\n        else {\n            // add waste area\n            int under_width = node->next->x - node->x;\n            if (under_width + visited_width > width)\n                under_width = width - visited_width;\n            waste_area += under_width * (min_y - node->y);\n            visited_width += under_width;\n        }\n        node = node->next;\n    }\n\n    *pwaste = waste_area;\n    return min_y;\n}\n\ntypedef struct\n{\n    int x, y;\n    stbrp_node** prev_link;\n} stbrp__findresult;\n\nstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context* c, int width, int height)\n{\n    int best_waste = (1 << 30), best_x, best_y = (1 << 30);\n    stbrp__findresult fr;\n    stbrp_node** prev, * node, * tail, ** best = 0;\n\n    // align to multiple of c->align\n    width = (width + c->align - 1);\n    width -= width % c->align;\n    STBRP_ASSERT(width % c->align == 0);\n\n    // if it can't possibly fit, bail immediately\n    if (width > c->width || height > c->height) {\n        fr.prev_link = 0;\n        fr.x = fr.y = 0;\n        return fr;\n    }\n\n    node = c->active_head;\n    prev = &c->active_head;\n    while (node->x + width <= c->width) {\n        int y, waste;\n        y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);\n        if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL\n            // bottom left\n            if (y < best_y) {\n                best_y = y;\n                best = prev;\n            }\n        }\n        else {\n            // best-fit\n            if (y + height <= c->height) {\n                // can only use it if it first vertically\n                if (y < best_y || (y == best_y && waste < best_waste)) {\n                    best_y = y;\n                    best_waste = waste;\n                    best = prev;\n                }\n            }\n        }\n        prev = &node->next;\n        node = node->next;\n    }\n\n    best_x = (best == 0) ? 0 : (*best)->x;\n\n    // if doing best-fit (BF), we also have to try aligning right edge to each node position\n    //\n    // e.g, if fitting\n    //\n    //     ____________________\n    //    |____________________|\n    //\n    //            into\n    //\n    //   |                         |\n    //   |             ____________|\n    //   |____________|\n    //\n    // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned\n    //\n    // This makes BF take about 2x the time\n\n    if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {\n        tail = c->active_head;\n        node = c->active_head;\n        prev = &c->active_head;\n        // find first node that's admissible\n        while (tail->x < width)\n            tail = tail->next;\n        while (tail) {\n            int xpos = tail->x - width;\n            int y, waste;\n            STBRP_ASSERT(xpos >= 0);\n            // find the left position that matches this\n            while (node->next->x <= xpos) {\n                prev = &node->next;\n                node = node->next;\n            }\n            STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);\n            y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);\n            if (y + height <= c->height) {\n                if (y <= best_y) {\n                    if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {\n                        best_x = xpos;\n                        STBRP_ASSERT(y <= best_y);\n                        best_y = y;\n                        best_waste = waste;\n                        best = prev;\n                    }\n                }\n            }\n            tail = tail->next;\n        }\n    }\n\n    fr.prev_link = best;\n    fr.x = best_x;\n    fr.y = best_y;\n    return fr;\n}\n\nstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context* context, int width, int height)\n{\n    // find best position according to heuristic\n    stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);\n    stbrp_node* node, * cur;\n\n    // bail if:\n    //    1. it failed\n    //    2. the best node doesn't fit (we don't always check this)\n    //    3. we're out of memory\n    if (res.prev_link == 0 || res.y + height > context->height || context->free_head == 0) {\n        res.prev_link = 0;\n        return res;\n    }\n\n    // on success, create new node\n    node = context->free_head;\n    node->x = (stbrp_coord)res.x;\n    node->y = (stbrp_coord)(res.y + height);\n\n    context->free_head = node->next;\n\n    // insert the new node into the right starting point, and\n    // let 'cur' point to the remaining nodes needing to be\n    // stiched back in\n\n    cur = *res.prev_link;\n    if (cur->x < res.x) {\n        // preserve the existing one, so start testing with the next one\n        stbrp_node* next = cur->next;\n        cur->next = node;\n        cur = next;\n    }\n    else {\n        *res.prev_link = node;\n    }\n\n    // from here, traverse cur and free the nodes, until we get to one\n    // that shouldn't be freed\n    while (cur->next && cur->next->x <= res.x + width) {\n        stbrp_node* next = cur->next;\n        // move the current node to the free list\n        cur->next = context->free_head;\n        context->free_head = cur;\n        cur = next;\n    }\n\n    // stitch the list back in\n    node->next = cur;\n\n    if (cur->x < res.x + width)\n        cur->x = (stbrp_coord)(res.x + width);\n\n#ifdef _DEBUG\n    cur = context->active_head;\n    while (cur->x < context->width) {\n        STBRP_ASSERT(cur->x < cur->next->x);\n        cur = cur->next;\n    }\n    STBRP_ASSERT(cur->next == 0);\n\n    {\n        int count = 0;\n        cur = context->active_head;\n        while (cur) {\n            cur = cur->next;\n            ++count;\n        }\n        cur = context->free_head;\n        while (cur) {\n            cur = cur->next;\n            ++count;\n        }\n        STBRP_ASSERT(count == context->num_nodes + 2);\n    }\n#endif\n\n    return res;\n}\n\nstatic int STBRP__CDECL rect_height_compare(const void* a, const void* b)\n{\n    const stbrp_rect* p = (const stbrp_rect*)a;\n    const stbrp_rect* q = (const stbrp_rect*)b;\n    if (p->h > q->h)\n        return -1;\n    if (p->h < q->h)\n        return  1;\n    return (p->w > q->w) ? -1 : (p->w < q->w);\n}\n\nstatic int STBRP__CDECL rect_original_order(const void* a, const void* b)\n{\n    const stbrp_rect* p = (const stbrp_rect*)a;\n    const stbrp_rect* q = (const stbrp_rect*)b;\n    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);\n}\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context* context, stbrp_rect* rects, int num_rects)\n{\n    int i, all_rects_packed = 1;\n\n    // we use the 'was_packed' field internally to allow sorting/unsorting\n    for (i = 0; i < num_rects; ++i) {\n        rects[i].was_packed = i;\n    }\n\n    // sort according to heuristic\n    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);\n\n    for (i = 0; i < num_rects; ++i) {\n        if (rects[i].w == 0 || rects[i].h == 0) {\n            rects[i].x = rects[i].y = 0;  // empty rect needs no space\n        }\n        else {\n            stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);\n            if (fr.prev_link) {\n                rects[i].x = (stbrp_coord)fr.x;\n                rects[i].y = (stbrp_coord)fr.y;\n            }\n            else {\n                rects[i].x = rects[i].y = STBRP__MAXVAL;\n            }\n        }\n    }\n\n    // unsort\n    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);\n\n    // set was_packed flags and all_rects_packed status\n    for (i = 0; i < num_rects; ++i) {\n        rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);\n        if (!rects[i].was_packed)\n            all_rects_packed = 0;\n    }\n\n    // return the all_rects_packed status\n    return all_rects_packed;\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#ifndef _H_MATH_\n#define _H_MATH_\n\n#ifdef __cplusplus\n#define c_func extern \"C\"\n#else\n#define c_func \n#endif\n\n\n#define MathPI 3.14159265358979323846f\n\nc_func float  MathRound(float x);\nc_func float  MathCeil(float x);\nc_func float  MathFloor(float x);\nc_func float  MathSin(float x);\nc_func float  MathCos(float x);\nc_func float  MathACos(float x);\nc_func float  MathTan(float x);\nc_func float  MathSqrt(float x);\nc_func float  MathExp(float x);\nc_func float  MathLog(float x);\nc_func float  MathPow(float x, float y);\nc_func double MathLdexp(double x, int exp);\nc_func float  MathRandom();\n\ninline float MathRadToDeg(float rad) {\n    return rad * 57.2958f;\n}\n\ninline float MathDegToRad(float deg) {\n    return deg * 0.0174533f;\n}\n\ninline float MathTrunc(float d) { \n    if (d > 0) { // Floor\n        return MathFloor(d);\n    }\n    // else { // Ceil\n    return MathCeil(d);\n}\n\ninline float MathFmod(float x, float y) {\n  return x - MathTrunc(x / y) * y;\n}\n\ninline float MathAbsF(float f) {\n    if (f < 0.0f) {\n        return -f;\n    }\n    return f;\n}\n\ninline int MathAbsI(int f) {\n    if (f < 0) {\n        return -f;\n    }\n    return f;\n}\n\ninline float MathMaxF(float a, float b) {\n    if (b > a) {\n        return b;\n    }\n    return a;\n}\n\ninline float MathMinF(float a, float b) {\n    if (b < a) {\n        return b;\n    }\n    return a;\n}\n\ninline char MathIsSpace(unsigned char c) {\n\tif (c == (unsigned char)(' ') ||\n\t\tc == (unsigned char)('\\f') ||\n\t\tc == (unsigned char)('\\n') ||\n\t\tc == (unsigned char)('\\r') ||\n\t\tc == (unsigned char)('\\t') ||\n\t\tc == (unsigned char)('\\v'))\n\t\treturn 1;\n\treturn 0;\n}\n\ninline long MathAToI(const char* s) {\n\tlong rv = 0;\n\tchar sign = 0;\n\n\t/* skip till we find either a digit or '+' or '-' */\n\twhile (*s) {\n\t\tif (*s <= '9' && *s >= '0')\n\t\t\tbreak;\n\t\tif (*s == '-' || *s == '+')\n\t\t\tbreak;\n\t\ts++;\n\t}\n\n\tsign = (*s == '-');\n\tif (*s == '-' || *s == '+') s++;\n\n\twhile (*s && *s >= '0' && *s <= '9') {\n\t\trv = (rv * 10) + (*s - '0');\n\t\ts++;\n\t}\n\n\treturn (sign ? -rv : rv);\n}\n\n// atof: https://github.com/darconeous/sdcc/blob/master/device/lib/pic16/libc/stdlib/atof.c\ninline float MathAToF(const char* s) {\n\tfloat value, fraction;\n\tchar iexp;\n\tchar sign;\n\n\t//Skip leading blanks\n\twhile (MathIsSpace(*s)) s++;\n\n\t//Get the sign\n\tif (*s == '-')\n\t{\n\t\tsign = 1;\n\t\ts++;\n\t}\n\telse\n\t{\n\t\tsign = 0;\n\t\tif (*s == '+') s++;\n\t}\n\n\t//Get the integer part\n\tfor (value = 0.0; (unsigned char)(*s) >= '0' && (unsigned char)(*s) <= '9'; s++)\n\t{\n\t\tvalue = 10.0 * value + (*s - '0');\n\t}\n\n\t//Get the fraction\n\tif (*s == '.')\n\t{\n\t\ts++;\n\t\tfor (fraction = 0.1; (unsigned char)(*s) >= '0' && (unsigned char)(*s) <= '9'; s++)\n\t\t{\n\t\t\tvalue += (*s - '0') * fraction;\n\t\t\tfraction *= 0.1;\n\t\t}\n\t}\n\n\t//Finally, the exponent (not very efficient, but enough for now*/\n\tif (*s == 'E' || *s == 'e')\n\t{\n\t\ts++;\n\t\tiexp = (char)MathAToI(s);\n\t\t{\n\t\t\twhile (iexp != 0)\n\t\t\t{\n\t\t\t\tif (iexp < 0)\n\t\t\t\t{\n\t\t\t\t\tvalue *= 0.1;\n\t\t\t\t\tiexp++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvalue *= 10.0;\n\t\t\t\t\tiexp--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sign) value *= -1.0;\n\treturn (value);\n}\n\n#endif","#ifndef _H_VEC2_\n#define _H_VEC2_\n\n#define VEC2_EPSILON 0.000001f\n\ntemplate<typename T>\nstruct TVec2 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t};\n\t\tT v[2];\n\t};\n\tinline TVec2() : x(T(0)), y(T(0)) { }\n\tinline TVec2(T _x, T _y) :\n\t\tx(_x), y(_y) { }\n\tinline TVec2(T* fv) :\n\t\tx(fv[0]), y(fv[1]) { }\n};\n\ntypedef TVec2<float> vec2;\ntypedef TVec2<int> ivec2;\ntypedef TVec2<unsigned int> uivec2;\n\nvec2 operator-(const vec2& l, const vec2& r);\nvec2 operator+(const vec2& l, const vec2& r);\nvec2 operator*(const vec2& l, const vec2& r);\nvec2 operator/(const vec2& l, const vec2& r);\nvec2 operator/(const vec2& l, float f);\nvec2 operator*(const vec2& l, float f);\n\nvoid normalize(vec2& v);\nvec2 normalized(const vec2& v);\nfloat dot(const vec2& l, const vec2& r);\nfloat lenSq(const vec2& v);\nfloat len(const vec2& v);\nvec2 abs(const vec2& v);\n\n#endif","#include \"vec2.h\"\n#include \"../platform/math.h\"\n\nvec2 operator-(const vec2& l, const vec2& r) {\n\treturn vec2(l.x - r.x, l.y - r.y);\n}\n\nvec2 operator+(const vec2& l, const vec2& r) {\n\treturn vec2(l.x + r.x, l.y + r.y);\n}\n\nvec2 operator*(const vec2& l, const vec2& r) {\n\treturn vec2(l.x * r.x, l.y * r.y);\n}\n\nvec2 operator/(const vec2& l, float r) {\n\treturn vec2(l.x / r, l.y / r);\n}\n\nvec2 operator/(const vec2& l, const vec2& r) {\n\treturn vec2(l.x / r.x, l.y / r.y);\n}\n\nvec2 operator*(const vec2& l, float f) {\n\treturn vec2(l.x * f, l.y * f);\n}\n\nvoid normalize(vec2& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y;\n\tif (lenSq < VEC2_EPSILON) {\n\t\treturn;\n\t}\n\tfloat invLen = 1.0f / MathSqrt(lenSq);\n\n\tv.x *= invLen;\n\tv.y *= invLen;\n}\n\nvec2 normalized(const vec2& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y;\n\tif (lenSq < VEC2_EPSILON) {\n\t\treturn v;\n\t}\n\tfloat invLen = 1.0f / MathSqrt(lenSq);\n\n\treturn vec2(\n\t\tv.x * invLen,\n\t\tv.y * invLen\n\t);\n}\n\nfloat dot(const vec2& l, const vec2& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\nfloat lenSq(const vec2& v) {\n\treturn v.x * v.x + v.y * v.y ;\n}\n\nfloat len(const vec2& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y;\n\tif (lenSq < VEC2_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\treturn MathSqrt(lenSq);\n}\n\nvec2 abs(const vec2& v) {\n\tvec2 result = v;\n\tif (v.x < 0.0f) {\n\t\tresult.x = -v.x;\n\t}\n\tif (v.y < 0.0f) {\n\t\tresult.y = -v.y;\n\t}\n\treturn result;\n}","#ifndef _H_DRAW2D_\n#define _H_DRAW2D_\n\n#include \"vec2.h\"\n#include \"vec3.h\"\n#include \"vec4.h\"\n\n#include \"../platform/memory.h\"\n\nnamespace Draw2D {\n    ////////////////////////////////////////////////////////////////\n    // Core API\n    ////////////////////////////////////////////////////////////////\n\n    enum class Interpolation {\n        Linear = 0,\n        Step = 1\n    };\n\n    struct Size {\n        float w;\n        float h;\n\n        inline Size(float _w = 0.0f, float _h = 0.0f) :\n            w(_w), h(_h) { }\n    };\n\n    struct Rect {\n        float x;\n        float y;\n        float w;\n        float h;\n\n        inline Rect(float _x = 0.0f, float _y = 0.0f, float _w = 0.0f, float _h = 0.0f) :\n            x(_x), y(_y), w(_w), h(_h) { }\n    };\n\n    void Initialize(); \n    void Shutdown();\n\n    void Begin(u32 designWidth, u32 designHeight, f32 designScale, u32 screenWidth, u32 screenHeight);\n    void End(); \n\n    void EnableAlphaBlending();\n    void DisableAlphaBlending();\n\n    void PushClip(f32 x, f32 y, f32 w, f32 h);\n    void PopClip();\n\n    u32 LoadFont(void* memory, u32 bytes, bool autoCleanup = false); // If own is true, DestroyFont will call MemRelease on the memory pointer passed here\n    void DestroyFont(u32 font);\n\n    u32 LoadImage(void* memory, u32 bytes, Interpolation interp); // NOTE: maybe interpolation should be \"bool useNearest\"\n    void DestroyImage(u32 image); \n\n    void DrawString(u32 font, u32 pixelHeight, f32 x, f32 y, const char* string, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    void DrawCodePoint(u32 font, u32 pixelHeight, f32 x, f32 y, unsigned char codePoint, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    int FindStringIndex(u32 font, u32 pixelHeight, const char* string, const vec2& relativePoint);\n    Size MeasureString(u32 font, u32 pixelHeight, const char* string);\n    Rect MeasureSubString(u32 font, u32 pixelHeight, const char* string, u32 startIndex, u32 len);\n    void DrawImage(u32 image, f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 sourceX, f32 sourceY, f32 sourceW, f32 shourceH, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotationRadians = 0.0f, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    void DrawLine(f32* points, u32 numPoints, f32 thickness = 1.0f, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    void DrawRect   (f32 x, f32 y, f32 w, f32 h, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotationRadians = 0.0f);\n    void DrawEllipse(f32 x, f32 y, f32 radiusX, f32 radiusY, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotationRadians = 0.0f);\n};\n\n#endif","// stb_sprintf - v1.10 - public domain snprintf() implementation\n// originally by Jeff Roberts / RAD Game Tools, 2015/10/20\n// http://github.com/nothings/stb\n//\n// allowed types:  sc uidBboXx p AaGgEef n\n// lengths      :  hh h ll j z t I64 I32 I\n//\n// Contributors:\n//    Fabian \"ryg\" Giesen (reformatting)\n//    github:aganm (attribute format)\n//\n// Contributors (bugfixes):\n//    github:d26435\n//    github:trex78\n//    github:account-login\n//    Jari Komppa (SI suffixes)\n//    Rohit Nirmal\n//    Marcin Wojdyr\n//    Leonard Ritter\n//    Stefano Zanotti\n//    Adam Allison\n//    Arvid Gerstmann\n//    Markus Kolb\n//\n// LICENSE:\n//\n//   See end of file for license information.\n\n#ifndef STB_SPRINTF_H_INCLUDE\n#define STB_SPRINTF_H_INCLUDE\n\n#include \"../platform/memory.h\"\n#if MEM_PLATFORM_WASM\n#include \"../platform/compiler/clang_stdarg.h\"\n#endif\n\n/*\nSingle file sprintf replacement.\n\nOriginally written by Jeff Roberts at RAD Game Tools - 2015/10/20.\nHereby placed in public domain.\n\nThis is a full sprintf replacement that supports everything that\nthe C runtime sprintfs support, including float/double, 64-bit integers,\nhex floats, field parameters (%*.*d stuff), length reads backs, etc.\n\nWhy would you need this if sprintf already exists?  Well, first off,\nit's *much* faster (see below). It's also much smaller than the CRT\nversions code-space-wise. We've also added some simple improvements\nthat are super handy (commas in thousands, callbacks at buffer full,\nfor example). Finally, the format strings for MSVC and GCC differ\nfor 64-bit integers (among other small things), so this lets you use\nthe same format strings in cross platform code.\n\nIt uses the standard single file trick of being both the header file\nand the source itself. If you just include it normally, you just get\nthe header file function definitions. To get the code, you include\nit from a C or C++ file and define STB_SPRINTF_IMPLEMENTATION first.\n\nIt only uses va_args macros from the C runtime to do it's work. It\ndoes cast doubles to S64s and shifts and divides U64s, which does\ndrag in CRT code on most platforms.\n\nIt compiles to roughly 8K with float support, and 4K without.\nAs a comparison, when using MSVC static libs, calling sprintf drags\nin 16K.\n\nAPI:\n====\nint stbsp_sprintf( char * buf, char const * fmt, ... )\nint stbsp_snprintf( char * buf, int count, char const * fmt, ... )\n  Convert an arg list into a buffer.  stbsp_snprintf always returns\n  a zero-terminated string (unlike regular snprintf).\n\nint stbsp_vsprintf( char * buf, char const * fmt, va_list va )\nint stbsp_vsnprintf( char * buf, int count, char const * fmt, va_list va )\n  Convert a va_list arg list into a buffer.  stbsp_vsnprintf always returns\n  a zero-terminated string (unlike regular snprintf).\n\nint stbsp_vsprintfcb( STBSP_SPRINTFCB * callback, void * user, char * buf, char const * fmt, va_list va )\n    typedef char * STBSP_SPRINTFCB( char const * buf, void * user, int len );\n  Convert into a buffer, calling back every STB_SPRINTF_MIN chars.\n  Your callback can then copy the chars out, print them or whatever.\n  This function is actually the workhorse for everything else.\n  The buffer you pass in must hold at least STB_SPRINTF_MIN characters.\n    // you return the next buffer to use or 0 to stop converting\n\nvoid stbsp_set_separators( char comma, char period )\n  Set the comma and period characters to use.\n\nFLOATS/DOUBLES:\n===============\nThis code uses a internal float->ascii conversion method that uses\ndoubles with error correction (double-doubles, for ~105 bits of\nprecision).  This conversion is round-trip perfect - that is, an atof\nof the values output here will give you the bit-exact double back.\n\nOne difference is that our insignificant digits will be different than\nwith MSVC or GCC (but they don't match each other either).  We also\ndon't attempt to find the minimum length matching float (pre-MSVC15\ndoesn't either).\n\nIf you don't need float or doubles at all, define STB_SPRINTF_NOFLOAT\nand you'll save 4K of code space.\n\n64-BIT INTS:\n============\nThis library also supports 64-bit integers and you can use MSVC style or\nGCC style indicators (%I64d or %lld).  It supports the C99 specifiers\nfor u32 and ptr_diff_t (%jd %zd) as well.\n\nEXTRAS:\n=======\nLike some GCCs, for integers and floats, you can use a ' (single quote)\nspecifier and commas will be inserted on the thousands: \"%'d\" on 12345\nwould print 12,345.\n\nFor integers and floats, you can use a \"$\" specifier and the number\nwill be converted to float and then divided to get kilo, mega, giga or\ntera and then printed, so \"%$d\" 1000 is \"1.0 k\", \"%$.2d\" 2536000 is\n\"2.53 M\", etc. For byte values, use two $:s, like \"%$$d\" to turn\n2536000 to \"2.42 Mi\". If you prefer JEDEC suffixes to SI ones, use three\n$:s: \"%$$$d\" -> \"2.42 M\". To remove the space between the number and the\nsuffix, add \"_\" specifier: \"%_$d\" -> \"2.53M\".\n\nIn addition to octal and hexadecimal conversions, you can print\nintegers in binary: \"%b\" for 256 would print 100.\n\nPERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):\n===================================================================\n\"%d\" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)\n\"%24d\" across all 32-bit ints (4.5x/4.2x faster)\n\"%x\" across all 32-bit ints (4.5x/3.8x faster)\n\"%08x\" across all 32-bit ints (4.3x/3.8x faster)\n\"%f\" across e-10 to e+10 floats (7.3x/6.0x faster)\n\"%e\" across e-10 to e+10 floats (8.1x/6.0x faster)\n\"%g\" across e-10 to e+10 floats (10.0x/7.1x faster)\n\"%f\" for values near e-300 (7.9x/6.5x faster)\n\"%f\" for values near e+300 (10.0x/9.1x faster)\n\"%e\" for values near e-300 (10.1x/7.0x faster)\n\"%e\" for values near e+300 (9.2x/6.0x faster)\n\"%.320f\" for values near e-300 (12.6x/11.2x faster)\n\"%a\" for random values (8.6x/4.3x faster)\n\"%I64d\" for 64-bits with 32-bit values (4.8x/3.4x faster)\n\"%I64d\" for 64-bits > 32-bit values (4.9x/5.5x faster)\n\"%s%s%s\" for 64 char strings (7.1x/7.3x faster)\n\"...512 char string...\" ( 35.0x/32.5x faster!)\n*/\n\n#if defined(__clang__)\n #if defined(__has_feature) && defined(__has_attribute)\n  #if __has_feature(address_sanitizer)\n   #if __has_attribute(__no_sanitize__)\n    #define STBSP__ASAN __attribute__((__no_sanitize__(\"address\")))\n   #elif __has_attribute(__no_sanitize_address__)\n    #define STBSP__ASAN __attribute__((__no_sanitize_address__))\n   #elif __has_attribute(__no_address_safety_analysis__)\n    #define STBSP__ASAN __attribute__((__no_address_safety_analysis__))\n   #endif\n  #endif\n #endif\n#elif defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))\n #if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__\n  #define STBSP__ASAN __attribute__((__no_sanitize_address__))\n #endif\n#endif\n\n#ifndef STBSP__ASAN\n#define STBSP__ASAN\n#endif\n\n#ifdef STB_SPRINTF_STATIC\n#define STBSP__PUBLICDEC static\n#define STBSP__PUBLICDEF static STBSP__ASAN\n#else\n#ifdef __cplusplus\n#define STBSP__PUBLICDEC extern \"C\"\n#define STBSP__PUBLICDEF extern \"C\" STBSP__ASAN\n#else\n#define STBSP__PUBLICDEC extern\n#define STBSP__PUBLICDEF STBSP__ASAN\n#endif\n#endif\n\n#if defined(__has_attribute)\n #if __has_attribute(format)\n   #define STBSP__ATTRIBUTE_FORMAT(fmt,va) __attribute__((format(printf,fmt,va)))\n #endif\n#endif\n\n#ifndef STBSP__ATTRIBUTE_FORMAT\n#define STBSP__ATTRIBUTE_FORMAT(fmt,va)\n#endif\n\n#ifdef _MSC_VER\n#define STBSP__NOTUSED(v)  (void)(v)\n#else\n#define STBSP__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#if MEM_PLATFORM_WINDOWS\n#include <stdarg.h> // for va_arg(), va_list()\n#endif\n\n#ifndef STB_SPRINTF_MIN\n#define STB_SPRINTF_MIN 512 // how many characters per callback\n#endif\ntypedef char *STBSP_SPRINTFCB(const char *buf, void *user, int len);\n\n#ifndef STB_SPRINTF_DECORATE\n#define STB_SPRINTF_DECORATE(name) stbsp_##name // define this before including if you want to change the names\n#endif\n\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, int count, char const *fmt, va_list va);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(2,3);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(3,4);\n\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);\nSTBSP__PUBLICDEC void STB_SPRINTF_DECORATE(set_separators)(char comma, char period);\n\n#endif // STB_SPRINTF_H_INCLUDE\n\n#ifdef STB_SPRINTF_IMPLEMENTATION\n\n#define stbsp__uint32 unsigned int\n#define stbsp__int32 signed int\n\n#ifdef _MSC_VER\n#define stbsp__uint64 unsigned __int64\n#define stbsp__int64 signed __int64\n#else\n#define stbsp__uint64 unsigned long long\n#define stbsp__int64 signed long long\n#endif\n#define stbsp__uint16 unsigned short\n\n#ifndef stbsp__uintptr\n#if defined(__ppc64__) || defined(__powerpc64__) || defined(__aarch64__) || defined(_M_X64) || defined(__x86_64__) || defined(__x86_64) || defined(__s390x__)\n#define stbsp__uintptr stbsp__uint64\n#else\n#define stbsp__uintptr stbsp__uint32\n#endif\n#endif\n\n#ifndef STB_SPRINTF_MSVC_MODE // used for MSVC2013 and earlier (MSVC2015 matches GCC)\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define STB_SPRINTF_MSVC_MODE\n#endif\n#endif\n\n#ifdef STB_SPRINTF_NOUNALIGNED // define this before inclusion to force stbsp_sprintf to always use aligned accesses\n#define STBSP__UNALIGNED(code)\n#else\n#define STBSP__UNALIGNED(code) code\n#endif\n\n#ifndef STB_SPRINTF_NOFLOAT\n// internal float utility functions\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits);\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value);\n#define STBSP__SPECIAL 0x7000\n#endif\n\nstatic char stbsp__period = '.';\nstatic char stbsp__comma = ',';\nstatic struct\n{\n   short temp; // force next field to be 2-byte aligned\n   char pair[201];\n} stbsp__digitpair =\n{\n  0,\n   \"00010203040506070809101112131415161718192021222324\"\n   \"25262728293031323334353637383940414243444546474849\"\n   \"50515253545556575859606162636465666768697071727374\"\n   \"75767778798081828384858687888990919293949596979899\"\n};\n\nSTBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char pcomma, char pperiod)\n{\n   stbsp__period = pperiod;\n   stbsp__comma = pcomma;\n}\n\n#define STBSP__LEFTJUST 1\n#define STBSP__LEADINGPLUS 2\n#define STBSP__LEADINGSPACE 4\n#define STBSP__LEADING_0X 8\n#define STBSP__LEADINGZERO 16\n#define STBSP__INTMAX 32\n#define STBSP__TRIPLET_COMMA 64\n#define STBSP__NEGATIVE 128\n#define STBSP__METRIC_SUFFIX 256\n#define STBSP__HALFWIDTH 512\n#define STBSP__METRIC_NOSPACE 1024\n#define STBSP__METRIC_1024 2048\n#define STBSP__METRIC_JEDEC 4096\n\nstatic void stbsp__lead_sign(stbsp__uint32 fl, char *sign)\n{\n   sign[0] = 0;\n   if (fl & STBSP__NEGATIVE) {\n      sign[0] = 1;\n      sign[1] = '-';\n   } else if (fl & STBSP__LEADINGSPACE) {\n      sign[0] = 1;\n      sign[1] = ' ';\n   } else if (fl & STBSP__LEADINGPLUS) {\n      sign[0] = 1;\n      sign[1] = '+';\n   }\n}\n\nstatic STBSP__ASAN stbsp__uint32 stbsp__strlen_limited(char const *s, stbsp__uint32 limit)\n{\n   char const * sn = s;\n\n   // get up to 4-byte alignment\n   for (;;) {\n      if (((stbsp__uintptr)sn & 3) == 0)\n         break;\n\n      if (!limit || *sn == 0)\n         return (stbsp__uint32)(sn - s);\n\n      ++sn;\n      --limit;\n   }\n\n   // scan over 4 bytes at a time to find terminating 0\n   // this will intentionally scan up to 3 bytes past the end of buffers,\n   // but becase it works 4B aligned, it will never cross page boundaries\n   // (hence the STBSP__ASAN markup; the over-read here is intentional\n   // and harmless)\n   while (limit >= 4) {\n      stbsp__uint32 v = *(stbsp__uint32 *)sn;\n      // bit hack to find if there's a 0 byte in there\n      if ((v - 0x01010101) & (~v) & 0x80808080UL)\n         break;\n\n      sn += 4;\n      limit -= 4;\n   }\n\n   // handle the last few characters to find actual size\n   while (limit && *sn) {\n      ++sn;\n      --limit;\n   }\n\n   return (stbsp__uint32)(sn - s);\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)\n{\n   static char hex[] = \"0123456789abcdefxp\";\n   static char hexu[] = \"0123456789ABCDEFXP\";\n   char *bf;\n   char const *f;\n   int tlen = 0;\n\n   bf = buf;\n   f = fmt;\n   for (;;) {\n      stbsp__int32 fw, pr, tz;\n      stbsp__uint32 fl;\n\n      // macros for the callback buffer stuff\n      #define stbsp__chk_cb_bufL(bytes)                        \\\n         {                                                     \\\n            int len = (int)(bf - buf);                         \\\n            if ((len + (bytes)) >= STB_SPRINTF_MIN) {          \\\n               tlen += len;                                    \\\n               if (0 == (bf = buf = callback(buf, user, len))) \\\n                  goto done;                                   \\\n            }                                                  \\\n         }\n      #define stbsp__chk_cb_buf(bytes)    \\\n         {                                \\\n            if (callback) {               \\\n               stbsp__chk_cb_bufL(bytes); \\\n            }                             \\\n         }\n      #define stbsp__flush_cb()                      \\\n         {                                           \\\n            stbsp__chk_cb_bufL(STB_SPRINTF_MIN - 1); \\\n         } // flush if there is even one byte in the buffer\n      #define stbsp__cb_buf_clamp(cl, v)                \\\n         cl = v;                                        \\\n         if (callback) {                                \\\n            int lg = STB_SPRINTF_MIN - (int)(bf - buf); \\\n            if (cl > lg)                                \\\n               cl = lg;                                 \\\n         }\n\n      // fast copy everything up to the next % (or end of string)\n      for (;;) {\n         while (((stbsp__uintptr)f) & 3) {\n         schk1:\n            if (f[0] == '%')\n               goto scandd;\n         schk2:\n            if (f[0] == 0)\n               goto endfmt;\n            stbsp__chk_cb_buf(1);\n            *bf++ = f[0];\n            ++f;\n         }\n         for (;;) {\n            // Check if the next 4 bytes contain %(0x25) or end of string.\n            // Using the 'hasless' trick:\n            // https://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord\n            stbsp__uint32 v, c;\n            v = *(stbsp__uint32 *)f;\n            c = (~v) & 0x80808080;\n            if (((v ^ 0x25252525) - 0x01010101) & c)\n               goto schk1;\n            if ((v - 0x01010101) & c)\n               goto schk2;\n            if (callback)\n               if ((STB_SPRINTF_MIN - (int)(bf - buf)) < 4)\n                  goto schk1;\n            #ifdef STB_SPRINTF_NOUNALIGNED\n                if(((stbsp__uintptr)bf) & 3) {\n                    bf[0] = f[0];\n                    bf[1] = f[1];\n                    bf[2] = f[2];\n                    bf[3] = f[3];\n                } else\n            #endif\n            {\n                *(stbsp__uint32 *)bf = v;\n            }\n            bf += 4;\n            f += 4;\n         }\n      }\n   scandd:\n\n      ++f;\n\n      // ok, we have a percent, read the modifiers first\n      fw = 0;\n      pr = -1;\n      fl = 0;\n      tz = 0;\n\n      // flags\n      for (;;) {\n         switch (f[0]) {\n         // if we have left justify\n         case '-':\n            fl |= STBSP__LEFTJUST;\n            ++f;\n            continue;\n         // if we have leading plus\n         case '+':\n            fl |= STBSP__LEADINGPLUS;\n            ++f;\n            continue;\n         // if we have leading space\n         case ' ':\n            fl |= STBSP__LEADINGSPACE;\n            ++f;\n            continue;\n         // if we have leading 0x\n         case '#':\n            fl |= STBSP__LEADING_0X;\n            ++f;\n            continue;\n         // if we have thousand commas\n         case '\\'':\n            fl |= STBSP__TRIPLET_COMMA;\n            ++f;\n            continue;\n         // if we have kilo marker (none->kilo->kibi->jedec)\n         case '$':\n            if (fl & STBSP__METRIC_SUFFIX) {\n               if (fl & STBSP__METRIC_1024) {\n                  fl |= STBSP__METRIC_JEDEC;\n               } else {\n                  fl |= STBSP__METRIC_1024;\n               }\n            } else {\n               fl |= STBSP__METRIC_SUFFIX;\n            }\n            ++f;\n            continue;\n         // if we don't want space between metric suffix and number\n         case '_':\n            fl |= STBSP__METRIC_NOSPACE;\n            ++f;\n            continue;\n         // if we have leading zero\n         case '0':\n            fl |= STBSP__LEADINGZERO;\n            ++f;\n            goto flags_done;\n         default: goto flags_done;\n         }\n      }\n   flags_done:\n\n      // get the field width\n      if (f[0] == '*') {\n         fw = va_arg(va, stbsp__uint32);\n         ++f;\n      } else {\n         while ((f[0] >= '0') && (f[0] <= '9')) {\n            fw = fw * 10 + f[0] - '0';\n            f++;\n         }\n      }\n      // get the precision\n      if (f[0] == '.') {\n         ++f;\n         if (f[0] == '*') {\n            pr = va_arg(va, stbsp__uint32);\n            ++f;\n         } else {\n            pr = 0;\n            while ((f[0] >= '0') && (f[0] <= '9')) {\n               pr = pr * 10 + f[0] - '0';\n               f++;\n            }\n         }\n      }\n\n      // handle integer size overrides\n      switch (f[0]) {\n      // are we halfwidth?\n      case 'h':\n         fl |= STBSP__HALFWIDTH;\n         ++f;\n         if (f[0] == 'h')\n            ++f;  // QUARTERWIDTH\n         break;\n      // are we 64-bit (unix style)\n      case 'l':\n         fl |= ((sizeof(long) == 8) ? STBSP__INTMAX : 0);\n         ++f;\n         if (f[0] == 'l') {\n            fl |= STBSP__INTMAX;\n            ++f;\n         }\n         break;\n      // are we 64-bit on intmax? (c99)\n      case 'j':\n         fl |= (sizeof(u32) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      // are we 64-bit on u32 or platform_t? (c99)\n      case 'z':\n         fl |= (sizeof(platform_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      case 't':\n         fl |= (sizeof(platform_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      // are we 64-bit (msft style)\n      case 'I':\n         if ((f[1] == '6') && (f[2] == '4')) {\n            fl |= STBSP__INTMAX;\n            f += 3;\n         } else if ((f[1] == '3') && (f[2] == '2')) {\n            f += 3;\n         } else {\n            fl |= ((sizeof(void *) == 8) ? STBSP__INTMAX : 0);\n            ++f;\n         }\n         break;\n      default: break;\n      }\n\n      // handle each replacement\n      switch (f[0]) {\n         #define STBSP__NUMSZ 512 // big enough for e308 (with commas) or e-307\n         char num[STBSP__NUMSZ];\n         char lead[8];\n         char tail[8];\n         char *s;\n         char const *h;\n         stbsp__uint32 l, n, cs;\n         stbsp__uint64 n64;\n#ifndef STB_SPRINTF_NOFLOAT\n         double fv;\n#endif\n         stbsp__int32 dp;\n         char const *sn;\n\n      case 's':\n         // get the string\n         s = va_arg(va, char *);\n         if (s == 0)\n            s = (char *)\"null\";\n         // get the length, limited to desired precision\n         // always limit to ~0u chars since our counts are 32b\n         l = stbsp__strlen_limited(s, (pr >= 0) ? pr : ~0u);\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         // copy the string in\n         goto scopy;\n\n      case 'c': // char\n         // get the character\n         s = num + STBSP__NUMSZ - 1;\n         *s = (char)va_arg(va, int);\n         l = 1;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         goto scopy;\n\n      case 'n': // weird write-bytes specifier\n      {\n         int *d = va_arg(va, int *);\n         *d = tlen + (int)(bf - buf);\n      } break;\n\n#ifdef STB_SPRINTF_NOFLOAT\n      case 'A':              // float\n      case 'a':              // hex float\n      case 'G':              // float\n      case 'g':              // float\n      case 'E':              // float\n      case 'e':              // float\n      case 'f':              // float\n         va_arg(va, double); // eat it\n         s = (char *)\"No float\";\n         l = 8;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         cs = 0;\n         STBSP__NOTUSED(dp);\n         goto scopy;\n#else\n      case 'A': // hex float\n      case 'a': // hex float\n         h = (f[0] == 'A') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_parts((stbsp__int64 *)&n64, &dp, fv))\n            fl |= STBSP__NEGATIVE;\n\n         s = num + 64;\n\n         stbsp__lead_sign(fl, lead);\n\n         if (dp == -1023)\n            dp = (n64) ? -1022 : 0;\n         else\n            n64 |= (((stbsp__uint64)1) << 52);\n         n64 <<= (64 - 56);\n         if (pr < 15)\n            n64 += ((((stbsp__uint64)8) << 56) >> (pr * 4));\n// add leading chars\n\n#ifdef STB_SPRINTF_MSVC_MODE\n         *s++ = '0';\n         *s++ = 'x';\n#else\n         lead[1 + lead[0]] = '0';\n         lead[2 + lead[0]] = 'x';\n         lead[0] += 2;\n#endif\n         *s++ = h[(n64 >> 60) & 15];\n         n64 <<= 4;\n         if (pr)\n            *s++ = stbsp__period;\n         sn = s;\n\n         // print the bits\n         n = pr;\n         if (n > 13)\n            n = 13;\n         if (pr > (stbsp__int32)n)\n            tz = pr - n;\n         pr = 0;\n         while (n--) {\n            *s++ = h[(n64 >> 60) & 15];\n            n64 <<= 4;\n         }\n\n         // print the expo\n         tail[1] = h[17];\n         if (dp < 0) {\n            tail[2] = '-';\n            dp = -dp;\n         } else\n            tail[2] = '+';\n         n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));\n         tail[0] = (char)n;\n         for (;;) {\n            tail[n] = '0' + dp % 10;\n            if (n <= 3)\n               break;\n            --n;\n            dp /= 10;\n         }\n\n         dp = (int)(s - sn);\n         l = (int)(s - (num + 64));\n         s = num + 64;\n         cs = 1 + (3 << 24);\n         goto scopy;\n\n      case 'G': // float\n      case 'g': // float\n         h = (f[0] == 'G') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6;\n         else if (pr == 0)\n            pr = 1; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))\n            fl |= STBSP__NEGATIVE;\n\n         n = pr;\n         if (l > (stbsp__uint32)pr)\n            l = pr;\n         while ((l > 1) && (pr) && (sn[l - 1] == '0')) {\n            --pr;\n            --l;\n         }\n\n         // should we use %e\n         if ((dp <= -4) || (dp > (stbsp__int32)n)) {\n            if (pr > (stbsp__int32)l)\n               pr = l - 1;\n            else if (pr)\n               --pr; // when using %e, there is one digit before the decimal\n            goto doexpfromg;\n         }\n         // this is the insane action to get the pr to match %g semantics for %f\n         if (dp > 0) {\n            pr = (dp < (stbsp__int32)l) ? l - dp : 0;\n         } else {\n            pr = -dp + ((pr > (stbsp__int32)l) ? (stbsp__int32) l : pr);\n         }\n         goto dofloatfromg;\n\n      case 'E': // float\n      case 'e': // float\n         h = (f[0] == 'E') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))\n            fl |= STBSP__NEGATIVE;\n      doexpfromg:\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n         if (dp == STBSP__SPECIAL) {\n            s = (char *)sn;\n            cs = 0;\n            pr = 0;\n            goto scopy;\n         }\n         s = num + 64;\n         // handle leading chars\n         *s++ = sn[0];\n\n         if (pr)\n            *s++ = stbsp__period;\n\n         // handle after decimal\n         if ((l - 1) > (stbsp__uint32)pr)\n            l = pr + 1;\n         for (n = 1; n < l; n++)\n            *s++ = sn[n];\n         // trailing zeros\n         tz = pr - (l - 1);\n         pr = 0;\n         // dump expo\n         tail[1] = h[0xe];\n         dp -= 1;\n         if (dp < 0) {\n            tail[2] = '-';\n            dp = -dp;\n         } else\n            tail[2] = '+';\n#ifdef STB_SPRINTF_MSVC_MODE\n         n = 5;\n#else\n         n = (dp >= 100) ? 5 : 4;\n#endif\n         tail[0] = (char)n;\n         for (;;) {\n            tail[n] = '0' + dp % 10;\n            if (n <= 3)\n               break;\n            --n;\n            dp /= 10;\n         }\n         cs = 1 + (3 << 24); // how many tens\n         goto flt_lead;\n\n      case 'f': // float\n         fv = va_arg(va, double);\n      doafloat:\n         // do kilos\n         if (fl & STBSP__METRIC_SUFFIX) {\n            double divisor;\n            divisor = 1000.0f;\n            if (fl & STBSP__METRIC_1024)\n               divisor = 1024.0;\n            while (fl < 0x4000000) {\n               if ((fv < divisor) && (fv > -divisor))\n                  break;\n               fv /= divisor;\n               fl += 0x1000000;\n            }\n         }\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))\n            fl |= STBSP__NEGATIVE;\n      dofloatfromg:\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n         if (dp == STBSP__SPECIAL) {\n            s = (char *)sn;\n            cs = 0;\n            pr = 0;\n            goto scopy;\n         }\n         s = num + 64;\n\n         // handle the three decimal varieties\n         if (dp <= 0) {\n            stbsp__int32 i;\n            // handle 0.000*000xxxx\n            *s++ = '0';\n            if (pr)\n               *s++ = stbsp__period;\n            n = -dp;\n            if ((stbsp__int32)n > pr)\n               n = pr;\n            i = n;\n            while (i) {\n               if ((((stbsp__uintptr)s) & 3) == 0)\n                  break;\n               *s++ = '0';\n               --i;\n            }\n            while (i >= 4) {\n               *(stbsp__uint32 *)s = 0x30303030;\n               s += 4;\n               i -= 4;\n            }\n            while (i) {\n               *s++ = '0';\n               --i;\n            }\n            if ((stbsp__int32)(l + n) > pr)\n               l = pr - n;\n            i = l;\n            while (i) {\n               *s++ = *sn++;\n               --i;\n            }\n            tz = pr - (n + l);\n            cs = 1 + (3 << 24); // how many tens did we write (for commas below)\n         } else {\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((600 - (stbsp__uint32)dp) % 3) : 0;\n            if ((stbsp__uint32)dp >= l) {\n               // handle xxxx000*000.0\n               n = 0;\n               for (;;) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                     cs = 0;\n                     *s++ = stbsp__comma;\n                  } else {\n                     *s++ = sn[n];\n                     ++n;\n                     if (n >= l)\n                        break;\n                  }\n               }\n               if (n < (stbsp__uint32)dp) {\n                  n = dp - n;\n                  if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n                     while (n) {\n                        if ((((stbsp__uintptr)s) & 3) == 0)\n                           break;\n                        *s++ = '0';\n                        --n;\n                     }\n                     while (n >= 4) {\n                        *(stbsp__uint32 *)s = 0x30303030;\n                        s += 4;\n                        n -= 4;\n                     }\n                  }\n                  while (n) {\n                     if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                        cs = 0;\n                        *s++ = stbsp__comma;\n                     } else {\n                        *s++ = '0';\n                        --n;\n                     }\n                  }\n               }\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\n               if (pr) {\n                  *s++ = stbsp__period;\n                  tz = pr;\n               }\n            } else {\n               // handle xxxxx.xxxx000*000\n               n = 0;\n               for (;;) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                     cs = 0;\n                     *s++ = stbsp__comma;\n                  } else {\n                     *s++ = sn[n];\n                     ++n;\n                     if (n >= (stbsp__uint32)dp)\n                        break;\n                  }\n               }\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\n               if (pr)\n                  *s++ = stbsp__period;\n               if ((l - dp) > (stbsp__uint32)pr)\n                  l = pr + dp;\n               while (n < l) {\n                  *s++ = sn[n];\n                  ++n;\n               }\n               tz = pr - (l - dp);\n            }\n         }\n         pr = 0;\n\n         // handle k,m,g,t\n         if (fl & STBSP__METRIC_SUFFIX) {\n            char idx;\n            idx = 1;\n            if (fl & STBSP__METRIC_NOSPACE)\n               idx = 0;\n            tail[0] = idx;\n            tail[1] = ' ';\n            {\n               if (fl >> 24) { // SI kilo is 'k', JEDEC and SI kibits are 'K'.\n                  if (fl & STBSP__METRIC_1024)\n                     tail[idx + 1] = \"_KMGT\"[fl >> 24];\n                  else\n                     tail[idx + 1] = \"_kMGT\"[fl >> 24];\n                  idx++;\n                  // If printing kibits and not in jedec, add the 'i'.\n                  if (fl & STBSP__METRIC_1024 && !(fl & STBSP__METRIC_JEDEC)) {\n                     tail[idx + 1] = 'i';\n                     idx++;\n                  }\n                  tail[0] = idx;\n               }\n            }\n         };\n\n      flt_lead:\n         // get the length that we copied\n         l = (stbsp__uint32)(s - (num + 64));\n         s = num + 64;\n         goto scopy;\n#endif\n\n      case 'B': // upper binary\n      case 'b': // lower binary\n         h = (f[0] == 'B') ? hexu : hex;\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 2;\n            lead[1] = '0';\n            lead[2] = h[0xb];\n         }\n         l = (8 << 4) | (1 << 8);\n         goto radixnum;\n\n      case 'o': // octal\n         h = hexu;\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 1;\n            lead[1] = '0';\n         }\n         l = (3 << 4) | (3 << 8);\n         goto radixnum;\n\n      case 'p': // pointer\n         fl |= (sizeof(void *) == 8) ? STBSP__INTMAX : 0;\n         pr = sizeof(void *) * 2;\n         fl &= ~STBSP__LEADINGZERO; // 'p' only prints the pointer with zeros\n                                    // fall through - to X\n\n      case 'X': // upper hex\n      case 'x': // lower hex\n         h = (f[0] == 'X') ? hexu : hex;\n         l = (4 << 4) | (4 << 8);\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 2;\n            lead[1] = '0';\n            lead[2] = h[16];\n         }\n      radixnum:\n         // get the number\n         if (fl & STBSP__INTMAX)\n            n64 = va_arg(va, stbsp__uint64);\n         else\n            n64 = va_arg(va, stbsp__uint32);\n\n         s = num + STBSP__NUMSZ;\n         dp = 0;\n         // clear tail, and clear leading if value is zero\n         tail[0] = 0;\n         if (n64 == 0) {\n            lead[0] = 0;\n            if (pr == 0) {\n               l = 0;\n               cs = 0;\n               goto scopy;\n            }\n         }\n         // convert to string\n         for (;;) {\n            *--s = h[n64 & ((1 << (l >> 8)) - 1)];\n            n64 >>= (l >> 8);\n            if (!((n64) || ((stbsp__int32)((num + STBSP__NUMSZ) - s) < pr)))\n               break;\n            if (fl & STBSP__TRIPLET_COMMA) {\n               ++l;\n               if ((l & 15) == ((l >> 4) & 15)) {\n                  l &= ~15;\n                  *--s = stbsp__comma;\n               }\n            }\n         };\n         // get the tens and the comma pos\n         cs = (stbsp__uint32)((num + STBSP__NUMSZ) - s) + ((((l >> 4) & 15)) << 24);\n         // get the length that we copied\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\n         // copy it\n         goto scopy;\n\n      case 'u': // unsigned\n      case 'i':\n      case 'd': // integer\n         // get the integer and abs it\n         if (fl & STBSP__INTMAX) {\n            stbsp__int64 i64 = va_arg(va, stbsp__int64);\n            n64 = (stbsp__uint64)i64;\n            if ((f[0] != 'u') && (i64 < 0)) {\n               n64 = (stbsp__uint64)-i64;\n               fl |= STBSP__NEGATIVE;\n            }\n         } else {\n            stbsp__int32 i = va_arg(va, stbsp__int32);\n            n64 = (stbsp__uint32)i;\n            if ((f[0] != 'u') && (i < 0)) {\n               n64 = (stbsp__uint32)-i;\n               fl |= STBSP__NEGATIVE;\n            }\n         }\n\n#ifndef STB_SPRINTF_NOFLOAT\n         if (fl & STBSP__METRIC_SUFFIX) {\n            if (n64 < 1024)\n               pr = 0;\n            else if (pr == -1)\n               pr = 1;\n            fv = (double)(stbsp__int64)n64;\n            goto doafloat;\n         }\n#endif\n\n         // convert to string\n         s = num + STBSP__NUMSZ;\n         l = 0;\n\n         for (;;) {\n            // do in 32-bit chunks (avoid lots of 64-bit divides even with constant denominators)\n            char *o = s - 8;\n            if (n64 >= 100000000) {\n               n = (stbsp__uint32)(n64 % 100000000);\n               n64 /= 100000000;\n            } else {\n               n = (stbsp__uint32)n64;\n               n64 = 0;\n            }\n            if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n               do {\n                  s -= 2;\n                  *(stbsp__uint16 *)s = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];\n                  n /= 100;\n               } while (n);\n            }\n            while (n) {\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\n                  l = 0;\n                  *--s = stbsp__comma;\n                  --o;\n               } else {\n                  *--s = (char)(n % 10) + '0';\n                  n /= 10;\n               }\n            }\n            if (n64 == 0) {\n               if ((s[0] == '0') && (s != (num + STBSP__NUMSZ)))\n                  ++s;\n               break;\n            }\n            while (s != o)\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\n                  l = 0;\n                  *--s = stbsp__comma;\n                  --o;\n               } else {\n                  *--s = '0';\n               }\n         }\n\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n\n         // get the length that we copied\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\n         if (l == 0) {\n            *--s = '0';\n            l = 1;\n         }\n         cs = l + (3 << 24);\n         if (pr < 0)\n            pr = 0;\n\n      scopy:\n         // get fw=leading/trailing space, pr=leading zeros\n         if (pr < (stbsp__int32)l)\n            pr = l;\n         n = pr + lead[0] + tail[0] + tz;\n         if (fw < (stbsp__int32)n)\n            fw = n;\n         fw -= n;\n         pr -= l;\n\n         // handle right justify and leading zeros\n         if ((fl & STBSP__LEFTJUST) == 0) {\n            if (fl & STBSP__LEADINGZERO) // if leading zeros, everything is in pr\n            {\n               pr = (fw > pr) ? fw : pr;\n               fw = 0;\n            } else {\n               fl &= ~STBSP__TRIPLET_COMMA; // if no leading zeros, then no commas\n            }\n         }\n\n         // copy the spaces and/or zeros\n         if (fw + pr) {\n            stbsp__int32 i;\n            stbsp__uint32 c;\n\n            // copy leading spaces (or when doing %8.4d stuff)\n            if ((fl & STBSP__LEFTJUST) == 0)\n               while (fw > 0) {\n                  stbsp__cb_buf_clamp(i, fw);\n                  fw -= i;\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x20202020;\n                     bf += 4;\n                     i -= 4;\n                  }\n                  while (i) {\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  stbsp__chk_cb_buf(1);\n               }\n\n            // copy leader\n            sn = lead + 1;\n            while (lead[0]) {\n               stbsp__cb_buf_clamp(i, lead[0]);\n               lead[0] -= (char)i;\n               while (i) {\n                  *bf++ = *sn++;\n                  --i;\n               }\n               stbsp__chk_cb_buf(1);\n            }\n\n            // copy leading zeros\n            c = cs >> 24;\n            cs &= 0xffffff;\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((stbsp__uint32)(c - ((pr + cs) % (c + 1)))) : 0;\n            while (pr > 0) {\n               stbsp__cb_buf_clamp(i, pr);\n               pr -= i;\n               if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = '0';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x30303030;\n                     bf += 4;\n                     i -= 4;\n                  }\n               }\n               while (i) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (cs++ == c)) {\n                     cs = 0;\n                     *bf++ = stbsp__comma;\n                  } else\n                     *bf++ = '0';\n                  --i;\n               }\n               stbsp__chk_cb_buf(1);\n            }\n         }\n\n         // copy leader if there is still one\n         sn = lead + 1;\n         while (lead[0]) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, lead[0]);\n            lead[0] -= (char)i;\n            while (i) {\n               *bf++ = *sn++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy the string\n         n = l;\n         while (n) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, n);\n            n -= i;\n            STBSP__UNALIGNED(while (i >= 4) {\n               *(stbsp__uint32 volatile *)bf = *(stbsp__uint32 volatile *)s;\n               bf += 4;\n               s += 4;\n               i -= 4;\n            })\n            while (i) {\n               *bf++ = *s++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy trailing zeros\n         while (tz) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, tz);\n            tz -= i;\n            while (i) {\n               if ((((stbsp__uintptr)bf) & 3) == 0)\n                  break;\n               *bf++ = '0';\n               --i;\n            }\n            while (i >= 4) {\n               *(stbsp__uint32 *)bf = 0x30303030;\n               bf += 4;\n               i -= 4;\n            }\n            while (i) {\n               *bf++ = '0';\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy tail if there is one\n         sn = tail + 1;\n         while (tail[0]) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, tail[0]);\n            tail[0] -= (char)i;\n            while (i) {\n               *bf++ = *sn++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // handle the left justify\n         if (fl & STBSP__LEFTJUST)\n            if (fw > 0) {\n               while (fw) {\n                  stbsp__int32 i;\n                  stbsp__cb_buf_clamp(i, fw);\n                  fw -= i;\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x20202020;\n                     bf += 4;\n                     i -= 4;\n                  }\n                  while (i--)\n                     *bf++ = ' ';\n                  stbsp__chk_cb_buf(1);\n               }\n            }\n         break;\n\n      default: // unknown, just copy code\n         s = num + STBSP__NUMSZ - 1;\n         *s = f[0];\n         l = 1;\n         fw = fl = 0;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         goto scopy;\n      }\n      ++f;\n   }\nendfmt:\n\n   if (!callback)\n      *bf = 0;\n   else\n      stbsp__flush_cb();\n\ndone:\n   return tlen + (int)(bf - buf);\n}\n\n// cleanup\n#undef STBSP__LEFTJUST\n#undef STBSP__LEADINGPLUS\n#undef STBSP__LEADINGSPACE\n#undef STBSP__LEADING_0X\n#undef STBSP__LEADINGZERO\n#undef STBSP__INTMAX\n#undef STBSP__TRIPLET_COMMA\n#undef STBSP__NEGATIVE\n#undef STBSP__METRIC_SUFFIX\n#undef STBSP__NUMSZ\n#undef stbsp__chk_cb_bufL\n#undef stbsp__chk_cb_buf\n#undef stbsp__flush_cb\n#undef stbsp__cb_buf_clamp\n\n// ============================================================================\n//   wrapper functions\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...)\n{\n   int result;\n   va_list va;\n   va_start(va, fmt);\n   result = STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\n   va_end(va);\n   return result;\n}\n\ntypedef struct stbsp__context {\n   char *buf;\n   int count;\n   int length;\n   char tmp[STB_SPRINTF_MIN];\n} stbsp__context;\n\nstatic char *stbsp__clamp_callback(const char *buf, void *user, int len)\n{\n   stbsp__context *c = (stbsp__context *)user;\n   c->length += len;\n\n   if (len > c->count)\n      len = c->count;\n\n   if (len) {\n      if (buf != c->buf) {\n         const char *s, *se;\n         char *d;\n         d = c->buf;\n         s = buf;\n         se = buf + len;\n         do {\n            *d++ = *s++;\n         } while (s < se);\n      }\n      c->buf += len;\n      c->count -= len;\n   }\n\n   if (c->count <= 0)\n      return c->tmp;\n   return (c->count >= STB_SPRINTF_MIN) ? c->buf : c->tmp; // go direct into buffer if you can\n}\n\nstatic char * stbsp__count_clamp_callback( const char * buf, void * user, int len )\n{\n   stbsp__context * c = (stbsp__context*)user;\n   (void) sizeof(buf);\n\n   c->length += len;\n   return c->tmp; // go direct into buffer if you can\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE( vsnprintf )( char * buf, int count, char const * fmt, va_list va )\n{\n   stbsp__context c;\n\n   if ( (count == 0) && !buf )\n   {\n      c.length = 0;\n\n      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__count_clamp_callback, &c, c.tmp, fmt, va );\n   }\n   else\n   {\n      int l;\n\n      c.buf = buf;\n      c.count = count;\n      c.length = 0;\n\n      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__clamp_callback, &c, stbsp__clamp_callback(0,&c,0), fmt, va );\n\n      // zero-terminate\n      l = (int)( c.buf - buf );\n      if ( l >= count ) // should never be greater, only equal (or less) than count\n         l = count - 1;\n      buf[l] = 0;\n   }\n\n   return c.length;\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...)\n{\n   int result;\n   va_list va;\n   va_start(va, fmt);\n\n   result = STB_SPRINTF_DECORATE(vsnprintf)(buf, count, fmt, va);\n   va_end(va);\n\n   return result;\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va)\n{\n   return STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\n}\n\n// =======================================================================\n//   low level float utility functions\n\n#ifndef STB_SPRINTF_NOFLOAT\n\n// copies d to bits w/ strict aliasing (this compiles to nothing on /Ox)\n#define STBSP__COPYFP(dest, src)                   \\\n   {                                               \\\n      int cn;                                      \\\n      for (cn = 0; cn < 8; cn++)                   \\\n         ((char *)&dest)[cn] = ((char *)&src)[cn]; \\\n   }\n\n// get float info\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value)\n{\n   double d;\n   stbsp__int64 b = 0;\n\n   // load value and round at the frac_digits\n   d = value;\n\n   STBSP__COPYFP(b, d);\n\n   *bits = b & ((((stbsp__uint64)1) << 52) - 1);\n   *expo = (stbsp__int32)(((b >> 52) & 2047) - 1023);\n\n   return (stbsp__int32)((stbsp__uint64) b >> 63);\n}\n\nstatic double const stbsp__bot[23] = {\n   1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,\n   1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022\n};\nstatic double const stbsp__negbot[22] = {\n   1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,\n   1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022\n};\nstatic double const stbsp__negboterr[22] = {\n   -5.551115123125783e-018,  -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,\n   4.5251888174113739e-024,  -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028,  2.0113352370744385e-029,\n   -3.0373745563400371e-030, 1.1806906454401013e-032,  -7.7705399876661076e-032, 2.0902213275965398e-033,  -7.1542424054621921e-034, -7.1542424054621926e-035,\n   2.4754073164739869e-036,  5.4846728545790429e-037,  9.2462547772103625e-038,  -4.8596774326570872e-039\n};\nstatic double const stbsp__top[13] = {\n   1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299\n};\nstatic double const stbsp__negtop[13] = {\n   1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299\n};\nstatic double const stbsp__toperr[13] = {\n   8388608,\n   6.8601809640529717e+028,\n   -7.253143638152921e+052,\n   -4.3377296974619174e+075,\n   -1.5559416129466825e+098,\n   -3.2841562489204913e+121,\n   -3.7745893248228135e+144,\n   -1.7356668416969134e+167,\n   -3.8893577551088374e+190,\n   -9.9566444326005119e+213,\n   6.3641293062232429e+236,\n   -5.2069140800249813e+259,\n   -5.2504760255204387e+282\n};\nstatic double const stbsp__negtoperr[13] = {\n   3.9565301985100693e-040,  -2.299904345391321e-063,  3.6506201437945798e-086,  1.1875228833981544e-109,\n   -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178,  -5.7778912386589953e-201,\n   7.4997100559334532e-224,  -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,\n   8.0970921678014997e-317\n};\n\n#if defined(_MSC_VER) && (_MSC_VER <= 1200)\nstatic stbsp__uint64 const stbsp__powten[20] = {\n   1,\n   10,\n   100,\n   1000,\n   10000,\n   100000,\n   1000000,\n   10000000,\n   100000000,\n   1000000000,\n   10000000000,\n   100000000000,\n   1000000000000,\n   10000000000000,\n   100000000000000,\n   1000000000000000,\n   10000000000000000,\n   100000000000000000,\n   1000000000000000000,\n   10000000000000000000U\n};\n#define stbsp__tento19th ((stbsp__uint64)1000000000000000000)\n#else\nstatic stbsp__uint64 const stbsp__powten[20] = {\n   1,\n   10,\n   100,\n   1000,\n   10000,\n   100000,\n   1000000,\n   10000000,\n   100000000,\n   1000000000,\n   10000000000ULL,\n   100000000000ULL,\n   1000000000000ULL,\n   10000000000000ULL,\n   100000000000000ULL,\n   1000000000000000ULL,\n   10000000000000000ULL,\n   100000000000000000ULL,\n   1000000000000000000ULL,\n   10000000000000000000ULL\n};\n#define stbsp__tento19th (1000000000000000000ULL)\n#endif\n\n#define stbsp__ddmulthi(oh, ol, xh, yh)                            \\\n   {                                                               \\\n      double ahi = 0, alo, bhi = 0, blo;                           \\\n      stbsp__int64 bt;                                             \\\n      oh = xh * yh;                                                \\\n      STBSP__COPYFP(bt, xh);                                       \\\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\n      STBSP__COPYFP(ahi, bt);                                      \\\n      alo = xh - ahi;                                              \\\n      STBSP__COPYFP(bt, yh);                                       \\\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\n      STBSP__COPYFP(bhi, bt);                                      \\\n      blo = yh - bhi;                                              \\\n      ol = ((ahi * bhi - oh) + ahi * blo + alo * bhi) + alo * blo; \\\n   }\n\n#define stbsp__ddtoS64(ob, xh, xl)          \\\n   {                                        \\\n      double ahi = 0, alo, vh, t;           \\\n      ob = (stbsp__int64)xh;                \\\n      vh = (double)ob;                      \\\n      ahi = (xh - vh);                      \\\n      t = (ahi - xh);                       \\\n      alo = (xh - (ahi - t)) - (vh + t);    \\\n      ob += (stbsp__int64)(ahi + alo + xl); \\\n   }\n\n#define stbsp__ddrenorm(oh, ol) \\\n   {                            \\\n      double s;                 \\\n      s = oh + ol;              \\\n      ol = ol - (s - oh);       \\\n      oh = s;                   \\\n   }\n\n#define stbsp__ddmultlo(oh, ol, xh, xl, yh, yl) ol = ol + (xh * yl + xl * yh);\n\n#define stbsp__ddmultlos(oh, ol, xh, yl) ol = ol + (xh * yl);\n\nstatic void stbsp__raise_to_power10(double *ohi, double *olo, double d, stbsp__int32 power) // power can be -323 to +350\n{\n   double ph, pl;\n   if ((power >= 0) && (power <= 22)) {\n      stbsp__ddmulthi(ph, pl, d, stbsp__bot[power]);\n   } else {\n      stbsp__int32 e, et, eb;\n      double p2h, p2l;\n\n      e = power;\n      if (power < 0)\n         e = -e;\n      et = (e * 0x2c9) >> 14; /* %23 */\n      if (et > 13)\n         et = 13;\n      eb = e - (et * 23);\n\n      ph = d;\n      pl = 0.0;\n      if (power < 0) {\n         if (eb) {\n            --eb;\n            stbsp__ddmulthi(ph, pl, d, stbsp__negbot[eb]);\n            stbsp__ddmultlos(ph, pl, d, stbsp__negboterr[eb]);\n         }\n         if (et) {\n            stbsp__ddrenorm(ph, pl);\n            --et;\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__negtop[et]);\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__negtop[et], stbsp__negtoperr[et]);\n            ph = p2h;\n            pl = p2l;\n         }\n      } else {\n         if (eb) {\n            e = eb;\n            if (eb > 22)\n               eb = 22;\n            e -= eb;\n            stbsp__ddmulthi(ph, pl, d, stbsp__bot[eb]);\n            if (e) {\n               stbsp__ddrenorm(ph, pl);\n               stbsp__ddmulthi(p2h, p2l, ph, stbsp__bot[e]);\n               stbsp__ddmultlos(p2h, p2l, stbsp__bot[e], pl);\n               ph = p2h;\n               pl = p2l;\n            }\n         }\n         if (et) {\n            stbsp__ddrenorm(ph, pl);\n            --et;\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__top[et]);\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__top[et], stbsp__toperr[et]);\n            ph = p2h;\n            pl = p2l;\n         }\n      }\n   }\n   stbsp__ddrenorm(ph, pl);\n   *ohi = ph;\n   *olo = pl;\n}\n\n// given a float value, returns the significant bits in bits, and the position of the\n//   decimal point in decimal_pos.  +/-INF and NAN are specified by special values\n//   returned in the decimal_pos parameter.\n// frac_digits is absolute normally, but if you want from first significant digits (got %g and %e), or in 0x80000000\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits)\n{\n   double d;\n   stbsp__int64 bits = 0;\n   stbsp__int32 expo, e, ng, tens;\n\n   d = value;\n   STBSP__COPYFP(bits, d);\n   expo = (stbsp__int32)((bits >> 52) & 2047);\n   ng = (stbsp__int32)((stbsp__uint64) bits >> 63);\n   if (ng)\n      d = -d;\n\n   if (expo == 2047) // is nan or inf?\n   {\n      *start = (bits & ((((stbsp__uint64)1) << 52) - 1)) ? \"NaN\" : \"Inf\";\n      *decimal_pos = STBSP__SPECIAL;\n      *len = 3;\n      return ng;\n   }\n\n   if (expo == 0) // is zero or denormal\n   {\n      if (((stbsp__uint64) bits << 1) == 0) // do zero\n      {\n         *decimal_pos = 1;\n         *start = out;\n         out[0] = '0';\n         *len = 1;\n         return ng;\n      }\n      // find the right expo for denormals\n      {\n         stbsp__int64 v = ((stbsp__uint64)1) << 51;\n         while ((bits & v) == 0) {\n            --expo;\n            v >>= 1;\n         }\n      }\n   }\n\n   // find the decimal exponent as well as the decimal bits of the value\n   {\n      double ph, pl;\n\n      // log10 estimate - very specifically tweaked to hit or undershoot by no more than 1 of log10 of all expos 1..2046\n      tens = expo - 1023;\n      tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);\n\n      // move the significant bits into position and stick them into an int\n      stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);\n\n      // get full as much precision from double-double as possible\n      stbsp__ddtoS64(bits, ph, pl);\n\n      // check if we undershot\n      if (((stbsp__uint64)bits) >= stbsp__tento19th)\n         ++tens;\n   }\n\n   // now do the rounding in integer land\n   frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);\n   if ((frac_digits < 24)) {\n      stbsp__uint32 dg = 1;\n      if ((stbsp__uint64)bits >= stbsp__powten[9])\n         dg = 10;\n      while ((stbsp__uint64)bits >= stbsp__powten[dg]) {\n         ++dg;\n         if (dg == 20)\n            goto noround;\n      }\n      if (frac_digits < dg) {\n         stbsp__uint64 r;\n         // add 0.5 at the right position and round\n         e = dg - frac_digits;\n         if ((stbsp__uint32)e >= 24)\n            goto noround;\n         r = stbsp__powten[e];\n         bits = bits + (r / 2);\n         if ((stbsp__uint64)bits >= stbsp__powten[dg])\n            ++tens;\n         bits /= r;\n      }\n   noround:;\n   }\n\n   // kill long trailing runs of zeros\n   if (bits) {\n      stbsp__uint32 n;\n      for (;;) {\n         if (bits <= 0xffffffff)\n            break;\n         if (bits % 1000)\n            goto donez;\n         bits /= 1000;\n      }\n      n = (stbsp__uint32)bits;\n      while ((n % 1000) == 0)\n         n /= 1000;\n      bits = n;\n   donez:;\n   }\n\n   // convert to string\n   out += 64;\n   e = 0;\n   for (;;) {\n      stbsp__uint32 n;\n      char *o = out - 8;\n      // do the conversion in chunks of U32s (avoid most 64-bit divides, worth it, constant denomiators be damned)\n      if (bits >= 100000000) {\n         n = (stbsp__uint32)(bits % 100000000);\n         bits /= 100000000;\n      } else {\n         n = (stbsp__uint32)bits;\n         bits = 0;\n      }\n      while (n) {\n         out -= 2;\n         *(stbsp__uint16 *)out = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];\n         n /= 100;\n         e += 2;\n      }\n      if (bits == 0) {\n         if ((e) && (out[0] == '0')) {\n            ++out;\n            --e;\n         }\n         break;\n      }\n      while (out != o) {\n         *--out = '0';\n         ++e;\n      }\n   }\n\n   *decimal_pos = tens;\n   *start = out;\n   *len = e;\n   return ng;\n}\n\n#undef stbsp__ddmulthi\n#undef stbsp__ddrenorm\n#undef stbsp__ddmultlo\n#undef stbsp__ddmultlos\n#undef STBSP__SPECIAL\n#undef STBSP__COPYFP\n\n#endif // STB_SPRINTF_NOFLOAT\n\n// clean up\n#undef stbsp__uint16\n#undef stbsp__uint32\n#undef stbsp__int32\n#undef stbsp__uint64\n#undef stbsp__int64\n#undef STBSP__UNALIGNED\n\n#endif // STB_SPRINTF_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#include \"imgui.h\"\n#include \"../platform/math.h\"\n#include \"../platform/window.h\"\n#include \"../framework/vector.h\"\n#include \"../framework/draw2d.h\"\n#include \"../debt/stb_sprintf.h\"\n\n#define IMGUI_ACTIVE_INPUT_NONE 0\n#define IMGUI_ACTIVE_INPUT_MOUSE 1\n#define IMGUI_ACTIVE_INPUT_TOUCH1 2\n#define IMGUI_ACTIVE_INPUT_TOUCH2 3\n#define IMGUI_ACTIVE_INPUT_TOUCH3 4\n#define IMGUI_ACTIVE_INPUT_TOUCH4 5\n#define IMGUI_ACTIVE_INPUT_TOUCH5 6\n\n#define IMGUI_WIDGET_BLOCK_SIZE 256\n\nnamespace Imgui {\n\tvoid SetTooltipLabel(const char* label);\n\tnamespace Internal {\n#if PLATFORM_DEBUG\n\t\tstruct RectBlock\n\t\t{\n\t\t\tImgui::Rect rectangles[IMGUI_WIDGET_BLOCK_SIZE];\n\t\t\tRectBlock* next;\n\t\t};\n#endif\n\t\tenum class TextAreaState {\n\t\t\tNone = 0,\n\t\t\tActivated,\n\t\t\tIdle,\n\t\t\tShutdown\n\t\t};\n\n\t\tstruct TextAreaInstance {\n\t\t\ti32 widgetId;\n\t\t\tchar* buffer;\n\t\t\tu32 length;\n\t\t\tu32 capacity;\n\t\t\ti32 karratIndex;\n\t\t\ti32 selection;\n\t\t\tTextAreaState state;\n\n\t\t\tinline void Reserve(u32 cap) {\n\t\t\t\tu32 newCap = capacity;\n\t\t\t\tif (capacity == 0) {\n\t\t\t\t\tnewCap = 16;\n\t\t\t\t}\n\t\t\t\tif (newCap < cap) {\n\t\t\t\t\tnewCap = cap;\n\t\t\t\t}\n\n\t\t\t\tif (capacity != newCap) {\n\t\t\t\t\tbuffer = (char*)MemRealloc(buffer, sizeof(char) * newCap);\n\t\t\t\t\tcapacity = newCap;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinline void Set(const char* newText, u32 newTextLen) {\n\t\t\t\tif (newTextLen + 1 >= capacity) {\n\t\t\t\t\tReserve(newTextLen + 1);\n\t\t\t\t}\n\n\t\t\t\tif (newTextLen == 0) {\n\t\t\t\t\tbuffer[0] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMemCopy(buffer, newText, newTextLen); // This includes the null terminator (i think)\n\t\t\t\t\tbuffer[newTextLen] = 0;\n\t\t\t\t}\n\t\t\t\tlength = newTextLen;\n\t\t\t}\n\t\t};\n\n\t\tstruct State {\n\t\t\tconst StyleSheet* style;\n\n\t\t\ti32 hotControl;\n\t\t\ti32 activeControl;\n\n\t\t\tu32 widgetFont;\n\t\t\tu32 interfaceFont;\n\t\t\tu32 labelFont;\n\n\t\t\ti32 positiveIdGenerator;\n\t\t\ti32 negativeIdGenerator;\n\n\t\t\ti32 grabKeyboardOnOrAfter;\n\n\t\t\tf32 dpi;\n\n\t\t\ti32 lastHotControl;\n\t\t\tf32 hotControlTimer;\n\n\t\t\ti32 lastActiveControl;\n\t\t\tf32 activeControlTimer;\n\t\t\tf32 lastTextDoubleClickTimer;\n\n\t\t\tf32 pulseTimer;\n\t\t\tbool pulse;\n\n\t\t\tf32 longPulseTimer;\n\t\t\tbool longPulse;\n\n\t\t\tf32 blinkTimer;\n\t\t\tbool blink;\n\n\t\t\ti32 tooltipIcon;\n\t\t\tconst char* tooltipLabel;\n\t\t\ti32 activeInputMethod;\n\n\t\t\tTextAreaInstance textAreaA;\n\t\t\tTextAreaInstance textAreaB;\n\n\t\t\tf32 timeSinceLastRelease;\n\n\t\t\tbool debugOverlayEnabled;\n\n#if PLATFORM_DEBUG\n\t\t\tRectBlock positiveWidgets;\n\t\t\tRectBlock negativeWidgets;\n#endif\n\t\tprivate:\n#if PLATFORM_DEBUG\n\n\t\t\tinline i32 _PrivateGetWidgetIndex(i32 widgetId) {\n\t\t\t\ti32 widgetIndex = MathAbsI(widgetId);\n\t\t\t\tu32 widgetBlock = widgetIndex / IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\twidgetIndex -= widgetBlock * IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\tPlatformAssert(widgetIndex >= 0, __LOCATION__);\n\t\t\t\tPlatformAssert(widgetIndex < IMGUI_WIDGET_BLOCK_SIZE, __LOCATION__);\n\t\t\t\treturn widgetIndex;\n\t\t\t}\n\n\t\t\tRectBlock* _PrivateGetWidgetBlock(i32 widgetId) {\n\t\t\t\tRectBlock* block = &positiveWidgets;\n\t\t\t\tif (widgetId < 0) {\n\t\t\t\t\tblock = &negativeWidgets;\n\t\t\t\t}\n\n\t\t\t\ti32 widgetIndex = MathAbsI(widgetId);\n\t\t\t\tu32 widgetBlock = widgetIndex / IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\twidgetIndex -= widgetBlock * IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\tPlatformAssert(widgetIndex >= 0, __LOCATION__);\n\t\t\t\tPlatformAssert(widgetIndex < IMGUI_WIDGET_BLOCK_SIZE, __LOCATION__);\n\n\t\t\t\tfor (u32 i = 0; i < widgetBlock; ++i) {\n\t\t\t\t\tif (block->next == 0) {\n\t\t\t\t\t\tblock->next = (RectBlock*)MemAlloc(sizeof(RectBlock));\n\t\t\t\t\t}\n\t\t\t\t\tblock = block->next;\n\t\t\t\t}\n\n\t\t\t\treturn block;\n\t\t\t}\n#endif\n\t\t\tinline i32 _PrivateGenerateWidget(const Rect& widgetRect, i32 widgetId) {\n#if PLATFORM_DEBUG\n\t\t\t\tRectBlock* block = _PrivateGetWidgetBlock(widgetId);\n\t\t\t\ti32 index = _PrivateGetWidgetIndex(widgetId);\n\t\t\t\tblock->rectangles[index] = widgetRect;\n#endif\n\t\t\t\treturn widgetId;\n\t\t\t}\n\t\tpublic:\n\t\t\tinline Rect Debug_GetWidgetRect(i32 widgetId) {\n#if PLATFORM_DEBUG\n\t\t\t\tRectBlock* block = _PrivateGetWidgetBlock(widgetId);\n\t\t\t\ti32 index = _PrivateGetWidgetIndex(widgetId);\n\t\t\t\treturn block->rectangles[index];\n#else\n\t\t\t\treturn Rect(0, 0, 50, 50);\n#endif\n\t\t\t}\n\n\t\t\tinline i32 NegativeId(const Rect& widgetRect) {\n\t\t\t\treturn _PrivateGenerateWidget(widgetRect, --negativeIdGenerator);\n\t\t\t}\n\n\t\t\tinline i32 PositiveId(const Rect& widgetRect) {\n\t\t\t\treturn _PrivateGenerateWidget(widgetRect, ++positiveIdGenerator);\n\t\t\t}\n\n\t\t\t\n\t\t\t// A \"pointer\" in this context is the mouse or a touch. Only one thing can be\n\t\t\t// the active pointer at once. IE, if the active pointer is the mouse, then\n\t\t\t// touch events wont be dispatched. But if the active pointer is a touch,\n\t\t\t// then mouse events wont be dispatched. Only one active touch at a time.\n\t\t\tinline f32 GetPointerX() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchGetX(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseGetX();\n\t\t\t}\n\n\t\t\tinline f32 GetPointerY() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchGetY(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseGetY();\n\t\t\t}\n\n\t\t\tinline f32 GetPointerDeltaX() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchDeltaX(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseDeltaX();\n\t\t\t}\n\n\t\t\tinline f32 GetPointerDeltaY() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchDeltaY(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseDeltaY();\n\t\t\t}\n\n\t\t\tinline bool GetPointerPressed() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchPressed(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MousePressed(MouseButtonLeft);\n\t\t\t}\n\n\t\t\tinline bool GetPointerReleased() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchReleased(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseReleased(MouseButtonLeft);\n\t\t\t}\n\n\t\t\tinline bool GetPointerUp() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn !TouchIsActive(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseUp(MouseButtonLeft);\n\t\t\t}\n\t\t};\n\n\t\tState* gState;\n\n\t\tinline u32 StrLen(const char* str) {\n\t\t\tif (str == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tu32 len = 0;\n\t\t\tfor (const char* s = str; *s != 0; ++s, ++len);\n\t\t\treturn len;\n\t\t}\n\n\n\t\t// Returns the number of elements shifted\n\t\tinline i32 RemoveRangeFromString(char* stringToModify, u32 stringLen, i32 startIndex, i32 endIndex) {\n\t\t\tif (startIndex > endIndex) {\n\t\t\t\ti32 tmp = startIndex;\n\t\t\t\tstartIndex = endIndex;\n\t\t\t\tendIndex = tmp;\n\t\t\t}\n\n\t\t\tint n = endIndex - startIndex;\n\t\t\tint p = startIndex;\n\t\t\t\n\t\t\tif (p + n >= stringLen + 1) { // +1 to clear the string (it's cool, i own the memory for sure)\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tint cut = 0;\n\t\t\tfor (n += p; stringToModify[n] != 0; cut++) {\n\t\t\t\tstringToModify[p++] = stringToModify[n++];\n\t\t\t}\n\t\t\tstringToModify[p] = 0;\n\t\t\t\n\t\t\treturn cut;\n\t\t}\n\n\t\tinline bool MakeHotOrActive(i32 widgetId, const Rect& screenPos, const vec2& mouse, const char* tooltip) {\n\t\t\t// Make hot\n\t\t\tif (mouse.x >= screenPos.x && mouse.x <= screenPos.x + screenPos.w) {\n\t\t\t\tif (mouse.y >= screenPos.y && mouse.y <= screenPos.y + screenPos.h) {\n\t\t\t\t\tif (Internal::gState->activeControl == widgetId || Internal::gState->activeControl == 0) {\n\t\t\t\t\t\tInternal::gState->hotControl = widgetId;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make active\n\t\t\tif (Internal::gState->hotControl == widgetId && Internal::gState->activeControl == 0) {\n\t\t\t\tif (Internal::gState->GetPointerPressed()) {\n\t\t\t\t\tInternal::gState->activeControl = widgetId;\n\t\t\t\t\tInternal::gState->hotControlTimer = 0.0f;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (tooltip != 0 && Internal::gState->hotControlTimer > IMGUI_TOOLTIP_MIN && Internal::gState->hotControlTimer < IMGUI_TOOLTIP_MAX) {\n\t\t\t\t\t\tImgui::SetTooltipLabel(tooltip);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Activate return\n\t\t\tif (Internal::gState->activeControl == widgetId && Internal::gState->hotControl == widgetId) {\n\t\t\t\tif (Internal::gState->GetPointerReleased()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\n\t\tinline i32 GetStringIndexUnderMouse(const char* string, i32 inputTextLength, const Rect& screenPos, const Draw2D::Size& inputTextSize, const vec2& mouse) {\n\t\t\tint index = -1;\n\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\tfloat string_y = screenPos.y + 2;\n\t\t\tvec2 relativePoint(mouse.x - string_x, 0); // ignore y\n\n\n\t\t\tif (relativePoint.y >= 0 && relativePoint.y <= inputTextSize.h) {\n\t\t\t\tif (relativePoint.x < 0) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t\telse if (relativePoint.x > inputTextSize.w) {\n\t\t\t\t\tindex = inputTextLength;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tindex = Draw2D::FindStringIndex(Internal::gState->interfaceFont, Internal::gState->style->textAreaFontSize, string, relativePoint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index < 0) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\telse if (index >= inputTextLength) {\n\t\t\t\tindex = (i32)inputTextLength;\n\t\t\t}\n\n\t\t\treturn index;\n\t\t}\n\t\n\t\t// You are responsible for calling MemFree here\n\t\tinline char* GetSubString(const char* string, i32 startIndex, i32 endIndex) {\n\t\t\tif (endIndex < startIndex) {\n\t\t\t\ti32 tmp = endIndex;\n\t\t\t\tendIndex = startIndex;\n\t\t\t\tstartIndex = tmp;\n\t\t\t}\n\n\t\t\ti32 len = endIndex - startIndex;\n\t\t\tif (len <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (string == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (startIndex < 0 || endIndex < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tchar* buffer = (char*)MemAlloc(len + 1);\n\t\t\tMemClear(buffer, len + 1);\n\t\t\tfor (i32 i = 0; i < len; ++i) {\n\t\t\t\tbuffer[i] = string[startIndex + i];\n\t\t\t}\n\t\t\tbuffer[len] = '\\0';\n\n\t\t\treturn buffer;\n\t\t}\n\t}\n\n\tbool UndoListItem(const Rect& screenPos, const Rect& scrollArea, const char* name, bool evenOrOdd, bool disabled, bool top) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tf32 mouseX = Internal::gState->GetPointerX() / dpi;\n\t\tf32 mouseY = Internal::gState->GetPointerY() / dpi;\n\t\tbool activated = false;\n\n\t\tbool mouseInScrollArea = mouseX >= scrollArea.x && mouseX <= scrollArea.x + scrollArea.w && mouseY >= scrollArea.y && mouseY <= scrollArea.y + scrollArea.h;\n\t\tif (mouseInScrollArea) {\n\t\t\tbool mouseInControlArea = mouseX >= screenPos.x && mouseX <= screenPos.x + screenPos.w && mouseY >= screenPos.y && mouseY <= screenPos.y + screenPos.h;\n\t\t\tif (mouseInControlArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tactivated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tStyleColor bg = s->hierarchyItemBG_A;\n\t\tStyleColor txt = s->hierarchyLabel;\n\t\tif (evenOrOdd) {\n\t\t\tbg = s->hierarchyItemBG_B;\n\t\t}\n\n\t\tif (top) {\n\t\t\tbg = s->hierarchyItemBG_Selected;\n\t\t}\n\t\telse if (disabled) {\n\t\t\ttxt = s->hierarchyLabelDisabled;\n\t\t\tbg = s->hierarchyItemBGDisabled;\n\t\t}\n\n\t\tif (Intersects(screenPos, scrollArea)) {\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, bg.r, bg.g, bg.b);\n\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->hierarchyLabelFontSize,\n\t\t\t\tscreenPos.x + 5, screenPos.y + s->hierarchyLabelFontSize, name, txt.r, txt.g, txt.b);\n\t\t}\n\n\t\treturn activated;\n\t}\n\n\tHierarchyListItemResult HierarchyListItem(const Rect& screenPos, const Rect& listARea, const char* name, f32 indent, bool evenOrOdd, bool selected, bool expanded, bool leaf) {\n\t\tHierarchyListItemResult result;\n\t\tresult.expanded = expanded;\n\t\t\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tf32 mouseX = Internal::gState->GetPointerX() / dpi; \n\t\tf32 mouseY = Internal::gState->GetPointerY() / dpi; \n\t\t\n\t\tbool activated = false;\n\t\t\n\t\tf32 toggleX = screenPos.x + indent;\n\t\tf32 toggleY = screenPos.y + s->hierarchyLabelFontSize + 3;\n\t\tRect toggleArea(toggleX, screenPos.y, s->hierarchyLabelFontSize + 3, screenPos.h);\n\t\ti32 toggleId = Internal::gState->NegativeId(toggleArea);\n\n\t\tbool mouseInListArea = mouseX >= listARea.x && mouseX <= listARea.x + listARea.w && mouseY >= listARea.y && mouseY <= listARea.y + listARea.h;\n\t\t\n\t\tif (mouseInListArea) {\n\t\t\tbool mouseInControlArea = mouseX >= screenPos.x && mouseX <= screenPos.x + screenPos.w && mouseY >= screenPos.y && mouseY <= screenPos.y + screenPos.h;\n\t\t\tbool mouseInToggleArea = mouseX >= toggleArea.x && mouseX <= toggleArea.x + toggleArea.w && mouseY >= toggleArea.y && mouseY <= toggleArea.y + toggleArea.h;\n\t\t\t\n\t\t\tbool wasHotOrActive = Internal::gState->activeControl == widgetId || Internal::gState->hotControl == widgetId;\n\n\t\t\tif ((!wasHotOrActive) && mouseInToggleArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(toggleId, toggleArea, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tresult.expanded = !result.expanded;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mouseInControlArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tactivated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tStyleColor bg = s->hierarchyItemBG_A;\n\t\tif (evenOrOdd) {\n\t\t\tbg = s->hierarchyItemBG_B;\n\t\t}\n\n\t\tif (selected) {\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tbg = s->hierarchyItemBG_Movable;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbg = s->hierarchyItemBG_Selected;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tbg = s->hierarchyItemBG_Movable;\n\t\t\t}\n\t\t}\n\n\t\tif (Intersects(screenPos, listARea)) {\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, bg.r, bg.g, bg.b);\n\t\t\t\n\t\t\t//Draw2D::DrawRect(toggleArea.x, toggleArea.y, toggleArea.w, toggleArea.h, 1, 0, 0);\n\n\t\t\tif (!leaf) {\n\t\t\t\tStyleColor toggleColor = s->hierarchyToggleNormal;\n\t\t\t\tif (Internal::gState->hotControl == toggleId || Internal::gState->activeControl == toggleId) {\n\t\t\t\t\ttoggleColor = s->hierarchyToggleHot;\n\t\t\t\t}\n\n\t\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, s->hierarchyLabelFontSize - 1, toggleX, toggleY,\n\t\t\t\t\texpanded ? IMGUI_ICON_CODEPOINT_EXPANDED : IMGUI_ICON_CODEPOINT_COLLAPSED,\n\t\t\t\t\ttoggleColor.r, toggleColor.g, toggleColor.b);\n\t\t\t}\n\t\t\t\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->hierarchyLabelFontSize,\n\t\t\t\ttoggleX + toggleArea.w, toggleY - 3 + 1, name,\n\t\t\t\ts->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n\t\t}\n\n\t\tresult.activated = activated;\n\t\tresult.dragging = Internal::gState->activeControl == widgetId;\n\t\treturn result;\n\t}\n\n\tfloat Split(const Rect& screenPos, bool horizontal, float minSplitterSize, float normalizedDivider) {\n\t\tif (normalizedDivider < 0.0f) {\n\t\t\tnormalizedDivider = 0.0f;\n\t\t}\n\t\telse if (normalizedDivider > 1.0f) {\n\t\t\tnormalizedDivider = 1.0f;\n\t\t}\n\n\t\tf32 x = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 y = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouseVector(x / dpi, y / dpi);\n\n\t\tRect grabberArea;\n\t\tif (!horizontal) {\n\t\t\tfloat divider = screenPos.w * normalizedDivider;\n\t\t\tgrabberArea.x = (screenPos.x + divider) - (IMGUI_SPLITTER_GRABBABLE_WIDTH / 2.0f);\n\t\t\tgrabberArea.w = IMGUI_SPLITTER_GRABBABLE_WIDTH;\n\t\t\tgrabberArea.y = screenPos.y;\n\t\t\tgrabberArea.h = screenPos.h;\n\n\t\t}\n\t\telse {\n\t\t\tfloat divider = screenPos.h * normalizedDivider;\n\n\t\t\tgrabberArea.x = screenPos.x;\n\t\t\tgrabberArea.w = screenPos.w;\n\t\t\tgrabberArea.y = (screenPos.y + divider) - (IMGUI_SPLITTER_GRABBABLE_WIDTH / 2.0f);\n\t\t\tgrabberArea.h = IMGUI_SPLITTER_GRABBABLE_WIDTH;\n\t\t}\n\n\t\ti32 widgetId = Internal::gState->NegativeId(grabberArea);\n\t\tInternal::MakeHotOrActive(widgetId, grabberArea, mouseVector, 0);\n\n\t\tif (!horizontal) {\n\t\t\t// Move the splitter to normalizedDivider\n\t\t\tfloat targetX = normalizedDivider * screenPos.w + screenPos.x;\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\ttargetX = x / dpi; // Track the mouse\n\t\t\t}\n\n\t\t\t{ // Constrain splitter to control\n\t\t\t\tif (targetX < screenPos.x) {\n\t\t\t\t\ttargetX = screenPos.x;\n\t\t\t\t}\n\t\t\t\tif (targetX > screenPos.x + screenPos.w) {\n\t\t\t\t\ttargetX = screenPos.x + screenPos.w;\n\t\t\t\t}\n\n\t\t\t\t// Respect min sizes (adjust right first to keep left always visible?\n\t\t\t\tif (screenPos.w - (targetX - screenPos.x) < minSplitterSize) { // Right side is too small\n\t\t\t\t\ttargetX = screenPos.x + screenPos.w - minSplitterSize;\n\t\t\t\t}\n\t\t\t\tif (targetX - screenPos.x < minSplitterSize) { // Left side is too small\n\t\t\t\t\ttargetX = screenPos.x + minSplitterSize;\n\t\t\t\t}\n\n\t\t\t\tfloat normalizedTarget = (targetX - screenPos.x) / screenPos.w;\n\t\t\t\tnormalizedDivider = MathMaxF(MathMinF(normalizedTarget, 1.0f), 0.0f);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Move the splitter to normalizedDivider\n\t\t\tfloat targetY = (normalizedDivider) * screenPos.h + screenPos.y;\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\ttargetY = y / dpi; // Track the mouse\n\t\t\t}\n\n\t\t\t{ // Constrain splitter to control\n\t\t\t\tif (targetY < screenPos.y) {\n\t\t\t\t\ttargetY = screenPos.y;\n\t\t\t\t}\n\t\t\t\tif (targetY > screenPos.y + screenPos.h) {\n\t\t\t\t\ttargetY = screenPos.y + screenPos.h;\n\t\t\t\t}\n\n\t\t\t\t// Respect min sizes (adjust right first to keep left always visible?\n\t\t\t\tif (screenPos.h - (targetY - screenPos.y) < minSplitterSize) { // Top side is too small\n\t\t\t\t\ttargetY = screenPos.y + screenPos.h - minSplitterSize;\n\t\t\t\t}\n\t\t\t\tif (targetY - screenPos.y < minSplitterSize) { // Bottom side is too small\n\t\t\t\t\ttargetY = screenPos.y + minSplitterSize;\n\t\t\t\t}\n\n\t\t\t\tfloat normalizedTarget = (targetY - screenPos.y) / screenPos.h;\n\t\t\t\tnormalizedDivider = MathMaxF(MathMinF(normalizedTarget, 1.0f), 0.0f);\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ // Drawing\n\t\t\tfloat colorA[3] = {\n\t\t\t\tInternal::gState->style->dividerAColor.r, Internal::gState->style->dividerAColor.g, Internal::gState->style->dividerAColor.b\n\t\t\t};\n\t\t\tfloat colorB[3] = {\n\t\t\t\tInternal::gState->style->dividerBColor.r, Internal::gState->style->dividerBColor.g, Internal::gState->style->dividerBColor.b\n\t\t\t};\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tcolorA[0] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorA[1] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorA[2] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorB[0] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorB[1] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorB[2] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tSetTooltipIcon(horizontal ? IMGUI_ICON_CODEPOINT_RESIZE_VERTICAL : IMGUI_ICON_CODEPOINT_RESIZE_HORIZONTAL);\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tcolorA[0] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorA[1] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorA[2] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorB[0] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorB[1] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorB[2] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tif (Internal::gState->activeControl == 0) {\n\t\t\t\t\tSetTooltipIcon(horizontal ? IMGUI_ICON_CODEPOINT_RESIZE_VERTICAL : IMGUI_ICON_CODEPOINT_RESIZE_HORIZONTAL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRect splitterArea = SplitFirstArea(screenPos, horizontal, normalizedDivider);\n\n\t\t\tRect line(\n\t\t\t\tsplitterArea.x + splitterArea.w, splitterArea.y,\n\t\t\t\t2, splitterArea.h);\n\n\t\t\tif (horizontal) {\n\t\t\t\tline.x = splitterArea.x;\n\t\t\t\tline.y = splitterArea.y + splitterArea.h;\n\t\t\t\tline.w = splitterArea.w;\n\t\t\t\tline.h = 2;\n\t\t\t}\n\n\t\t\tDraw2D::DrawRect(line.x, line.y, line.w, line.h, colorA[0], colorA[1], colorA[2]);\n\n\t\t\tif (horizontal) {\n\t\t\t\tline.y += 1;\n\t\t\t\tline.h -= 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tline.x += 1;\n\t\t\t\tline.w -= 1;\n\t\t\t}\n\n\t\t\tDraw2D::DrawRect(line.x, line.y, line.w, line.h, colorB[0], colorB[1], colorB[2]);\n\t\t}\n\n\t\treturn normalizedDivider;\n\t}\n\n\tRect SplitFirstArea(const Rect& screenPos, bool horizontal, float splitter) {\n\t\tRect result = screenPos;\n\t\tif (splitter < 0.0f) { splitter = 0.0f; }\n\t\tif (splitter > 1.0f) { splitter = 1.0f; }\n\n\t\tif (!horizontal) {\n\t\t\tresult.x = MathFloor(screenPos.x);\n\t\t\tresult.w = MathFloor(screenPos.w * splitter);\n\t\t\tresult.w -= 1; // Padding for grabber\n\t\t}\n\t\telse {\n\t\t\tresult.y = MathFloor(screenPos.y);\n\t\t\tresult.h = MathFloor(screenPos.h * splitter);\n\t\t\tresult.h -= 1; // Padding for for grabber\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tRect SplitSecondArea(const Rect& screenPos, bool horizontal, float splitter) {\n\t\tRect result = screenPos;\n\t\tif (splitter < 0.0f) { splitter = 0.0f; }\n\t\tif (splitter > 1.0f) { splitter = 1.0f; }\n\t\tRect firstArea = SplitFirstArea(screenPos, horizontal, splitter);\n\n\t\tif (!horizontal) {\n\t\t\tresult.x = firstArea.x + firstArea.w;\n\t\t\tresult.w = MathMaxF(screenPos.w - firstArea.w, 0.0f);\n\n\t\t\t// For grabber\n\t\t\tresult.x += 2;\n\t\t\tresult.w -= 2;\n\t\t}\n\t\telse {\n\t\t\tresult.y = firstArea.y + firstArea.h;\n\t\t\tresult.h = MathMaxF(screenPos.h - firstArea.h, 0.0f);\n\n\t\t\t// For grabber\n\t\t\tresult.y += 2;\n\t\t\tresult.h -= 2;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tPoint GetPointer() {\n\t\treturn Point(Internal::gState->GetPointerX() / Internal::gState->dpi, Internal::gState->GetPointerY() / Internal::gState->dpi);\n\t}\n\n\tbool PointerReleased() {\n\t\treturn Internal::gState->GetPointerReleased();\n\t}\n\n\tbool GetPulse() {\n\t\treturn Internal::gState->pulse;\n\t}\n\n\tvoid Label(const Rect& screenPos, const char* text, bool disabled) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 fontSize = screenPos.h;\n\n\t\tStyleColor c = s->labelFontColorNormal;\n\t\tif (disabled) {\n\t\t\tc = s->labelFontColorDisabled;\n\t\t}\n\n\t\tDraw2D::DrawString(Internal::gState->interfaceFont, screenPos.h, screenPos.x, screenPos.y + screenPos.h, text, c.r, c.g, c.b);\n\t}\n\n\tu32 Header(const Rect& screenPos, const char** options, u32 numOptions, u32 selectedOption) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, s->headerBgColor.r, s->headerBgColor.g, s->headerBgColor.b);\n\t\tDraw2D::DrawRect(screenPos.x, i32(screenPos.y + screenPos.h) - 2, screenPos.w, 1, s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\t\t\n\t\tfloat carrat = screenPos.x;\n\t\tImgui::Point mousePos(Internal::gState->GetPointerX() / Internal::gState->dpi,\n\t\t\tInternal::gState->GetPointerY() / Internal::gState->dpi);\n\n\t\tfloat colorA[3] = {\n\t\t\t\tInternal::gState->style->dividerAColor.r, Internal::gState->style->dividerAColor.g, Internal::gState->style->dividerAColor.b\n\t\t};\n\t\tfloat colorB[3] = {\n\t\t\tInternal::gState->style->dividerBColor.r, Internal::gState->style->dividerBColor.g, Internal::gState->style->dividerBColor.b\n\t\t};\n\n\t\tu32 result = selectedOption;\n\n\t\tfor (u32 i = 0; i < numOptions; ++i) {\n\n\t\t\tDraw2D::Size stringSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->headerFontSize, options[i]);\n\t\t\tstringSize.w += 10;\n\n\t\t\tRect clickArea(carrat, screenPos.y, stringSize.w, screenPos.h);\n\t\t\ti32 widgetId = Internal::gState->NegativeId(clickArea);\n\n\t\t\tif (Contains(clickArea, mousePos)) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, clickArea, vec2(mousePos.x, mousePos.y), 0)) {\n\t\t\t\t\tresult = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tDraw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h, s->HeaderBGActiveColor.r, s->HeaderBGActiveColor.g, s->HeaderBGActiveColor.b);\n\t\t\t}\n\t\t\telse  if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tDraw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h, s->HeaderBGHotColor.r, s->HeaderBGHotColor.g, s->HeaderBGHotColor.b);\n\t\t\t}\n\t\t\telse if (result == i) {\n\t\t\t\tDraw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h, s->HeaderBGActiveColor.r, s->HeaderBGActiveColor.g, s->HeaderBGActiveColor.b);\n\t\t\t}\n\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->headerFontSize,\n\t\t\t\tcarrat + 5, screenPos.y + 3 + s->headerFontSize, options[i],\n\t\t\t\ts->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n\t\t\t\n\t\t\tcarrat += stringSize.w;\n\n\t\t\tif (i + 1 < numOptions) {\n\t\t\t\tRect divider = screenPos;\n\t\t\t\tdivider.x = carrat;\n\t\t\t\tdivider.w = 2;\n\t\t\t\tDraw2D::DrawRect(divider.x, divider.y, divider.w, divider.h, colorA[0], colorA[1], colorA[2]);\n\t\t\t\tdivider.x = carrat + 1;\n\t\t\t\tdivider.w = 1;\n\t\t\t\tDraw2D::DrawRect(divider.x, divider.y, divider.w, divider.h, colorB[0], colorB[1], colorB[2]);\n\t\t\t\tcarrat += 2;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvoid SetTooltipIcon(int codePoint) {\n\t\tInternal::gState->tooltipIcon = codePoint;\n\t}\n\n\tvoid SetTooltipLabel(const char* label) {\n\t\tInternal::gState->tooltipLabel = label;\n\t}\n\n\tPoint GetPointer(float dpi) {\n\t\treturn Point(Internal::gState->GetPointerX() / dpi, Internal::gState->GetPointerY() / dpi);\n\t}\n\n\tvoid Icon(const Rect& screenPos, u32 iconSize, u32 codePoint, float r, float g, float b, float a) {\n\t\tDraw2D::DrawCodePoint(\n\t\t\tInternal::gState->widgetFont, iconSize,\n\t\t\tscreenPos.x,\n\t\t\tscreenPos.y + iconSize,\n\t\t\tcodePoint,\n\t\t\tr, g, b, a\n\t\t);\n\t}\n\n\tbool HandleScroll(const Rect& scrollArea) {\n\t\tfloat dpi = Internal::gState->dpi;\n\t\tfloat mouseX = Internal::gState->GetPointerX() / dpi;\n\t\tfloat mouseY = Internal::gState->GetPointerY() / dpi;\n\t\treturn Contains(scrollArea, Point(mouseX, mouseY));\n\t}\n\n\tfloat ScrollBar(const Rect& screenPos, float value, bool horizontal, float grabberSize, bool handleScroll) {\n\t\ti32 scrollTrackId = Internal::gState->NegativeId(screenPos);\n\t\t// TODO: The scroll Track id here is actually wrong. To make a proper scroll track, we would need two buttons!\n\t\t// one on top, one on bottom. OMG, EXTEND THE UP / DOWN ARROW HIT AREAS / LOGIC?!?!?!?\n\n\t\tfloat dpi = Internal::gState->dpi;\n\t\tPoint mousePos((float)Internal::gState->GetPointerX() / dpi, (float)Internal::gState->GetPointerY() / dpi);\n\t\tPoint mouseDelta((float)Internal::gState->GetPointerDeltaX() / dpi, (float)Internal::gState->GetPointerDeltaY() / dpi);\n\t\t\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tif (grabberSize < 0.0f) {\n\t\t\tgrabberSize = 0.0f;\n\t\t}\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\ts->scrollBarTrackBG.r, s->scrollBarTrackBG.g, s->scrollBarTrackBG.b);\n\n\t\tu32 arrowAIcon = 0;\n\t\tu32 arrowBIcon = 0;\n\n\t\tfloat v = value;\n\t\tif (v < 0.0f) {\n\t\t\tv = 0.0f;\n\t\t}\n\t\telse if (v > 1.0f) {\n\t\t\tv = 1.0f;\n\t\t}\n\n\t\tRect arrowAArea = screenPos;\n\t\tRect arrowBArea = screenPos;\n\t\tRect track = screenPos;\n\t\tRect grabHandle = screenPos;\n\n\t\tStyleColor iconAColor = s->scrollBarIconNormal;\n\t\tStyleColor iconBColor = s->scrollBarIconNormal;\n\n\t\tif (horizontal) {\n\t\t\tarrowAIcon = IMGUI_ICON_CODEPOINT_ARROW_LEFT;\n\t\t\tarrowBIcon = IMGUI_ICON_CODEPOINT_ARROW_RIGHT;\n\t\t\tarrowAArea.w = arrowAArea.h;\n\t\t\tarrowBArea.w = arrowBArea.h;\n\t\t\tarrowBArea.x = screenPos.x + screenPos.w - arrowBArea.w;\n\n\t\t\t// Set track between arrows\n\t\t\ttrack.x += arrowAArea.w;\n\t\t\ttrack.w -= arrowAArea.w * 2.0f;\n\n\t\t\t// Add 1px gab before / after arrows\n\t\t\ttrack.x += 1;\n\t\t\ttrack.w -= 2;\n\n\t\t\tif (grabberSize > track.w - track.w / 4.0f) {\n\t\t\t\tgrabberSize = track.w - track.w / 4.0f;\n\t\t\t}\n\n\t\t\t// Adjust track area for grabber\n\t\t\ttrack.x += grabberSize / 2.0f;\n\t\t\ttrack.w -= grabberSize;\n\n\t\t\tif (grabberSize > 0.0f) {\n\t\t\t\tgrabHandle.h -= 6;\n\t\t\t\tgrabHandle.y += 3;\n\t\t\t\tgrabHandle.w = grabberSize;\n\n\t\t\t\tfloat handlePos = track.w * v + track.x;\n\t\t\t\tgrabHandle.x = handlePos - grabberSize / 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tarrowAIcon = IMGUI_ICON_CODEPOINT_ARROW_UP;\n\t\t\tarrowBIcon = IMGUI_ICON_CODEPOINT_ARROW_DOWN;\n\t\t\tarrowAArea.h = arrowAArea.w;\n\t\t\tarrowBArea.h = arrowBArea.w;\n\t\t\tarrowBArea.y = screenPos.y + screenPos.h - arrowBArea.h;\n\n\t\t\t// Set track between arrows\n\t\t\ttrack.y += arrowBArea.h;\n\t\t\ttrack.h -= arrowBArea.h * 2.0f;\n\n\t\t\t// Add 1px gab before / after arrows\n\t\t\ttrack.y += 1;\n\t\t\ttrack.h -= 2;\n\n\t\t\tif (grabberSize > track.h - track.h / 4.0f) {\n\t\t\t\tgrabberSize = track.h - track.h / 4.0f;\n\t\t\t}\n\n\t\t\t// Adjust track area for grabber\n\t\t\ttrack.y += grabberSize / 2.0f;\n\t\t\ttrack.h -= grabberSize;\n\n\t\t\tif (grabberSize > 0.0f) {\n\t\t\t\tgrabHandle.w -= 6;\n\t\t\t\tgrabHandle.x += 3;\n\t\t\t\tgrabHandle.h = grabberSize;\n\n\t\t\t\tfloat handlePos = track.h * v + track.y;\n\t\t\t\tgrabHandle.y = handlePos - grabberSize / 2;\n\t\t\t}\n\t\t}\n\n\t\ti32 scrollUpId = Internal::gState->NegativeId(arrowAArea); \n\t\ti32 scrollDownId = Internal::gState->NegativeId(arrowBArea);\n\t\ti32 scrollHandleId = Internal::gState->NegativeId(grabHandle);\n\n\t\tif (grabberSize > 0.0f) {\n\t\t\tInternal::MakeHotOrActive(scrollUpId, arrowAArea, vec2(mousePos.x, mousePos.y), 0);\n\t\t\tInternal::MakeHotOrActive(scrollDownId, arrowBArea, vec2(mousePos.x, mousePos.y), 0);\n\t\t\tInternal::MakeHotOrActive(scrollHandleId, grabHandle, vec2(mousePos.x, mousePos.y), 0);\n\t\t}\n\n\t\tif (Internal::gState->activeControl == scrollUpId) {\n\t\t\tif (Internal::gState->pulse) {\n\t\t\t\tv -= 0.1f;\n\t\t\t}\n\t\t}\n\t\telse if (Internal::gState->activeControl == scrollDownId) {\n\t\t\tif (Internal::gState->pulse) {\n\t\t\t\tv += 0.1f;\n\t\t\t}\n\t\t}\n\t\telse if (Internal::gState->activeControl == scrollHandleId) {\n\t\t\tfloat scroll_v = 0.0f;\n\t\t\tif (horizontal) {\n\t\t\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\t\tscroll_v = mouseDelta.x / track.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\t\tscroll_v = mouseDelta.y / track.h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv += scroll_v;\n\t\t}\n\t\telse if (handleScroll) { // This is the scroll wheel here\n\t\t\ti32 scroll = MouseGetScroll();\n\t\t\ti32 prev = MousePrevScroll();\n\t\t\tif (scroll != prev) {\n\t\t\t\tif (scroll > 0) {\n\t\t\t\t\tv -= 0.1f;\n\t\t\t\t}\n\t\t\t\telse if (scroll < 0) {\n\t\t\t\t\tv += 0.1f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v < 0.0f) {\n\t\t\tv = 0.0f;\n\t\t}\n\t\telse if (v > 1.0f) {\n\t\t\tv = 1.0f;\n\t\t}\n\n\t\tif ((Internal::gState->hotControl == scrollUpId && Internal::gState->activeControl == 0)|| Internal::gState->activeControl == scrollUpId) {\n\t\t\ticonAColor = s->scrollBarIconHot;\n\t\t\tDraw2D::DrawRect(arrowAArea.x, arrowAArea.y, arrowAArea.w, arrowAArea.h,\n\t\t\t\ts->scrollBarHotButtonBg.r, s->scrollBarHotButtonBg.g, s->scrollBarHotButtonBg.b);\n\t\t}\n\t\telse if ((Internal::gState->hotControl == scrollDownId && Internal::gState->activeControl == 0) || Internal::gState->activeControl == scrollDownId) {\n\t\t\ticonBColor = s->scrollBarIconHot;\n\t\t\tDraw2D::DrawRect(arrowBArea.x, arrowBArea.y, arrowBArea.w, arrowBArea.h,\n\t\t\t\ts->scrollBarHotButtonBg.r, s->scrollBarHotButtonBg.g, s->scrollBarHotButtonBg.b);\n\t\t}\n\t\t\n\t\tif (grabberSize > 0.0f) {\n\t\t\tImgui::Icon(arrowAArea, s->scrollIconSize, arrowAIcon, iconAColor.r, iconAColor.g, iconAColor.b);\n\t\t\tImgui::Icon(arrowBArea, s->scrollIconSize, arrowBIcon, iconBColor.r, iconBColor.g, iconBColor.b);\n\t\t}\n\n\t\tif (grabberSize > 0.0f) { // Handle\n\t\t\tif ((Internal::gState->hotControl == scrollHandleId && Internal::gState->activeControl == 0) || Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\tDraw2D::DrawRect(grabHandle.x, grabHandle.y, grabHandle.w, grabHandle.h,\n\t\t\t\t\ts->scrollGrabberHot.r, s->scrollGrabberHot.g, s->scrollGrabberHot.b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDraw2D::DrawRect(grabHandle.x, grabHandle.y, grabHandle.w, grabHandle.h,\n\t\t\t\t\ts->scrollGrabberNormal.r, s->scrollGrabberNormal.g, s->scrollGrabberNormal.b);\n\t\t\t}\n\t\t}\n\n\t\tif (grabberSize <= 0.0f) {\n\t\t\treturn 0.0f;\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tbool ClickArea(const Rect& screenPos) {\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\t\treturn Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0);\n\t}\n\n\tbool FooterButton(const Rect& screenPos, u32 codePoint, const char* caption) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tu32 iconSize = u32(s->hierarchyFooterButtonSize) - 4;\n\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool result = Internal::MakeHotOrActive(widgetId, screenPos, mouse, caption);\n\n\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\tStyleColor border = s->hierarchyFooterButtonBorder_Active;\n\t\t\tStyleColor button = s->hierarchyFooterButtonBG_Active;\n\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\t\tborder.r, border.g, border.b);\n\t\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2,\n\t\t\t\tbutton.r, button.g, button.b);\n\t\t}\n\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\tStyleColor border = s->hierarchyFooterButtonBorder_Hot;\n\t\t\tStyleColor button = s->hierarchyFooterButtonBG_Hot;\n\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\t\tborder.r, border.g, border.b);\n\t\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2,\n\t\t\t\tbutton.r, button.g, button.b);\n\t\t}\n#if 0\n\t\telse { // Debugging for normal state\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, 1, 0, 0);\n\t\t}\n#endif\n\n\t\tStyleColor iconColor = s->hierarchyFooterButtonIcon;\n\t\tDraw2D::DrawCodePoint(\n\t\t\tInternal::gState->widgetFont, iconSize,\n\t\t\tscreenPos.x + 2,\n\t\t\tscreenPos.y + iconSize + 3,\n\t\t\tcodePoint,\n\t\t\ticonColor.r, iconColor.g, iconColor.b, 1.0f\n\t\t);\n\n\t\treturn result;\n\t}\n\n\tvoid Label(const Rect& screenPos, const char* text, u32 fontHeight) {\n\t\t// TODO: Build the label\n\t}\n\n\tbool IconToggle(const Rect& screenPos, u32 trueIcon, u32 falseIcon, bool state, bool disabled) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tu32 iconSize = u32(screenPos.h) - 6;\n\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool result = state;\n\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0)) {\n\t\t\tresult = !result;\n\t\t}\n\n\t\tStyleColor borderColor = s->toggleButtonBorder;\n\t\tif (disabled) {\n\t\t\tborderColor = s->toggleButtonDisabledBorder;\n\t\t}\n\t\t// Draw outline\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, borderColor.r, borderColor.g, borderColor.b);\n\t\t\n\t\tStyleColor bgColor = s->toggleButtonNormal;\n\t\tif (disabled) {\n\t\t\tbgColor = s->toggleButtonDisabled;\n\t\t}\n\t\telse if (state) {\n\t\t\tbgColor = s->toggleButtonActive;\n\t\t\tif (Internal::gState->hotControl == widgetId) {\n\t\t\t\tbgColor = s->toggleButtonHot;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tbgColor = s->toggleButtonActive;\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tbgColor = s->toggleButtonHot;\n\t\t\t}\n\t\t}\n\n\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, bgColor.r, bgColor.g, bgColor.b);\n\n\t\tStyleColor iconColor = s->textAreaFont_Normal;\n\t\tif (disabled) {\n\t\t\ticonColor = s->textAreaFont_Disabled;\n\t\t}\n\n\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, screenPos.h - 6, screenPos.x + 3, screenPos.y + 3 + (screenPos.h - 6), \n\t\t\tstate ? falseIcon : trueIcon, iconColor.r, iconColor.g, iconColor.b);\n\n\t\treturn result;\n\t}\n\n\tconst char* TextArea(const Rect& screenPos, const char* inputText, const char* label, bool disabled, bool fraction) {\n\t\tPlatformAssert(inputText != 0, __LOCATION__);\n\t\tPlatformAssert(label != 0, __LOCATION__);\n\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->PositiveId(screenPos);\n\n\t\tbool kbdActivate = false;\n\t\tif (Internal::gState->grabKeyboardOnOrAfter > 0) {\n\t\t\tif (widgetId == Internal::gState->grabKeyboardOnOrAfter) {\n\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = 0;\n\t\t\t\tkbdActivate = true;\n\t\t\t}\n\t\t}\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tconst char* string = inputText;\n\t\tu32 inputTextLength = Internal::StrLen(string);\n\t\tDraw2D::Size inputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\tbool return_hit = false;\n\n\t\tInternal::TextAreaInstance* textArea = 0;\n\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0) || kbdActivate) {\n\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId || Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\t// Claim text area (guaranteed to exist at this point)\n\t\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaA;\n\t\t\t\t}\n\t\t\t\telse if (Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaB;\n\t\t\t\t}\n\t\t\t\tPlatformAssert(textArea != 0, __LOCATION__);\n\n\t\t\t\t// Select which text to work with\n\t\t\t\tif (textArea != 0) {\n\t\t\t\t\tstring = textArea->buffer;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstring = inputText;\n\t\t\t\t}\n\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\t\t\t// Select everything on double click\n\t\t\t\tif (Internal::gState->lastTextDoubleClickTimer < IMGUI_DOUBLECLICK_SECOND) {\n\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInternal::gState->lastTextDoubleClickTimer = 0.0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Internal::gState->textAreaA.widgetId == 0) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaA;\n\n\t\t\t\t\tif (Internal::gState->textAreaB.widgetId != 0) {\n\t\t\t\t\t\tInternal::gState->textAreaB.state = Internal::TextAreaState::Shutdown;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInternal::gState->textAreaA.state = Internal::TextAreaState::Shutdown;\n\t\t\t\t\tPlatformAssert(Internal::gState->textAreaB.widgetId == 0, __LOCATION__);\n\t\t\t\t\ttextArea = &Internal::gState->textAreaB;\n\t\t\t\t}\n\n\t\t\t\ttextArea->widgetId = widgetId;\n\t\t\t\ttextArea->state = Internal::TextAreaState::Activated;\n\t\t\t\ttextArea->karratIndex = 0;// stringLength > 0 ? stringLength - 1 : 0;\n\t\t\t\ttextArea->selection = Internal::StrLen(inputText); // 0 to string length is select everything\n\t\t\t\ttextArea->Reserve(inputTextLength);\n\t\t\t\ttextArea->Set(inputText, textArea->selection);\n\n\t\t\t\t// Select which text to work with\n\t\t\t\tif (textArea != 0) {\n\t\t\t\t\tstring = textArea->buffer;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstring = inputText;\n\t\t\t\t}\n\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId || Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaA;\n\t\t\t\t}\n\t\t\t\telse if (Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaB;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Select which text to work with\n\t\t\tif (textArea != 0) {\n\t\t\t\tstring = textArea->buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstring = inputText;\n\t\t\t}\n\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\t\tif (textArea != 0) {\n\t\t\t\ttextArea->state = Internal::TextAreaState::Idle;\n\t\t\t\tif (Internal::gState->GetPointerPressed()) {\n\t\t\t\t\t// Shutdown if mouse clicked outside\n\t\t\t\t\tif (!Contains(screenPos, Imgui::Point(mouse.x, mouse.y))) {\n\t\t\t\t\t\ttextArea->state = Internal::TextAreaState::Shutdown;\n\t\t\t\t\t}\n\t\t\t\t\t// Move karrat if mouse clicked inside\n\t\t\t\t\telse {\n\t\t\t\t\t\tvec2 adjustedMouse = mouse;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (inputTextSize.w >= screenPos.w - 6) { // To keep karrat on screen :(\n\t\t\t\t\t\t\tDraw2D::Rect distanceToKarrat = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\t\t\t\t\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\t\t\t\t\tfloat karrat_x = string_x + distanceToKarrat.w;\n\n\t\t\t\t\t\t\tif (karrat_x < screenPos.x) {\n\t\t\t\t\t\t\t\tfloat delta = screenPos.x - karrat_x;\n\t\t\t\t\t\t\t\tdelta += 5; // Arbitrary\n\t\t\t\t\t\t\t\tadjustedMouse.x -= delta;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (karrat_x > screenPos.x + screenPos.w) {\n\t\t\t\t\t\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti32 index = Internal::GetStringIndexUnderMouse(string, inputTextLength, screenPos, inputTextSize, adjustedMouse);\n\t\t\t\t\t\ttextArea->karratIndex = index;\n\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the mouse is being dragged\n\t\t\t\telse if (!Internal::gState->GetPointerUp()) {\n\t\t\t\t\tvec2 fakeMouse = mouse;\n\t\t\t\t\tfakeMouse.y = screenPos.y;\n\t\t\t\t\tif (inputTextSize.w >= screenPos.w - 6) { // To keep karrat on screen :(\n\t\t\t\t\t\tDraw2D::Rect distanceToKarrat = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\t\t\t\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\t\t\t\tfloat karrat_x = string_x + distanceToKarrat.w;\n\n\t\t\t\t\t\tif (karrat_x < screenPos.x) {\n\t\t\t\t\t\t\tfloat delta = screenPos.x - karrat_x;\n\t\t\t\t\t\t\tdelta += 5; // Arbitrary\n\t\t\t\t\t\t\tfakeMouse.x -= delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (karrat_x > screenPos.x + screenPos.w) {\n\t\t\t\t\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti32 index = Internal::GetStringIndexUnderMouse(string, inputTextLength, screenPos, inputTextSize, fakeMouse);\n\t\t\t\t\ttextArea->selection = index - textArea->karratIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Handle text input. Text area, karrat and selection are all done by now\n\t\tbool shift = KeyboardDown(KeyboardCodeShift);\n\t\tbool control = KeyboardDown(KeyboardCodeControl);\n\n\t\tif (textArea != 0) {\n\t\t\tif (textArea->state == Internal::TextAreaState::Activated) {\n\t\t\t}\n\t\t\telse if (textArea->state == Internal::TextAreaState::Idle) {\n\t\t\t\t{ // Process text input\n\t\t\t\t\tu32 keyCode = ConsumeKeyQueue();\n\t\t\t\t\tbool processed_key = false;\n\t\t\t\t\twhile (keyCode != KeyboardCodeLeftMouse) {\n\t\t\t\t\t\tprocessed_key = true;\n\t\t\t\t\t\tchar ascii = ScanCodeToAscii(keyCode, shift);\n\n\t\t\t\t\t\tbool skipCharacter = false;\n\t\t\t\t\t\tif (fraction) {\n\t\t\t\t\t\t\tskipCharacter = true;\n\t\t\t\t\t\t\tif (ascii >= '0' && ascii <= '9') {\n\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == '.') {\n\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\tfor (i32 i = 0; i < textArea->length; ++i) {\n\t\t\t\t\t\t\t\t\tif (textArea->buffer[i] == '.') {\n\t\t\t\t\t\t\t\t\t\tskipCharacter = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == '-') {\n\t\t\t\t\t\t\t\tif (textArea->length == 0) {\n\t\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (textArea->karratIndex == 0) {\n\t\t\t\t\t\t\t\t\tif (textArea->length > 0) {\n\t\t\t\t\t\t\t\t\t\tif (textArea->buffer[0] != '-') {\n\t\t\t\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure the text areas buffer has enough room\n\t\t\t\t\t\tif (textArea->length + 2 >= textArea->capacity) {\n\t\t\t\t\t\t\tif (textArea->capacity < 16) {\n\t\t\t\t\t\t\t\ttextArea->capacity = 16;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextArea->capacity *= 2;\n\t\t\t\t\t\t\ttextArea->buffer = (char*)MemRealloc(textArea->buffer, textArea->capacity);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (control) {\n\t\t\t\t\t\t\tif (ascii == 'c' || ascii == 'C') {\n\t\t\t\t\t\t\t\tchar* toCopy = Internal::GetSubString(textArea->buffer, textArea->karratIndex, textArea->karratIndex + textArea->selection);\n\t\t\t\t\t\t\t\tif (toCopy != 0) {\n\t\t\t\t\t\t\t\t\tWriteClipboard(toCopy);\n\t\t\t\t\t\t\t\t\tMemRelease(toCopy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == 'v' || ascii == 'V') {\n\t\t\t\t\t\t\t\tchar* toPaste = ReadClipboard();\n\t\t\t\t\t\t\t\tif (toPaste != 0) {\n\t\t\t\t\t\t\t\t\ti32 len = Internal::StrLen(toPaste);\n\n\t\t\t\t\t\t\t\t\t// Make sure text area has enough room\n\t\t\t\t\t\t\t\t\tif (textArea->capacity <= len) {\n\t\t\t\t\t\t\t\t\t\ttextArea->capacity = len + (len / 2);\n\t\t\t\t\t\t\t\t\t\ttextArea->buffer = (char*)MemRealloc(textArea->buffer, textArea->capacity);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Copy text\n\t\t\t\t\t\t\t\t\tfor (i32 i = 0; i < len; ++i) {\n\t\t\t\t\t\t\t\t\t\ttextArea->buffer[i] = toPaste[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttextArea->buffer[len] = 0;\n\t\t\t\t\t\t\t\t\ttextArea->length = len;\n\n\t\t\t\t\t\t\t\t\t// Update internal numbers\n\t\t\t\t\t\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\t\t\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\t\t\t\t\t\t\t\t// Move karrat to end\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = inputTextLength;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == 'x' || ascii == 'X') {\n\t\t\t\t\t\t\t\tchar* toCopy = Internal::GetSubString(textArea->buffer, textArea->karratIndex, textArea->karratIndex + textArea->selection);\n\t\t\t\t\t\t\t\tif (toCopy != 0) {\n\t\t\t\t\t\t\t\t\tWriteClipboard(toCopy);\n\t\t\t\t\t\t\t\t\tMemRelease(toCopy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == 'a' || ascii == 'A') {\n\t\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle text clear if there is any text selected\n\t\t\t\t\t\tbool clearedText = false;\n\t\t\t\t\t\tif (textArea->selection != 0 && ascii != '\\t' && ascii != '\\n' && ascii != 0) {\n\t\t\t\t\t\t\tif (!control || (control && (ascii == 'X' || ascii == 'x'))) {\n\t\t\t\t\t\t\t\tif (fraction && skipCharacter) {\n\t\t\t\t\t\t\t\t\t// Ignore key. I think that's the right call here\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ti32 startIndex = textArea->karratIndex;\n\t\t\t\t\t\t\t\t\ti32 endIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t\tif (endIndex < startIndex) {\n\t\t\t\t\t\t\t\t\t\ti32 tmp = endIndex;\n\t\t\t\t\t\t\t\t\t\tendIndex = startIndex;\n\t\t\t\t\t\t\t\t\t\tstartIndex = tmp;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tPlatformAssert(endIndex != startIndex, __LOCATION__);\n\n\t\t\t\t\t\t\t\t\tInternal::RemoveRangeFromString(textArea->buffer, textArea->length, startIndex, endIndex);\n\t\t\t\t\t\t\t\t\ti32 lengthRemoved = endIndex - startIndex;\n\t\t\t\t\t\t\t\t\ttextArea->length -= lengthRemoved;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = startIndex;\n\t\t\t\t\t\t\t\t\tclearedText = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Append character after karrat\n\t\t\t\t\t\tif (control) {\n\t\t\t\t\t\t\t// Already handled\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\n') {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\n\t\t\t\t\t\t\treturn_hit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\t') {\n\t\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = widgetId - 1; // Let the next box grab it\n\t\t\t\t\t\t\t\tif (Internal::gState->grabKeyboardOnOrAfter <= 0) {\n\t\t\t\t\t\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextArea->state = Internal::TextAreaState::Shutdown; // Shut us down\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = widgetId + 1; // Let the next box grab it\n\t\t\t\t\t\t\t\ttextArea->state = Internal::TextAreaState::Shutdown; // Shut us down\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\b') {\n\t\t\t\t\t\t\tif (!clearedText) {\n\t\t\t\t\t\t\t\tif (textArea->karratIndex > 0) {\n\t\t\t\t\t\t\t\t\tInternal::RemoveRangeFromString(textArea->buffer, textArea->length, textArea->karratIndex - 1, textArea->karratIndex);\n\t\t\t\t\t\t\t\t\ttextArea->buffer[--textArea->length] = 0;\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex -= 1;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\a') {\n\t\t\t\t\t\t\tif (!clearedText) {\n\t\t\t\t\t\t\t\tif (textArea->length > 0) {\n\t\t\t\t\t\t\t\t\tInternal::RemoveRangeFromString(textArea->buffer, textArea->length, textArea->karratIndex, textArea->karratIndex + 1);\n\t\t\t\t\t\t\t\t\ttextArea->buffer[--textArea->length] = 0;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (textArea->karratIndex > textArea->length - 1) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->length - 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii != 0) {\n\t\t\t\t\t\t\tif (!skipCharacter) {\n\t\t\t\t\t\t\t\t// Shift string to make room for the new character\n\t\t\t\t\t\t\t\tif (textArea->karratIndex < textArea->length && textArea->karratIndex >= 0) {\n\t\t\t\t\t\t\t\t\t// Selection here is alweays 0, so we can just use karratINdex\n\t\t\t\t\t\t\t\t\t// Length + 1 so it overrides null?\n\t\t\t\t\t\t\t\t\tfor (int i = textArea->length; i >= textArea->karratIndex; --i) {\n\t\t\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\t\t\ttextArea->buffer[i] = textArea->buffer[i - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set karrat to current character\n\t\t\t\t\t\t\t\ttextArea->buffer[textArea->karratIndex++] = ascii;\n\t\t\t\t\t\t\t\ttextArea->buffer[++textArea->length] = 0;\n\n\t\t\t\t\t\t\t\t// Show karrat if a character was inserted\n\t\t\t\t\t\t\t\tInternal::gState->blink = true;\n\t\t\t\t\t\t\t\tInternal::gState->blinkTimer = 0.0f;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tkeyCode = ConsumeKeyQueue();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (processed_key) {\n\t\t\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{ // Process arrow nagivation\n\t\t\t\t\ti32 arrowStartIndex = textArea->karratIndex;\n\t\t\t\t\ti32 arrowEndIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\n\t\t\t\t\tbool leftArrowPressed = KeyboardPressed(KeyboardCodeLeft);\n\t\t\t\t\tbool leftArrowDown = KeyboardDown(KeyboardCodeLeft);\n\t\t\t\t\tbool rightArrowPressed = KeyboardPressed(KeyboardCodeRight);\n\t\t\t\t\tbool rightArrowDown = KeyboardDown(KeyboardCodeRight);\n\n\t\t\t\t\tif (leftArrowPressed || rightArrowPressed) {\n\t\t\t\t\t\tInternal::gState->pulseTimer = 0.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (leftArrowDown || rightArrowDown) {\n\t\t\t\t\t\tInternal::gState->blink = true;\n\t\t\t\t\t\tInternal::gState->blinkTimer = 0.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (leftArrowPressed || leftArrowDown) {\n\t\t\t\t\t\tif (Internal::gState->pulse || leftArrowPressed) {\n\t\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\t\tif (arrowEndIndex < arrowStartIndex) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t\ttextArea->selection *= -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tPlatformAssert(textArea->selection >= 0, __LOCATION__);\n\t\t\t\t\t\t\t\tif (textArea->karratIndex > 0) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex -= 1;\n\t\t\t\t\t\t\t\t\ttextArea->selection += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (textArea->selection == 0 && inputTextLength > 0) {\n\t\t\t\t\t\t\t\tif (--textArea->karratIndex < 0) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (textArea->selection != 0) {\n\t\t\t\t\t\t\t\tif (arrowEndIndex < arrowStartIndex) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (rightArrowPressed || rightArrowDown) {\n\t\t\t\t\t\t if (Internal::gState->pulse || rightArrowPressed) {\n\t\t\t\t\t\t\t if (shift) {\n\t\t\t\t\t\t\t\t if (arrowEndIndex < arrowStartIndex) {\n\t\t\t\t\t\t\t\t\t textArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t\t textArea->selection *= -1;\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t PlatformAssert(textArea->selection >= 0, __LOCATION__);\n\t\t\t\t\t\t\t\t if (textArea->karratIndex + textArea->selection < inputTextLength) {\n\t\t\t\t\t\t\t\t\t textArea->selection += 1;\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t else if (textArea->selection == 0 && inputTextLength > 0) {\n\t\t\t\t\t\t\t\tif (++textArea->karratIndex >= inputTextLength) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = inputTextLength;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (textArea->selection != 0) {\n\t\t\t\t\t\t\t\tif (arrowEndIndex > arrowStartIndex) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (KeyboardPressed(KeyboardCodeUp)) {\n\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (KeyboardPressed(KeyboardCodeDown)) {\n\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (inputTextLength > 0) {\n\t\t\t\t\t\t\t\ttextArea->karratIndex = inputTextLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (textArea->state == Internal::TextAreaState::Shutdown) {\n\t\t\t}\n\t\t}\n\n\t\t{ // Drawing\n\t\t\tStyleColor bgColor = s->textAreaBg_Normal;\n\t\t\tStyleColor txtColor = s->textAreaFont_Normal;\n\t\t\tStyleColor outlinColor = s->textAreaOutline_Normal;\n\t\t\tStyleColor labelColor = s->textAreaLabel_Normal;\n\n\t\t\tif (disabled) {\n\t\t\t\tbgColor = s->textAreaBg_Disabled;\n\t\t\t\ttxtColor = s->textAreaFont_Disabled;\n\t\t\t\toutlinColor = s->textAreaOutline_Disabled;\n\t\t\t\tlabelColor = s->textAreaLabel_Disabled;\n\t\t\t}\n\t\t\telse if (Internal::gState->activeControl == widgetId || textArea != 0) {\n\t\t\t\tbgColor = s->textAreaBg_Active;\n\t\t\t\ttxtColor = s->textAreaFont_Active;\n\t\t\t\toutlinColor = s->textAreaOutline_Active;\n\t\t\t\tlabelColor = s->textAreaLabel_Active;\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tbgColor = s->textAreaBg_Hot;\n\t\t\t\ttxtColor = s->textAreaFont_Hot;\n\t\t\t\toutlinColor = s->textAreaOutline_Hot;\n\t\t\t\tlabelColor = s->textAreaLabel_Hot;\n\t\t\t}\n\n\t\t\t// Draw bg\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, outlinColor.r, outlinColor.g, outlinColor.b);\n\t\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, bgColor.r, bgColor.g, bgColor.b);\n\t\t\tDraw2D::DrawString(Internal::gState->labelFont, s->textAreaLabelSize, screenPos.x + 3, screenPos.y, label, labelColor.r, labelColor.g, labelColor.b);\n\n\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\tfloat string_y = screenPos.y + 2;\n\n\t\t\tbool clip = false;\n\t\t\tif (inputTextSize.w > screenPos.w - 6) {\n\t\t\t\tclip = true;\n\t\t\t\tDraw2D::PushClip(screenPos.x + 3, screenPos.y, screenPos.w - 6, screenPos.h);\n\t\t\t}\n\n\t\t\t// Adjust string position so karrat is visible\n\t\t\tDraw2D::Rect distanceToKarrat(0, 0, 0, 0);\n\t\t\tif (textArea != 0) {\n\t\t\t\tdistanceToKarrat = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\t\t\t\tfloat karrat_x = string_x + distanceToKarrat.w;\n\n\t\t\t\tif (karrat_x < screenPos.x) {\n\t\t\t\t\tfloat delta = screenPos.x - karrat_x;\n\t\t\t\t\tdelta += 5; // Arbitrary\n\t\t\t\t\tstring_x += delta;\n\t\t\t\t}\n\t\t\t\telse if (karrat_x > screenPos.x + screenPos.w) {\n\t\t\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Draw selection\n\t\t\tif (textArea != 0 && textArea->selection != 0) {\n\t\t\t\ti32 selectionStart = textArea->karratIndex;\n\t\t\t\ti32 selectionEnd = selectionStart + textArea->selection;\n\t\t\t\tif (selectionEnd < selectionStart) {\n\t\t\t\t\ti32 tmp = selectionEnd;\n\t\t\t\t\tselectionEnd = selectionStart;\n\t\t\t\t\tselectionStart = tmp;\n\t\t\t\t}\n\t\t\t\tif (selectionStart >= 0) {\n\t\t\t\t\tDraw2D::Rect substring = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, selectionStart, selectionEnd - selectionStart);\n\t\t\t\t\tDraw2D::DrawRect(string_x + substring.x, string_y + substring.y, substring.w, substring.h, s->textAreaSelectionColor.r, s->textAreaSelectionColor.g, s->textAreaSelectionColor.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Draw string\n\t\t\tstring_y += s->textAreaFontSize;\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->textAreaFontSize, string_x, string_y, string, txtColor.r, txtColor.g, txtColor.b);\n\t\t\tstring_y -= s->textAreaFontSize;\n\n\t\t\t// Draw karrat\n\t\t\tif (textArea != 0 && textArea->karratIndex >= 0 && textArea->selection == 0) {\n\t\t\t\tDraw2D::Rect substring = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\n\t\t\t\tf32 karratPosX = string_x + substring.x + substring.w - 1;\n\t\t\t\tf32 karratPosY = string_y + 1;\n\t\t\t\tf32 karratHeight = substring.h - 4;\n\n\t\t\t\tif (Internal::gState->blink) {\n\t\t\t\t\tDraw2D::DrawRect(karratPosX - 3, karratPosY - 1, 3 + 1 + 3, 1, s->karratColor.r, s->karratColor.g, s->karratColor.b);\n\t\t\t\t\tDraw2D::DrawRect(karratPosX, karratPosY, 1, karratHeight, s->karratColor.r, s->karratColor.g, s->karratColor.b);\n\t\t\t\t\tDraw2D::DrawRect(karratPosX - 3, karratPosY + karratHeight, 3 + 1 + 3, 1, s->karratColor.r, s->karratColor.g, s->karratColor.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (clip) {\n\t\t\t\tDraw2D::PopClip();\n\t\t\t}\n\t\t}\n\n\t\tif (textArea != 0 && textArea->state == Internal::TextAreaState::Shutdown) {\n\t\t\ttextArea->widgetId = 0;\n\t\t\treturn textArea->buffer;\n\t\t}\n\n\t\tif (textArea != 0 && return_hit) {\n\t\t\treturn textArea->buffer;\n\t\t}\n\n\t\treturn inputText;\n\t}\n\n\tvoid Initialize(u32 interfaceFont, u32 widgetFont, u32 labelFont) {\n\t\tInternal::gState = (Internal::State*)MemAlloc(sizeof(Internal::State));\n\t\tMemClear(Internal::gState, sizeof(Internal::State));\n\t\tInternal::gState->widgetFont = widgetFont;\n\t\tInternal::gState->interfaceFont = interfaceFont;\n\t\tInternal::gState->labelFont = labelFont;\n\t}\n\n\tvoid Shutdown() {\n\t\tif (Internal::gState->textAreaA.buffer != 0) {\n\t\t\tMemRelease(Internal::gState->textAreaA.buffer);\n\t\t}\n\t\tif (Internal::gState->textAreaB.buffer != 0) {\n\t\t\tMemRelease(Internal::gState->textAreaB.buffer);\n\t\t}\n#if PLATFORM_DEBUG\n\t\tInternal::RectBlock* iter = Internal::gState->positiveWidgets.next;\n\t\twhile (iter != 0) {\n\t\t\tInternal::RectBlock* del = iter;\n\t\t\titer = iter->next;\n\t\t\tMemRelease(del);\n\t\t}\n\t\titer = Internal::gState->negativeWidgets.next;\n\t\twhile (iter != 0) {\n\t\t\tInternal::RectBlock* del = iter;\n\t\t\titer = iter->next;\n\t\t\tMemRelease(del);\n\t\t}\n#endif\n\t\tMemRelease(Internal::gState);\n\t}\n\n\tvoid BeginFrame(float dpi, const struct StyleSheet& style) {\n\t\tInternal::gState->dpi = dpi;\n\t\tInternal::gState->tooltipIcon = -1;\n\t\tInternal::gState->tooltipLabel = 0;\n\t\tInternal::gState->style = &style;\n\t\tInternal::gState->positiveIdGenerator = 0;\n\t\tInternal::gState->negativeIdGenerator = 0;\n\t\tif (Internal::gState->lastHotControl != Internal::gState->hotControl) {\n\t\t\tInternal::gState->hotControlTimer = 0.0f;\n\t\t}\n\t\tInternal::gState->lastHotControl = Internal::gState->hotControl;\n\t\tInternal::gState->hotControl = 0;\n\n\t\t// Update pointer state\n\t\tif (Internal::gState->activeInputMethod == IMGUI_ACTIVE_INPUT_NONE) {\n\t\t\tif (MousePressed(MouseButtonLeft)) {\n\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_MOUSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (u32 i = 0; i < 5; ++i) {\n\t\t\t\t\tif (TouchPressed(i)) {\n\t\t\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_TOUCH1 + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid EndFrame(u32 screenWidth, u32 screenHeight) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tif (Internal::gState->tooltipIcon >= 0 && Internal::gState->tooltipIcon < 256) {\n\t\t\tf32 x = Internal::gState->GetPointerX();\n\t\t\tf32 y = Internal::gState->GetPointerY();\n\t\t\tf32 dpi = Internal::gState->dpi;\n\t\t\t\n\t\t\tconst StyleColor& back = s->tooltipIconBGColor;\n\t\t\tconst StyleColor& fore = s->tooltipIconFGColor;\n\t\t\tfloat offset = MathMaxF(1.0f, MathFloor(dpi));\n\t\t\t\n\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, IMGUI_TOOLTIP_SIZE, (x + (3 * dpi)) / dpi, (y + (3 * dpi)) / dpi, Internal::gState->tooltipIcon, back.r, back.g, back.b, 1.0f);\n\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, IMGUI_TOOLTIP_SIZE, (x + (3 * dpi) + offset) / dpi, (y + (3 * dpi) + offset) / dpi, Internal::gState->tooltipIcon, fore.r, fore.g, fore.b, 1.0f);\n\t\t}\n\n\t\tif (Internal::gState->tooltipLabel != 0) {\n\t\t\tf32 dpi = Internal::gState->dpi;\n\n\t\t\tf32 x = Internal::gState->GetPointerX() / dpi;\n\t\t\tf32 y = Internal::gState->GetPointerY() / dpi;\n\n\t\t\tDraw2D::Size stringSize = Draw2D::MeasureString(Internal::gState->interfaceFont, IMGUI_TOOLTIP_SIZE - 2, Internal::gState->tooltipLabel);\n\t\t\tstringSize.w += 2;\n\t\t\tif (x + stringSize.w > (f32)screenWidth / dpi) {\n\t\t\t\tx -= stringSize.w;\n\t\t\t}\n\n\t\t\tDraw2D::DrawRect(x - 1, y - IMGUI_TOOLTIP_SIZE - 1, stringSize.w + 2, IMGUI_TOOLTIP_SIZE + 2, s->tooltipIconBGColor.r, s->tooltipIconBGColor.g, s->tooltipIconBGColor.b);\n\t\t\tDraw2D::DrawRect(x, y - IMGUI_TOOLTIP_SIZE, stringSize.w, IMGUI_TOOLTIP_SIZE, s->tooltipTextBGColor.r, s->tooltipTextBGColor.g, s->tooltipTextBGColor.b);\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, IMGUI_TOOLTIP_SIZE - 2, x + 2, y - 2, Internal::gState->tooltipLabel, s->tooltipTextColor.r, s->tooltipTextColor.g, s->tooltipTextColor.b);\n\t\t}\n\n\t\tif (Internal::gState->activeInputMethod != IMGUI_ACTIVE_INPUT_NONE) {\n\t\t\tif (Internal::gState->activeInputMethod == IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\tif (MouseReleased(MouseButtonLeft)) {\n\t\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint touchIndex = Internal::gState->activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\tif (TouchReleased(touchIndex)) {\n\t\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Internal::gState->lastActiveControl != Internal::gState->activeControl) {\n\t\t\tInternal::gState->activeControlTimer = 0.0f;\n\t\t}\n\t\tInternal::gState->lastActiveControl = Internal::gState->activeControl;\n\n\t\ti32 _active = Internal::gState->activeControl;\n\n\t\tif (Internal::gState->grabKeyboardOnOrAfter >= Internal::gState->positiveIdGenerator) {\n\t\t\tInternal::gState->grabKeyboardOnOrAfter = 1;\n\t\t}\n\t\telse if (Internal::gState->grabKeyboardOnOrAfter < 0) {\n\t\t\tInternal::gState->grabKeyboardOnOrAfter = Internal::gState->positiveIdGenerator;\n\t\t\tif (Internal::gState->grabKeyboardOnOrAfter < 0) {\n\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (Internal::gState->GetPointerReleased()) {\n\t\t\tInternal::gState->activeControl = 0;\n\t\t}\n\n#if PLATFORM_DEBUG\n\t\tif (Internal::gState->debugOverlayEnabled) {\n\t\t\tif (Internal::gState->hotControl != 0) {\n\t\t\t\tRect hotRect = Internal::gState->Debug_GetWidgetRect(Internal::gState->hotControl);\n\t\t\t\tDraw2D::DrawRect(hotRect.x, hotRect.y, hotRect.w, hotRect.h, 1.0f, 0.0f, 0.0f, 0.3f);\n\t\t\t}\n\n\t\t\tif (_active != 0) {\n\t\t\t\tRect activeRect = Internal::gState->Debug_GetWidgetRect(_active);\n\t\t\t\tDraw2D::DrawRect(activeRect.x, activeRect.y, activeRect.w, activeRect.h, 0.0f, 1.0f, 0.0f, 0.3f);\n\t\t\t}\n\t\t}\n#endif\n\n\t\tClearKeyQueue();\n\t}\n\n\tvoid TickFrame(float deltaTime) {\n\t\tInternal::gState->pulse = false;\n\t\tInternal::gState->pulseTimer += deltaTime;\n\t\tInternal::gState->lastTextDoubleClickTimer += deltaTime;\n\t\tInternal::gState->longPulse = false;\n\t\tInternal::gState->longPulseTimer += deltaTime;\n\n\t\tif (Internal::gState->activeControl != 0) {\n\t\t\tInternal::gState->activeControlTimer += deltaTime;\n\t\t}\n\t\telse {\n\t\t\tInternal::gState->activeControlTimer = 0.0f;\n\t\t}\n\n\t\tif (Internal::gState->hotControl != 0) {\n\t\t\tInternal::gState->hotControlTimer += deltaTime;\n\t\t}\n\t\telse {\n\t\t\tInternal::gState->hotControlTimer = 0.0f;\n\t\t}\n\n\t\tif (Internal::gState->pulseTimer > float(IMGUI_PULSE_MS) / 1000.0f) {\n\t\t\tInternal::gState->pulseTimer = 0;\n\t\t\tInternal::gState->pulse = true;\n\t\t}\n\n\t\tif (Internal::gState->longPulseTimer > float(IMGUI_LONG_PULSE_MS) / 1000.0f) {\n\t\t\tInternal::gState->longPulseTimer = 0;\n\t\t\tInternal::gState->longPulse = true;\n\t\t}\n\n\t\tfloat blinkLimit = float(IMGUI_BLINK_MS) / 1000.0f;\n\t\tif (Internal::gState->blink) {\n\t\t\tInternal::gState->blinkTimer += deltaTime;\n\t\t\tif (Internal::gState->blinkTimer > blinkLimit) {\n\t\t\t\tInternal::gState->blinkTimer = 0;\n\t\t\t\tInternal::gState->blink = !Internal::gState->blink;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tblinkLimit *= -1.0f;\n\t\t\tInternal::gState->blinkTimer -= deltaTime;\n\t\t\tif (Internal::gState->blinkTimer < blinkLimit) {\n\t\t\t\tInternal::gState->blinkTimer = 0;\n\t\t\t\tInternal::gState->blink = !Internal::gState->blink;\n\t\t\t}\n\t\t}\n\n\t\tif (KeyboardPressed(KeyboardCodeTilde)) {\n\t\t\tInternal::gState->debugOverlayEnabled = !Internal::gState->debugOverlayEnabled;\n\t\t}\n\t}\n}","#ifndef _H_IMGUI_\n#define _H_IMGUI_\n\n#include \"../platform/memory.h\"\n#include \"Node2D.h\"\n\n// TODO: Everything should be in the style sheet!\n#define IMGUI_ICON_CODEPOINT_RESIZE_HORIZONTAL 'A'\n#define IMGUI_ICON_CODEPOINT_RESIZE_VERTICAL 'B'\n#define IMGUI_ICON_CODEPOINT_TRASHCAN 'C'\n#define IMGUI_ICON_CODEPOINT_NEWLAYER 'D'\n#define IMGUI_ICON_CODEPOINT_NEWCHAIN 'E'\n#define IMGUI_ICON_CODEPOINT_NEWSPRITE 'F'\n#define IMGUI_ICON_CODEPOINT_REMOVECHAIN 'G'\n#define IMGUI_ICON_CODEPOINT_REMOVESPRITE 'H'\n#define IMGUI_ICON_CODEPOINT_CHAIN 'I'\n#define IMGUI_ICON_CODEPOINT_KEY 'J'\n#define IMGUI_ICON_CODEPOINT_NOKEY 'K'\n#define IMGUI_ICON_CODEPOINT_DESELECT 'L'\n#define IMGUI_ICON_CODEPOINT_UNDO 'M'\n#define IMGUI_ICON_CODEPOINT_REDO 'N'\n#define IMGUI_ICON_CODEPOINT_CLEAR_UNDO 'O'\n#define IMGUI_ICON_CODEPOINT_ARROW_DOWN 'P'\n#define IMGUI_ICON_CODEPOINT_ARROW_UP 'Q'\n#define IMGUI_ICON_CODEPOINT_ARROW_LEFT 'R'\n#define IMGUI_ICON_CODEPOINT_ARROW_RIGHT 'S'\n#define IMGUI_ICON_CODEPOINT_VISIBLE 'T'\n#define IMGUI_ICON_CODEPOINT_INVISIBLE 'U'\n#define IMGUI_ICON_CODEPOINT_DEBUGOFF 'V'\n#define IMGUI_ICON_CODEPOINT_DEBUGON 'W'\n#define IMGUI_ICON_CODEPOINT_COLLAPSED 'X'\n#define IMGUI_ICON_CODEPOINT_EXPANDED 'Y'\n#define IMGUI_ICON_CODEPOINT_KEYBOARD_OUTLINED 'Z'\n#define IMGUI_ICON_CODEPOINT_KEYBOARD_FILLED 'a'\n#define IMGUI_ICON_CODEPOINT_LOCK_CLOSED 'b'\n#define IMGUI_ICON_CODEPOINT_LOCK_OPEN 'c'\n\n#define IMGUI_TOOLTIP_SIZE 18\n#define IMGUI_SPLITTER_GRABBABLE_WIDTH 4.0f\n#define IMGUI_PULSE_MS 250\n#define IMGUI_LONG_PULSE_MS 500\n#define IMGUI_BLINK_MS 800\n#define IMGUI_TOOLTIP_MIN 1.5f\n#define IMGUI_TOOLTIP_MAX 12.0f\n#define IMGUI_TRANSFORM_HEIGHT 110.0f\n#define IMGUI_DOUBLECLICK_SECOND 0.4f\n\nstruct StyleColor {\n\tunion {\n\t\tstruct {\n\t\t\tfloat r;\n\t\t\tfloat g;\n\t\t\tfloat b;\n\t\t\tfloat a;\n\t\t};\n\t\tfloat rgba[4];\n\t};\n\n\tinline StyleColor(float _r = 0.0f, float _g = 0.0f, float _b = 0.0f, float _a = 1.0f) :\n\t\tr(_r), g(_g), b(_b), a(_a) {}\n};\n\ninline StyleColor ColorRGB8(u8 r, u8 g, u8 b) {\n\tfloat _r = (float)r / 255.0f;\n\tfloat _g = (float)g / 255.0f;\n\tfloat _b = (float)b / 255.0f;\n\treturn StyleColor(_r, _g, _b, 1.0f);\n}\n\ninline StyleColor ColorRGB8(u8 c) {\n\tfloat _r = (float)c / 255.0f;\n\tfloat _g = (float)c / 255.0f;\n\tfloat _b = (float)c / 255.0f;\n\treturn StyleColor(_r, _g, _b, 1.0f);\n}\n\nstruct StyleSheet {\n\tStyleColor menuBarBg;\n\tfloat menuBarHeight;\n\n\tStyleColor toolBarBg;\n\tfloat toolbarWidth;\n\n\tStyleColor footerBg;\n\tfloat footerHeight;\n\n\tfloat inspectorMinWidth;\n\tfloat animatorMinHeight;\n\n\tu32 menuTextLineHeight;\n\n\tStyleColor tooltipIconBGColor;\n\tStyleColor tooltipIconFGColor;\n\tStyleColor tooltipTextColor;\n\tStyleColor tooltipTextBGColor;\n\n\tStyleColor documentBGColor;\n\tStyleColor panelBgColor;\n\n\tStyleColor dividerAColor;\n\tStyleColor dividerBColor;\n\tfloat dividerHotTint;\n\tfloat dividerActiveTint;\n\n\tfloat headerHeight;\n\tu32 headerFontSize;\n\tStyleColor headerBgColor;\n\tStyleColor headerFontColor;\n\tStyleColor HeaderBGHotColor;\n\tStyleColor HeaderBGActiveColor;\n\n\tStyleColor hierarchyFooterBg;\n\tfloat hierarchyFooterHeight;\n\tfloat hierarchyFooterButtonSize;\n\tStyleColor hierarchyFooterButtonBG_Hot;\n\tStyleColor hierarchyFooterButtonBG_Active;\n\tStyleColor hierarchyFooterButtonBorder_Hot;\n\tStyleColor hierarchyFooterButtonBorder_Active;\n\tStyleColor hierarchyFooterButtonIcon;\n\tStyleColor hierarchyFooterDisabledIconColor;\n\tStyleColor hierarchyLabelDisabled;\n\tStyleColor hierarchyItemBGDisabled;\n\n\tfloat listBoxItemHeight;\n\tu32 hierarchyLabelFontSize;\n\tStyleColor hierarchyItemBG_A;\n\tStyleColor hierarchyItemBG_B;\n\tStyleColor hierarchyItemBG_Selected;\n\tStyleColor hierarchyItemBG_Movable;\n\tStyleColor hierarchyLabel;\n\tStyleColor hierarchyToggleNormal;\n\tStyleColor hierarchyToggleHot;\n\n\tStyleColor scrollBarTrackBG;\n\tStyleColor scrollBarIconNormal;\n\tStyleColor scrollBarIconHot;\n\tStyleColor scrollBarHotButtonBg;\n\tStyleColor scrollGrabberNormal;\n\tStyleColor scrollGrabberHot;\n\tfloat scrollBarSize;\n\tfloat scrollIconSize;\n\tfloat scrollBarHandleSize;\n\n\tStyleColor toggleButtonBorder;\n\tStyleColor toggleButtonDisabledBorder;\n\tStyleColor toggleButtonNormal;\n\tStyleColor toggleButtonHot;\n\tStyleColor toggleButtonActive;\n\tStyleColor toggleButtonDisabled;\n\n\tStyleColor textAreaBg_Normal;\n\tStyleColor textAreaBg_Hot;\n\tStyleColor textAreaBg_Active;\n\tStyleColor textAreaBg_Disabled;\n\n\tStyleColor textAreaFont_Normal;\n\tStyleColor textAreaFont_Hot;\n\tStyleColor textAreaFont_Active;\n\tStyleColor textAreaFont_Disabled;\n\n\tStyleColor textAreaOutline_Normal;\n\tStyleColor textAreaOutline_Hot;\n\tStyleColor textAreaOutline_Active;\n\tStyleColor textAreaOutline_Disabled;\n\n\tStyleColor textAreaLabel_Normal;\n\tStyleColor textAreaLabel_Hot;\n\tStyleColor textAreaLabel_Active;\n\tStyleColor textAreaLabel_Disabled;\n\n\tStyleColor labelFontColorNormal;\n\tStyleColor labelFontColorDisabled;\n\n\tStyleColor textAreaSelectionColor;\n\tStyleColor karratColor;\n\n\tf32 txtAreaHeight;\n\tu32 textAreaFontSize;\n\tu32 textAreaLabelSize;\n};\n\nnamespace Imgui {\n\tstruct Point {\n\t\tfloat x;\n\t\tfloat y;\n\n\t\tinline Point(float _x = 0.0f, float _y = 0.0f) : x(_x), y(_y) { }\n\t};\n\n\tstruct Rect {\n\t\tf32 x;\n\t\tf32 y;\n\t\tf32 w;\n\t\tf32 h;\n\n\t\tinline Rect(f32 _x = 0.0f, f32 _y = 0.0f, f32 _w = 0.0f, f32 _h = 0.0f) :\n\t\t\tx(_x), y(_y), w(_w), h(_h) {}\n\t};\n\n\tinline bool Contains(const Rect& rect, const Point& point) {\n\t\tif (point.x >= rect.x && point.x <= rect.x + rect.w) {\n\t\t\tif (point.y >= rect.y && point.y <= rect.y + rect.h) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tinline bool Intersects(const Rect& r1, const Rect& r2) {\n\t\treturn !(r1.x + r1.w < r2.x || r1.y + r1.h < r2.y || r1.x > r2.x + r2.w || r1.y > r2.y + r2.h);\n\t}\n\n\tvoid Initialize(u32 interfaceFont, u32 widgetFont, u32 labelFont);\n\tvoid Shutdown();\n\tvoid BeginFrame(float dpi, const struct StyleSheet& style);\n\tvoid EndFrame(u32 screenWidth, u32 screenHeight);\n\tvoid TickFrame(float deltaTime);\n\n\tfloat Split(const Rect& screenPos, bool horizontal, float minSplitterHeight, float normalizedDivider);\n\tRect SplitFirstArea(const Rect& screenPos, bool horizontal, float splitter);\n\tRect SplitSecondArea(const Rect& screenPos, bool horizontal, float splitter);\n\t\n\tinline float HSplit(const Rect& screenPos, float minSplitterHeight, float normalizedDivider) {\n\t\treturn Split(screenPos, true, minSplitterHeight, normalizedDivider);\n\t}\n\tinline Rect HSplitFirstArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitFirstArea(screenPos, true, splitter);\n\t}\n\tinline Rect HSplitSecondArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitSecondArea(screenPos, true, splitter);\n\t}\n\n\tinline float VSplit(const Rect& screenPos, float minSplitterWidth, float normalizedDivider) {\n\t\treturn Split(screenPos, false, minSplitterWidth, normalizedDivider);\n\t}\n\tinline Rect VSplitFirstArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitFirstArea(screenPos, false, splitter);\n\t}\n\tinline Rect VSplitSecondArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitSecondArea(screenPos, false, splitter);\n\t}\n\n\tstruct HierarchyListItemResult { // TODO: should be a bitmask\n\t\tbool activated;\n\t\tbool dragging;\n\t\tbool expanded;\n\t};\n\n\tHierarchyListItemResult HierarchyListItem(const Rect& screenPos, const Rect& listARea, const char* name, f32 indent, bool evenOrOdd, bool selected, bool expanded, bool leaf);\n\tbool UndoListItem(const Rect& screenPos, const Rect& scrollArea, const char* name, bool evenOrOdd, bool disabled, bool top);\n\tu32 Header(const Rect& screenPos, const char** options, u32 numOptions, u32 selectedOption);\n\n\t// Will show an overlay next to the pointer. Drawn in EndFrame.\n\tvoid SetTooltipIcon(int codePoint);\n\n\tbool IconToggle(const Rect& screenPos, u32 trueIcon, u32 falseIcon, bool state, bool disabled);\n\tbool FooterButton(const Rect& screenPos, u32 codePoint, const char* caption);\n\tbool ClickArea(const Rect& screenPos);\n\t\n\tvoid Icon(const Rect& screenPos, u32 iconSize, u32 codePoint, float r = 1.0f, float g = 1.0f, float b = 1.0f, float a = 1.0f);\n\n\tfloat ScrollBar(const Rect& screeenPos, float value, bool horizontal, float grabberHeight = 15.0f, bool handleScroll = false);\n\tbool HandleScroll(const Rect& scrollArea);\n\n\tinline float HScroll(const Rect& screenPos, float value, float grabberHeight = 15.0f, bool handleScroll = false) {\n\t\treturn ScrollBar(screenPos, value, true, grabberHeight, handleScroll);\n\t}\n\tinline float VScroll(const Rect& screenPos, float value, float grabberHeight = 15.0f, bool handleScroll = false) {\n\t\treturn ScrollBar(screenPos, value, false, grabberHeight, handleScroll);\n\t}\n\n\tvoid Label(const Rect& screenPos, const char* text, bool disabled);\n\n\tPoint GetPointer();\n\tbool GetPulse();\n\tbool PointerReleased();\n\n\t// Returns the same pointer as the second argument (inputText) when the control is inactive or the text is being edited\n\t// returns a pointer to a new string when the edited text is commited. The returned string is valid until Imgui::EndFrame\n\tconst char* TextArea(const Rect& screenPos, const char* inputText, const char* label, bool disabled, bool fraction);\n\n}\n\n#endif","#ifndef _H_WINDOW_\n#define _H_WINDOW_\n\n#ifndef WINDOW_HEAP_SIZE\n#define WINDOW_HEAP_SIZE 142595760\n#endif\n\n#ifndef WINDOW_MAX_TOUCHES\n#define WINDOW_MAX_TOUCHES 5\n#endif\n\ntypedef unsigned int u32;\ntypedef int i32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(i32) == 4, \"i32 should be a 4 byte type\");\n\n#define KeyboardCodeLeftMouse         1  //  \n#define KeyboardCodeRightMouse        2  //  \n#define KeyboardCodeBackspace         3  //  Backspace\n#define KeyboardCodeMiddleMouse       4  //  \n#define KeyboardCodeReturn            5  //  Enter\n#define KeyboardCodeShift             6  //  Shift \n#define KeyboardCodeControl           7  //  Control key\n#define KeyboardCodeAlt               8  //  Alt key\n#define KeyboardCodeCapslock          9  //  Capslock\n#define KeyboardCodeEscape           10  //  Escape\n#define KeyboardCodeSpace            11  //  Spacebar\n#define KeyboardCodeLeft             12  //  Left arrow\n#define KeyboardCodeUp               13  //  Up arrow\n#define KeyboardCodeRight            14  //  Right arrow\n#define KeyboardCodeDown             15  //  Down arrow\n#define KeyboardCodeDelete           16  //  Delete key\n#define KeyboardCode0                17  //  Key 0\n#define KeyboardCode1                18  //  Key 1\n#define KeyboardCode2                19  //  Key 2\n#define KeyboardCode3                20  //  Key 3\n#define KeyboardCode4                21  //  Key 4\n#define KeyboardCode5                22  //  Key 5\n#define KeyboardCode6                23  //  Key 6\n#define KeyboardCode7                24  //  Key 7\n#define KeyboardCode8                25  //  Key 8\n#define KeyboardCode9                26  //  Key 9\n#define KeyboardCodeA                27  //  Key A\n#define KeyboardCodeB                28  //  Key B\n#define KeyboardCodeC                29  //  Key C\n#define KeyboardCodeD                30  //  Key D\n#define KeyboardCodeE                31  //  Key E\n#define KeyboardCodeF                32  //  Key F\n#define KeyboardCodeG                33  //  Key G\n#define KeyboardCodeH                34  //  Key H\n#define KeyboardCodeI                35  //  Key I\n#define KeyboardCodeJ                36  //  Key J\n#define KeyboardCodeK                37  //  Key K\n#define KeyboardCodeL                38  //  Key L\n#define KeyboardCodeM                39  //  Key M\n#define KeyboardCodeN                40  //  Key N\n#define KeyboardCodeO                41  //  Key O\n#define KeyboardCodeP                42  //  Key P\n#define KeyboardCodeQ                43  //  Key Q\n#define KeyboardCodeR                44  //  Key R\n#define KeyboardCodeS                45  //  Key S\n#define KeyboardCodeT                46  //  Key T\n#define KeyboardCodeU                47  //  Key U\n#define KeyboardCodeV                48  //  Key V\n#define KeyboardCodeW                49  //  Key W\n#define KeyboardCodeX                50  //  Key X\n#define KeyboardCodeY                51  //  Key Y\n#define KeyboardCodeZ                52  //  Key Z\n#define KeyboardCodeSemicolon        53  //  ;:\n#define KeyboardCodeColon            53  //  ;:\n#define KeyboardCodePlus             54  //  +=\n#define KeyboardCodeEquals           54  //  +=\n#define KeyboardCodeComma            55  //  ,<\n#define KeyboardCodeLess             55  //  ,<\n#define KeyboardCodeMinus            56  //  -_\n#define KeyboardCodeUnderscore       56  //  -_\n#define KeyboardCodePeriod           57  //  .>\n#define KeyboardCodeGreater          57  //  .>\n#define KeyboardCodeSlash            58  //  /?\n#define KeyboardCodeQuestionmark     58  //  /?\n#define KeyboardCodeTilde            59  //  ~`\n#define KeyboardCodeTick             59  //  ~`\n#define KeyboardCodeLBracket         60  //  [{\n#define KeyboardCodeLBrace           60  //  [{\n#define KeyboardCodeBackslash        61  //  \\|\n#define KeyboardCodeCarray           61  //  \\|\n#define KeyboardCodeRbracket         62  //  ]}\n#define KeyboardCodeRBrace           62  //  ]}\n#define KeyboardCodeQoute            63  //  \"'\n#define KeyboardCodeTab              64  //  Tab\n\nextern \"C\" u32 AsciiToScancode(char val);\nextern \"C\" char ScanCodeToAscii(u32 scanCode, bool shift);\n\nextern \"C\" bool KeyboardDown(u32 scanCode);\nextern \"C\" bool KeyboardPrevDown(u32 scanCode);\n\n\n// Queued keyboard input is hacked together (at best)\n// ConsumeKeyQueue will return a key code as long as there is queued input\n// ConsumeKeyQueue will return KeyboardCodeLeftMouse if there is no more input\n// ClearKeyQueue must be called once a frame to reset the internal queue pointer\nextern \"C\" void PushKey(u32 scanCode);\nextern \"C\" u32 ConsumeKeyQueue();\nextern \"C\" void ClearKeyQueue();\n\nextern \"C\" void WriteClipboard(const char* string); \nextern \"C\" char* ReadClipboard(); \n\ninline bool KeyboardUp(u32 scanCode) {\n    return !KeyboardDown(scanCode);\n}\n\ninline bool KeyboardPrevUp(u32 scanCode) {\n    return !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardPressed(u32 scanCode) {\n    return KeyboardDown(scanCode) && !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardReleased(u32 scanCode) {\n    return !KeyboardDown(scanCode) && KeyboardPrevDown(scanCode);\n}\n\n// Mouse API\n#define MouseButtonLeft         KeyboardCodeLeftMouse\n#define MouseButtonMiddle       KeyboardCodeMiddleMouse\n#define MouseButtonRight        KeyboardCodeRightMouse\n\nextern \"C\" u32 MouseGetX();\nextern \"C\" u32 MouseGetY();\nextern \"C\" i32 MouseGetScroll();\nextern \"C\" bool MouseDown(u32 button);\n\nextern \"C\" u32 MousePrevX();\nextern \"C\" u32 MousePrevY();\nextern \"C\" i32 MousePrevScroll();\nextern \"C\" bool MousePrevDown(u32 button);\n\ninline bool MouseUp(u32 button) {\n    return !MouseDown(button);\n}\n\ninline bool MousePrevUp(u32 button) {\n    return !MousePrevDown(button);\n}\n\ninline bool MousePressed(u32 button) {\n    return MouseDown(button) && !MousePrevDown(button);\n}\n\ninline bool MouseReleased(u32 button) {\n    return !MouseDown(button) && MousePrevDown(button);\n}\n\ninline i32 MouseDeltaX() {\n    i32 thisX = MouseGetX();\n    i32 lastX = MousePrevX();\n    return thisX - lastX;\n}\n\ninline i32 MouseDeltaY() {\n    i32 thisY = MouseGetY();\n    i32 lastY = MousePrevY();\n    return thisY - lastY;\n}\n\n// Touch API\nextern \"C\" u32 TouchGetMaxContacts();\nextern \"C\" u32 TouchGetNumContacts(); // Misleading, touch array is sparse. Always loop to max.\n\nextern \"C\" u32 TouchGetX(u32 touchIndex);\nextern \"C\" u32 TouchGetY(u32 touchIndex);\nextern \"C\" bool TouchIsActive(u32 touchIndex);\n\nextern \"C\" u32 TouchGetPrevX(u32 touchIndex);\nextern \"C\" u32 TouchGetPrevY(u32 touchIndex);\nextern \"C\" bool TouchWasActive(u32 touchIndex);\n\ninline bool TouchPressed(u32 touchIndex) {\n    return TouchIsActive(touchIndex) && !TouchWasActive(touchIndex);\n}\n\ninline bool TouchReleased(u32 touchIndex) {\n    return !TouchIsActive(touchIndex) && TouchWasActive(touchIndex);\n}\n\ninline i32 TouchDeltaX(u32 touchIndex) {\n    if (!TouchIsActive(touchIndex) || !TouchWasActive(touchIndex)) {\n        return 0;\n    }\n    i32 thisX = TouchGetX(touchIndex);\n    i32 lastX = TouchGetPrevX(touchIndex);\n    return thisX - lastX;\n}\n\ninline i32 TouchDeltaY(u32 touchIndex) {\n    if (!TouchIsActive(touchIndex) || !TouchWasActive(touchIndex)) {\n        return 0;\n    }\n    i32 thisY = TouchGetY(touchIndex);\n    i32 lastY = TouchGetPrevY(touchIndex);\n    return thisY - lastY;\n}\n\n// Window API\n// The following functions need to be declared. Initialize returns the userdata pointer that is passed to the other functions.\n/*#define WasmExport __attribute__ (( visibility( \"default\" ) )) extern \"C\"\nWasmExport void* Initialize();\nWasmExport void Update(float dt, void* userData);\nWasmExport void Render(unsigned int x, unsigned int y, unsigned int w, unsigned int h, float dpi, void* userData);\nWasmExport void Shutdown(void* userData);*/\n\n// TODO: Need a \"Get Pointer\" API, similar to what i build in the animator imgui sample\n// a pointer is either a touch or a mouse, whatever happened first.\n\nextern \"C\" void WindowUpdateTitle(const char* newTitle);\n\n#endif","#include \"Node2D.h\"\n\nu32 CountDescendants(Node2D* node) {\n\tif (node == 0) {\n\t\treturn 0;\n\t}\n\n\tu32 result = 0;\n\n\tNode2D* itr = node;\n\tbool traversing = true;\n\twhile (traversing) {\n\t\tif (itr != node) { // Process\n\t\t\tresult += 1;\n\t\t}\n\n\t\tif (itr->firstChild) {\n\t\t\titr = itr->firstChild;\n\t\t}\n\t\telse {\n\t\t\twhile (itr->next == 0) {\n\t\t\t\tif (itr == node) {\n\t\t\t\t\ttraversing = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr = itr->parent;\n\t\t\t}\n\t\t\tif (itr == node) {\n\t\t\t\ttraversing = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titr = itr->next;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvoid ForEachNode(Node2D* root, NodeVisitor callback, void* userData) {\n\tNode2D* itr = root;\n\tbool traversing = true;\n\twhile (traversing) {\n\t\tcallback(itr, userData);\n\n\t\tif (itr->firstChild) {\n\t\t\titr = itr->firstChild;\n\t\t}\n\t\telse {\n\t\t\twhile (itr->next == 0) {\n\t\t\t\tif (itr == root) {\n\t\t\t\t\ttraversing = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr = itr->parent;\n\t\t\t}\n\t\t\tif (itr == root) { \n\t\t\t\ttraversing = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titr = itr->next;\n\t\t}\n\t}\n}\n\nvoid RecursivleyDestroyNode(Node2D* node) {\n\t// Unhook from hierarchy\n\tif (node->parent != 0) {\n\t\tRemoveChild(*node->parent, *node);\n\t}\n\n\t// Iterate subtree and release all resources\n\n\tNode2D* itr = node;\n\tbool traversing = true;\n\twhile (traversing) {\n\t\tif (itr->firstChild) {\n\t\t\titr = itr->firstChild;\n\t\t}\n\t\telse {\n\t\t\t// At the bottom of the tree. This node has no children. \n\t\t\tNode2D* parent = itr->parent;\n\t\t\tNode2D* next = itr->next;\n\n\t\t\tif (parent != 0) {\n\t\t\t\tRemoveChild(*parent, *itr);\n\t\t\t}\n\t\t\tPlatformAssert(itr->parent == 0, __LOCATION__);\n\t\t\tPlatformAssert(itr->firstChild == 0, __LOCATION__);\n\n\t\t\t{ // Release memory\n\t\t\t\tif (itr->name != 0) {\n\t\t\t\t\tMemRelease(itr->name);\n\t\t\t\t\titr->name = 0;\n\t\t\t\t}\n\n\t\t\t\tif (itr == node) {\n\t\t\t\t\ttraversing = false;\n\t\t\t\t}\n\t\t\t\tMemRelease(itr);\n\t\t\t}\n\n\t\t\tif (next != 0) {\n\t\t\t\titr = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\titr = parent;\n\t\t\t}\n\t\t}\n\t}\n}\n\nNode2D* GetLastChild(Node2D& node) {\n\tif (node.firstChild == 0) {\n\t\treturn 0;\n\t}\n\tNode2D* iter = node.firstChild;\n\twhile (iter->next != 0) {\n\t\titer = iter->next;\n\t}\n\treturn iter;\n}\n\nNode2D* GetChildById(Node2D& node, u32 uid) {\n\tif (node.firstChild == 0 || uid == 0) {\n\t\treturn 0;\n\t}\n\n\tNode2D* iter = node.firstChild;\n\twhile (iter->next != 0) {\n\t\tif (iter->uid == uid) {\n\t\t\tbreak;\n\t\t}\n\t\titer = iter->next;\n\t}\n\n\treturn iter;\n}\n\nbool RemoveChild(Node2D& parent, Node2D& child) {\n\tif (parent.firstChild == 0) {\n\t\treturn false;\n\t}\n\n\tNode2D* iter = parent.firstChild;\n\tNode2D* prev = 0;\n\twhile (iter != 0) {\n\t\tif (iter == &child) {\n\t\t\tbreak;\n\t\t}\n\t\tprev = iter;\n\t\titer = iter->next;\n\t}\n\n\tif (iter == 0) {\n\t\treturn false;\n\t}\n\n\tif (prev != 0) {\n\t\tprev->next = iter->next;\n\t}\n\telse {\n\t\tparent.firstChild = iter->next;\n\t}\n\n\tchild.parent = 0;\n\tchild.depth = 0;\n\tchild.next = 0;\n\n\treturn true;\n}\n\nbool AddChild(Node2D& parent, Node2D& child) {\n\tNode2D* lastChild = GetLastChild(parent);\n\n\tif (lastChild != 0) {\n\t\tlastChild->next = &child;\n\t\tchild.next = 0;\n\t}\n\telse {\n\t\tchild.next = parent.firstChild;\n\t\tparent.firstChild = &child;\n\t}\n\tchild.parent = &parent;\n\tchild.depth = parent.depth + 1;\n\n\treturn true;\n}\n\nbool AddChild(Node2D& parent, Node2D& child, u32 lastSibling) {\n\tNode2D* prevNode = GetChildById(parent, lastSibling);\n\n\tif (prevNode != 0) {\n\t\tchild.next = prevNode->next;\n\t\tprevNode->next = &child;\n\t}\n\telse {\n\t\tchild.next = parent.firstChild;\n\t\tparent.firstChild = &child;\n\t}\n\tchild.parent = &parent;\n\tchild.depth = parent.depth + 1;\n\n\treturn true;\n}\n\nvoid SetParent(Node2D* parent, Node2D& child) {\n\tif (child.parent != 0) {\n\t\tbool removed = RemoveChild(*child.parent, child);\n\t\tPlatformAssert(removed, __LOCATION__);\n\t}\n\n\tchild.parent = parent;\n\tchild.depth = 0;\n\tif (parent != 0) {\n\t\tchild.depth = parent->depth + 1;\n\t}\n\n\tif (parent != 0) {\n\t\tAddChild(*child.parent, child);\n\n\t\tu32 parentDepth = 0;\n\t\tNode2D* iter = parent;\n\t\twhile (iter != 0) {\n\t\t\tparentDepth += 1;\n\t\t\titer = iter->parent;\n\t\t}\n\t\tparent->depth = parentDepth == 0? 0 : parentDepth - 1;\n\t\tForEachNode(parent, [](Node2D* node, void* userData) {\n\t\t\tif (node != userData) {\n\t\t\t\tnode->depth = node->parent->depth + 1;\n\t\t\t}\n\t\t}, parent);\n\t}\n}\n\nvoid SetParent(Node2D* parent, Node2D& child, u32 lastSibling) {\n\tif (child.parent != 0) {\n\t\tbool removed = RemoveChild(*child.parent, child);\n\t\tPlatformAssert(removed, __LOCATION__);\n\t}\n\n\tchild.parent = parent;\n\tchild.depth = 0;\n\n\tif (parent != 0) {\n\t\tAddChild(*child.parent, child, lastSibling);\n\t\tchild.depth = parent->depth + 1;\n\n\t\tu32 parentDepth = 0;\n\t\tNode2D* iter = parent;\n\t\twhile (iter != 0) {\n\t\t\tparentDepth += 1;\n\t\t\titer = iter->parent;\n\t\t}\n\t\tparent->depth = parentDepth == 0 ? 0 : parentDepth - 1;\n\t\tForEachNode(parent, [](Node2D* node, void* userData) {\n\t\t\tif (node != userData) {\n\t\t\t\tnode->depth = node->parent->depth + 1;\n\t\t\t}\n\t\t}, parent);\n\t}\n}\n\nvoid SetName(Node2D& node, const char* name) {\n\tu32 len = 0;\n\tif (name != 0) {\n\t\tfor (len = 0; name[len] != 0; ++len);\n\t}\n\n\tif (len > node.nameCapacity) {\n\t\twhile (len > node.nameCapacity) {\n\t\t\tnode.nameCapacity = node.nameCapacity * 2;\n\t\t}\n\t\tMemRelease(node.name);\n\t\tnode.name = (char*)MemAlloc(node.nameCapacity + 1);\n\t\tMemClear(node.name, node.nameCapacity + 1);\n\t\tnode.nameLength = 0;\n\t}\n\n\tfor (u32 i = 0; i < len; ++i) {\n\t\tnode.name[i] = name[i];\n\t}\n\tnode.name[len] = 0;\n\tnode.nameLength = len;\n}","#include \"Document.h\"\n#include \"../debt/stb_sprintf.h\"\n#include \"../platform/memory.h\"\n\nNode2D* Document::DepthFirst(Node2D* iter) {\n    if (iter == 0) {\n        return rootNode;\n    }\n\n    if (iter->firstChild) {\n        iter = iter->firstChild;\n    }\n    else {\n        while (iter->next == 0) {\n            if (iter == rootNode) { // This should be iteration root, not document root\n                return 0;\n            }\n            iter = iter->parent;\n        }\n        // This isn't 100% accurate, should stop if iter == root, but i don't have the iteration root\n        iter = iter->next;\n    }\n\n    return iter;\n}\n\nNode2D* Document::DepthFirstExpandedOnly(Node2D* iter) {\n    if (iter == 0) {\n        return rootNode;\n    }\n\n    bool shouldDescend = iter->firstChild && iter->uiExpanded;\n    if (iter == rootNode) {\n        shouldDescend = true;\n    }\n\n    if (shouldDescend) {\n        iter = iter->firstChild;\n    }\n    else {\n        while (iter->next == 0) {\n            if (iter == rootNode) { // This should be iteration root, not document root\n                return 0;\n            }\n            iter = iter->parent;\n        }\n        // This isn't 100% accurate, should stop if iter == root, but i don't have the iteration root\n        iter = iter->next;\n    }\n\n    return iter;\n}\n\nNode2D* Document::FindNodeById(u32 nodeId) { // Non intrusive, non extra memory DFS: https://stackoverflow.com/questions/5278580/non-recursive-depth-first-search-algorithm\n    if (nodeId == 0) {\n        return 0;\n    }\n    \n    Node2D* itr = rootNode;\n    bool traversing = true;\n    while (traversing) {\n        if (itr != rootNode) { // Process\n            if (itr->uid == nodeId) {\n                return itr;\n            }\n        }\n\n        if (itr->firstChild) {\n            itr = itr->firstChild;\n        }\n        else {\n            while (itr->next == 0) {\n                if (itr == rootNode) {\n                    traversing = false;\n                    break;\n                }\n                itr = itr->parent;\n            }\n            if (itr == rootNode) {\n                traversing = false;\n                break;\n            }\n            itr = itr->next;\n        }\n    }\n\n    return 0;\n}\n\nstatic void _RecursivleyDestroyNodeIfItHasNoReferences(Node2D* node) {\n    while (node->firstChild != 0) {\n        Node2D* lastChild = GetLastChild(*node);\n        PlatformAssert(lastChild->next == 0, __LOCATION__);\n        _RecursivleyDestroyNodeIfItHasNoReferences(lastChild);\n    }\n\n    SetParent(0, *node);\n    if (node->name != 0) {\n        MemRelease(node->name);\n        node->name = 0;\n    }\n\n    MemRelease(node);\n}\n\nbool RecursivleyDestroyNodeIfItHasNoReferences(Node2D* node) { // TODO: Make this not recursive\n    if (node == 0) {\n        return false;\n    }\n\n    if (node->refCount == 0) {\n        ForEachNode(node, [](Node2D* childNode, void* userData) {\n            PlatformAssert(childNode->refCount == 0, __LOCATION__);\n            }, 0);\n\n        _RecursivleyDestroyNodeIfItHasNoReferences(node);\n\n        return true;\n    }\n\n    return false;\n}\n\nstruct DocumentAction {\n    virtual void Undo() = 0;\n    virtual void Redo() = 0;\n    virtual ~DocumentAction() = 0;\n    virtual const char* Name() = 0;\n};\n\nDocumentAction::~DocumentAction() {  }\n\nstruct HierarchySelectAction : DocumentAction {\n    Document* owner;\n    u32 selectedId;\n    u32 lastSelectedId;\n\n    HierarchySelectAction(Document* doc, u32 newSelection, u32 oldSelection) {\n        owner = doc;\n        selectedId = newSelection;\n        lastSelectedId = oldSelection;\n    }\n\n    ~HierarchySelectAction() {\n    }\n\n    void Redo() {\n        Node2D* selection = owner->FindNodeById(selectedId);\n        owner->selectedNode = selection;\n    }\n\n    void Undo() {\n        Node2D* selection = owner->FindNodeById(lastSelectedId);\n        owner->selectedNode = selection;\n    }\n\n    const char* Name()  {\n        if (selectedId == 0) {\n            return \"Hierarchy deselect\";\n        }\n        return \"Hierarchy select\";\n    }\n};\n\nstruct NullAction : DocumentAction {\n    NullAction() { }\n\n    void Redo() { }\n\n    void Undo() { }\n\n    ~NullAction() {\n        PlatformAssert(false, __LOCATION__);\n    }\n\n    const char* Name() {\n        return \"Null action\";\n    }\n};\n\nstruct RearrangeNodeAction : DocumentAction {\n    Document* doc;\n    \n    u32 targetId;\n\n    u32 newParentId;\n    u32 newPrevId;\n\n    u32 oldParentId;\n    u32 oldPrevId;\n\n    RearrangeNodeAction(Document* d, Node2D* target, Node2D* parent, Node2D* prevNode) {\n        PlatformAssert(target != 0, __LOCATION__);\n        PlatformAssert(parent != 0, __LOCATION__);\n\n        doc = d;\n        targetId = target->uid;\n        oldParentId = 0;\n        oldPrevId = 0;\n        if (target->parent != 0) {\n            oldParentId = target->parent->uid;\n\n            Node2D* iter = target->parent->firstChild;\n            Node2D* prev = 0;\n            while (iter != 0) {\n                if (iter == target) {\n                    break;\n                }\n                prev = iter;\n                iter = iter->next;\n            }\n\n            if (prev != 0) {\n                oldPrevId = prev->uid;\n            }\n        }\n\n        newParentId = parent->uid;\n        newPrevId = 0;\n        if (prevNode != 0) {\n            newPrevId = prevNode->uid;\n            PlatformAssert(prevNode->parent = parent, __LOCATION__);\n        }\n    }\n\n    void Redo() {\n        Node2D* newParent = doc->FindNodeById(newParentId);\n        if (newParent == 0) {\n            newParent = doc->rootNode;\n        }\n        Node2D* target = doc->FindNodeById(targetId);\n        SetParent(newParent, *target, newPrevId);\n    }\n\n    void Undo() {\n        Node2D* oldParent = doc->FindNodeById(oldParentId);\n        if (oldParent == 0) {\n            oldParent = doc->rootNode;\n        }\n        Node2D* target = doc->FindNodeById(targetId);\n        SetParent(oldParent, *target, oldPrevId);\n    }\n\n    ~RearrangeNodeAction() {  }\n\n    const char* Name() {\n        return \"Hierarchy Reorder\";\n    }\n};\n\nstruct CreateNodeAction : DocumentAction {\n    Document* owner;\n    u32 parentUID;\n    Node2D* createdInstance;\n    bool undone;\n\n    CreateNodeAction(Document* doc, u32 parent) {\n        owner = doc;\n        parentUID = parent;\n        undone = false;\n\n        owner->dirty = true;\n        Node2D* _parent = owner->FindNodeById(parentUID);\n        if (_parent == 0) {\n            _parent = owner->rootNode;\n        }\n\n        createdInstance = (Node2D*)MemAlloc(sizeof(Node2D));\n        MemClear(createdInstance, sizeof(Node2D));\n        createdInstance->uid = ++owner->nodeUidGenerator;\n\n        createdInstance->name = (char*)MemAlloc(NODE2D_DEFAULT_NAME_CAPACITY + 1);\n        MemClear(createdInstance->name, NODE2D_DEFAULT_NAME_CAPACITY + 1);\n        createdInstance->nameCapacity = NODE2D_DEFAULT_NAME_CAPACITY;\n        stbsp_snprintf(createdInstance->name, createdInstance->nameCapacity, \"Node %d\", createdInstance->uid);\n\n        createdInstance->refCount += 1;  // +1 for the create node action\n        createdInstance->scale = vec2(1, 1);\n        createdInstance->uiScaleLock = true;\n        createdInstance->uiVisible = true;\n        createdInstance->uiExpanded = true;\n\n        SetParent(_parent, *createdInstance);\n        SetName(*createdInstance, createdInstance->name);\n    }\n\n    ~CreateNodeAction() {\n        createdInstance->refCount -= 1;\n        if (undone) {\n            PlatformAssert(createdInstance->firstChild == 0, __LOCATION__);\n        }\n        RecursivleyDestroyNodeIfItHasNoReferences(createdInstance);\n\n        owner = 0;\n    }\n\n    void Undo() {\n        undone = true;\n        owner->dirty = true;\n        owner->numNodes -= 1;\n        createdInstance->refCount -= 1;  // -1 since it's deleted\n        PlatformAssert(createdInstance->refCount != 0, __LOCATION__); // This struct has to have +1 ref!\n\n        if (createdInstance->parent != 0) {\n            RemoveChild(*createdInstance->parent, *createdInstance);\n        }\n\n        PlatformAssert(createdInstance->firstChild == 0, __LOCATION__);\n    }\n\n    void Redo() {\n        undone = false;\n        owner->dirty = true;\n        owner->numNodes += 1;\n        Node2D* parent = owner->FindNodeById(parentUID);\n        if (parent == 0) {\n            parent = owner->rootNode;\n        }\n        createdInstance->refCount += 1;  // +1 since it's in document\n\n        SetParent(parent, *createdInstance);\n    }\n\n    const char* Name() {\n        return \"Hierarchy create node\";\n    }\n\n    Node2D* RedoResult() {\n        return createdInstance;\n    }\n};\n\nstruct DeleteNodeAction : DocumentAction {\n    Document* owner;\n    Node2D* deletedNode;\n    u32 parentId;\n    u32 lastSibling;\n\n    DeleteNodeAction(Document* doc, Node2D* target) {\n        PlatformAssert(target != 0, __LOCATION__);\n        owner = doc;\n        parentId = 0;\n        deletedNode = target;\n\n\n        // Increase the reference cound for every node that the delete action touches\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) { // Not sure if i should do this just to the root, or all nodes\n            node->refCount += 1;\n            PlatformAssert(node->refCount > 0, __LOCATION__);\n        }, 0);\n\n        lastSibling = 0;\n        if (target->parent != 0) {\n            parentId = target->parent->uid;\n            Node2D* iter = target->parent->firstChild;\n            while (iter != 0) {\n                if (iter->uid == target->uid) {\n                    break;\n                }\n                lastSibling = iter->uid;\n                iter = iter->next;\n            }\n        }\n    }\n\n    ~DeleteNodeAction() {\n        // Decrease the reference count, since the delete action is gone\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) {\n            node->refCount -= 1;\n        }, 0);\n\n        RecursivleyDestroyNodeIfItHasNoReferences(deletedNode);\n    }\n\n    void Undo() {\n        Node2D* parent = owner->FindNodeById(parentId);\n        if (parent == 0) {\n            parent = owner->rootNode;\n        }\n        SetParent(parent, *deletedNode, lastSibling);\n        owner->selectedNode = deletedNode;\n\n        // Increase the reference cound for every node when it is added to the hierarchy\n        u32 nodesToRemove = 0;\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) {\n            u32* nodesToRemove = (u32*)userData;\n            *nodesToRemove += 1;\n            node->refCount += 1;\n            PlatformAssert(node->refCount > 0, __LOCATION__);\n        }, &nodesToRemove);\n        owner->numNodes += nodesToRemove;\n\n    }\n\n    void Redo() {\n        PlatformAssert (owner->selectedNode->uid == deletedNode->uid, __LOCATION__);\n        SetParent(0, *deletedNode);\n        owner->selectedNode = 0;\n\n        // Decrease the reference cound for every node when it is removed from the hierarchy\n        u32 nodesToRemove = 0;\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) {\n            u32* nodesToRemove = (u32*)userData;\n            *nodesToRemove += 1; \n            node->refCount -= 1;\n            PlatformAssert(node->refCount > 0, __LOCATION__);\n        }, & nodesToRemove);\n        owner->numNodes -= nodesToRemove;\n    }\n\n    const char* Name() {\n        return \"Hierarchy delete node\";\n    }\n};\n\nstruct RenameNodeAction : DocumentAction {\n    Document* owner;\n    u32 nodeId;\n    char* oldName;\n    u32 oldNameLen;\n    char* newName;\n    u32 newNameLen;\n\n    RenameNodeAction(Document* doc, Node2D* node, const char* name) {\n        PlatformAssert(node != 0, __LOCATION__);\n        PlatformAssert(name != 0, __LOCATION__);\n\n        owner = doc;\n        nodeId = node->uid;\n\n        oldName = 0;\n        oldNameLen = 0;\n        if (node->name != 0) {\n            oldNameLen = node->nameLength;\n            oldName = (char*)MemAlloc(oldNameLen + 1);\n            for (u32 i = 0; i < oldNameLen; ++i) {\n                oldName[i] = node->name[i];\n            }\n            oldName[oldNameLen] = 0;\n        }\n\n        newName = 0;\n        newNameLen = 0;\n        if (name) {\n            u32 len = 0;\n            const char* iter = name;\n            while (*iter != 0) {\n                len++;\n                iter++;\n            }\n\n            newNameLen = len;\n            newName = (char*)MemAlloc(newNameLen + 1);\n            for (u32 i = 0; i < newNameLen; ++i) {\n                newName[i] = name[i];\n            }\n            newName[newNameLen] = 0;\n        }\n    }\n\n    void Redo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        if (node->nameCapacity < newNameLen + 1) {\n            node->nameCapacity = newNameLen + 1;\n            node->name = (char*)MemRealloc(node->name, newNameLen + 1);\n        }\n\n        node->nameLength = newNameLen;\n        for (u32 i = 0; i < newNameLen; ++i) {\n            node->name[i] = newName[i];\n        }\n        node->name[newNameLen] = 0;\n    }\n\n    void Undo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        if (node->nameCapacity < oldNameLen + 1) {\n            node->nameCapacity = oldNameLen + 1;\n            node->name = (char*)MemRealloc(node->name, oldNameLen + 1);\n        }\n\n        node->nameLength = oldNameLen;\n        for (u32 i = 0; i < oldNameLen; ++i) {\n            node->name[i] = oldName[i];\n        }\n        node->name[oldNameLen] = 0;\n    }\n\n    ~RenameNodeAction() {\n        if (oldName != 0) {\n            MemRelease(oldName);\n        }\n        if (newName != 0) {\n            MemRelease(newName);\n        }\n    }\n\n    const char* Name() {\n        return \"Rename node\";\n    }\n};\n\nstruct EditTransformAction : DocumentAction {\n    Document* owner;\n    u32 nodeId;\n\n    vec2 olsPos;\n    vec2 newPos;\n\n    float oldRot;\n    float newRot;\n\n    vec2 oldScale;\n    vec2 newScale;\n\n    EditTransformAction(Document* doc, Node2D* node, const vec2& nPos, float nRot, const vec2& nScale) {\n        owner = doc;\n        nodeId = node->uid;\n\n        olsPos = node->position;\n        oldRot = node->rotation;\n        oldScale = node->scale;\n\n        newPos = nPos;\n        newRot = nRot;\n        newScale = nScale;\n    }\n\n    void Redo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        node->position = newPos;\n        node->rotation = newRot;\n        node->scale = newScale;\n    }\n\n    void Undo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        node->position = olsPos;\n        node->rotation = oldRot;\n        node->scale = oldScale;\n    }\n\n    ~EditTransformAction() {\n        // Nothing to do\n    }\n\n    const char* Name() {\n        return \"Edit node transform\";\n    }\n};\n\nstruct ToggleUniformScaleAction : DocumentAction {\n    Document* owner;\n    u32 nodeId;\n\n    bool initialStae;\n    bool newState;\n\n    ToggleUniformScaleAction(Document* doc, Node2D* node) { \n        owner = doc;\n        nodeId = node->uid;\n        initialStae = node->uiScaleLock;\n        newState = !initialStae;\n    }\n\n    void Redo() { \n        Node2D* node = owner->FindNodeById(nodeId);\n        node->uiScaleLock = newState;\n    }\n\n    void Undo() { \n        Node2D* node = owner->FindNodeById(nodeId);\n        node->uiScaleLock = initialStae;\n    }\n\n    ~ToggleUniformScaleAction() { }\n\n    const char* Name() {\n        return \"Toggle uniform scale\";\n    }\n};\n\nstruct StaticActionSize {\n    union {\n        HierarchySelectAction hierarchySelection;\n        CreateNodeAction createNode;\n        DeleteNodeAction deleteNode;\n        RearrangeNodeAction arrangeNode;\n        RenameNodeAction renameNode;\n        EditTransformAction editTransform;\n        ToggleUniformScaleAction toggleUniformScale;\n    };\n};\n\nStaticActionSize* GrabNextUndoSlot(Document* d);\n\nvoid Document::DeleteNode(Node2D* node) {\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    DeleteNodeAction* dAction = new (action)DeleteNodeAction(this, node);\n    dAction->Redo();\n}\n\nNode2D* Document::CreateNode(Node2D* parent) {\n    if (parent == 0) {\n        parent = rootNode;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    CreateNodeAction* cAction = new (action)CreateNodeAction(this, parent->uid);\n    cAction->Redo();\n    return cAction->RedoResult();\n}\n\nvoid Document::RearrangeNode(Node2D& nodeToInsert, Node2D& parent, Node2D* prevSibling) {\n    PlatformAssert(nodeToInsert.parent != 0, __LOCATION__);\n\n    Node2D* iter = &parent;\n    while (iter != 0) {\n        if (iter == &nodeToInsert) {\n            return; // Early out if causing a problem\n        }\n        iter = iter->parent;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    RearrangeNodeAction* rAction = new (action)RearrangeNodeAction(this, &nodeToInsert, &parent, prevSibling);\n    rAction->Redo();\n}\n\nvoid Document::RenameNode(Node2D* node, const char* newName) {\n    PlatformAssert(node != 0, __LOCATION__);\n    PlatformAssert(newName != 0, __LOCATION__);\n\n    const char* oldName = node->name;\n\n    bool same = true;\n\n    u32 newLen = 0;\n    for (; newName[newLen] != '\\0'; ++newLen);\n    u32 oldLen = 0;\n    for (; oldName[oldLen] != '\\0'; ++oldLen);\n\n    if (newLen != oldLen) {\n        same = false;\n    }\n    else {\n        for (u32 i = 0; i < newLen; ++i) {\n            if (newName[i] != oldName[i]) {\n                same = false;\n                break;\n            }\n        }\n    }\n\n    if (!same) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        RenameNodeAction* rAction = new (action)RenameNodeAction(this, node, newName);\n        rAction->Redo();\n    }\n}\n\n#define NODE_TRANSFORM_DELTA 0.00001f\nvoid Document::UpdateNodeTransform(Node2D* node, const vec2& pos, float rot, const vec2& scl) {\n    PlatformAssert(node != 0, __LOCATION__);\n\n    vec2 posDelta = abs(node->position - pos);\n    float rotDelta = MathAbsF(node->rotation - rot);\n    vec2 scaleDelta = abs(node->scale - scl);\n\n    bool same = true;\n    if (posDelta.x > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (posDelta.y > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (rotDelta > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (scaleDelta.x > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (scaleDelta.y > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n\n    if (!same) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        EditTransformAction* eAction = new (action)EditTransformAction(this, node, pos, rot, scl);\n        eAction->Redo();\n    }\n}\n\nvoid Document::ToggleUniformScale(Node2D* node) {\n    PlatformAssert(node != 0, __LOCATION__);\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    ToggleUniformScaleAction* tAction = new (action)ToggleUniformScaleAction(this, node);\n    tAction->Redo();\n}\n\nNode2D* Document::SelectNode(Node2D* node) {\n    u32 prevSelectionId = 0;\n    Node2D* prevSelect = 0;\n    if (selectedNode != 0) {\n        prevSelectionId = selectedNode->uid;\n        prevSelect = selectedNode;\n    }\n\n    u32 nodeSelectionID = 0;\n    if (selectedNode != 0 && node != 0 && selectedNode->uid == node->uid) {\n        return selectedNode;\n    }\n    else if (node != 0) {\n        nodeSelectionID = node->uid;\n    }\n    \n    StaticActionSize* action = GrabNextUndoSlot(this);\n    HierarchySelectAction* hAction = new (action) HierarchySelectAction(this, nodeSelectionID, prevSelectionId);\n    hAction->Redo();\n    return prevSelect;\n}\n\nDocument::Document(u32 numUndoSteps) :\n    dirty(false), numNodes(0), selectedNode(0),\n    nodeUidGenerator(0), undoStackCurrent(0) {\n\n    if (numUndoSteps < 10) {\n        numUndoSteps = 10;\n    }\n\n    if (numUndoSteps % 2 != 0) {\n        numUndoSteps += 1;\n    }\n    u32 undoStackSize = numUndoSteps * 2 * sizeof(StaticActionSize);\n\n    rootNode = (Node2D*)MemAlloc(sizeof(Node2D));\n    MemClear(rootNode, sizeof(Node2D));\n    rootNode->scale = vec2(1, 1);\n    rootNode->refCount += 1;\n\n    undoNumSteps = numUndoSteps;\n    undoStack = (StaticActionSize*)MemAlloc(undoStackSize);\n    MemClear(undoStack, undoStackSize);\n    undoStackTop = undoStackCurrent;\n\n    // Initialize all undo actions to be null actions\n    for (u32 i = 0; i < numUndoSteps * 2; ++i) {\n        NullAction* action = new (&undoStack[i])NullAction();\n    }\n}\n\nvoid Document::ClearUndoHistory(u32 firstIndex, u32 lastIndex) {\n    if (lastIndex > undoStackTop) {\n        lastIndex = undoStackTop;\n    }\n    if (lastIndex == 0 && undoStackTop == 0) {\n        return;\n    }\n\n    PlatformAssert(firstIndex < lastIndex, __LOCATION__);\n    PlatformAssert(lastIndex >= 1, __LOCATION__);\n\n    i32 _lastIndex = lastIndex;\n    i32 _firstIndex = firstIndex;\n\n    if (lastIndex >= 1) {\n        //for (i32 i = _lastIndex - 1; i >= _firstIndex; i--) {\n        // I'm sure this will come back to bite me in the ass\n        // loop forward, because if looping backward, i can\n        // get at a destroy call, without ever having seen it's \n        // create call in the stack, leaking one reference.\n        // If it's a problem later, remove the reference assert 1\n        // from the destroy action? I'm not sure if that's a good solution.\n        for (i32 i = _firstIndex; i < _lastIndex; ++i) {\n            DocumentAction* actionToUndo = (DocumentAction*)&undoStack[i];\n            actionToUndo->~DocumentAction();\n            new (actionToUndo)NullAction();\n        }\n    }\n}\n\nDocument::~Document() {\n    ClearUndoHistory(0, undoStackTop);\n    PlatformAssert(rootNode->refCount == 1, __LOCATION__);\n\n    // Release the hierarchy\n    ForEachNode(rootNode, [](Node2D* node, void* userData) {\n        PlatformAssert(node->refCount == 1, __LOCATION__);\n        node->refCount -= 1;\n    }, 0);\n    RecursivleyDestroyNodeIfItHasNoReferences(rootNode);\n    rootNode = 0;\n\n    MemRelease(undoStack);\n}\n\nStaticActionSize* GrabNextUndoSlot(Document* d) {\n    // Ran out of steps. Remove the first half of the undo stack\n    // and use the second half. I doubled the requested undo\n    // stack size to avoid having to use a doubly linked list\n    if (d->undoStackCurrent == d->undoNumSteps * 2) {\n        void* target = d->undoStack;\n        void* source = &d->undoStack[d->undoNumSteps];\n        d->ClearUndoHistory(0, d->undoNumSteps);\n        \n        MemCopy(target, source, d->undoNumSteps * sizeof(StaticActionSize));\n        d->undoStackTop -= d->undoNumSteps;\n        d->undoStackCurrent -= d->undoNumSteps;\n\n        for (i32 i = d->undoNumSteps * 2 - 1; i >= d->undoNumSteps; i--) {\n            DocumentAction* actionToUndo = (DocumentAction*)&d->undoStack[i];\n            // Destructor does not need to be called, we're just transferring ownership\n            // with that memcpy\n            new (actionToUndo)NullAction();\n        }\n    }\n    else {\n        // Abandoning old undo stack with new action, need to clean up memory\n        if (d->undoStackTop != d->undoStackCurrent) {\n            d->ClearUndoHistory(d->undoStackCurrent, d->undoStackTop);\n            d->undoStackTop = d->undoStackCurrent;\n        }\n    }\n\n    StaticActionSize* result = &d->undoStack[d->undoStackCurrent++];\n    d->undoStackTop = d->undoStackCurrent;\n\n    return result;\n}\n\nvoid Document::Undo() {\n    if (undoStackCurrent == 0) {\n        return;\n    }\n\n    StaticActionSize* genericAction = &undoStack[--undoStackCurrent];\n    DocumentAction* action = (DocumentAction*)genericAction;\n    action->Undo();\n}\n\nvoid Document::Redo() {\n    if (undoStackCurrent >= undoStackTop) {\n        return;\n    }\n\n    StaticActionSize* genericAction = &undoStack[undoStackCurrent++];\n    DocumentAction* action = (DocumentAction*)genericAction;\n    action->Redo();\n}\n\nconst char* Document::GetUndoStepName(u32 index) {\n    PlatformAssert(undoStackTop >= GetNumUndoSteps(), __LOCATION__);\n    u32 base = undoStackTop - GetNumUndoSteps();\n    StaticActionSize* genericAction = &undoStack[base + index];\n    DocumentAction* action = (DocumentAction*)genericAction;\n    return action->Name();\n}","#ifndef _H_DOCUMENT_\n#define _H_DOCUMENT_\n\n#include \"Node2D.h\"\n\nstruct Document {\n    friend struct CreateNodeAction;\n    friend struct DeleteNodeAction;\n    friend struct HierarchySelectAction;\n    friend struct RearrangeNodeAction;\n    friend struct StaticActionSize* GrabNextUndoSlot(Document*);\nprotected:\n    bool dirty;\n\n    Node2D* rootNode;\n    u32 numNodes;\n\n    u32 nodeUidGenerator;\n\n    Node2D* selectedNode;\n\n    struct StaticActionSize* undoStack; \n    u32 undoNumSteps;\n    u32 undoStackTop;\n    u32 undoStackCurrent; // 1 past the last undo\n    void ClearUndoHistory(u32 firstIndex, u32 lastIndex);\npublic:\n    Document(u32 numUndoSteps);\n    ~Document();\n\n    void Undo();\n    void Redo();\n    inline void ClearUndoHistory() {\n        ClearUndoHistory(0, undoStackTop);\n        undoStackTop = 0;\n        undoStackCurrent = 0;\n    }\n\n    Node2D* FindNodeById(u32 nodeId);\n    \n    Node2D* CreateNode(Node2D* parent);\n    void DeleteNode(Node2D* node); // \n    Node2D* SelectNode(Node2D* node); // Returns previous selection\n    void RenameNode(Node2D* node, const char* newName);\n    void UpdateNodeTransform(Node2D* node, const vec2& pos, float rot, const vec2& scl);\n    void ToggleUniformScale(Node2D* node);\n\n    void RearrangeNode(Node2D& nodeToInsert, Node2D& parent, Node2D* prevSibling);\n\n    Node2D* DepthFirst(Node2D* iter);\n    Node2D* DepthFirstExpandedOnly(Node2D* iter);\npublic:\n    inline Node2D* GetSelectedNode() {\n        return selectedNode;\n    }\n\n    inline u32 GetNodeCount() {\n        return numNodes;\n    }\n\n    inline u32 GetVisibleNodeCount() {\n        u32 count = 0;\n        Node2D* iter = DepthFirstExpandedOnly(0);\n        iter = DepthFirstExpandedOnly(iter);\n        while (iter != 0) {\n            count += 1;\n            iter = DepthFirstExpandedOnly(iter);\n        }\n        return count;\n    }\n\n    inline bool CanRedo() {\n        return undoStackCurrent < undoStackTop;\n    }\n\n    inline bool CanUndo() {\n        u32 undoStackBottom = undoStackTop < undoNumSteps ? 0 : undoStackTop - undoNumSteps;\n        PlatformAssert(undoStackCurrent >= undoStackBottom, __LOCATION__);\n        u32 current = undoStackCurrent - undoStackBottom;\n        return current != 0;\n    }\n\n    inline u32 GetNumUndoSteps() {\n        return (undoStackTop > undoNumSteps) ? undoNumSteps : undoStackTop;\n    }\n\n    inline u32 GetUndoStackCurrent()  {\n        u32 undoStackBottom = undoStackTop < undoNumSteps? 0 : undoStackTop - undoNumSteps;\n        PlatformAssert(undoStackCurrent >= undoStackBottom, __LOCATION__);\n        return undoStackCurrent - undoStackBottom;\n    }\n\n    inline u32 GetMaxUndoSteps() {\n        return undoNumSteps;\n    }\n\n    const char* GetUndoStepName(u32 index);\n};\n\n#endif // !_H_DOCUMENT_\n"],"mappings":"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"}