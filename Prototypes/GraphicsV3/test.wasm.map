{"version":3,"names":[],"sources":["test.cpp","debt/lodepng.c","debt/stb_vorbis.c","debt/calcTangents.cpp","graphics.h","window.h"],"sourcesContent":["// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    __wasm_call_ctors();\n}\n\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\"\n\n#include \"window.h\"\n#include \"memory.h\"\n#include \"math.h\"\n#include \"loader.h\"\n#include \"graphics.h\"\n#include \"audio.h\"\n\n#include \"debt/lodepng.h\"\n#include \"debt/lodepng.c\"\n#include \"debt/stb_vorbis.c\"\n#include \"debt/calcTangents.cpp\"\n\n// TODO: Reduce so it's not 26MB\n#define LOAD_BUFFER_SIZE (1024 * 1024 * 26)\n\nWASM_MEM_EXPOSE_HEAP\nWASM_LOADER_ENABLE_CALLBACKS\n\nstruct AppData {\n    u32 vbo;\n    u32 shader;\n    u32 vao;\n\n    u32 planeVBO;\n    u32 planeVAO;\n    u32 planeNumVerts;\n    u32 planeShader;\n    u32 planeUniformModel;\n    u32 planeUniformView;\n    u32 planeUniformProj;\n    u32 planeUniformShadow;\n    u32 PlaneUniformColorSpec;\n    u32 PlaneUniformNormal;\n    u32 PlaneUniformShadowMap; \n    u32 PlaneUniformLightDirection;\n    u32 PlaneUniformLightColor;\n    u32 PlaneUniformViewPos;\n    u32 PlaneTextureColorSpec;\n    u32 PlaneTextureNormal;\n\n    u32 shadowMapShader;\n    u32 shadowMapUniformMvp;\n    u32 shadowMapTexture;\n    u32 shadowMapVao;\n\n    u32 skullShader;\n    u32 skullVbo;\n    u32 skullVao;\n    u32 skullNumVerts;\n    u32 skullUniformModel;\n    u32 skullUniformView;\n    u32 skullUniformProj;\n    u32 skullUniformAlbedo;\n    u32 skullUniformNormal;\n    u32 skullUniformTop;\n    u32 skullUniformBottom;\n    u32 skullUniformLightDir;\n    u32 skullUniformLightColor;\n    u32 skullUniformViewPos;\n    u32 skullAlbedoTexture;\n    u32 skullNormalTexture;\n    bool canDisplaySkull;\n\n    float* model;\n    float* view;\n    float* proj;\n    float cam[3];\n\n    u32 oneShotBufffer;\n    u32 oneShotBus;\n    u32 loopingBus;\n    u32 loopingBuffer;\n    u32 loopingSound;\n};\n\nexport void* Initialize() {\n    float vertices[] = {\n        -0.5f, -0.5f, 0.0f,\n        0.5f, -0.5f, 0.0f,\n        0.0f,  0.5f, 0.0f\n    };  \n\n    AppData* app = (AppData*)MemAllocate(sizeof(AppData), 0);\n    app->canDisplaySkull = false;\n    app->oneShotBus = AudioCreateBus();\n    app->loopingBus = AudioCreateBus();\n\n    app->model = (float*)MemAllocate(sizeof(float) * 16, 0);\n    app->view = (float*)MemAllocate(sizeof(float) * 16, 0);\n    app->proj = (float*)MemAllocate(sizeof(float) * 16, 0);\n\n    for (int i = 0; i < 16; ++i) {\n        app->model[i] = 0.0f;\n        app->view[i] = 0.0f;\n        app->proj[i] = 0.0f;\n    }\n    app->model[0] = app->model[5] = app->model[10] = 0.1f;\n    app->model[12] = 1.5f;\n    app->model[14] = -0.5;\n    app->model[15] = 1.0f;\n\n    app->proj[0] = 1.82434f;\n    app->proj[5] = 2.43245f;\n    app->proj[10] = -1.00020f;\n    app->proj[11] = -1.00000f;\n    app->proj[14] = -0.20002f;\n    app->proj[15] =  0.00000f;\n     \n    app->view[0]  = 0.98773f;\n    app->view[1]  = -0.05942f;\n    app->view[2]  = 0.13843f;\n    app->view[5]  = 0.91813f;\n    app->view[6]  = 0.39411f;\n    app->view[8]  = -0.15065f;\n    app->view[9]  = -0.38962f;\n    app->view[10] = 0.90761f;\n    app->view[14] = -7.59863f;\n    app->view[15] = 1.00000f;\n\n    app->cam[0] = 1.05370f;\n    app->cam[1] = 3.00000f;\n    app->cam[2] = 6.90875f;\n\n    app->shadowMapTexture = GfxCreateDepthTexture(4096, 4096);\n    GfxSetTextureSampler(app->shadowMapTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterNearest, GfxFilterNone, GfxFilterNearest);\n\n    app->vbo = GfxCreateBuffer();\n    GfxFillArrayBuffer(app->vbo, vertices, sizeof(float) * 9, true);\n\n    const char* v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                            \"layout (location = 0) in vec3 aPos;\\n\"\n                            \"void main() {\\n\"\n                            \"    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"\n                            \"}\";\n    const char* f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                            \"out vec4 FragColor;\\n\"\n                            \"void main() {\\n\"\n                            \"    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"\n                            \"}\";\n    app->shader = GfxCreateShader(v_shader, f_shader);\n\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 position;\\n\"\n                \"uniform mat4 mvp;\\n\"\n                \"void main (void) {\\n\"\n                \"  gl_Position = mvp * vec4(position, 1.0);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"void main (void) {\\n\"\n                \"  FragColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);\\n\"\n                \"}\\n\";\n    app->shadowMapShader = GfxCreateShader(v_shader, f_shader);\n    app->shadowMapUniformMvp = GfxGetUniformSlot(app->shadowMapShader, \"mvp\");\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 aPos;\\n\"\n                \"in vec3 aNorm;\\n\"\n                \"in vec3 aTan;\\n\"\n                \"in vec2 aTexCoord;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform mat4 view;\\n\"\n                \"uniform mat4 projection;\\n\"\n                \"uniform mat4 shadow;\\n\"\n                \"out mat3 TBN;\\n\"\n                \"out vec2 TexCoord;\\n\"\n                \"out vec3 FragPos;\\n\"\n                \"out vec4 LightViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tgl_Position = projection * view * model * vec4(aPos, 1.0);\\n\"\n                \"\tFragPos = vec3(model * vec4(aPos, 1.0));\\n\"\n                \"\tLightViewPos = shadow * vec4(aPos, 1.0);\\n\"\n                \"\tvec3 biTangent = cross(aNorm, aTan);\\n\"\n                \"\tvec3 T = normalize(vec3(model * vec4(aTan,   0.0)));\\n\"\n                \"\tvec3 B = normalize(vec3(model * vec4(biTangent, 0.0)));\\n\"\n                \"\tvec3 N = normalize(vec3(model * vec4(aNorm,    0.0)));\\n\"\n                \"\tTBN = mat3(T, B, N);\\n\"\n                \"\tTexCoord = vec2(aTexCoord.x, aTexCoord.y);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec2 TexCoord;\\n\"\n                \"in vec3 FragPos;\\n\"\n                \"in mat3 TBN;\\n\"\n                \"in vec4 LightViewPos;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"uniform sampler2D uColorSpec;\\n\"\n                \"uniform sampler2D uNormal;\\n\"\n                \"uniform sampler2D uShadowMap; \\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform vec3 LightDirection;\\n\"\n                \"uniform vec3 LightColor;\\n\"\n                \"uniform vec3 ViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tvec3 normal = texture(uNormal, TexCoord).rgb; \\n\"\n                \"\tnormal = normal * 2.0 - 1.0;\\n\"\n                \"\tnormal = normalize(TBN * normal); // World space normal\\n\"\n                \"\tvec4 colorSpec = texture(uColorSpec, TexCoord);\\n\"\n                \"\tvec3 objectColor = colorSpec.rgb;\\n\"\n                \"\tvec3 lightDir = normalize(-LightDirection);\\n\"\n                \"\tfloat diff = max(dot(normal, lightDir), 0.0);\\n\"\n                \"\tvec3 diffuse = diff * LightColor;\\n\"\n                \"\tvec3 ambient = 0.2 * LightColor;\\n\"\n                \"\tvec3 viewDir = normalize(ViewPos - FragPos);\\n\"\n                \"\tvec3 reflectDir = reflect(-lightDir, normal);\\n\"\n                \"\tfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n\"\n                \"\tvec3 specular = colorSpec.a * spec * LightColor;  \\n\"\n                \"\tvec4 FinalColor = vec4((ambient+diffuse+specular) * objectColor, 1.0);\\n\"\n                \"\tvec3 p = LightViewPos.xyz / LightViewPos.w;\\n\"\n                \"\tFragColor = FinalColor * (texture(uShadowMap, p.xy).r < p.z? 0.0 : 1.0);\\n\"\n                \"}\\n\";\n    app->planeShader = GfxCreateShader(v_shader, f_shader);\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 aPos;\\n\"\n                \"in vec3 aNorm;\\n\"\n                \"in vec3 aTan;\\n\"\n                \"in vec2 aTexCoord;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform mat4 view;\\n\"\n                \"uniform mat4 projection;\\n\"\n                \"out mat3 TBN;\\n\"\n                \"out vec2 TexCoord;\\n\"\n                \"out vec3 FragPos;\\n\"\n                \"void main() {\\n\"\n                \"\tgl_Position = projection * view * model * vec4(aPos, 1.0);\\n\"\n                \"\tFragPos = vec3(model * vec4(aPos, 1.0));\\n\"\n                \"\tvec3 biTangent = cross(aNorm, aTan);\\n\"\n                \"\tvec3 T = normalize(vec3(model * vec4(aTan,   0.0)));\\n\"\n                \"\tvec3 B = normalize(vec3(model * vec4(biTangent, 0.0)));\\n\"\n                \"\tvec3 N = normalize(vec3(model * vec4(aNorm,    0.0)));\\n\"\n                \"\tTBN = mat3(T, B, N);\\n\"\n                \"\tTexCoord = vec2(aTexCoord.x, aTexCoord.y);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                \"in vec2 TexCoord;\\n\"\n                \"in vec3 FragPos;\\n\"\n                \"in mat3 TBN;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"uniform sampler2D uColorSpec;\\n\"\n                \"uniform sampler2D uNormal;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform vec3 HemiTop;\\n\"\n                \"uniform vec3 HemiBottom;\\n\"\n                \"uniform vec3 LightDirection;\\n\"\n                \"uniform vec3 LightColor;\\n\"\n                \"uniform vec3 ViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tvec3 normal = texture(uNormal, TexCoord).rgb;\\n\" \n                \"\tnormal = normal * 2.0 - 1.0;\\n\"\n                \"\tnormal = normalize(TBN * normal); // World space normal\\n\"\n                \"\tvec4 colorSpec = texture(uColorSpec, TexCoord);\\n\"\n                \"\tvec3 color = colorSpec.rgb;\\n\"\n                \"\tvec3 lightDir = normalize(-LightDirection);\\n\"\n                \"\tfloat diff = max(dot(normal, lightDir), 0.0);\\n\"\n                \"\tvec3 diffuse = diff * LightColor;\\n\"\n                \"\tdiff = max(dot(normal, normalize(vec3(-0.25, -1, 1))), 0.0);\\n\"\n                \"\tvec3 ambient = mix(HemiBottom, HemiTop, diff) * LightColor;\\n\"\n                \"\tvec3 viewDir = normalize(ViewPos - FragPos);\\n\"\n                \"\tvec3 reflectDir = reflect(-lightDir, normal);\\n\"\n                \"\tfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n\"\n                \"\tvec3 specular = colorSpec.a * spec * LightColor;  \\n\"\n                \"\tFragColor = vec4((ambient + diffuse + specular) * color, 1.0);\\n\"\n                \"}\\n\";\n    app->skullShader = GfxCreateShader(v_shader, f_shader);\n    app->skullUniformAlbedo = GfxGetUniformSlot(app->skullShader, \"uColorSpec\");\n\n    app->skullUniformNormal= GfxGetUniformSlot(app->skullShader, \"uNormal\");\n    app->skullUniformTop= GfxGetUniformSlot(app->skullShader, \"HemiTop\");\n    app->skullUniformBottom= GfxGetUniformSlot(app->skullShader, \"HemiBottom\");\n    app->skullUniformLightDir= GfxGetUniformSlot(app->skullShader, \"LightDirection\");\n    app->skullUniformLightColor= GfxGetUniformSlot(app->skullShader, \"LightColor\");\n    app->skullUniformViewPos= GfxGetUniformSlot(app->skullShader, \"ViewPos\");\n\n    app->vao = GfxCreateShaderVertexLayout(app->shader);\n    GfxAddBufferToLayout(app->vao, \"aPos\", app->vbo, 3, 0, GfxBufferTypeFloat32, 0);\n\n\n    void* loadArena = MemAllocate(LOAD_BUFFER_SIZE, 0);\n    LoadFileAsynch(\"assets/skull.mesh\", false, loadArena, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n        AppData* app = (AppData*)userData;\n\n        unsigned int* uint_data = (unsigned int*)data;\n        unsigned int numVerts = uint_data[0];  // Ignore 1, and 2. Always the same anyway\n        app->skullNumVerts = numVerts;\n       \n        float* srcPos = (float*)(uint_data + 3);\n        float* srcNrm = srcPos + numVerts * 3;\n        float* srcTex = srcNrm + numVerts * 3;\n\n        unsigned int tanArray_size = sizeof(float) * 3 * numVerts;\n        float* tanArray = (float*)MemAllocate(tanArray_size, 0);\n        MemClear(tanArray, tanArray_size);\n        CalculateMeshTangents::CalculateTangentArray(numVerts, srcPos, srcNrm, srcTex, tanArray);\n\n        unsigned int interleaved_size = sizeof(float) * numVerts * (3 + 3 + 3 + 2);\n        float* interleaved = (float*)MemAllocate(interleaved_size, 0);\n\n        for (int i = 0, j = 0; i < numVerts; ++i, j += 11) {\n            interleaved[j + 0] = srcPos[i * 3 + 0];\n            interleaved[j + 1] = srcPos[i * 3 + 1];\n            interleaved[j + 2] = srcPos[i * 3 + 2];\n\n            interleaved[j + 3] = srcNrm[i * 3 + 0];\n            interleaved[j + 4] = srcNrm[i * 3 + 1];\n            interleaved[j + 5] = srcNrm[i * 3 + 2];\n\n            interleaved[j + 6] = srcTex[i * 2 + 0];\n            interleaved[j + 7] = srcTex[i * 2 + 1];\n\n            interleaved[j + 8] = tanArray[i * 3 + 0];\n            interleaved[j + 9] = tanArray[i * 3 + 1];\n            interleaved[j + 10] = tanArray[i * 3 + 2];\n        }\n\n        app->skullVbo = GfxCreateBuffer();\n        GfxFillArrayBuffer(app->skullVbo, interleaved, interleaved_size, true);\n\n        app->skullVao = GfxCreateShaderVertexLayout(app->skullShader);\n        GfxAddBufferToLayout(app->skullVao, \"aPos\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n        GfxAddBufferToLayout(app->skullVao, \"aNorm\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 3); \n        GfxAddBufferToLayout(app->skullVao, \"aTexCoord\", app->skullVbo, 2, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 6);\n        GfxAddBufferToLayout(app->skullVao, \"aTan\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 8); \n\n        app->skullUniformModel = GfxGetUniformSlot(app->skullShader, \"model\");\n        app->skullUniformView  = GfxGetUniformSlot(app->skullShader, \"view\");\n        app->skullUniformProj  = GfxGetUniformSlot(app->skullShader, \"projection\");\n\n        app->shadowMapVao = GfxCreateShaderVertexLayout(app->shadowMapShader);\n        GfxAddBufferToLayout(app->shadowMapVao, \"position\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n\n        MemRelease(interleaved);\n        MemRelease(tanArray);\n\n        LoadFileAsynch(\"assets/Skull_AlbedoSpec.png\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n            AppData* app = (AppData*)userData;\n\n            u32 width = 0;\n            u32 height = 0;\n            u32 channels = 3;\n            LodePNGState state;\n            lodepng_state_init(&state);\n            lodepng_inspect(&width, &height, &state, (const unsigned char*)data, bytes); \n            unsigned int format = GfxTextureFormatRGB8;\n            if (lodepng_get_channels(&state.info_raw) == 4) {\n                format = GfxTextureFormatRGBA8;\n                channels = 4;\n            }   \n            unsigned char* img_data = (unsigned char*) MemAllocate(sizeof(char) * width * height * channels, 0);\n            lodepng_decode_memory(&img_data, &width, &height,\n                               (const unsigned char*)data, bytes,\n                               state.info_raw.colortype, state.info_raw.bitdepth);\n            lodepng_state_cleanup(&state);\n            app->skullAlbedoTexture = GfxCreateTexture(img_data, width, height, format, format, true);\n            GfxSetTextureSampler(app->skullAlbedoTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n            MemRelease(img_data);\n\n            LoadFileAsynch(\"assets/Skull_Normal.png\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                AppData* app = (AppData*)userData;\n               \n                u32 width = 0;\n                u32 height = 0;\n                u32 channels = 3;\n                LodePNGState state;\n                lodepng_state_init(&state);\n                lodepng_inspect(&width, &height, &state, (const unsigned char*)data, bytes); \n                unsigned int format = GfxTextureFormatRGB8;\n                if (lodepng_get_channels(&state.info_raw) == 4) {\n                    format = GfxTextureFormatRGBA8;\n                    channels = 4;\n                }   \n                unsigned char* img_data = (unsigned char*) MemAllocate(sizeof(char) * width * height * channels, 0);\n                lodepng_decode_memory(&img_data, &width, &height,\n                                (const unsigned char*)data, bytes,\n                                state.info_raw.colortype, state.info_raw.bitdepth);\n                lodepng_state_cleanup(&state);\n                app->skullNormalTexture = GfxCreateTexture(img_data, width, height, format, format, true);\n                GfxSetTextureSampler(app->skullNormalTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                MemRelease(img_data);          \n                \n                LoadFileAsynch(\"assets/plane.mesh\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                    AppData* app = (AppData*)userData;\n                    unsigned int* uint_data = (unsigned int*)data;\n                    unsigned int numVerts = uint_data[0];  // Ignore 1, and 2. Always the same anyway\n                    app->planeNumVerts = numVerts;\n                \n                    float* srcPos = (float*)(uint_data + 3);\n                    float* srcNrm = srcPos + numVerts * 3;\n                    float* srcTex = srcNrm + numVerts * 3;\n\n                    unsigned int tanArray_size = sizeof(float) * 3 * numVerts;\n                    float* tanArray = (float*)MemAllocate(tanArray_size, 0);\n                    MemClear(tanArray, tanArray_size);\n                    CalculateMeshTangents::CalculateTangentArray(numVerts, srcPos, srcNrm, srcTex, tanArray);\n                    unsigned int interleaved_size = sizeof(float) * numVerts * (3 + 3 + 3 + 2);\n                    float* interleaved = (float*)MemAllocate(interleaved_size, 0);\n                    for (int i = 0, j = 0; i < numVerts; ++i, j += 11) {\n                        interleaved[j + 0] = srcPos[i * 3 + 0];\n                        interleaved[j + 1] = srcPos[i * 3 + 1];\n                        interleaved[j + 2] = srcPos[i * 3 + 2];\n\n                        interleaved[j + 3] = srcNrm[i * 3 + 0];\n                        interleaved[j + 4] = srcNrm[i * 3 + 1];\n                        interleaved[j + 5] = srcNrm[i * 3 + 2];\n\n                        interleaved[j + 6] = srcTex[i * 2 + 0];\n                        interleaved[j + 7] = srcTex[i * 2 + 1];\n\n                        interleaved[j + 8] = tanArray[i * 3 + 0];\n                        interleaved[j + 9] = tanArray[i * 3 + 1];\n                        interleaved[j + 10] = tanArray[i * 3 + 2];\n                    }\n\n                    app->planeVBO = GfxCreateBuffer();\n                    GfxFillArrayBuffer(app->planeVBO, interleaved, interleaved_size, true);\n\n                    app->planeVAO = GfxCreateShaderVertexLayout(app->planeShader);\n                    GfxAddBufferToLayout(app->planeVAO, \"aPos\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n                    GfxAddBufferToLayout(app->planeVAO, \"aNorm\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 3); \n                    GfxAddBufferToLayout(app->planeVAO, \"aTexCoord\", app->planeVBO, 2, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 6);\n                    GfxAddBufferToLayout(app->planeVAO, \"aTan\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 8); \n\n                    app->planeUniformModel = GfxGetUniformSlot(app->planeShader, \"model\");\n                    app->planeUniformView = GfxGetUniformSlot(app->planeShader, \"view\");\n                    app->planeUniformProj = GfxGetUniformSlot(app->planeShader, \"projection\");\n                    app->planeUniformShadow = GfxGetUniformSlot(app->planeShader, \"shadow\");\n\n                    app->PlaneUniformColorSpec = GfxGetUniformSlot(app->planeShader, \"uColorSpec\");\n                    app->PlaneUniformNormal = GfxGetUniformSlot(app->planeShader, \"uNormal\");\n                    app->PlaneUniformShadowMap = GfxGetUniformSlot(app->planeShader, \"uShadowMap\");\n\n                    app->PlaneUniformLightDirection = GfxGetUniformSlot(app->planeShader, \"LightDirection\");\n                    app->PlaneUniformLightColor = GfxGetUniformSlot(app->planeShader, \"LightColor\");\n                    app->PlaneUniformViewPos = GfxGetUniformSlot(app->planeShader, \"ViewPos\");\n\n                    MemRelease(interleaved);\n                    MemRelease(tanArray);\n\n                    LoadFileAsynch(\"assets/Plane_AlbedoSpec.png\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                        AppData* app = (AppData*)userData;\n\n                        u32 width = 0;\n                        u32 height = 0;\n                        u32 channels = 3;\n                        LodePNGState state;\n                        lodepng_state_init(&state);\n                        lodepng_inspect(&width, &height, &state, (const unsigned char*)data, bytes); \n                        unsigned int format = GfxTextureFormatRGB8;\n                        if (lodepng_get_channels(&state.info_raw) == 4) {\n                            format = GfxTextureFormatRGBA8;\n                            channels = 4;\n                        }   \n                        unsigned char* img_data = (unsigned char*) MemAllocate(sizeof(char) * width * height * channels, 0);\n                        lodepng_decode_memory(&img_data, &width, &height,\n                                        (const unsigned char*)data, bytes,\n                                        state.info_raw.colortype, state.info_raw.bitdepth);\n                        lodepng_state_cleanup(&state);\n                        app->PlaneTextureColorSpec =  GfxCreateTexture(img_data, width, height, format, format, true);\n                        GfxSetTextureSampler(app->PlaneTextureColorSpec, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                        MemRelease(img_data);  \n                \n                        LoadFileAsynch(\"assets/Plane_Normal.png\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                            AppData* app = (AppData*)userData;\n                            u32 width = 0;\n                            u32 height = 0;\n                            u32 channels = 3;\n                            LodePNGState state;\n                            lodepng_state_init(&state);\n                            lodepng_inspect(&width, &height, &state, (const unsigned char*)data, bytes); \n                            unsigned int format = GfxTextureFormatRGB8;\n                            if (lodepng_get_channels(&state.info_raw) == 4) {\n                                format = GfxTextureFormatRGBA8;\n                                channels = 4;\n                            }   \n                            unsigned char* img_data = (unsigned char*) MemAllocate(sizeof(char) * width * height * channels, 0);\n                            lodepng_decode_memory(&img_data, &width, &height,\n                                            (const unsigned char*)data, bytes,\n                                            state.info_raw.colortype, state.info_raw.bitdepth);\n                            lodepng_state_cleanup(&state);\n                            app->PlaneTextureNormal =  GfxCreateTexture(img_data, width, height, format, format, true);\n                            GfxSetTextureSampler(app->PlaneTextureNormal, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                            MemRelease(img_data);        \n                            \n                            LoadFileAsynch(\"assets/oneshot.ogg\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                                AppData* app = (AppData*)userData;\n\n                                int channels = 0;\n                                int sampleRate = 0;\n                                short* decodedData = 0;\n                                int numSamples = stb_vorbis_decode_memory((const uint8*)data, (int)bytes, &channels, &sampleRate, &decodedData);\n                                app->oneShotBufffer = AudioCreateBuffer(channels, sampleRate, numSamples, decodedData);\n                                MemRelease(decodedData);\n\n                                if (numSamples <= 0 || decodedData == 0) {\n                                    MemDbgPrintStr(\"oneshot.ogg, bad data\");\n                                }\n                                \n                                LoadFileAsynch(\"assets/piano.ogg\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                                    AppData* app = (AppData*)userData;\n\n                                    int channels = 0;\n                                    int sampleRate = 0;\n                                    short* decodedData = 0;\n                                    int numSamples = stb_vorbis_decode_memory((const uint8*)data, (int)bytes, &channels, &sampleRate, &decodedData);\n                                    app->loopingBuffer = AudioCreateBuffer(channels, sampleRate, numSamples, decodedData);\n\n                                    if (numSamples <= 0 || decodedData == 0) {\n                                        MemDbgPrintStr(\"piano.ogg, bad data\");\n                                    }\n                                    \n                                    MemRelease(decodedData);\n\n                                    app->loopingSound = AudioPlay2D(app->loopingBuffer, app->loopingBus, true, 0.75f, 0.0f);\n\n                                    MemRelease(data);\n                                    app->canDisplaySkull = true;\n                                }, app);\n                            }, app);\n                        }, app);\n                    }, app);\n                }, app);\n            }, app);\n        }, app);\n    }, app);\n\n    GfxEnableDepthTest();\n\n    return app;\n}\n\nexport void Render(unsigned int x, unsigned int y, unsigned int w, unsigned int h, void* userData) {\n    AppData* app = (AppData*)userData;\n\n    if (MousePressed(MouseButtonLeft)) {\n        AudioPlay2D(app->oneShotBufffer, app->oneShotBus, false, 1.0f, 0.0f);\n        MemDbgPrintStr(\"Left mouse pressed\");\n    }\n    else if (MouseReleased(MouseButtonLeft)) {\n        MemDbgPrintStr(\"Left mouse released\");\n    }\n\n    if (KeyboardPressed(KeyboardCodeSpace)) {\n        MemDbgPrintStr(\"space pressed\");\n        AudioSetVolume(app->oneShotBus, 0.5f);\n    }\n    else if (KeyboardReleased(KeyboardCodeSpace)) {\n        MemDbgPrintStr(\"space released\");\n    }\n\n    if (KeyboardDown(KeyboardCodeSpace)) {\n        MemDbgPrintStr(\"space down\");\n    }\n    \n    if (TouchPressed(0)) {\n        if (app->loopingSound != 0) {\n            AudioStop(app->loopingSound);\n            app->loopingSound = 0;\n        }\n        else {\n            app->loopingSound = AudioPlay2D(app->loopingBuffer, app->loopingBus, true, 0.75f, 0.0f);\n        }\n        MemDbgPrintStr(\"touch 0 pressed\");\n    }\n    if (TouchReleased(0)) {\n        MemDbgPrintStr(\"touch 0 released\");\n    }\n\n    if (TouchPressed(1)) {\n        if (app->loopingSound != 0) {\n            AudioSetPan(app->loopingSound, -1.0f);\n        }\n        MemDbgPrintStr(\"touch 1 pressed\");\n    }\n    if (TouchReleased(1)) {\n        MemDbgPrintStr(\"touch 1 released\");\n    }\n}\n\n\nexport void Update(float dt, void* userData) {\n    AppData* app = (AppData*)userData;\n    /*GfxClearColor(0, 0, 0.5f, 0.6f, 0.7f);\n    GfxClearDepth(0, 0, 1.0f);\n    GfxDraw(0, 0, app->vao, GfxDrawModeTriangles, 0, 3, 1);*/\n\n    const float plane_shadow[16] = {0.13074f, 0.01829f, 0.01400f, 0.00000f,0.00000f, 0.09512f, -0.06999f, 0.00000f,0.02615f, -0.09146f, -0.06999f, 0.00000f,0.50000f, 0.42866f, 0.54184f, 1.00000f };\n    const float plane_model[16] = {2.00000f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 2.00000f, 0.00000f, 0.00000f,0.00000f, 0.00000f, 2.00000f, 0.00000f,0.00000f, -1.50000f, 0.00000f, 1.00000f };\n    const float skull_model[16] = {0.10000f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 0.10000f, 0.00000f, 0.00000f,0.00000f, 0.00000f, 0.10000f, 0.00000f,1.50000f, 0.00000f, -0.50000f, 1.00000f };\n    const float shadow_mvp[16] = {0.01307f, 0.00183f, 0.00140f, 0.00000f,0.00000f, 0.00951f, -0.00700f, 0.00000f,0.00261f, -0.00915f, -0.00700f, 0.00000f,0.18304f, 0.07317f, 0.05468f, 1.00000f };\n    const float view[16] = {0.99916f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 0.91836f, 0.39357f, 0.00000f,0.00000f, -0.39358f, 0.91833f, 0.00000f,0.00000f, 0.00000f, -7.60905f, 1.00000f };\n    const float proj[16] = {1.82434f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 2.43245f, 0.00000f, 0.00000f,0.00000f, 0.00000f, -1.00020f, -1.00000f,0.00000f, 0.00000f, -0.20002f, 0.00000f };\n\n    if (app->canDisplaySkull) {\n        { // Draw lightmap\n            GfxSetViewport(0, 0, 4096, 4096);\n            GfxClearDepth(0, 0, 1.0f);\n            GfxSetCullState(GfxCullFaceFront, GfxFaceWindCounterClockwise);\n            GfxSetUniform(app->shadowMapShader, app->shadowMapUniformMvp, (void*)shadow_mvp, GfxUniformTypeFloat16, 1); \n            GfxDraw(0, app->shadowMapTexture, app->shadowMapVao, GfxDrawModeTriangles, 0, app->skullNumVerts, 1);\n            GfxSetCullState(GfxCullFaceBack, GfxFaceWindCounterClockwise);\n            GfxSetViewport(0, 0, 800, 600);\n        }\n\n        GfxClearAll(0, 0, 0.5f, 0.6f, 0.7f, 1.0f);\n\n        const float lightDir[3] = {0.2f, -1.0f, -1.0f};\n        const float lightColor[3] = {1.0f, 1.0f, 1.0f};\n\n        { // Draw Skull\n            const float hemiTop[3] = {0.2f, 0.2f, 0.2f};\n            const float hemiBottom[3] = {0.1f, 0.1f, 0.1f};\n\n            GfxSetUniform(app->skullShader, app->skullUniformModel, (void*)skull_model, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformView, (void*)view, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformProj, (void*)proj, GfxUniformTypeFloat16, 1); \n            \n            GfxSetUniformTexture(app->skullShader, app->skullUniformAlbedo, app->skullAlbedoTexture);\n            GfxSetUniformTexture(app->skullShader, app->skullUniformNormal, app->skullNormalTexture);\n            \n            GfxSetUniform(app->skullShader, app->skullUniformTop, (void*)hemiTop, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformBottom, (void*)hemiBottom, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformLightDir, (void*)lightDir, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformLightColor, (void*)lightColor, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformViewPos, app->cam, GfxUniformTypeFloat3, 1); \n\n            GfxDraw(0, 0, app->skullVao, GfxDrawModeTriangles, 0, app->skullNumVerts, 1);\n        }\n\n        { // Draw plane\n            GfxSetUniform(app->planeShader, app->planeUniformModel, (void*)plane_model, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->planeShader, app->planeUniformView, (void*)view, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->planeShader, app->planeUniformProj, (void*)proj, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->planeShader, app->planeUniformShadow,  (void*)plane_shadow, GfxUniformTypeFloat16, 1); \n\n            GfxSetUniform(app->planeShader, app->PlaneUniformLightDirection,(void*)lightDir, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->planeShader, app->PlaneUniformLightColor, (void*)lightColor, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->planeShader, app->PlaneUniformViewPos, app->cam, GfxUniformTypeFloat3, 1); \n\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformColorSpec, app->PlaneTextureColorSpec);\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformNormal, app->PlaneTextureNormal);\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformShadowMap, app->shadowMapTexture);\n\n            GfxDraw(0, 0, app->planeVAO, GfxDrawModeTriangles, 0, app->planeNumVerts, 1);\n        }\n    }\n}","/*\nLodePNG version 20221108\n\nCopyright (c) 2005-2022 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n/*\nThe manual and changelog are in the header file \"lodepng.h\"\nRename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.\n*/\n\n#include \"lodepng.h\"\n\n#ifdef LODEPNG_COMPILE_DISK\n#include <limits.h> /* LONG_MAX */\n#include <stdio.h> /* file handling */\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\n#include <stdlib.h> /* allocations */\n#endif /* LODEPNG_COMPILE_ALLOCATORS */\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/\n#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/\n#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/\n#endif /*_MSC_VER */\n\nconst char* LODEPNG_VERSION_STRING = \"20221108\";\n\n/*\nThis source file is divided into the following large parts. The code sections\nwith the \"LODEPNG_COMPILE_\" #defines divide this up further in an intermixed way.\n-Tools for C and common code for PNG and Zlib\n-C Code for Zlib (huffman, deflate, ...)\n-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)\n-The C++ wrapper around all of the above\n*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // Tools for C, and common code for PNG and Zlib.                       // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*The malloc, realloc and free functions defined here with \"lodepng_\" in front\nof the name, so that you can easily change them to others related to your\nplatform if needed. Everything else in the code calls these. Pass\n-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out\n#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and\ndefine them in your own project's source files without needing to change\nlodepng source code. Don't forget to remove \"static\" if you copypaste them\nfrom here.*/\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\nstatic void* lodepng_malloc(size_t size) {\n#ifdef LODEPNG_MAX_ALLOC\n  if(size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n  return malloc(size);\n}\n\n/* NOTE: when realloc returns NULL, it leaves the original memory untouched */\nstatic void* lodepng_realloc(void* ptr, size_t new_size) {\n#ifdef LODEPNG_MAX_ALLOC\n  if(new_size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n  return realloc(ptr, new_size);\n}\n\nstatic void lodepng_free(void* ptr) {\n  free(ptr);\n}\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\n/* TODO: support giving additional void* payload to the custom allocators */\nvoid* lodepng_malloc(size_t size);\nvoid* lodepng_realloc(void* ptr, size_t new_size);\nvoid lodepng_free(void* ptr);\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\n\n/* convince the compiler to inline a function, for use when this measurably improves performance */\n/* inline is not available in C90, but use it when supported by the compiler */\n#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined(__cplusplus) && (__cplusplus >= 199711L))\n#define LODEPNG_INLINE inline\n#else\n#define LODEPNG_INLINE /* not available */\n#endif\n\n/* restrict is not available in C90, but use it when supported by the compiler */\n#if (defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))) ||\\\n    (defined(_MSC_VER) && (_MSC_VER >= 1400)) || \\\n    (defined(__WATCOMC__) && (__WATCOMC__ >= 1250) && !defined(__cplusplus))\n#define LODEPNG_RESTRICT __restrict\n#else\n#define LODEPNG_RESTRICT /* not available */\n#endif\n\n/* Replacements for C library functions such as memcpy and strlen, to support platforms\nwhere a full C library is not available. The compiler can recognize them and compile\nto something as fast. */\n\nstatic void lodepng_memcpy(void* LODEPNG_RESTRICT dst,\n                           const void* LODEPNG_RESTRICT src, size_t size) {\n  size_t i;\n  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];\n}\n\nstatic void lodepng_memset(void* LODEPNG_RESTRICT dst,\n                           int value, size_t num) {\n  size_t i;\n  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;\n}\n\n/* does not check memory out of bounds, do not use on untrusted data */\nstatic size_t lodepng_strlen(const char* a) {\n  const char* orig = a;\n  /* avoid warning about unused function in case of disabled COMPILE... macros */\n  (void)(&lodepng_strlen);\n  while(*a) a++;\n  return (size_t)(a - orig);\n}\n\n#define LODEPNG_MAX(a, b) (((a) > (b)) ? (a) : (b))\n#define LODEPNG_MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))\n\n#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)\n/* Safely check if adding two integers will overflow (no undefined\nbehavior, compiler removing the code, etc...) and output result. */\nstatic int lodepng_addofl(size_t a, size_t b, size_t* result) {\n  *result = a + b; /* Unsigned addition is well defined and safe in C90 */\n  return *result < a;\n}\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n/* Safely check if multiplying two integers will overflow (no undefined\nbehavior, compiler removing the code, etc...) and output result. */\nstatic int lodepng_mulofl(size_t a, size_t b, size_t* result) {\n  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */\n  return (a != 0 && *result / a != b);\n}\n\n#ifdef LODEPNG_COMPILE_ZLIB\n/* Safely check if a + b > c, even if overflow could happen. */\nstatic int lodepng_gtofl(size_t a, size_t b, size_t c) {\n  size_t d;\n  if(lodepng_addofl(a, b, &d)) return 1;\n  return d > c;\n}\n#endif /*LODEPNG_COMPILE_ZLIB*/\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n\n/*\nOften in case of an error a value is assigned to a variable and then it breaks\nout of a loop (to go to the cleanup phase of a function). This macro does that.\nIt makes the error handling code shorter and more readable.\n\nExample: if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83);\n*/\n#define CERROR_BREAK(errorvar, code){\\\n  errorvar = code;\\\n  break;\\\n}\n\n/*version of CERROR_BREAK that assumes the common case where the error variable is named \"error\"*/\n#define ERROR_BREAK(code) CERROR_BREAK(error, code)\n\n/*Set error var to the error code, and return it.*/\n#define CERROR_RETURN_ERROR(errorvar, code){\\\n  errorvar = code;\\\n  return code;\\\n}\n\n/*Try the code, if it returns error, also return the error.*/\n#define CERROR_TRY_RETURN(call){\\\n  unsigned error = call;\\\n  if(error) return error;\\\n}\n\n/*Set error var to the error code, and return from the void function.*/\n#define CERROR_RETURN(errorvar, code){\\\n  errorvar = code;\\\n  return;\\\n}\n\n/*\nAbout uivector, ucvector and string:\n-All of them wrap dynamic arrays or text strings in a similar way.\n-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.\n-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.\n-They're not used in the interface, only internally in this file as static functions.\n-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.\n*/\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_ENCODER\n/*dynamic vector of unsigned ints*/\ntypedef struct uivector {\n  unsigned* data;\n  size_t size; /*size in number of unsigned longs*/\n  size_t allocsize; /*allocated size in bytes*/\n} uivector;\n\nstatic void uivector_cleanup(void* p) {\n  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;\n  lodepng_free(((uivector*)p)->data);\n  ((uivector*)p)->data = NULL;\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_resize(uivector* p, size_t size) {\n  size_t allocsize = size * sizeof(unsigned);\n  if(allocsize > p->allocsize) {\n    size_t newsize = allocsize + (p->allocsize >> 1u);\n    void* data = lodepng_realloc(p->data, newsize);\n    if(data) {\n      p->allocsize = newsize;\n      p->data = (unsigned*)data;\n    }\n    else return 0; /*error: not enough memory*/\n  }\n  p->size = size;\n  return 1; /*success*/\n}\n\nstatic void uivector_init(uivector* p) {\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_push_back(uivector* p, unsigned c) {\n  if(!uivector_resize(p, p->size + 1)) return 0;\n  p->data[p->size - 1] = c;\n  return 1;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n/* /////////////////////////////////////////////////////////////////////////// */\n\n/*dynamic vector of unsigned chars*/\ntypedef struct ucvector {\n  unsigned char* data;\n  size_t size; /*used size*/\n  size_t allocsize; /*allocated size*/\n} ucvector;\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned ucvector_reserve(ucvector* p, size_t size) {\n  if(size > p->allocsize) {\n    size_t newsize = size + (p->allocsize >> 1u);\n    void* data = lodepng_realloc(p->data, newsize);\n    if(data) {\n      p->allocsize = newsize;\n      p->data = (unsigned char*)data;\n    }\n    else return 0; /*error: not enough memory*/\n  }\n  return 1; /*success*/\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned ucvector_resize(ucvector* p, size_t size) {\n  p->size = size;\n  return ucvector_reserve(p, size);\n}\n\nstatic ucvector ucvector_init(unsigned char* buffer, size_t size) {\n  ucvector v;\n  v.data = buffer;\n  v.allocsize = v.size = size;\n  return v;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_PNG\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\n/*free string pointer and set it to NULL*/\nstatic void string_cleanup(char** out) {\n  lodepng_free(*out);\n  *out = NULL;\n}\n\n/*also appends null termination character*/\nstatic char* alloc_string_sized(const char* in, size_t insize) {\n  char* out = (char*)lodepng_malloc(insize + 1);\n  if(out) {\n    lodepng_memcpy(out, in, insize);\n    out[insize] = 0;\n  }\n  return out;\n}\n\n/* dynamically allocates a new string with a copy of the null terminated input text */\nstatic char* alloc_string(const char* in) {\n  return alloc_string_sized(in, lodepng_strlen(in));\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)\nstatic unsigned lodepng_read32bitInt(const unsigned char* buffer) {\n  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |\n         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);\n}\n#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/\n\n#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)\n/*buffer must have at least 4 allocated bytes available*/\nstatic void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {\n  buffer[0] = (unsigned char)((value >> 24) & 0xff);\n  buffer[1] = (unsigned char)((value >> 16) & 0xff);\n  buffer[2] = (unsigned char)((value >>  8) & 0xff);\n  buffer[3] = (unsigned char)((value      ) & 0xff);\n}\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / File IO                                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_DISK\n\n/* returns negative value on error. This should be pure C compatible, so no fstat. */\nstatic long lodepng_filesize(const char* filename) {\n  FILE* file;\n  long size;\n  file = fopen(filename, \"rb\");\n  if(!file) return -1;\n\n  if(fseek(file, 0, SEEK_END) != 0) {\n    fclose(file);\n    return -1;\n  }\n\n  size = ftell(file);\n  /* It may give LONG_MAX as directory size, this is invalid for us. */\n  if(size == LONG_MAX) size = -1;\n\n  fclose(file);\n  return size;\n}\n\n/* load file into buffer that already has the correct allocated size. Returns error code.*/\nstatic unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {\n  FILE* file;\n  size_t readsize;\n  file = fopen(filename, \"rb\");\n  if(!file) return 78;\n\n  readsize = fread(out, 1, size, file);\n  fclose(file);\n\n  if(readsize != size) return 78;\n  return 0;\n}\n\nunsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {\n  long size = lodepng_filesize(filename);\n  if(size < 0) return 78;\n  *outsize = (size_t)size;\n\n  *out = (unsigned char*)lodepng_malloc((size_t)size);\n  if(!(*out) && size > 0) return 83; /*the above malloc failed*/\n\n  return lodepng_buffer_file(*out, (size_t)size, filename);\n}\n\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\nunsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {\n  FILE* file;\n  file = fopen(filename, \"wb\" );\n  if(!file) return 79;\n  fwrite(buffer, 1, buffersize, file);\n  fclose(file);\n  return 0;\n}\n\n#endif /*LODEPNG_COMPILE_DISK*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // End of common code and tools. Begin of Zlib related code.            // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_ENCODER\n\ntypedef struct {\n  ucvector* data;\n  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/\n} LodePNGBitWriter;\n\nstatic void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {\n  writer->data = data;\n  writer->bp = 0;\n}\n\n/*TODO: this ignores potential out of memory errors*/\n#define WRITEBIT(writer, bit){\\\n  /* append new byte */\\\n  if(((writer->bp) & 7u) == 0) {\\\n    if(!ucvector_resize(writer->data, writer->data->size + 1)) return;\\\n    writer->data->data[writer->data->size - 1] = 0;\\\n  }\\\n  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\\\n  ++writer->bp;\\\n}\n\n/* LSB of value is written first, and LSB of bytes is used first */\nstatic void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {\n  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */\n    WRITEBIT(writer, value);\n  } else {\n    /* TODO: increase output size only once here rather than in each WRITEBIT */\n    size_t i;\n    for(i = 0; i != nbits; ++i) {\n      WRITEBIT(writer, (unsigned char)((value >> i) & 1));\n    }\n  }\n}\n\n/* This one is to use for adding huffman symbol, the value bits are written MSB first */\nstatic void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {\n  size_t i;\n  for(i = 0; i != nbits; ++i) {\n    /* TODO: increase output size only once here rather than in each WRITEBIT */\n    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));\n  }\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\ntypedef struct {\n  const unsigned char* data;\n  size_t size; /*size of data in bytes*/\n  size_t bitsize; /*size of data in bits, end of valid bp values, should be 8*size*/\n  size_t bp;\n  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/\n} LodePNGBitReader;\n\n/* data size argument is in bytes. Returns error if size too large causing overflow */\nstatic unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {\n  size_t temp;\n  reader->data = data;\n  reader->size = size;\n  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */\n  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;\n  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and\n  trying to ensure 32 more bits*/\n  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;\n  reader->bp = 0;\n  reader->buffer = 0;\n  return 0; /*ok*/\n}\n\n/*\nensureBits functions:\nEnsures the reader can at least read nbits bits in one or more readBits calls,\nsafely even if not enough bits are available.\nThe nbits parameter is unused but is given for documentation purposes, error\nchecking for amount of bits must be done beforehand.\n*/\n\n/*See ensureBits documentation above. This one ensures up to 9 bits */\nstatic LODEPNG_INLINE void ensureBits9(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 1u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);\n    reader->buffer >>= (reader->bp & 7u);\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer = reader->data[start + 0];\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/*See ensureBits documentation above. This one ensures up to 17 bits */\nstatic LODEPNG_INLINE void ensureBits17(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 2u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |\n                     ((unsigned)reader->data[start + 2] << 16u);\n    reader->buffer >>= (reader->bp & 7u);\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer |= reader->data[start + 0];\n    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/*See ensureBits documentation above. This one ensures up to 25 bits */\nstatic LODEPNG_INLINE void ensureBits25(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 3u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |\n                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);\n    reader->buffer >>= (reader->bp & 7u);\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer |= reader->data[start + 0];\n    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);\n    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/*See ensureBits documentation above. This one ensures up to 32 bits */\nstatic LODEPNG_INLINE void ensureBits32(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 4u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |\n                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);\n    reader->buffer >>= (reader->bp & 7u);\n    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer |= reader->data[start + 0];\n    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);\n    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);\n    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */\nstatic LODEPNG_INLINE unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {\n  /* The shift allows nbits to be only up to 31. */\n  return reader->buffer & ((1u << nbits) - 1u);\n}\n\n/* Must have enough bits available with ensureBits */\nstatic LODEPNG_INLINE void advanceBits(LodePNGBitReader* reader, size_t nbits) {\n  reader->buffer >>= nbits;\n  reader->bp += nbits;\n}\n\n/* Must have enough bits available with ensureBits */\nstatic LODEPNG_INLINE unsigned readBits(LodePNGBitReader* reader, size_t nbits) {\n  unsigned result = peekBits(reader, nbits);\n  advanceBits(reader, nbits);\n  return result;\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\nstatic unsigned reverseBits(unsigned bits, unsigned num) {\n  /*TODO: implement faster lookup table based version when needed*/\n  unsigned i, result = 0;\n  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;\n  return result;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Deflate - Huffman                                                      / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#define FIRST_LENGTH_CODE_INDEX 257\n#define LAST_LENGTH_CODE_INDEX 285\n/*256 literals, the end code, some length codes, and 2 unused codes*/\n#define NUM_DEFLATE_CODE_SYMBOLS 288\n/*the distance codes have their own symbols, 30 used, 2 unused*/\n#define NUM_DISTANCE_SYMBOLS 32\n/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/\n#define NUM_CODE_LENGTH_CODES 19\n\n/*the base lengths represented by codes 257-285*/\nstatic const unsigned LENGTHBASE[29]\n  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,\n     67, 83, 99, 115, 131, 163, 195, 227, 258};\n\n/*the extra bits used by codes 257-285 (added to base length)*/\nstatic const unsigned LENGTHEXTRA[29]\n  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,\n      4,  4,  4,   4,   5,   5,   5,   5,   0};\n\n/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/\nstatic const unsigned DISTANCEBASE[30]\n  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,\n     769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};\n\n/*the extra bits of backwards distances (added to base)*/\nstatic const unsigned DISTANCEEXTRA[30]\n  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,\n       8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};\n\n/*the order in which \"code length alphabet code lengths\" are stored as specified by deflate, out of this the huffman\ntree of the dynamic huffman tree lengths is generated*/\nstatic const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]\n  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*\nHuffman tree struct, containing multiple representations of the tree\n*/\ntypedef struct HuffmanTree {\n  unsigned* codes; /*the huffman codes (bit patterns representing the symbols)*/\n  unsigned* lengths; /*the lengths of the huffman codes*/\n  unsigned maxbitlen; /*maximum number of bits a single code can get*/\n  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/\n  /* for reading only */\n  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/\n  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/\n} HuffmanTree;\n\nstatic void HuffmanTree_init(HuffmanTree* tree) {\n  tree->codes = 0;\n  tree->lengths = 0;\n  tree->table_len = 0;\n  tree->table_value = 0;\n}\n\nstatic void HuffmanTree_cleanup(HuffmanTree* tree) {\n  lodepng_free(tree->codes);\n  lodepng_free(tree->lengths);\n  lodepng_free(tree->table_len);\n  lodepng_free(tree->table_value);\n}\n\n/* amount of bits for first huffman table lookup (aka root bits), see HuffmanTree_makeTable and huffmanDecodeSymbol.*/\n/* values 8u and 9u work the fastest */\n#define FIRSTBITS 9u\n\n/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,\nwhich is possible in case of only 0 or 1 present symbols. */\n#define INVALIDSYMBOL 65535u\n\n/* make table for huffman decoding */\nstatic unsigned HuffmanTree_makeTable(HuffmanTree* tree) {\n  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/\n  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;\n  size_t i, numpresent, pointer, size; /*total table size*/\n  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));\n  if(!maxlens) return 83; /*alloc fail*/\n\n  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/\n  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));\n  for(i = 0; i < tree->numcodes; i++) {\n    unsigned symbol = tree->codes[i];\n    unsigned l = tree->lengths[i];\n    unsigned index;\n    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/\n    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/\n    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);\n    maxlens[index] = LODEPNG_MAX(maxlens[index], l);\n  }\n  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */\n  size = headsize;\n  for(i = 0; i < headsize; ++i) {\n    unsigned l = maxlens[i];\n    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));\n  }\n  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));\n  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));\n  if(!tree->table_len || !tree->table_value) {\n    lodepng_free(maxlens);\n    /* freeing tree->table values is done at a higher scope */\n    return 83; /*alloc fail*/\n  }\n  /*initialize with an invalid length to indicate unused entries*/\n  for(i = 0; i < size; ++i) tree->table_len[i] = 16;\n\n  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/\n  pointer = headsize;\n  for(i = 0; i < headsize; ++i) {\n    unsigned l = maxlens[i];\n    if(l <= FIRSTBITS) continue;\n    tree->table_len[i] = l;\n    tree->table_value[i] = pointer;\n    pointer += (1u << (l - FIRSTBITS));\n  }\n  lodepng_free(maxlens);\n\n  /*fill in the first table for short symbols, or secondary table for long symbols*/\n  numpresent = 0;\n  for(i = 0; i < tree->numcodes; ++i) {\n    unsigned l = tree->lengths[i];\n    unsigned symbol, reverse;\n    if(l == 0) continue;\n    symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/\n    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/\n    reverse = reverseBits(symbol, l);\n    numpresent++;\n\n    if(l <= FIRSTBITS) {\n      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/\n      unsigned num = 1u << (FIRSTBITS - l);\n      unsigned j;\n      for(j = 0; j < num; ++j) {\n        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/\n        unsigned index = reverse | (j << l);\n        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/\n        tree->table_len[index] = l;\n        tree->table_value[index] = i;\n      }\n    } else {\n      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/\n      /*the FIRSTBITS MSBs of the symbol are the first table index*/\n      unsigned index = reverse & mask;\n      unsigned maxlen = tree->table_len[index];\n      /*log2 of secondary table length, should be >= l - FIRSTBITS*/\n      unsigned tablelen = maxlen - FIRSTBITS;\n      unsigned start = tree->table_value[index]; /*starting index in secondary table*/\n      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/\n      unsigned j;\n      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/\n      for(j = 0; j < num; ++j) {\n        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */\n        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));\n        tree->table_len[index2] = l;\n        tree->table_value[index2] = i;\n      }\n    }\n  }\n\n  if(numpresent < 2) {\n    /* In case of exactly 1 symbol, in theory the huffman symbol needs 0 bits,\n    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can\n    appear at all, but such huffman tree could still exist (e.g. if distance\n    codes are never used). In both cases, not all symbols of the table will be\n    filled in. Fill them in with an invalid symbol value so returning them from\n    huffmanDecodeSymbol will cause error. */\n    for(i = 0; i < size; ++i) {\n      if(tree->table_len[i] == 16) {\n        /* As length, use a value smaller than FIRSTBITS for the head table,\n        and a value larger than FIRSTBITS for the secondary table, to ensure\n        valid behavior for advanceBits when reading this symbol. */\n        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);\n        tree->table_value[i] = INVALIDSYMBOL;\n      }\n    }\n  } else {\n    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.\n    If that is not the case (due to too long length codes), the table will not\n    have been fully used, and this is an error (not all bit combinations can be\n    decoded): an oversubscribed huffman tree, indicated by error 55. */\n    for(i = 0; i < size; ++i) {\n      if(tree->table_len[i] == 16) return 55;\n    }\n  }\n\n  return 0;\n}\n\n/*\nSecond step for the ...makeFromLengths and ...makeFromFrequencies functions.\nnumcodes, lengths and maxbitlen must already be filled in correctly. return\nvalue is error.\n*/\nstatic unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {\n  unsigned* blcount;\n  unsigned* nextcode;\n  unsigned error = 0;\n  unsigned bits, n;\n\n  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));\n  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));\n  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));\n  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/\n\n  if(!error) {\n    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;\n    /*step 1: count number of instances of each code length*/\n    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];\n    /*step 2: generate the nextcode values*/\n    for(bits = 1; bits <= tree->maxbitlen; ++bits) {\n      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;\n    }\n    /*step 3: generate all the codes*/\n    for(n = 0; n != tree->numcodes; ++n) {\n      if(tree->lengths[n] != 0) {\n        tree->codes[n] = nextcode[tree->lengths[n]]++;\n        /*remove superfluous bits from the code*/\n        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);\n      }\n    }\n  }\n\n  lodepng_free(blcount);\n  lodepng_free(nextcode);\n\n  if(!error) error = HuffmanTree_makeTable(tree);\n  return error;\n}\n\n/*\ngiven the code lengths (as stored in the PNG file), generate the tree as defined\nby Deflate. maxbitlen is the maximum bits that a code in the tree can have.\nreturn value is error.\n*/\nstatic unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,\n                                            size_t numcodes, unsigned maxbitlen) {\n  unsigned i;\n  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->maxbitlen = maxbitlen;\n  return HuffmanTree_makeFromLengths2(tree);\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/*BPM: Boundary Package Merge, see \"A Fast and Space-Economical Algorithm for Length-Limited Coding\",\nJyrki Katajainen, Alistair Moffat, Andrew Turpin, 1995.*/\n\n/*chain node for boundary package merge*/\ntypedef struct BPMNode {\n  int weight; /*the sum of all weights in this chain*/\n  unsigned index; /*index of this leaf node (called \"count\" in the paper)*/\n  struct BPMNode* tail; /*the next nodes in this chain (null if last)*/\n  int in_use;\n} BPMNode;\n\n/*lists of chains*/\ntypedef struct BPMLists {\n  /*memory pool*/\n  unsigned memsize;\n  BPMNode* memory;\n  unsigned numfree;\n  unsigned nextfree;\n  BPMNode** freelist;\n  /*two heads of lookahead chains per list*/\n  unsigned listsize;\n  BPMNode** chains0;\n  BPMNode** chains1;\n} BPMLists;\n\n/*creates a new chain node with the given parameters, from the memory in the lists */\nstatic BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {\n  unsigned i;\n  BPMNode* result;\n\n  /*memory full, so garbage collect*/\n  if(lists->nextfree >= lists->numfree) {\n    /*mark only those that are in use*/\n    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;\n    for(i = 0; i != lists->listsize; ++i) {\n      BPMNode* node;\n      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;\n      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;\n    }\n    /*collect those that are free*/\n    lists->numfree = 0;\n    for(i = 0; i != lists->memsize; ++i) {\n      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];\n    }\n    lists->nextfree = 0;\n  }\n\n  result = lists->freelist[lists->nextfree++];\n  result->weight = weight;\n  result->index = index;\n  result->tail = tail;\n  return result;\n}\n\n/*sort the leaves with stable mergesort*/\nstatic void bpmnode_sort(BPMNode* leaves, size_t num) {\n  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);\n  size_t width, counter = 0;\n  for(width = 1; width < num; width *= 2) {\n    BPMNode* a = (counter & 1) ? mem : leaves;\n    BPMNode* b = (counter & 1) ? leaves : mem;\n    size_t p;\n    for(p = 0; p < num; p += 2 * width) {\n      size_t q = (p + width > num) ? num : (p + width);\n      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);\n      size_t i = p, j = q, k;\n      for(k = p; k < r; k++) {\n        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];\n        else b[k] = a[j++];\n      }\n    }\n    counter++;\n  }\n  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);\n  lodepng_free(mem);\n}\n\n/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/\nstatic void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {\n  unsigned lastindex = lists->chains1[c]->index;\n\n  if(c == 0) {\n    if(lastindex >= numpresent) return;\n    lists->chains0[c] = lists->chains1[c];\n    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);\n  } else {\n    /*sum of the weights of the head nodes of the previous lookahead chains.*/\n    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;\n    lists->chains0[c] = lists->chains1[c];\n    if(lastindex < numpresent && sum > leaves[lastindex].weight) {\n      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);\n      return;\n    }\n    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);\n    /*in the end we are only interested in the chain of the last list, so no\n    need to recurse if we're at the last one (this gives measurable speedup)*/\n    if(num + 1 < (int)(2 * numpresent - 2)) {\n      boundaryPM(lists, leaves, numpresent, c - 1, num);\n      boundaryPM(lists, leaves, numpresent, c - 1, num);\n    }\n  }\n}\n\nunsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\n                                      size_t numcodes, unsigned maxbitlen) {\n  unsigned error = 0;\n  unsigned i;\n  size_t numpresent = 0; /*number of symbols with non-zero frequency*/\n  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/\n\n  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/\n  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/\n\n  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));\n  if(!leaves) return 83; /*alloc fail*/\n\n  for(i = 0; i != numcodes; ++i) {\n    if(frequencies[i] > 0) {\n      leaves[numpresent].weight = (int)frequencies[i];\n      leaves[numpresent].index = i;\n      ++numpresent;\n    }\n  }\n\n  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));\n\n  /*ensure at least two present symbols. There should be at least one symbol\n  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To\n  make these work as well ensure there are at least two symbols. The\n  Package-Merge code below also doesn't work correctly if there's only one\n  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/\n  if(numpresent == 0) {\n    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/\n  } else if(numpresent == 1) {\n    lengths[leaves[0].index] = 1;\n    lengths[leaves[0].index == 0 ? 1 : 0] = 1;\n  } else {\n    BPMLists lists;\n    BPMNode* node;\n\n    bpmnode_sort(leaves, numpresent);\n\n    lists.listsize = maxbitlen;\n    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);\n    lists.nextfree = 0;\n    lists.numfree = lists.memsize;\n    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));\n    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));\n    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));\n    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));\n    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/\n\n    if(!error) {\n      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];\n\n      bpmnode_create(&lists, leaves[0].weight, 1, 0);\n      bpmnode_create(&lists, leaves[1].weight, 2, 0);\n\n      for(i = 0; i != lists.listsize; ++i) {\n        lists.chains0[i] = &lists.memory[0];\n        lists.chains1[i] = &lists.memory[1];\n      }\n\n      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/\n      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);\n\n      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {\n        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];\n      }\n    }\n\n    lodepng_free(lists.memory);\n    lodepng_free(lists.freelist);\n    lodepng_free(lists.chains0);\n    lodepng_free(lists.chains1);\n  }\n\n  lodepng_free(leaves);\n  return error;\n}\n\n/*Create the Huffman tree given the symbol frequencies*/\nstatic unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/\n  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/\nstatic unsigned generateFixedLitLenTree(HuffmanTree* tree) {\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/\n  for(i =   0; i <= 143; ++i) bitlen[i] = 8;\n  for(i = 144; i <= 255; ++i) bitlen[i] = 9;\n  for(i = 256; i <= 279; ++i) bitlen[i] = 7;\n  for(i = 280; i <= 287; ++i) bitlen[i] = 8;\n\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}\n\n/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/\nstatic unsigned generateFixedDistanceTree(HuffmanTree* tree) {\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*there are 32 distance codes, but 30-31 are unused*/\n  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/*\nreturns the code. The bit reader must already have been ensured at least 15 bits\n*/\nstatic unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {\n  unsigned short code = peekBits(reader, FIRSTBITS);\n  unsigned short l = codetree->table_len[code];\n  unsigned short value = codetree->table_value[code];\n  if(l <= FIRSTBITS) {\n    advanceBits(reader, l);\n    return value;\n  } else {\n    advanceBits(reader, FIRSTBITS);\n    value += peekBits(reader, l - FIRSTBITS);\n    advanceBits(reader, codetree->table_len[value] - FIRSTBITS);\n    return codetree->table_value[value];\n  }\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Inflator (Decompressor)                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*get the tree of a deflated block with fixed tree, as specified in the deflate specification\nReturns error code.*/\nstatic unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {\n  unsigned error = generateFixedLitLenTree(tree_ll);\n  if(error) return error;\n  return generateFixedDistanceTree(tree_d);\n}\n\n/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/\nstatic unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,\n                                      LodePNGBitReader* reader) {\n  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/\n  unsigned error = 0;\n  unsigned n, HLIT, HDIST, HCLEN, i;\n\n  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/\n  unsigned* bitlen_ll = 0; /*lit,len code lengths*/\n  unsigned* bitlen_d = 0; /*dist code lengths*/\n  /*code length code lengths (\"clcl\"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/\n  unsigned* bitlen_cl = 0;\n  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/\n\n  if(reader->bitsize - reader->bp < 14) return 49; /*error: the bit pointer is or will go past the memory*/\n  ensureBits17(reader, 14);\n\n  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/\n  HLIT =  readBits(reader, 5) + 257;\n  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/\n  HDIST = readBits(reader, 5) + 1;\n  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/\n  HCLEN = readBits(reader, 4) + 4;\n\n  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));\n  if(!bitlen_cl) return 83 /*alloc fail*/;\n\n  HuffmanTree_init(&tree_cl);\n\n  while(!error) {\n    /*read the code length codes out of 3 * (amount of code length codes) bits*/\n    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {\n      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/\n    }\n    for(i = 0; i != HCLEN; ++i) {\n      ensureBits9(reader, 3); /*out of bounds already checked above */\n      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);\n    }\n    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {\n      bitlen_cl[CLCL_ORDER[i]] = 0;\n    }\n\n    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);\n    if(error) break;\n\n    /*now we can use this tree to read the lengths for the tree that this function will return*/\n    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\n    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);\n    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));\n    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));\n\n    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/\n    i = 0;\n    while(i < HLIT + HDIST) {\n      unsigned code;\n      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/\n      code = huffmanDecodeSymbol(reader, &tree_cl);\n      if(code <= 15) /*a length code*/ {\n        if(i < HLIT) bitlen_ll[i] = code;\n        else bitlen_d[i - HLIT] = code;\n        ++i;\n      } else if(code == 16) /*repeat previous*/ {\n        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/\n        unsigned value; /*set value to the previous code*/\n\n        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/\n\n        replength += readBits(reader, 2);\n\n        if(i < HLIT + 1) value = bitlen_ll[i - 1];\n        else value = bitlen_d[i - HLIT - 1];\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; ++n) {\n          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/\n          if(i < HLIT) bitlen_ll[i] = value;\n          else bitlen_d[i - HLIT] = value;\n          ++i;\n        }\n      } else if(code == 17) /*repeat \"0\" 3-10 times*/ {\n        unsigned replength = 3; /*read in the bits that indicate repeat length*/\n        replength += readBits(reader, 3);\n\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; ++n) {\n          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/\n\n          if(i < HLIT) bitlen_ll[i] = 0;\n          else bitlen_d[i - HLIT] = 0;\n          ++i;\n        }\n      } else if(code == 18) /*repeat \"0\" 11-138 times*/ {\n        unsigned replength = 11; /*read in the bits that indicate repeat length*/\n        replength += readBits(reader, 7);\n\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; ++n) {\n          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/\n\n          if(i < HLIT) bitlen_ll[i] = 0;\n          else bitlen_d[i - HLIT] = 0;\n          ++i;\n        }\n      } else /*if(code == INVALIDSYMBOL)*/ {\n        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/\n      }\n      /*check if any of the ensureBits above went out of bounds*/\n      if(reader->bp > reader->bitsize) {\n        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n        (10=no endcode, 11=wrong jump outside of tree)*/\n        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */\n        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\n      }\n    }\n    if(error) break;\n\n    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/\n\n    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/\n    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);\n    if(error) break;\n    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);\n\n    break; /*end of error-while*/\n  }\n\n  lodepng_free(bitlen_cl);\n  lodepng_free(bitlen_ll);\n  lodepng_free(bitlen_d);\n  HuffmanTree_cleanup(&tree_cl);\n\n  return error;\n}\n\n/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/\nstatic unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,\n                                    unsigned btype, size_t max_output_size) {\n  unsigned error = 0;\n  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/\n  HuffmanTree tree_d; /*the huffman tree for distance codes*/\n  const size_t reserved_size = 260; /* must be at least 258 for max length, and a few extra for adding a few extra literals */\n  int done = 0;\n\n  if(!ucvector_reserve(out, out->size + reserved_size)) return 83; /*alloc fail*/\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);\n  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);\n\n\n  while(!error && !done) /*decode all symbols until end reached, breaks at end code*/ {\n    /*code_ll is literal, length or end code*/\n    unsigned code_ll;\n    /* ensure enough bits for 2 huffman code reads (15 bits each): if the first is a literal, a second literal is read at once. This\n    appears to be slightly faster, than ensuring 20 bits here for 1 huffman symbol and the potential 5 extra bits for the length symbol.*/\n    ensureBits32(reader, 30);\n    code_ll = huffmanDecodeSymbol(reader, &tree_ll);\n    if(code_ll <= 255) {\n      /*slightly faster code path if multiple literals in a row*/\n      out->data[out->size++] = (unsigned char)code_ll;\n      code_ll = huffmanDecodeSymbol(reader, &tree_ll);\n    }\n    if(code_ll <= 255) /*literal symbol*/ {\n      out->data[out->size++] = (unsigned char)code_ll;\n    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {\n      unsigned code_d, distance;\n      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/\n      size_t start, backward, length;\n\n      /*part 1: get length base*/\n      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];\n\n      /*part 2: get extra bits and add the value of that to length*/\n      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];\n      if(numextrabits_l != 0) {\n        /* bits already ensured above */\n        ensureBits25(reader, 5);\n        length += readBits(reader, numextrabits_l);\n      }\n\n      /*part 3: get distance code*/\n      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */\n      code_d = huffmanDecodeSymbol(reader, &tree_d);\n      if(code_d > 29) {\n        if(code_d <= 31) {\n          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/\n        } else /* if(code_d == INVALIDSYMBOL) */{\n          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/\n        }\n      }\n      distance = DISTANCEBASE[code_d];\n\n      /*part 4: get extra bits from distance*/\n      numextrabits_d = DISTANCEEXTRA[code_d];\n      if(numextrabits_d != 0) {\n        /* bits already ensured above */\n        distance += readBits(reader, numextrabits_d);\n      }\n\n      /*part 5: fill in all the out[n] values based on the length and dist*/\n      start = out->size;\n      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/\n      backward = start - distance;\n\n      out->size += length;\n      if(distance < length) {\n        size_t forward;\n        lodepng_memcpy(out->data + start, out->data + backward, distance);\n        start += distance;\n        for(forward = distance; forward < length; ++forward) {\n          out->data[start++] = out->data[backward++];\n        }\n      } else {\n        lodepng_memcpy(out->data + start, out->data + backward, length);\n      }\n    } else if(code_ll == 256) {\n      done = 1; /*end code, finish the loop*/\n    } else /*if(code_ll == INVALIDSYMBOL)*/ {\n      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/\n    }\n    if(out->allocsize - out->size < reserved_size) {\n      if(!ucvector_reserve(out, out->size + reserved_size)) ERROR_BREAK(83); /*alloc fail*/\n    }\n    /*check if any of the ensureBits above went out of bounds*/\n    if(reader->bp > reader->bitsize) {\n      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n      (10=no endcode, 11=wrong jump outside of tree)*/\n      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */\n      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/\n    }\n    if(max_output_size && out->size > max_output_size) {\n      ERROR_BREAK(109); /*error, larger than max size*/\n    }\n  }\n\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}\n\nstatic unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,\n                                     const LodePNGDecompressSettings* settings) {\n  size_t bytepos;\n  size_t size = reader->size;\n  unsigned LEN, NLEN, error = 0;\n\n  /*go to first boundary of byte*/\n  bytepos = (reader->bp + 7u) >> 3u;\n\n  /*read LEN (2 bytes) and NLEN (2 bytes)*/\n  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/\n  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;\n  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;\n\n  /*check if 16-bit NLEN is really the one's complement of LEN*/\n  if(!settings->ignore_nlen && LEN + NLEN != 65535) {\n    return 21; /*error: NLEN is not one's complement of LEN*/\n  }\n\n  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/\n\n  /*read the literal data: LEN bytes are now stored in the out buffer*/\n  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/\n\n  /*out->data can be NULL (when LEN is zero), and arithmetics on NULL ptr is undefined*/\n  if (LEN) {\n    lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);\n    bytepos += LEN;\n  }\n\n  reader->bp = bytepos << 3u;\n\n  return error;\n}\n\nstatic unsigned lodepng_inflatev(ucvector* out,\n                                 const unsigned char* in, size_t insize,\n                                 const LodePNGDecompressSettings* settings) {\n  unsigned BFINAL = 0;\n  LodePNGBitReader reader;\n  unsigned error = LodePNGBitReader_init(&reader, in, insize);\n\n  if(error) return error;\n\n  while(!BFINAL) {\n    unsigned BTYPE;\n    if(reader.bitsize - reader.bp < 3) return 52; /*error, bit pointer will jump past memory*/\n    ensureBits9(&reader, 3);\n    BFINAL = readBits(&reader, 1);\n    BTYPE = readBits(&reader, 2);\n\n    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/\n    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/\n    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/\n    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;\n    if(error) break;\n  }\n\n  return error;\n}\n\nunsigned lodepng_inflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGDecompressSettings* settings) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_inflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\nstatic unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,\n                        const LodePNGDecompressSettings* settings) {\n  if(settings->custom_inflate) {\n    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);\n    out->allocsize = out->size;\n    if(error) {\n      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/\n      error = 110;\n      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/\n      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;\n    }\n    return error;\n  } else {\n    return lodepng_inflatev(out, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Deflator (Compressor)                                                  / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;\n\n/*search the index in the array, that has the largest value smaller than or equal to the given value,\ngiven array must be sorted (if no value is smaller, it returns the size of the given array)*/\nstatic size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {\n  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/\n  size_t left = 1;\n  size_t right = array_size - 1;\n\n  while(left <= right) {\n    size_t mid = (left + right) >> 1;\n    if(array[mid] >= value) right = mid - 1;\n    else left = mid + 1;\n  }\n  if(left >= array_size || array[left] > value) left--;\n  return left;\n}\n\nstatic void addLengthDistance(uivector* values, size_t length, size_t distance) {\n  /*values in encoded vector are those used by deflate:\n  0-255: literal bytes\n  256: end\n  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)\n  286-287: invalid*/\n\n  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);\n  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);\n  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);\n  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);\n\n  size_t pos = values->size;\n  /*TODO: return error when this fails (out of memory)*/\n  unsigned ok = uivector_resize(values, values->size + 4);\n  if(ok) {\n    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;\n    values->data[pos + 1] = extra_length;\n    values->data[pos + 2] = dist_code;\n    values->data[pos + 3] = extra_distance;\n  }\n}\n\n/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3\nbytes as input because 3 is the minimum match length for deflate*/\nstatic const unsigned HASH_NUM_VALUES = 65536;\nstatic const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/\n\ntypedef struct Hash {\n  int* head; /*hash value to head circular pos - can be outdated if went around window*/\n  /*circular pos to prev circular pos*/\n  unsigned short* chain;\n  int* val; /*circular pos to hash value*/\n\n  /*TODO: do this not only for zeros but for any repeated byte. However for PNG\n  it's always going to be the zeros that dominate, so not important for PNG*/\n  int* headz; /*similar to head, but for chainz*/\n  unsigned short* chainz; /*those with same amount of zeros*/\n  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/\n} Hash;\n\nstatic unsigned hash_init(Hash* hash, unsigned windowsize) {\n  unsigned i;\n  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);\n  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);\n  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n\n  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));\n  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n\n  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {\n    return 83; /*alloc fail*/\n  }\n\n  /*initialize hash table*/\n  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;\n  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;\n  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/\n\n  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;\n  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/\n\n  return 0;\n}\n\nstatic void hash_cleanup(Hash* hash) {\n  lodepng_free(hash->head);\n  lodepng_free(hash->val);\n  lodepng_free(hash->chain);\n\n  lodepng_free(hash->zeros);\n  lodepng_free(hash->headz);\n  lodepng_free(hash->chainz);\n}\n\n\n\nstatic unsigned getHash(const unsigned char* data, size_t size, size_t pos) {\n  unsigned result = 0;\n  if(pos + 2 < size) {\n    /*A simple shift and xor hash is used. Since the data of PNGs is dominated\n    by zeroes due to the filters, a better hash does not have a significant\n    effect on speed in traversing the chain, and causes more time spend on\n    calculating the hash.*/\n    result ^= ((unsigned)data[pos + 0] << 0u);\n    result ^= ((unsigned)data[pos + 1] << 4u);\n    result ^= ((unsigned)data[pos + 2] << 8u);\n  } else {\n    size_t amount, i;\n    if(pos >= size) return 0;\n    amount = size - pos;\n    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));\n  }\n  return result & HASH_BIT_MASK;\n}\n\nstatic unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {\n  const unsigned char* start = data + pos;\n  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;\n  if(end > data + size) end = data + size;\n  data = start;\n  while(data != end && *data == 0) ++data;\n  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/\n  return (unsigned)(data - start);\n}\n\n/*wpos = pos & (windowsize - 1)*/\nstatic void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {\n  hash->val[wpos] = (int)hashval;\n  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];\n  hash->head[hashval] = (int)wpos;\n\n  hash->zeros[wpos] = numzeros;\n  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];\n  hash->headz[numzeros] = (int)wpos;\n}\n\n/*\nLZ77-encode the data. Return value is error code. The input are raw bytes, the output\nis in the form of unsigned integers with codes representing for example literal bytes, or\nlength/distance pairs.\nIt uses a hash table technique to let it encode faster. When doing LZ77 encoding, a\nsliding window (of windowsize) is used, and all past bytes in that window can be used as\nthe \"dictionary\". A brute force search through all possible distances would be slow, and\nthis hash technique is one out of several ways to speed this up.\n*/\nstatic unsigned encodeLZ77(uivector* out, Hash* hash,\n                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,\n                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {\n  size_t pos;\n  unsigned i, error = 0;\n  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/\n  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;\n  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;\n\n  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/\n  unsigned numzeros = 0;\n\n  unsigned offset; /*the offset represents the distance in LZ77 terminology*/\n  unsigned length;\n  unsigned lazy = 0;\n  unsigned lazylength = 0, lazyoffset = 0;\n  unsigned hashval;\n  unsigned current_offset, current_length;\n  unsigned prev_offset;\n  const unsigned char *lastptr, *foreptr, *backptr;\n  unsigned hashpos;\n\n  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/\n  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/\n\n  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;\n\n  for(pos = inpos; pos < insize; ++pos) {\n    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/\n    unsigned chainlength = 0;\n\n    hashval = getHash(in, insize, pos);\n\n    if(usezeros && hashval == 0) {\n      if(numzeros == 0) numzeros = countZeros(in, insize, pos);\n      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;\n    } else {\n      numzeros = 0;\n    }\n\n    updateHashChain(hash, wpos, hashval, numzeros);\n\n    /*the length and offset found for the current position*/\n    length = 0;\n    offset = 0;\n\n    hashpos = hash->chain[wpos];\n\n    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];\n\n    /*search for the longest string*/\n    prev_offset = 0;\n    for(;;) {\n      if(chainlength++ >= maxchainlength) break;\n      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);\n\n      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/\n      prev_offset = current_offset;\n      if(current_offset > 0) {\n        /*test the next characters*/\n        foreptr = &in[pos];\n        backptr = &in[pos - current_offset];\n\n        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/\n        if(numzeros >= 3) {\n          unsigned skip = hash->zeros[hashpos];\n          if(skip > numzeros) skip = numzeros;\n          backptr += skip;\n          foreptr += skip;\n        }\n\n        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {\n          ++backptr;\n          ++foreptr;\n        }\n        current_length = (unsigned)(foreptr - &in[pos]);\n\n        if(current_length > length) {\n          length = current_length; /*the longest length*/\n          offset = current_offset; /*the offset that is related to this longest length*/\n          /*jump out once a length of max length is found (speed gain). This also jumps\n          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/\n          if(current_length >= nicematch) break;\n        }\n      }\n\n      if(hashpos == hash->chain[hashpos]) break;\n\n      if(numzeros >= 3 && length > numzeros) {\n        hashpos = hash->chainz[hashpos];\n        if(hash->zeros[hashpos] != numzeros) break;\n      } else {\n        hashpos = hash->chain[hashpos];\n        /*outdated hash value, happens if particular value was not encountered in whole last window*/\n        if(hash->val[hashpos] != (int)hashval) break;\n      }\n    }\n\n    if(lazymatching) {\n      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {\n        lazy = 1;\n        lazylength = length;\n        lazyoffset = offset;\n        continue; /*try the next byte*/\n      }\n      if(lazy) {\n        lazy = 0;\n        if(pos == 0) ERROR_BREAK(81);\n        if(length > lazylength + 1) {\n          /*push the previous character as literal*/\n          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);\n        } else {\n          length = lazylength;\n          offset = lazyoffset;\n          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/\n          hash->headz[numzeros] = -1; /*idem*/\n          --pos;\n        }\n      }\n    }\n    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);\n\n    /*encode it as length/distance pair or literal value*/\n    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\n    } else if(length < minmatch || (length == 3 && offset > 4096)) {\n      /*compensate for the fact that longer offsets have more extra bits, a\n      length of only 3 may be not worth it then*/\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\n    } else {\n      addLengthDistance(out, length, offset);\n      for(i = 1; i < length; ++i) {\n        ++pos;\n        wpos = pos & (windowsize - 1);\n        hashval = getHash(in, insize, pos);\n        if(usezeros && hashval == 0) {\n          if(numzeros == 0) numzeros = countZeros(in, insize, pos);\n          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;\n        } else {\n          numzeros = 0;\n        }\n        updateHashChain(hash, wpos, hashval, numzeros);\n      }\n    }\n  } /*end of the loop through each character of input*/\n\n  return error;\n}\n\n/* /////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {\n  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,\n  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/\n\n  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;\n  unsigned datapos = 0;\n  for(i = 0; i != numdeflateblocks; ++i) {\n    unsigned BFINAL, BTYPE, LEN, NLEN;\n    unsigned char firstbyte;\n    size_t pos = out->size;\n\n    BFINAL = (i == numdeflateblocks - 1);\n    BTYPE = 0;\n\n    LEN = 65535;\n    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;\n    NLEN = 65535 - LEN;\n\n    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/\n\n    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));\n    out->data[pos + 0] = firstbyte;\n    out->data[pos + 1] = (unsigned char)(LEN & 255);\n    out->data[pos + 2] = (unsigned char)(LEN >> 8u);\n    out->data[pos + 3] = (unsigned char)(NLEN & 255);\n    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);\n    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);\n    datapos += LEN;\n  }\n\n  return 0;\n}\n\n/*\nwrite the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.\ntree_ll: the tree for lit and len codes.\ntree_d: the tree for distance codes.\n*/\nstatic void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,\n                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {\n  size_t i = 0;\n  for(i = 0; i != lz77_encoded->size; ++i) {\n    unsigned val = lz77_encoded->data[i];\n    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);\n    if(val > 256) /*for a length code, 3 more things have to be added*/ {\n      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;\n      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];\n      unsigned length_extra_bits = lz77_encoded->data[++i];\n\n      unsigned distance_code = lz77_encoded->data[++i];\n\n      unsigned distance_index = distance_code;\n      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];\n      unsigned distance_extra_bits = lz77_encoded->data[++i];\n\n      writeBits(writer, length_extra_bits, n_length_extra_bits);\n      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);\n      writeBits(writer, distance_extra_bits, n_distance_extra_bits);\n    }\n  }\n}\n\n/*Deflate for a block of type \"dynamic\", that is, with freely, optimally, created huffman trees*/\nstatic unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,\n                               const unsigned char* data, size_t datapos, size_t dataend,\n                               const LodePNGCompressSettings* settings, unsigned final) {\n  unsigned error = 0;\n\n  /*\n  A block is compressed as follows: The PNG data is lz77 encoded, resulting in\n  literal bytes and length/distance pairs. This is then huffman compressed with\n  two huffman trees. One huffman tree is used for the lit and len values (\"ll\"),\n  another huffman tree is used for the dist values (\"d\"). These two trees are\n  stored using their code lengths, and to compress even more these code lengths\n  are also run-length encoded and huffman compressed. This gives a huffman tree\n  of code lengths \"cl\". The code lengths used to describe this third tree are\n  the code length code lengths (\"clcl\").\n  */\n\n  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/\n  uivector lz77_encoded;\n  HuffmanTree tree_ll; /*tree for lit,len values*/\n  HuffmanTree tree_d; /*tree for distance codes*/\n  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/\n  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/\n  unsigned* frequencies_d = 0; /*frequency of dist codes*/\n  unsigned* frequencies_cl = 0; /*frequency of code length codes*/\n  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/\n  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/\n  size_t datasize = dataend - datapos;\n\n  /*\n  If we could call \"bitlen_cl\" the the code length code lengths (\"clcl\"), that is the bit lengths of codes to represent\n  tree_cl in CLCL_ORDER, then due to the huffman compression of huffman tree representations (\"two levels\"), there are\n  some analogies:\n  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.\n  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.\n  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.\n  */\n\n  unsigned BFINAL = final;\n  size_t i;\n  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;\n  unsigned HLIT, HDIST, HCLEN;\n\n  uivector_init(&lz77_encoded);\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n  HuffmanTree_init(&tree_cl);\n  /* could fit on stack, but >1KB is on the larger side so allocate instead */\n  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));\n  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));\n  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));\n\n  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/\n\n  /*This while loop never loops due to a break at the end, it is here to\n  allow breaking out of it to the cleanup phase on error conditions.*/\n  while(!error) {\n    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));\n    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));\n    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));\n\n    if(settings->use_lz77) {\n      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\n                         settings->minmatch, settings->nicematch, settings->lazymatching);\n      if(error) break;\n    } else {\n      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);\n      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/\n    }\n\n    /*Count the frequencies of lit, len and dist codes*/\n    for(i = 0; i != lz77_encoded.size; ++i) {\n      unsigned symbol = lz77_encoded.data[i];\n      ++frequencies_ll[symbol];\n      if(symbol > 256) {\n        unsigned dist = lz77_encoded.data[i + 2];\n        ++frequencies_d[dist];\n        i += 3;\n      }\n    }\n    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/\n\n    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/\n    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);\n    if(error) break;\n    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/\n    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);\n    if(error) break;\n\n    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);\n    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);\n    /*store the code lengths of both generated trees in bitlen_lld*/\n    numcodes_lld = numcodes_ll + numcodes_d;\n    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));\n    /*numcodes_lld_e never needs more size than bitlen_lld*/\n    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));\n    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/\n    numcodes_lld_e = 0;\n\n    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];\n    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];\n\n    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),\n    17 (3-10 zeroes), 18 (11-138 zeroes)*/\n    for(i = 0; i != numcodes_lld; ++i) {\n      unsigned j = 0; /*amount of repetitions*/\n      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;\n\n      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {\n        ++j; /*include the first zero*/\n        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {\n          bitlen_lld_e[numcodes_lld_e++] = 17;\n          bitlen_lld_e[numcodes_lld_e++] = j - 3;\n        } else /*repeat code 18 supports max 138 zeroes*/ {\n          if(j > 138) j = 138;\n          bitlen_lld_e[numcodes_lld_e++] = 18;\n          bitlen_lld_e[numcodes_lld_e++] = j - 11;\n        }\n        i += (j - 1);\n      } else if(j >= 3) /*repeat code for value other than zero*/ {\n        size_t k;\n        unsigned num = j / 6u, rest = j % 6u;\n        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];\n        for(k = 0; k < num; ++k) {\n          bitlen_lld_e[numcodes_lld_e++] = 16;\n          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;\n        }\n        if(rest >= 3) {\n          bitlen_lld_e[numcodes_lld_e++] = 16;\n          bitlen_lld_e[numcodes_lld_e++] = rest - 3;\n        }\n        else j -= rest;\n        i += j;\n      } else /*too short to benefit from repeat code*/ {\n        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];\n      }\n    }\n\n    /*generate tree_cl, the huffmantree of huffmantrees*/\n    for(i = 0; i != numcodes_lld_e; ++i) {\n      ++frequencies_cl[bitlen_lld_e[i]];\n      /*after a repeat code come the bits that specify the number of repetitions,\n      those don't need to be in the frequencies_cl calculation*/\n      if(bitlen_lld_e[i] >= 16) ++i;\n    }\n\n    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,\n                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);\n    if(error) break;\n\n    /*compute amount of code-length-code-lengths to output*/\n    numcodes_cl = NUM_CODE_LENGTH_CODES;\n    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/\n    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {\n      numcodes_cl--;\n    }\n\n    /*\n    Write everything into the output\n\n    After the BFINAL and BTYPE, the dynamic block consists out of the following:\n    - 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN\n    - (HCLEN+4)*3 bits code lengths of code length alphabet\n    - HLIT + 257 code lengths of lit/length alphabet (encoded using the code length\n      alphabet, + possible repetition codes 16, 17, 18)\n    - HDIST + 1 code lengths of distance alphabet (encoded using the code length\n      alphabet, + possible repetition codes 16, 17, 18)\n    - compressed data\n    - 256 (end code)\n    */\n\n    /*Write block type*/\n    writeBits(writer, BFINAL, 1);\n    writeBits(writer, 0, 1); /*first bit of BTYPE \"dynamic\"*/\n    writeBits(writer, 1, 1); /*second bit of BTYPE \"dynamic\"*/\n\n    /*write the HLIT, HDIST and HCLEN values*/\n    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies\n    or in the loop for numcodes_cl above, which saves space. */\n    HLIT = (unsigned)(numcodes_ll - 257);\n    HDIST = (unsigned)(numcodes_d - 1);\n    HCLEN = (unsigned)(numcodes_cl - 4);\n    writeBits(writer, HLIT, 5);\n    writeBits(writer, HDIST, 5);\n    writeBits(writer, HCLEN, 4);\n\n    /*write the code lengths of the code length alphabet (\"bitlen_cl\")*/\n    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);\n\n    /*write the lengths of the lit/len AND the dist alphabet*/\n    for(i = 0; i != numcodes_lld_e; ++i) {\n      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);\n      /*extra bits of repeat codes*/\n      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);\n      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);\n      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);\n    }\n\n    /*write the compressed data symbols*/\n    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);\n    /*error: the length of the end code 256 must be larger than 0*/\n    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);\n\n    /*write the end code*/\n    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);\n\n    break; /*end of error-while*/\n  }\n\n  /*cleanup*/\n  uivector_cleanup(&lz77_encoded);\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n  HuffmanTree_cleanup(&tree_cl);\n  lodepng_free(frequencies_ll);\n  lodepng_free(frequencies_d);\n  lodepng_free(frequencies_cl);\n  lodepng_free(bitlen_lld);\n  lodepng_free(bitlen_lld_e);\n\n  return error;\n}\n\nstatic unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,\n                             const unsigned char* data,\n                             size_t datapos, size_t dataend,\n                             const LodePNGCompressSettings* settings, unsigned final) {\n  HuffmanTree tree_ll; /*tree for literal values and length codes*/\n  HuffmanTree tree_d; /*tree for distance codes*/\n\n  unsigned BFINAL = final;\n  unsigned error = 0;\n  size_t i;\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  error = generateFixedLitLenTree(&tree_ll);\n  if(!error) error = generateFixedDistanceTree(&tree_d);\n\n  if(!error) {\n    writeBits(writer, BFINAL, 1);\n    writeBits(writer, 1, 1); /*first bit of BTYPE*/\n    writeBits(writer, 0, 1); /*second bit of BTYPE*/\n\n    if(settings->use_lz77) /*LZ77 encoded*/ {\n      uivector lz77_encoded;\n      uivector_init(&lz77_encoded);\n      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\n                         settings->minmatch, settings->nicematch, settings->lazymatching);\n      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);\n      uivector_cleanup(&lz77_encoded);\n    } else /*no LZ77, but still will be Huffman compressed*/ {\n      for(i = datapos; i < dataend; ++i) {\n        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);\n      }\n    }\n    /*add END code*/\n    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);\n  }\n\n  /*cleanup*/\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}\n\nstatic unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,\n                                 const LodePNGCompressSettings* settings) {\n  unsigned error = 0;\n  size_t i, blocksize, numdeflateblocks;\n  Hash hash;\n  LodePNGBitWriter writer;\n\n  LodePNGBitWriter_init(&writer, out);\n\n  if(settings->btype > 2) return 61;\n  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);\n  else if(settings->btype == 1) blocksize = insize;\n  else /*if(settings->btype == 2)*/ {\n    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/\n    blocksize = insize / 8u + 8;\n    if(blocksize < 65536) blocksize = 65536;\n    if(blocksize > 262144) blocksize = 262144;\n  }\n\n  numdeflateblocks = (insize + blocksize - 1) / blocksize;\n  if(numdeflateblocks == 0) numdeflateblocks = 1;\n\n  error = hash_init(&hash, settings->windowsize);\n\n  if(!error) {\n    for(i = 0; i != numdeflateblocks && !error; ++i) {\n      unsigned final = (i == numdeflateblocks - 1);\n      size_t start = i * blocksize;\n      size_t end = start + blocksize;\n      if(end > insize) end = insize;\n\n      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);\n      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);\n    }\n  }\n\n  hash_cleanup(&hash);\n\n  return error;\n}\n\nunsigned lodepng_deflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGCompressSettings* settings) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_deflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\nstatic unsigned deflate(unsigned char** out, size_t* outsize,\n                        const unsigned char* in, size_t insize,\n                        const LodePNGCompressSettings* settings) {\n  if(settings->custom_deflate) {\n    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);\n    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/\n    return error ? 111 : 0;\n  } else {\n    return lodepng_deflate(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Adler32                                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {\n  unsigned s1 = adler & 0xffffu;\n  unsigned s2 = (adler >> 16u) & 0xffffu;\n\n  while(len != 0u) {\n    unsigned i;\n    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5552u ? 5552u : len;\n    len -= amount;\n    for(i = 0; i != amount; ++i) {\n      s1 += (*data++);\n      s2 += s1;\n    }\n    s1 %= 65521u;\n    s2 %= 65521u;\n  }\n\n  return (s2 << 16u) | s1;\n}\n\n/*Return the adler32 of the bytes data[0..len-1]*/\nstatic unsigned adler32(const unsigned char* data, unsigned len) {\n  return update_adler32(1u, data, len);\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Zlib                                                                   / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nstatic unsigned lodepng_zlib_decompressv(ucvector* out,\n                                         const unsigned char* in, size_t insize,\n                                         const LodePNGDecompressSettings* settings) {\n  unsigned error = 0;\n  unsigned CM, CINFO, FDICT;\n\n  if(insize < 2) return 53; /*error, size of zlib data too small*/\n  /*read information from zlib header*/\n  if((in[0] * 256 + in[1]) % 31 != 0) {\n    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/\n    return 24;\n  }\n\n  CM = in[0] & 15;\n  CINFO = (in[0] >> 4) & 15;\n  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/\n  FDICT = (in[1] >> 5) & 1;\n  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/\n\n  if(CM != 8 || CINFO > 7) {\n    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/\n    return 25;\n  }\n  if(FDICT != 0) {\n    /*error: the specification of PNG says about the zlib stream:\n      \"The additional flags shall not specify a preset dictionary.\"*/\n    return 26;\n  }\n\n  error = inflatev(out, in + 2, insize - 2, settings);\n  if(error) return error;\n\n  if(!settings->ignore_adler32) {\n    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);\n    unsigned checksum = adler32(out->data, (unsigned)(out->size));\n    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/\n  }\n\n  return 0; /*no error*/\n}\n\n\nunsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                 size_t insize, const LodePNGDecompressSettings* settings) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\n/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,\n                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {\n  unsigned error;\n  if(settings->custom_zlib) {\n    error = settings->custom_zlib(out, outsize, in, insize, settings);\n    if(error) {\n      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/\n      error = 110;\n      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/\n      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;\n    }\n  } else {\n    ucvector v = ucvector_init(*out, *outsize);\n    if(expected_size) {\n      /*reserve the memory to avoid intermediate reallocations*/\n      ucvector_resize(&v, *outsize + expected_size);\n      v.size = *outsize;\n    }\n    error = lodepng_zlib_decompressv(&v, in, insize, settings);\n    *out = v.data;\n    *outsize = v.size;\n  }\n  return error;\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\nunsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                               size_t insize, const LodePNGCompressSettings* settings) {\n  size_t i;\n  unsigned error;\n  unsigned char* deflatedata = 0;\n  size_t deflatesize = 0;\n\n  error = deflate(&deflatedata, &deflatesize, in, insize, settings);\n\n  *out = NULL;\n  *outsize = 0;\n  if(!error) {\n    *outsize = deflatesize + 6;\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!*out) error = 83; /*alloc fail*/\n  }\n\n  if(!error) {\n    unsigned ADLER32 = adler32(in, (unsigned)insize);\n    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/\n    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/\n    unsigned FLEVEL = 0;\n    unsigned FDICT = 0;\n    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;\n    unsigned FCHECK = 31 - CMFFLG % 31;\n    CMFFLG += FCHECK;\n\n    (*out)[0] = (unsigned char)(CMFFLG >> 8);\n    (*out)[1] = (unsigned char)(CMFFLG & 255);\n    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];\n    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);\n  }\n\n  lodepng_free(deflatedata);\n  return error;\n}\n\n/* compress using the default or custom zlib function */\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings) {\n  if(settings->custom_zlib) {\n    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);\n    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/\n    return error ? 111 : 0;\n  } else {\n    return lodepng_zlib_compress(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#else /*no LODEPNG_COMPILE_ZLIB*/\n\n#ifdef LODEPNG_COMPILE_DECODER\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,\n                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {\n  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */\n  (void)expected_size;\n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings) {\n  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */\n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/*this is a good tradeoff between speed and compression ratio*/\n#define DEFAULT_WINDOWSIZE 2048\n\nvoid lodepng_compress_settings_init(LodePNGCompressSettings* settings) {\n  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/\n  settings->btype = 2;\n  settings->use_lz77 = 1;\n  settings->windowsize = DEFAULT_WINDOWSIZE;\n  settings->minmatch = 3;\n  settings->nicematch = 128;\n  settings->lazymatching = 1;\n\n  settings->custom_zlib = 0;\n  settings->custom_deflate = 0;\n  settings->custom_context = 0;\n}\n\nconst LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};\n\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nvoid lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {\n  settings->ignore_adler32 = 0;\n  settings->ignore_nlen = 0;\n  settings->max_output_size = 0;\n\n  settings->custom_zlib = 0;\n  settings->custom_inflate = 0;\n  settings->custom_context = 0;\n}\n\nconst LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0, 0, 0};\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // End of Zlib related code. Begin of PNG related code.                 // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_PNG\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / CRC32                                                                  / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n\n#ifdef LODEPNG_COMPILE_CRC\n/* CRC polynomial: 0xedb88320 */\nstatic unsigned lodepng_crc32_table[256] = {\n           0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,\n   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,\n   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,\n   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,\n   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,\n   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,\n   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,\n   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,\n  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,\n  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,\n  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,\n  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,\n  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,\n  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,\n  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,\n  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,\n  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,\n  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,\n  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,\n  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,\n  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,\n  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,\n  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,\n  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,\n  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,\n  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,\n  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,\n  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,\n  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,\n  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,\n  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,\n  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u\n};\n\n/*Return the CRC of the bytes buf[0..len-1].*/\nunsigned lodepng_crc32(const unsigned char* data, size_t length) {\n  unsigned r = 0xffffffffu;\n  size_t i;\n  for(i = 0; i < length; ++i) {\n    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);\n  }\n  return r ^ 0xffffffffu;\n}\n#else /* LODEPNG_COMPILE_CRC */\n/*in this case, the function is only declared here, and must be defined externally\nso that it will be linked in*/\nunsigned lodepng_crc32(const unsigned char* data, size_t length);\n#endif /* LODEPNG_COMPILE_CRC */\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Reading and writing PNG color channel bits                             / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,\nso LodePNGBitWriter and LodePNGBitReader can't be used for those. */\n\nstatic unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {\n  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);\n  ++(*bitpointer);\n  return result;\n}\n\n/* TODO: make this faster */\nstatic unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {\n  unsigned result = 0;\n  size_t i;\n  for(i = 0 ; i < nbits; ++i) {\n    result <<= 1u;\n    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);\n  }\n  return result;\n}\n\nstatic void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {\n  /*the current bit in bitstream may be 0 or 1 for this to work*/\n  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));\n  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));\n  ++(*bitpointer);\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG chunks                                                             / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nunsigned lodepng_chunk_length(const unsigned char* chunk) {\n  return lodepng_read32bitInt(chunk);\n}\n\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk) {\n  unsigned i;\n  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];\n  type[4] = 0; /*null termination char*/\n}\n\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {\n  if(lodepng_strlen(type) != 4) return 0;\n  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);\n}\n\nunsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {\n  return((chunk[4] & 32) != 0);\n}\n\nunsigned char lodepng_chunk_private(const unsigned char* chunk) {\n  return((chunk[6] & 32) != 0);\n}\n\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {\n  return((chunk[7] & 32) != 0);\n}\n\nunsigned char* lodepng_chunk_data(unsigned char* chunk) {\n  return &chunk[8];\n}\n\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {\n  return &chunk[8];\n}\n\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk) {\n  unsigned length = lodepng_chunk_length(chunk);\n  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);\n  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/\n  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);\n  if(CRC != checksum) return 1;\n  else return 0;\n}\n\nvoid lodepng_chunk_generate_crc(unsigned char* chunk) {\n  unsigned length = lodepng_chunk_length(chunk);\n  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);\n  lodepng_set32bitInt(chunk + 8 + length, CRC);\n}\n\nunsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {\n  size_t available_size = (size_t)(end - chunk);\n  if(chunk >= end || available_size < 12) return end; /*too small to contain a chunk*/\n  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47\n    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {\n    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */\n    return chunk + 8;\n  } else {\n    size_t total_chunk_length;\n    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;\n    if(total_chunk_length > available_size) return end; /*outside of range*/\n    return chunk + total_chunk_length;\n  }\n}\n\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {\n  size_t available_size = (size_t)(end - chunk);\n  if(chunk >= end || available_size < 12) return end; /*too small to contain a chunk*/\n  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47\n    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {\n    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */\n    return chunk + 8;\n  } else {\n    size_t total_chunk_length;\n    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;\n    if(total_chunk_length > available_size) return end; /*outside of range*/\n    return chunk + total_chunk_length;\n  }\n}\n\nunsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {\n  for(;;) {\n    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */\n    if(lodepng_chunk_type_equals(chunk, type)) return chunk;\n    chunk = lodepng_chunk_next(chunk, end);\n  }\n}\n\nconst unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {\n  for(;;) {\n    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */\n    if(lodepng_chunk_type_equals(chunk, type)) return chunk;\n    chunk = lodepng_chunk_next_const(chunk, end);\n  }\n}\n\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {\n  unsigned i;\n  size_t total_chunk_length, new_length;\n  unsigned char *chunk_start, *new_buffer;\n\n  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;\n  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;\n\n  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);\n  if(!new_buffer) return 83; /*alloc fail*/\n  (*out) = new_buffer;\n  (*outsize) = new_length;\n  chunk_start = &(*out)[new_length - total_chunk_length];\n\n  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];\n\n  return 0;\n}\n\n/*Sets length and name and allocates the space for data and crc but does not\nset data or crc yet. Returns the start of the chunk in chunk. The start of\nthe data is at chunk + 8. To finalize chunk, add the data, then use\nlodepng_chunk_generate_crc */\nstatic unsigned lodepng_chunk_init(unsigned char** chunk,\n                                   ucvector* out,\n                                   unsigned length, const char* type) {\n  size_t new_length = out->size;\n  if(lodepng_addofl(new_length, length, &new_length)) return 77;\n  if(lodepng_addofl(new_length, 12, &new_length)) return 77;\n  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/\n  *chunk = out->data + new_length - length - 12u;\n\n  /*1: length*/\n  lodepng_set32bitInt(*chunk, length);\n\n  /*2: chunk name (4 letters)*/\n  lodepng_memcpy(*chunk + 4, type, 4);\n\n  return 0;\n}\n\n/* like lodepng_chunk_create but with custom allocsize */\nstatic unsigned lodepng_chunk_createv(ucvector* out,\n                                      unsigned length, const char* type, const unsigned char* data) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));\n\n  /*3: the data*/\n  lodepng_memcpy(chunk + 8, data, length);\n\n  /*4: CRC (of the chunkname characters and the data)*/\n  lodepng_chunk_generate_crc(chunk);\n\n  return 0;\n}\n\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,\n                              unsigned length, const char* type, const unsigned char* data) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_chunk_createv(&v, length, type, data);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Color types, channels, bits                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.\nReturn value is a LodePNG error code.*/\nstatic unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {\n  switch(colortype) {\n    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;\n    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;\n    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;\n    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;\n    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;\n    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */\n    default: return 31; /* invalid color type */\n  }\n  return 0; /*allowed color type / bits combination*/\n}\n\nstatic unsigned getNumColorChannels(LodePNGColorType colortype) {\n  switch(colortype) {\n    case LCT_GREY: return 1;\n    case LCT_RGB: return 3;\n    case LCT_PALETTE: return 1;\n    case LCT_GREY_ALPHA: return 2;\n    case LCT_RGBA: return 4;\n    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */\n    default: return 0; /*invalid color type*/\n  }\n}\n\nstatic unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {\n  /*bits per pixel is amount of channels * bits per channel*/\n  return getNumColorChannels(colortype) * bitdepth;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\nvoid lodepng_color_mode_init(LodePNGColorMode* info) {\n  info->key_defined = 0;\n  info->key_r = info->key_g = info->key_b = 0;\n  info->colortype = LCT_RGBA;\n  info->bitdepth = 8;\n  info->palette = 0;\n  info->palettesize = 0;\n}\n\n/*allocates palette memory if needed, and initializes all colors to black*/\nstatic void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {\n  size_t i;\n  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/\n  /*the palette must have room for up to 256 colors with 4 bytes each.*/\n  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);\n  if(!info->palette) return; /*alloc fail*/\n  for(i = 0; i != 256; ++i) {\n    /*Initialize all unused colors with black, the value used for invalid palette indices.\n    This is an error according to the PNG spec, but common PNG decoders make it black instead.\n    That makes color conversion slightly faster due to no error handling needed.*/\n    info->palette[i * 4 + 0] = 0;\n    info->palette[i * 4 + 1] = 0;\n    info->palette[i * 4 + 2] = 0;\n    info->palette[i * 4 + 3] = 255;\n  }\n}\n\nvoid lodepng_color_mode_cleanup(LodePNGColorMode* info) {\n  lodepng_palette_clear(info);\n}\n\nunsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {\n  lodepng_color_mode_cleanup(dest);\n  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));\n  if(source->palette) {\n    dest->palette = (unsigned char*)lodepng_malloc(1024);\n    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/\n    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);\n  }\n  return 0;\n}\n\nLodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {\n  LodePNGColorMode result;\n  lodepng_color_mode_init(&result);\n  result.colortype = colortype;\n  result.bitdepth = bitdepth;\n  return result;\n}\n\nstatic int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {\n  size_t i;\n  if(a->colortype != b->colortype) return 0;\n  if(a->bitdepth != b->bitdepth) return 0;\n  if(a->key_defined != b->key_defined) return 0;\n  if(a->key_defined) {\n    if(a->key_r != b->key_r) return 0;\n    if(a->key_g != b->key_g) return 0;\n    if(a->key_b != b->key_b) return 0;\n  }\n  if(a->palettesize != b->palettesize) return 0;\n  for(i = 0; i != a->palettesize * 4; ++i) {\n    if(a->palette[i] != b->palette[i]) return 0;\n  }\n  return 1;\n}\n\nvoid lodepng_palette_clear(LodePNGColorMode* info) {\n  if(info->palette) lodepng_free(info->palette);\n  info->palette = 0;\n  info->palettesize = 0;\n}\n\nunsigned lodepng_palette_add(LodePNGColorMode* info,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  if(!info->palette) /*allocate palette if empty*/ {\n    lodepng_color_mode_alloc_palette(info);\n    if(!info->palette) return 83; /*alloc fail*/\n  }\n  if(info->palettesize >= 256) {\n    return 108; /*too many palette values*/\n  }\n  info->palette[4 * info->palettesize + 0] = r;\n  info->palette[4 * info->palettesize + 1] = g;\n  info->palette[4 * info->palettesize + 2] = b;\n  info->palette[4 * info->palettesize + 3] = a;\n  ++info->palettesize;\n  return 0;\n}\n\n/*calculate bits per pixel out of colortype and bitdepth*/\nunsigned lodepng_get_bpp(const LodePNGColorMode* info) {\n  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);\n}\n\nunsigned lodepng_get_channels(const LodePNGColorMode* info) {\n  return getNumColorChannels(info->colortype);\n}\n\nunsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {\n  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;\n}\n\nunsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {\n  return (info->colortype & 4) != 0; /*4 or 6*/\n}\n\nunsigned lodepng_is_palette_type(const LodePNGColorMode* info) {\n  return info->colortype == LCT_PALETTE;\n}\n\nunsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {\n  size_t i;\n  for(i = 0; i != info->palettesize; ++i) {\n    if(info->palette[i * 4 + 3] < 255) return 1;\n  }\n  return 0;\n}\n\nunsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {\n  return info->key_defined\n      || lodepng_is_alpha_type(info)\n      || lodepng_has_palette_alpha(info);\n}\n\nstatic size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {\n  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);\n  size_t n = (size_t)w * (size_t)h;\n  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;\n}\n\nsize_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {\n  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);\n}\n\n\n#ifdef LODEPNG_COMPILE_PNG\n\n/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,\nand in addition has one extra byte per line: the filter byte. So this gives a larger\nresult than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */\nstatic size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {\n  /* + 1 for the filter byte, and possibly plus padding bits per line. */\n  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */\n  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;\n  return (size_t)h * line;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*Safely checks whether size_t overflow can be caused due to amount of pixels.\nThis check is overcautious rather than precise. If this check indicates no overflow,\nyou can safely compute in a size_t (but not an unsigned):\n-(size_t)w * (size_t)h * 8\n-amount of bytes in IDAT (including filter, padding and Adam7 bytes)\n-amount of bytes in raw color model\nReturns 1 if overflow possible, 0 if not.\n*/\nstatic int lodepng_pixel_overflow(unsigned w, unsigned h,\n                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {\n  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));\n  size_t numpixels, total;\n  size_t line; /* bytes per line in worst case */\n\n  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;\n  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */\n\n  /* Bytes per scanline with the expression \"(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u\" */\n  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;\n  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;\n\n  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */\n  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */\n\n  return 0; /* no overflow */\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\nstatic void LodePNGUnknownChunks_init(LodePNGInfo* info) {\n  unsigned i;\n  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;\n  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;\n}\n\nstatic void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {\n  unsigned i;\n  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);\n}\n\nstatic unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {\n  unsigned i;\n\n  LodePNGUnknownChunks_cleanup(dest);\n\n  for(i = 0; i != 3; ++i) {\n    size_t j;\n    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];\n    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);\n    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/\n    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {\n      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];\n    }\n  }\n\n  return 0;\n}\n\n/******************************************************************************/\n\nstatic void LodePNGText_init(LodePNGInfo* info) {\n  info->text_num = 0;\n  info->text_keys = NULL;\n  info->text_strings = NULL;\n}\n\nstatic void LodePNGText_cleanup(LodePNGInfo* info) {\n  size_t i;\n  for(i = 0; i != info->text_num; ++i) {\n    string_cleanup(&info->text_keys[i]);\n    string_cleanup(&info->text_strings[i]);\n  }\n  lodepng_free(info->text_keys);\n  lodepng_free(info->text_strings);\n}\n\nstatic unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {\n  size_t i = 0;\n  dest->text_keys = NULL;\n  dest->text_strings = NULL;\n  dest->text_num = 0;\n  for(i = 0; i != source->text_num; ++i) {\n    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));\n  }\n  return 0;\n}\n\nstatic unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {\n  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));\n  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));\n\n  if(new_keys) info->text_keys = new_keys;\n  if(new_strings) info->text_strings = new_strings;\n\n  if(!new_keys || !new_strings) return 83; /*alloc fail*/\n\n  ++info->text_num;\n  info->text_keys[info->text_num - 1] = alloc_string(key);\n  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);\n  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/\n\n  return 0;\n}\n\nunsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {\n  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));\n}\n\nvoid lodepng_clear_text(LodePNGInfo* info) {\n  LodePNGText_cleanup(info);\n}\n\n/******************************************************************************/\n\nstatic void LodePNGIText_init(LodePNGInfo* info) {\n  info->itext_num = 0;\n  info->itext_keys = NULL;\n  info->itext_langtags = NULL;\n  info->itext_transkeys = NULL;\n  info->itext_strings = NULL;\n}\n\nstatic void LodePNGIText_cleanup(LodePNGInfo* info) {\n  size_t i;\n  for(i = 0; i != info->itext_num; ++i) {\n    string_cleanup(&info->itext_keys[i]);\n    string_cleanup(&info->itext_langtags[i]);\n    string_cleanup(&info->itext_transkeys[i]);\n    string_cleanup(&info->itext_strings[i]);\n  }\n  lodepng_free(info->itext_keys);\n  lodepng_free(info->itext_langtags);\n  lodepng_free(info->itext_transkeys);\n  lodepng_free(info->itext_strings);\n}\n\nstatic unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {\n  size_t i = 0;\n  dest->itext_keys = NULL;\n  dest->itext_langtags = NULL;\n  dest->itext_transkeys = NULL;\n  dest->itext_strings = NULL;\n  dest->itext_num = 0;\n  for(i = 0; i != source->itext_num; ++i) {\n    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],\n                                        source->itext_transkeys[i], source->itext_strings[i]));\n  }\n  return 0;\n}\n\nvoid lodepng_clear_itext(LodePNGInfo* info) {\n  LodePNGIText_cleanup(info);\n}\n\nstatic unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,\n                                        const char* transkey, const char* str, size_t size) {\n  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));\n  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));\n  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));\n  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));\n\n  if(new_keys) info->itext_keys = new_keys;\n  if(new_langtags) info->itext_langtags = new_langtags;\n  if(new_transkeys) info->itext_transkeys = new_transkeys;\n  if(new_strings) info->itext_strings = new_strings;\n\n  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/\n\n  ++info->itext_num;\n\n  info->itext_keys[info->itext_num - 1] = alloc_string(key);\n  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);\n  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);\n  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);\n\n  return 0;\n}\n\nunsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,\n                           const char* transkey, const char* str) {\n  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));\n}\n\n/* same as set but does not delete */\nstatic unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {\n  if(profile_size == 0) return 100; /*invalid ICC profile size*/\n\n  info->iccp_name = alloc_string(name);\n  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);\n\n  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/\n\n  lodepng_memcpy(info->iccp_profile, profile, profile_size);\n  info->iccp_profile_size = profile_size;\n\n  return 0; /*ok*/\n}\n\nunsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {\n  if(info->iccp_name) lodepng_clear_icc(info);\n  info->iccp_defined = 1;\n\n  return lodepng_assign_icc(info, name, profile, profile_size);\n}\n\nvoid lodepng_clear_icc(LodePNGInfo* info) {\n  string_cleanup(&info->iccp_name);\n  lodepng_free(info->iccp_profile);\n  info->iccp_profile = NULL;\n  info->iccp_profile_size = 0;\n  info->iccp_defined = 0;\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nvoid lodepng_info_init(LodePNGInfo* info) {\n  lodepng_color_mode_init(&info->color);\n  info->interlace_method = 0;\n  info->compression_method = 0;\n  info->filter_method = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  info->background_defined = 0;\n  info->background_r = info->background_g = info->background_b = 0;\n\n  LodePNGText_init(info);\n  LodePNGIText_init(info);\n\n  info->time_defined = 0;\n  info->phys_defined = 0;\n\n  info->gama_defined = 0;\n  info->chrm_defined = 0;\n  info->srgb_defined = 0;\n  info->iccp_defined = 0;\n  info->iccp_name = NULL;\n  info->iccp_profile = NULL;\n\n  info->sbit_defined = 0;\n  info->sbit_r = info->sbit_g = info->sbit_b = info->sbit_a = 0;\n\n  LodePNGUnknownChunks_init(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\nvoid lodepng_info_cleanup(LodePNGInfo* info) {\n  lodepng_color_mode_cleanup(&info->color);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  LodePNGText_cleanup(info);\n  LodePNGIText_cleanup(info);\n\n  lodepng_clear_icc(info);\n\n  LodePNGUnknownChunks_cleanup(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\nunsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {\n  lodepng_info_cleanup(dest);\n  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));\n  lodepng_color_mode_init(&dest->color);\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\n  if(source->iccp_defined) {\n    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));\n  }\n\n  LodePNGUnknownChunks_init(dest);\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  return 0;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/\nstatic void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {\n  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/\n  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/\n  unsigned p = index & m;\n  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/\n  in = in << (bits * (m - p));\n  if(p == 0) out[index * bits / 8u] = in;\n  else out[index * bits / 8u] |= in;\n}\n\ntypedef struct ColorTree ColorTree;\n\n/*\nOne node of a color tree\nThis is the data structure used to count the number of unique colors and to get a palette\nindex for a color. It's like an octree, but because the alpha channel is used too, each\nnode has 16 instead of 8 children.\n*/\nstruct ColorTree {\n  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/\n  int index; /*the payload. Only has a meaningful value if this is in the last level*/\n};\n\nstatic void color_tree_init(ColorTree* tree) {\n  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));\n  tree->index = -1;\n}\n\nstatic void color_tree_cleanup(ColorTree* tree) {\n  int i;\n  for(i = 0; i != 16; ++i) {\n    if(tree->children[i]) {\n      color_tree_cleanup(tree->children[i]);\n      lodepng_free(tree->children[i]);\n    }\n  }\n}\n\n/*returns -1 if color not present, its index otherwise*/\nstatic int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  int bit = 0;\n  for(bit = 0; bit < 8; ++bit) {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i]) return -1;\n    else tree = tree->children[i];\n  }\n  return tree ? tree->index : -1;\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  return color_tree_get(tree, r, g, b, a) >= 0;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*color is not allowed to already exist.\nIndex should be >= 0 (it's signed to be compatible with using -1 for \"doesn't exist\")\nReturns error code, or 0 if ok*/\nstatic unsigned color_tree_add(ColorTree* tree,\n                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {\n  int bit;\n  for(bit = 0; bit < 8; ++bit) {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i]) {\n      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));\n      if(!tree->children[i]) return 83; /*alloc fail*/\n      color_tree_init(tree->children[i]);\n    }\n    tree = tree->children[i];\n  }\n  tree->index = (int)index;\n  return 0;\n}\n\n/*put a pixel, given its RGBA color, into image of any color type*/\nstatic unsigned rgba8ToPixel(unsigned char* out, size_t i,\n                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  if(mode->colortype == LCT_GREY) {\n    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/\n    if(mode->bitdepth == 8) out[i] = gray;\n    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;\n    else {\n      /*take the most significant bits of gray*/\n      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);\n      addColorBits(out, i, mode->bitdepth, gray);\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      out[i * 3 + 0] = r;\n      out[i * 3 + 1] = g;\n      out[i * 3 + 2] = b;\n    } else {\n      out[i * 6 + 0] = out[i * 6 + 1] = r;\n      out[i * 6 + 2] = out[i * 6 + 3] = g;\n      out[i * 6 + 4] = out[i * 6 + 5] = b;\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    int index = color_tree_get(tree, r, g, b, a);\n    if(index < 0) return 82; /*color not in palette*/\n    if(mode->bitdepth == 8) out[i] = index;\n    else addColorBits(out, i, mode->bitdepth, (unsigned)index);\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/\n    if(mode->bitdepth == 8) {\n      out[i * 2 + 0] = gray;\n      out[i * 2 + 1] = a;\n    } else if(mode->bitdepth == 16) {\n      out[i * 4 + 0] = out[i * 4 + 1] = gray;\n      out[i * 4 + 2] = out[i * 4 + 3] = a;\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      out[i * 4 + 0] = r;\n      out[i * 4 + 1] = g;\n      out[i * 4 + 2] = b;\n      out[i * 4 + 3] = a;\n    } else {\n      out[i * 8 + 0] = out[i * 8 + 1] = r;\n      out[i * 8 + 2] = out[i * 8 + 3] = g;\n      out[i * 8 + 4] = out[i * 8 + 5] = b;\n      out[i * 8 + 6] = out[i * 8 + 7] = a;\n    }\n  }\n\n  return 0; /*no error*/\n}\n\n/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/\nstatic void rgba16ToPixel(unsigned char* out, size_t i,\n                         const LodePNGColorMode* mode,\n                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {\n  if(mode->colortype == LCT_GREY) {\n    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/\n    out[i * 2 + 0] = (gray >> 8) & 255;\n    out[i * 2 + 1] = gray & 255;\n  } else if(mode->colortype == LCT_RGB) {\n    out[i * 6 + 0] = (r >> 8) & 255;\n    out[i * 6 + 1] = r & 255;\n    out[i * 6 + 2] = (g >> 8) & 255;\n    out[i * 6 + 3] = g & 255;\n    out[i * 6 + 4] = (b >> 8) & 255;\n    out[i * 6 + 5] = b & 255;\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/\n    out[i * 4 + 0] = (gray >> 8) & 255;\n    out[i * 4 + 1] = gray & 255;\n    out[i * 4 + 2] = (a >> 8) & 255;\n    out[i * 4 + 3] = a & 255;\n  } else if(mode->colortype == LCT_RGBA) {\n    out[i * 8 + 0] = (r >> 8) & 255;\n    out[i * 8 + 1] = r & 255;\n    out[i * 8 + 2] = (g >> 8) & 255;\n    out[i * 8 + 3] = g & 255;\n    out[i * 8 + 4] = (b >> 8) & 255;\n    out[i * 8 + 5] = b & 255;\n    out[i * 8 + 6] = (a >> 8) & 255;\n    out[i * 8 + 7] = a & 255;\n  }\n}\n\n/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/\nstatic void getPixelColorRGBA8(unsigned char* r, unsigned char* g,\n                               unsigned char* b, unsigned char* a,\n                               const unsigned char* in, size_t i,\n                               const LodePNGColorMode* mode) {\n  if(mode->colortype == LCT_GREY) {\n    if(mode->bitdepth == 8) {\n      *r = *g = *b = in[i];\n      if(mode->key_defined && *r == mode->key_r) *a = 0;\n      else *a = 255;\n    } else if(mode->bitdepth == 16) {\n      *r = *g = *b = in[i * 2 + 0];\n      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n      else *a = 255;\n    } else {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = i * mode->bitdepth;\n      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n      *r = *g = *b = (value * 255) / highest;\n      if(mode->key_defined && value == mode->key_r) *a = 0;\n      else *a = 255;\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];\n      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;\n      else *a = 255;\n    } else {\n      *r = in[i * 6 + 0];\n      *g = in[i * 6 + 2];\n      *b = in[i * 6 + 4];\n      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n      else *a = 255;\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    unsigned index;\n    if(mode->bitdepth == 8) index = in[i];\n    else {\n      size_t j = i * mode->bitdepth;\n      index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n    }\n    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n    *r = mode->palette[index * 4 + 0];\n    *g = mode->palette[index * 4 + 1];\n    *b = mode->palette[index * 4 + 2];\n    *a = mode->palette[index * 4 + 3];\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    if(mode->bitdepth == 8) {\n      *r = *g = *b = in[i * 2 + 0];\n      *a = in[i * 2 + 1];\n    } else {\n      *r = *g = *b = in[i * 4 + 0];\n      *a = in[i * 4 + 2];\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      *r = in[i * 4 + 0];\n      *g = in[i * 4 + 1];\n      *b = in[i * 4 + 2];\n      *a = in[i * 4 + 3];\n    } else {\n      *r = in[i * 8 + 0];\n      *g = in[i * 8 + 2];\n      *b = in[i * 8 + 4];\n      *a = in[i * 8 + 6];\n    }\n  }\n}\n\n/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color\nmode test cases, optimized to convert the colors much faster, when converting\nto the common case of RGBA with 8 bit per channel. buffer must be RGBA with\nenough memory.*/\nstatic void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,\n                                const unsigned char* LODEPNG_RESTRICT in,\n                                const LodePNGColorMode* mode) {\n  unsigned num_channels = 4;\n  size_t i;\n  if(mode->colortype == LCT_GREY) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i];\n        buffer[3] = 255;\n      }\n      if(mode->key_defined) {\n        buffer -= numpixels * num_channels;\n        for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n          if(buffer[0] == mode->key_r) buffer[3] = 0;\n        }\n      }\n    } else if(mode->bitdepth == 16) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2];\n        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;\n      }\n    } else {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;\n        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;\n      }\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        lodepng_memcpy(buffer, &in[i * 3], 3);\n        buffer[3] = 255;\n      }\n      if(mode->key_defined) {\n        buffer -= numpixels * num_channels;\n        for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;\n        }\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 6 + 0];\n        buffer[1] = in[i * 6 + 2];\n        buffer[2] = in[i * 6 + 4];\n        buffer[3] = mode->key_defined\n           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;\n      }\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = in[i];\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);\n      }\n    } else {\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);\n      }\n    }\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];\n        buffer[3] = in[i * 2 + 1];\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];\n        buffer[3] = in[i * 4 + 2];\n      }\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      lodepng_memcpy(buffer, in, numpixels * 4);\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 8 + 0];\n        buffer[1] = in[i * 8 + 2];\n        buffer[2] = in[i * 8 + 4];\n        buffer[3] = in[i * 8 + 6];\n      }\n    }\n  }\n}\n\n/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/\nstatic void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,\n                               const unsigned char* LODEPNG_RESTRICT in,\n                               const LodePNGColorMode* mode) {\n  const unsigned num_channels = 3;\n  size_t i;\n  if(mode->colortype == LCT_GREY) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i];\n      }\n    } else if(mode->bitdepth == 16) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2];\n      }\n    } else {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;\n      }\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      lodepng_memcpy(buffer, in, numpixels * 3);\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 6 + 0];\n        buffer[1] = in[i * 6 + 2];\n        buffer[2] = in[i * 6 + 4];\n      }\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = in[i];\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);\n      }\n    } else {\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);\n      }\n    }\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];\n      }\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        lodepng_memcpy(buffer, &in[i * 4], 3);\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 8 + 0];\n        buffer[1] = in[i * 8 + 2];\n        buffer[2] = in[i * 8 + 4];\n      }\n    }\n  }\n}\n\n/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with\ngiven color type, but the given color type must be 16-bit itself.*/\nstatic void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {\n  if(mode->colortype == LCT_GREY) {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  } else if(mode->colortype == LCT_RGB) {\n    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined\n       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];\n  } else if(mode->colortype == LCT_RGBA) {\n    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}\n\nunsigned lodepng_convert(unsigned char* out, const unsigned char* in,\n                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,\n                         unsigned w, unsigned h) {\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = (size_t)w * (size_t)h;\n  unsigned error = 0;\n\n  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {\n    return 107; /* error: must provide palette if input mode is palette */\n  }\n\n  if(lodepng_color_mode_equal(mode_out, mode_in)) {\n    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);\n    lodepng_memcpy(out, in, numbytes);\n    return 0;\n  }\n\n  if(mode_out->colortype == LCT_PALETTE) {\n    size_t palettesize = mode_out->palettesize;\n    const unsigned char* palette = mode_out->palette;\n    size_t palsize = (size_t)1u << mode_out->bitdepth;\n    /*if the user specified output palette but did not give the values, assume\n    they want the values of the input color type (assuming that one is palette).\n    Note that we never create a new palette ourselves.*/\n    if(palettesize == 0) {\n      palettesize = mode_in->palettesize;\n      palette = mode_in->palette;\n      /*if the input was also palette with same bitdepth, then the color types are also\n      equal, so copy literally. This to preserve the exact indices that were in the PNG\n      even in case there are duplicate colors in the palette.*/\n      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {\n        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);\n        lodepng_memcpy(out, in, numbytes);\n        return 0;\n      }\n    }\n    if(palettesize < palsize) palsize = palettesize;\n    color_tree_init(&tree);\n    for(i = 0; i != palsize; ++i) {\n      const unsigned char* p = &palette[i * 4];\n      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);\n      if(error) break;\n    }\n  }\n\n  if(!error) {\n    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {\n      for(i = 0; i != numpixels; ++i) {\n        unsigned short r = 0, g = 0, b = 0, a = 0;\n        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n        rgba16ToPixel(out, i, mode_out, r, g, b, a);\n      }\n    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {\n      getPixelColorsRGBA8(out, numpixels, in, mode_in);\n    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {\n      getPixelColorsRGB8(out, numpixels, in, mode_in);\n    } else {\n      unsigned char r = 0, g = 0, b = 0, a = 0;\n      for(i = 0; i != numpixels; ++i) {\n        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);\n        if(error) break;\n      }\n    }\n  }\n\n  if(mode_out->colortype == LCT_PALETTE) {\n    color_tree_cleanup(&tree);\n  }\n\n  return error;\n}\n\n\n/* Converts a single rgb color without alpha from one type to another, color bits truncated to\ntheir bitdepth. In case of single channel (gray or palette), only the r channel is used. Slow\nfunction, do not use to process all pixels of an image. Alpha channel not supported on purpose:\nthis is for bKGD, supporting alpha may prevent it from finding a color in the palette, from the\nspecification it looks like bKGD should ignore the alpha values of the palette since it can use\nany palette index but doesn't have an alpha channel. Idem with ignoring color key. */\nunsigned lodepng_convert_rgb(\n    unsigned* r_out, unsigned* g_out, unsigned* b_out,\n    unsigned r_in, unsigned g_in, unsigned b_in,\n    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {\n  unsigned r = 0, g = 0, b = 0;\n  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/\n  unsigned shift = 16 - mode_out->bitdepth;\n\n  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {\n    r = g = b = r_in * mul;\n  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {\n    r = r_in * mul;\n    g = g_in * mul;\n    b = b_in * mul;\n  } else if(mode_in->colortype == LCT_PALETTE) {\n    if(r_in >= mode_in->palettesize) return 82;\n    r = mode_in->palette[r_in * 4 + 0] * 257u;\n    g = mode_in->palette[r_in * 4 + 1] * 257u;\n    b = mode_in->palette[r_in * 4 + 2] * 257u;\n  } else {\n    return 31;\n  }\n\n  /* now convert to output format */\n  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {\n    *r_out = r >> shift ;\n  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {\n    *r_out = r >> shift ;\n    *g_out = g >> shift ;\n    *b_out = b >> shift ;\n  } else if(mode_out->colortype == LCT_PALETTE) {\n    unsigned i;\n    /* a 16-bit color cannot be in the palette */\n    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;\n    for(i = 0; i < mode_out->palettesize; i++) {\n      unsigned j = i * 4;\n      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&\n          (b >> 8) == mode_out->palette[j + 2]) {\n        *r_out = i;\n        return 0;\n      }\n    }\n    return 82;\n  } else {\n    return 31;\n  }\n\n  return 0;\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\nvoid lodepng_color_stats_init(LodePNGColorStats* stats) {\n  /*stats*/\n  stats->colored = 0;\n  stats->key = 0;\n  stats->key_r = stats->key_g = stats->key_b = 0;\n  stats->alpha = 0;\n  stats->numcolors = 0;\n  stats->bits = 1;\n  stats->numpixels = 0;\n  /*settings*/\n  stats->allow_palette = 1;\n  stats->allow_greyscale = 1;\n}\n\n/*function used for debug purposes with C++*/\n/*void printColorStats(LodePNGColorStats* p) {\n  std::cout << \"colored: \" << (int)p->colored << \", \";\n  std::cout << \"key: \" << (int)p->key << \", \";\n  std::cout << \"key_r: \" << (int)p->key_r << \", \";\n  std::cout << \"key_g: \" << (int)p->key_g << \", \";\n  std::cout << \"key_b: \" << (int)p->key_b << \", \";\n  std::cout << \"alpha: \" << (int)p->alpha << \", \";\n  std::cout << \"numcolors: \" << (int)p->numcolors << \", \";\n  std::cout << \"bits: \" << (int)p->bits << std::endl;\n}*/\n\n/*Returns how many bits needed to represent given value (max 8 bit)*/\nstatic unsigned getValueRequiredBits(unsigned char value) {\n  if(value == 0 || value == 255) return 1;\n  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/\n  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;\n  return 8;\n}\n\n/*stats must already have been inited. */\nunsigned lodepng_compute_color_stats(LodePNGColorStats* stats,\n                                     const unsigned char* in, unsigned w, unsigned h,\n                                     const LodePNGColorMode* mode_in) {\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = (size_t)w * (size_t)h;\n  unsigned error = 0;\n\n  /* mark things as done already if it would be impossible to have a more expensive case */\n  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;\n  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;\n  unsigned numcolors_done = 0;\n  unsigned bpp = lodepng_get_bpp(mode_in);\n  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;\n  unsigned sixteen = 0; /* whether the input image is 16 bit */\n  unsigned maxnumcolors = 257;\n  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));\n\n  stats->numpixels += numpixels;\n\n  /*if palette not allowed, no need to compute numcolors*/\n  if(!stats->allow_palette) numcolors_done = 1;\n\n  color_tree_init(&tree);\n\n  /*If the stats was already filled in from previous data, fill its palette in tree\n  and mark things as done already if we know they are the most expensive case already*/\n  if(stats->alpha) alpha_done = 1;\n  if(stats->colored) colored_done = 1;\n  if(stats->bits == 16) numcolors_done = 1;\n  if(stats->bits >= bpp) bits_done = 1;\n  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;\n\n  if(!numcolors_done) {\n    for(i = 0; i < stats->numcolors; i++) {\n      const unsigned char* color = &stats->palette[i * 4];\n      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);\n      if(error) goto cleanup;\n    }\n  }\n\n  /*Check if the 16-bit input is truly 16-bit*/\n  if(mode_in->bitdepth == 16 && !sixteen) {\n    unsigned short r = 0, g = 0, b = 0, a = 0;\n    for(i = 0; i != numpixels; ++i) {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||\n         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {\n        stats->bits = 16;\n        sixteen = 1;\n        bits_done = 1;\n        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/\n        break;\n      }\n    }\n  }\n\n  if(sixteen) {\n    unsigned short r = 0, g = 0, b = 0, a = 0;\n\n    for(i = 0; i != numpixels; ++i) {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n\n      if(!colored_done && (r != g || r != b)) {\n        stats->colored = 1;\n        colored_done = 1;\n      }\n\n      if(!alpha_done) {\n        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);\n        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n        } else if(a == 0 && !stats->alpha && !stats->key) {\n          stats->key = 1;\n          stats->key_r = r;\n          stats->key_g = g;\n          stats->key_b = b;\n        } else if(a == 65535 && stats->key && matchkey) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n        }\n      }\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n\n    if(stats->key && !stats->alpha) {\n      for(i = 0; i != numpixels; ++i) {\n        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n        }\n      }\n    }\n  } else /* < 16-bit */ {\n    unsigned char r = 0, g = 0, b = 0, a = 0;\n    for(i = 0; i != numpixels; ++i) {\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n\n      if(!bits_done && stats->bits < 8) {\n        /*only r is checked, < 8 bits is only relevant for grayscale*/\n        unsigned bits = getValueRequiredBits(r);\n        if(bits > stats->bits) stats->bits = bits;\n      }\n      bits_done = (stats->bits >= bpp);\n\n      if(!colored_done && (r != g || r != b)) {\n        stats->colored = 1;\n        colored_done = 1;\n        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/\n      }\n\n      if(!alpha_done) {\n        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);\n        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        } else if(a == 0 && !stats->alpha && !stats->key) {\n          stats->key = 1;\n          stats->key_r = r;\n          stats->key_g = g;\n          stats->key_b = b;\n        } else if(a == 255 && stats->key && matchkey) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n      }\n\n      if(!numcolors_done) {\n        if(!color_tree_has(&tree, r, g, b, a)) {\n          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);\n          if(error) goto cleanup;\n          if(stats->numcolors < 256) {\n            unsigned char* p = stats->palette;\n            unsigned n = stats->numcolors;\n            p[n * 4 + 0] = r;\n            p[n * 4 + 1] = g;\n            p[n * 4 + 2] = b;\n            p[n * 4 + 3] = a;\n          }\n          ++stats->numcolors;\n          numcolors_done = stats->numcolors >= maxnumcolors;\n        }\n      }\n\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n\n    if(stats->key && !stats->alpha) {\n      for(i = 0; i != numpixels; ++i) {\n        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n      }\n    }\n\n    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/\n    stats->key_r += (stats->key_r << 8);\n    stats->key_g += (stats->key_g << 8);\n    stats->key_b += (stats->key_b << 8);\n  }\n\ncleanup:\n  color_tree_cleanup(&tree);\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit\n(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for\nall pixels of an image but only for a few additional values. */\nstatic unsigned lodepng_color_stats_add(LodePNGColorStats* stats,\n                                        unsigned r, unsigned g, unsigned b, unsigned a) {\n  unsigned error = 0;\n  unsigned char image[8];\n  LodePNGColorMode mode;\n  lodepng_color_mode_init(&mode);\n  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;\n  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;\n  mode.bitdepth = 16;\n  mode.colortype = LCT_RGBA;\n  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);\n  lodepng_color_mode_cleanup(&mode);\n  return error;\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n/*Computes a minimal PNG color model that can contain all colors as indicated by the stats.\nThe stats should be computed with lodepng_compute_color_stats.\nmode_in is raw color profile of the image the stats were computed on, to copy palette order from when relevant.\nMinimal PNG color model means the color type and bit depth that gives smallest amount of bits in the output image,\ne.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...\nThis is used if auto_convert is enabled (it is by default).\n*/\nstatic unsigned auto_choose_color(LodePNGColorMode* mode_out,\n                                  const LodePNGColorMode* mode_in,\n                                  const LodePNGColorStats* stats) {\n  unsigned error = 0;\n  unsigned palettebits;\n  size_t i, n;\n  size_t numpixels = stats->numpixels;\n  unsigned palette_ok, gray_ok;\n\n  unsigned alpha = stats->alpha;\n  unsigned key = stats->key;\n  unsigned bits = stats->bits;\n\n  mode_out->key_defined = 0;\n\n  if(key && numpixels <= 16) {\n    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/\n    key = 0;\n    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n  }\n\n  gray_ok = !stats->colored;\n  if(!stats->allow_greyscale) gray_ok = 0;\n  if(!gray_ok && bits < 8) bits = 8;\n\n  n = stats->numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/\n  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/\n  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/\n  if(!stats->allow_palette) palette_ok = 0;\n\n  if(palette_ok) {\n    const unsigned char* p = stats->palette;\n    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/\n    for(i = 0; i != stats->numcolors; ++i) {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth) {\n      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/\n      lodepng_color_mode_cleanup(mode_out); /*clears palette, keeps the above set colortype and bitdepth fields as-is*/\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  } else /*8-bit or 16-bit per channel*/ {\n    mode_out->bitdepth = bits;\n    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)\n                                : (gray_ok ? LCT_GREY : LCT_RGB);\n    if(key) {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/\n      mode_out->key_r = stats->key_r & mask;\n      mode_out->key_g = stats->key_g & mask;\n      mode_out->key_b = stats->key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n\n  return error;\n}\n\n#endif /* #ifdef LODEPNG_COMPILE_ENCODER */\n\n/*\nPaeth predictor, used by PNG filter type 4\nThe parameters are of type short, but should come from unsigned chars, the shorts\nare only needed to make the paeth calculation correct.\n*/\nstatic unsigned char paethPredictor(short a, short b, short c) {\n  short pa = LODEPNG_ABS(b - c);\n  short pb = LODEPNG_ABS(a - c);\n  short pc = LODEPNG_ABS(a + b - c - c);\n  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */\n  if(pb < pa) { a = b; pa = pb; }\n  return (pc < pa) ? c : a;\n}\n\n/*shared values used by multiple Adam7 related functions*/\n\nstatic const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/\nstatic const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/\nstatic const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/\nstatic const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/\n\n/*\nOutputs various dimensions and positions in the image related to the Adam7 reduced images.\npassw: output containing the width of the 7 passes\npassh: output containing the height of the 7 passes\nfilter_passstart: output containing the index of the start and end of each\n reduced image with filter bytes\npadded_passstart output containing the index of the start and end of each\n reduced image when without filter bytes but with padded scanlines\npassstart: output containing the index of the start and end of each reduced\n image without padding between scanlines, but still padding between the images\nw, h: width and height of non-interlaced image\nbpp: bits per pixel\n\"padded\" is only relevant if bpp is less than 8 and a scanline or image does not\n end at a full byte\n*/\nstatic void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],\n                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {\n  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/\n  unsigned i;\n\n  /*calculate width and height in pixels of each pass*/\n  for(i = 0; i != 7; ++i) {\n    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];\n    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];\n    if(passw[i] == 0) passh[i] = 0;\n    if(passh[i] == 0) passw[i] = 0;\n  }\n\n  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;\n  for(i = 0; i != 7; ++i) {\n    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/\n    filter_passstart[i + 1] = filter_passstart[i]\n                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);\n    /*bits padded if needed to fill full byte at end of each scanline*/\n    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);\n    /*only padded at end of reduced image*/\n    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;\n  }\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG Decoder                                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*read the information from the header and store it in the LodePNGInfo. return value is error*/\nunsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,\n                         const unsigned char* in, size_t insize) {\n  unsigned width, height;\n  LodePNGInfo* info = &state->info_png;\n  if(insize == 0 || in == 0) {\n    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/\n  }\n  if(insize < 33) {\n    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/\n  }\n\n  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/\n  /* TODO: remove this. One should use a new LodePNGState for new sessions */\n  lodepng_info_cleanup(info);\n  lodepng_info_init(info);\n\n  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71\n     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {\n    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/\n  }\n  if(lodepng_chunk_length(in + 8) != 13) {\n    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/\n  }\n  if(!lodepng_chunk_type_equals(in + 8, \"IHDR\")) {\n    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/\n  }\n\n  /*read the values given in the header*/\n  width = lodepng_read32bitInt(&in[16]);\n  height = lodepng_read32bitInt(&in[20]);\n  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/\n  if(w) *w = width;\n  if(h) *h = height;\n  info->color.bitdepth = in[24];\n  info->color.colortype = (LodePNGColorType)in[25];\n  info->compression_method = in[26];\n  info->filter_method = in[27];\n  info->interlace_method = in[28];\n\n  /*errors returned only after the parsing so other values are still output*/\n\n  /*error: invalid image size*/\n  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);\n  /*error: invalid colortype or bitdepth combination*/\n  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);\n  if(state->error) return state->error;\n  /*error: only compression method 0 is allowed in the specification*/\n  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);\n  /*error: only filter method 0 is allowed in the specification*/\n  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);\n  /*error: only interlace methods 0 and 1 exist in the specification*/\n  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);\n\n  if(!state->decoder.ignore_crc) {\n    unsigned CRC = lodepng_read32bitInt(&in[29]);\n    unsigned checksum = lodepng_crc32(&in[12], 17);\n    if(CRC != checksum) {\n      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/\n    }\n  }\n\n  return state->error;\n}\n\nstatic unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,\n                                 size_t bytewidth, unsigned char filterType, size_t length) {\n  /*\n  For PNG filter method 0\n  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,\n  the filter works byte per byte (bytewidth = 1)\n  precon is the previous unfiltered scanline, recon the result, scanline the current one\n  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead\n  recon and scanline MAY be the same memory address! precon must be disjoint.\n  */\n\n  size_t i;\n  switch(filterType) {\n    case 0:\n      for(i = 0; i != length; ++i) recon[i] = scanline[i];\n      break;\n    case 1: {\n      size_t j = 0;\n      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];\n      for(i = bytewidth; i != length; ++i, ++j) recon[i] = scanline[i] + recon[j];\n      break;\n    }\n    case 2:\n      if(precon) {\n        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];\n      } else {\n        for(i = 0; i != length; ++i) recon[i] = scanline[i];\n      }\n      break;\n    case 3:\n      if(precon) {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);\n        /* Unroll independent paths of this predictor. A 6x and 8x version is also possible but that adds\n        too much code. Whether this speeds up anything depends on compiler and settings. */\n        if(bytewidth >= 4) {\n          for(; i + 3 < length; i += 4, j += 4) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];\n            recon[i + 0] = s0 + ((r0 + p0) >> 1u);\n            recon[i + 1] = s1 + ((r1 + p1) >> 1u);\n            recon[i + 2] = s2 + ((r2 + p2) >> 1u);\n            recon[i + 3] = s3 + ((r3 + p3) >> 1u);\n          }\n        } else if(bytewidth >= 3) {\n          for(; i + 2 < length; i += 3, j += 3) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];\n            recon[i + 0] = s0 + ((r0 + p0) >> 1u);\n            recon[i + 1] = s1 + ((r1 + p1) >> 1u);\n            recon[i + 2] = s2 + ((r2 + p2) >> 1u);\n          }\n        } else if(bytewidth >= 2) {\n          for(; i + 1 < length; i += 2, j += 2) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];\n            recon[i + 0] = s0 + ((r0 + p0) >> 1u);\n            recon[i + 1] = s1 + ((r1 + p1) >> 1u);\n          }\n        }\n        for(; i != length; ++i, ++j) recon[i] = scanline[i] + ((recon[j] + precon[i]) >> 1u);\n      } else {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];\n        for(i = bytewidth; i != length; ++i, ++j) recon[i] = scanline[i] + (recon[j] >> 1u);\n      }\n      break;\n    case 4:\n      if(precon) {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) {\n          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/\n        }\n\n        /* Unroll independent paths of the paeth predictor. A 6x and 8x version is also possible but that\n        adds too much code. Whether this speeds up anything depends on compiler and settings. */\n        if(bytewidth >= 4) {\n          for(; i + 3 < length; i += 4, j += 4) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];\n            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];\n            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);\n            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);\n            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);\n            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);\n          }\n        } else if(bytewidth >= 3) {\n          for(; i + 2 < length; i += 3, j += 3) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];\n            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];\n            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);\n            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);\n            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);\n          }\n        } else if(bytewidth >= 2) {\n          for(; i + 1 < length; i += 2, j += 2) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];\n            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];\n            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);\n            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);\n          }\n        }\n\n        for(; i != length; ++i, ++j) {\n          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[j]));\n        }\n      } else {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) {\n          recon[i] = scanline[i];\n        }\n        for(i = bytewidth; i != length; ++i, ++j) {\n          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/\n          recon[i] = (scanline[i] + recon[j]);\n        }\n      }\n      break;\n    default: return 36; /*error: invalid filter type given*/\n  }\n  return 0;\n}\n\nstatic unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {\n  /*\n  For PNG filter method 0\n  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)\n  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline\n  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel\n  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)\n  */\n\n  unsigned y;\n  unsigned char* prevline = 0;\n\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\n  size_t bytewidth = (bpp + 7u) / 8u;\n  /*the width of a scanline in bytes, not including the filter type*/\n  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;\n\n  for(y = 0; y < h; ++y) {\n    size_t outindex = linebytes * y;\n    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n    unsigned char filterType = in[inindex];\n\n    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));\n\n    prevline = &out[outindex];\n  }\n\n  return 0;\n}\n\n/*\nin: Adam7 interlaced image, with no padding bits between scanlines, but between\n reduced images so that each reduced image starts at a byte.\nout: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h\nbpp: bits per pixel\nout has the following size in bits: w * h * bpp.\nin is possibly bigger due to padding bits between reduced images.\nout must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation\n(because that's likely a little bit faster)\nNOTE: comments about padding bits are only relevant if bpp < 8\n*/\nstatic void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {\n  unsigned passw[7], passh[7];\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\n  unsigned i;\n\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n  if(bpp >= 8) {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      size_t bytewidth = bpp / 8u;\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;\n        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w\n                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;\n        for(b = 0; b < bytewidth; ++b) {\n          out[pixeloutstart + b] = in[pixelinstart + b];\n        }\n      }\n    }\n  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      unsigned ilinebits = bpp * passw[i];\n      unsigned olinebits = bpp * w;\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\n        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;\n        for(b = 0; b < bpp; ++b) {\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\n          setBitOfReversedStream(&obp, out, bit);\n        }\n      }\n    }\n  }\n}\n\nstatic void removePaddingBits(unsigned char* out, const unsigned char* in,\n                              size_t olinebits, size_t ilinebits, unsigned h) {\n  /*\n  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need\n  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers\n  for the Adam7 code, the color convert code and the output to the user.\n  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must\n  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits\n  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7\n  only useful if (ilinebits - olinebits) is a value in the range 1..7\n  */\n  unsigned y;\n  size_t diff = ilinebits - olinebits;\n  size_t ibp = 0, obp = 0; /*input and output bit pointers*/\n  for(y = 0; y < h; ++y) {\n    size_t x;\n    for(x = 0; x < olinebits; ++x) {\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\n      setBitOfReversedStream(&obp, out, bit);\n    }\n    ibp += diff;\n  }\n}\n\n/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from\nthe IDAT chunks (with filter index bytes and possible padding bits)\nreturn value is error*/\nstatic unsigned postProcessScanlines(unsigned char* out, unsigned char* in,\n                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {\n  /*\n  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.\n  Steps:\n  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)\n  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace\n  NOTE: the in buffer will be overwritten with intermediate data!\n  */\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  if(bpp == 0) return 31; /*error: invalid colortype*/\n\n  if(info_png->interlace_method == 0) {\n    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {\n      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));\n      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);\n    }\n    /*we can immediately filter into the out buffer, no other steps needed*/\n    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));\n  } else /*interlace_method is 1 (Adam7)*/ {\n    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned i;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n    for(i = 0; i != 7; ++i) {\n      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));\n      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,\n      move bytes instead of bits or move not at all*/\n      if(bpp < 8) {\n        /*remove padding bits in scanlines; after this there still may be padding\n        bits between the different reduced images: each reduced image still starts nicely at a byte*/\n        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,\n                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);\n      }\n    }\n\n    Adam7_deinterlace(out, in, w, h, bpp);\n  }\n\n  return 0;\n}\n\nstatic unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {\n  unsigned pos = 0, i;\n  color->palettesize = chunkLength / 3u;\n  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/\n  lodepng_color_mode_alloc_palette(color);\n  if(!color->palette && color->palettesize) {\n    color->palettesize = 0;\n    return 83; /*alloc fail*/\n  }\n\n  for(i = 0; i != color->palettesize; ++i) {\n    color->palette[4 * i + 0] = data[pos++]; /*R*/\n    color->palette[4 * i + 1] = data[pos++]; /*G*/\n    color->palette[4 * i + 2] = data[pos++]; /*B*/\n    color->palette[4 * i + 3] = 255; /*alpha*/\n  }\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {\n  unsigned i;\n  if(color->colortype == LCT_PALETTE) {\n    /*error: more alpha values given than there are palette entries*/\n    if(chunkLength > color->palettesize) return 39;\n\n    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];\n  } else if(color->colortype == LCT_GREY) {\n    /*error: this chunk must be 2 bytes for grayscale image*/\n    if(chunkLength != 2) return 30;\n\n    color->key_defined = 1;\n    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];\n  } else if(color->colortype == LCT_RGB) {\n    /*error: this chunk must be 6 bytes for RGB image*/\n    if(chunkLength != 6) return 41;\n\n    color->key_defined = 1;\n    color->key_r = 256u * data[0] + data[1];\n    color->key_g = 256u * data[2] + data[3];\n    color->key_b = 256u * data[4] + data[5];\n  }\n  else return 42; /*error: tRNS chunk not allowed for other color models*/\n\n  return 0; /* OK */\n}\n\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*background color chunk (bKGD)*/\nstatic unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(info->color.colortype == LCT_PALETTE) {\n    /*error: this chunk must be 1 byte for indexed color image*/\n    if(chunkLength != 1) return 43;\n\n    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/\n    if(data[0] >= info->color.palettesize) return 103;\n\n    info->background_defined = 1;\n    info->background_r = info->background_g = info->background_b = data[0];\n  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {\n    /*error: this chunk must be 2 bytes for grayscale image*/\n    if(chunkLength != 2) return 44;\n\n    /*the values are truncated to bitdepth in the PNG file*/\n    info->background_defined = 1;\n    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {\n    /*error: this chunk must be 6 bytes for grayscale image*/\n    if(chunkLength != 6) return 45;\n\n    /*the values are truncated to bitdepth in the PNG file*/\n    info->background_defined = 1;\n    info->background_r = 256u * data[0] + data[1];\n    info->background_g = 256u * data[2] + data[3];\n    info->background_b = 256u * data[4] + data[5];\n  }\n\n  return 0; /* OK */\n}\n\n/*text chunk (tEXt)*/\nstatic unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n\n  while(!error) /*not really a while loop, only used to break on error*/ {\n    unsigned length, string2_begin;\n\n    length = 0;\n    while(length < chunkLength && data[length] != 0) ++length;\n    /*even though it's not allowed by the standard, no error is thrown if\n    there's no null termination char, if the text is empty*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(key, data, length);\n    key[length] = 0;\n\n    string2_begin = length + 1; /*skip keyword null terminator*/\n\n    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);\n    str = (char*)lodepng_malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(str, data + string2_begin, length);\n    str[length] = 0;\n\n    error = lodepng_add_text(info, key, str);\n\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(str);\n\n  return error;\n}\n\n/*compressed text chunk (zTXt)*/\nstatic unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,\n                               const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n\n  /*copy the object to change parameters in it*/\n  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;\n\n  unsigned length, string2_begin;\n  char *key = 0;\n  unsigned char* str = 0;\n  size_t size = 0;\n\n  while(!error) /*not really a while loop, only used to break on error*/ {\n    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\n    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(key, data, length);\n    key[length] = 0;\n\n    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\n\n    string2_begin = length + 2;\n    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\n\n    length = (unsigned)chunkLength - string2_begin;\n    zlibsettings.max_output_size = decoder->max_text_size;\n    /*will fail if zlib error, e.g. if length is too small*/\n    error = zlib_decompress(&str, &size, 0, &data[string2_begin],\n                            length, &zlibsettings);\n    /*error: compressed text larger than  decoder->max_text_size*/\n    if(error && size > zlibsettings.max_output_size) error = 112;\n    if(error) break;\n    error = lodepng_add_text_sized(info, key, (char*)str, size);\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(str);\n\n  return error;\n}\n\n/*international text chunk (iTXt)*/\nstatic unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,\n                               const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n  unsigned i;\n\n  /*copy the object to change parameters in it*/\n  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;\n\n  unsigned length, begin, compressed;\n  char *key = 0, *langtag = 0, *transkey = 0;\n\n  while(!error) /*not really a while loop, only used to break on error*/ {\n    /*Quick check if the chunk length isn't too small. Even without check\n    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/\n    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/\n\n    /*read the key*/\n    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\n    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(key, data, length);\n    key[length] = 0;\n\n    /*read the compression method*/\n    compressed = data[length + 1];\n    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\n\n    /*even though it's not allowed by the standard, no error is thrown if\n    there's no null termination char, if the text is empty for the next 3 texts*/\n\n    /*read the langtag*/\n    begin = length + 3;\n    length = 0;\n    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;\n\n    langtag = (char*)lodepng_malloc(length + 1);\n    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(langtag, data + begin, length);\n    langtag[length] = 0;\n\n    /*read the transkey*/\n    begin += length + 1;\n    length = 0;\n    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;\n\n    transkey = (char*)lodepng_malloc(length + 1);\n    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(transkey, data + begin, length);\n    transkey[length] = 0;\n\n    /*read the actual text*/\n    begin += length + 1;\n\n    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;\n\n    if(compressed) {\n      unsigned char* str = 0;\n      size_t size = 0;\n      zlibsettings.max_output_size = decoder->max_text_size;\n      /*will fail if zlib error, e.g. if length is too small*/\n      error = zlib_decompress(&str, &size, 0, &data[begin],\n                              length, &zlibsettings);\n      /*error: compressed text larger than  decoder->max_text_size*/\n      if(error && size > zlibsettings.max_output_size) error = 112;\n      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);\n      lodepng_free(str);\n    } else {\n      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);\n    }\n\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(langtag);\n  lodepng_free(transkey);\n\n  return error;\n}\n\nstatic unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/\n\n  info->time_defined = 1;\n  info->time.year = 256u * data[0] + data[1];\n  info->time.month = data[2];\n  info->time.day = data[3];\n  info->time.hour = data[4];\n  info->time.minute = data[5];\n  info->time.second = data[6];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/\n\n  info->phys_defined = 1;\n  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\n  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];\n  info->phys_unit = data[8];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/\n\n  info->gama_defined = 1;\n  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/\n\n  info->chrm_defined = 1;\n  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];\n  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];\n  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];\n  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];\n  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];\n  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];\n  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];\n  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/\n\n  info->srgb_defined = 1;\n  info->srgb_intent = data[0];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,\n                               const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n  unsigned i;\n  size_t size = 0;\n  /*copy the object to change parameters in it*/\n  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;\n\n  unsigned length, string2_begin;\n\n  info->iccp_defined = 1;\n  if(info->iccp_name) lodepng_clear_icc(info);\n\n  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\n  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/\n  if(length < 1 || length > 79) return 89; /*keyword too short or long*/\n\n  info->iccp_name = (char*)lodepng_malloc(length + 1);\n  if(!info->iccp_name) return 83; /*alloc fail*/\n\n  info->iccp_name[length] = 0;\n  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];\n\n  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/\n\n  string2_begin = length + 2;\n  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/\n\n  length = (unsigned)chunkLength - string2_begin;\n  zlibsettings.max_output_size = decoder->max_icc_size;\n  error = zlib_decompress(&info->iccp_profile, &size, 0,\n                          &data[string2_begin],\n                          length, &zlibsettings);\n  /*error: ICC profile larger than  decoder->max_icc_size*/\n  if(error && size > zlibsettings.max_output_size) error = 113;\n  info->iccp_profile_size = size;\n  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/\n  return error;\n}\n\n/*significant bits chunk (sBIT)*/\nstatic unsigned readChunk_sBIT(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  unsigned bitdepth = (info->color.colortype == LCT_PALETTE) ? 8 : info->color.bitdepth;\n  if(info->color.colortype == LCT_GREY) {\n    /*error: this chunk must be 1 bytes for grayscale image*/\n    if(chunkLength != 1) return 114;\n    if(data[0] == 0 || data[0] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = info->sbit_g = info->sbit_b = data[0]; /*setting g and b is not required, but sensible*/\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_PALETTE) {\n    /*error: this chunk must be 3 bytes for RGB and palette image*/\n    if(chunkLength != 3) return 114;\n    if(data[0] == 0 || data[1] == 0 || data[2] == 0) return 115;\n    if(data[0] > bitdepth || data[1] > bitdepth || data[2] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = data[0];\n    info->sbit_g = data[1];\n    info->sbit_b = data[2];\n  } else if(info->color.colortype == LCT_GREY_ALPHA) {\n    /*error: this chunk must be 2 byte for grayscale with alpha image*/\n    if(chunkLength != 2) return 114;\n    if(data[0] == 0 || data[1] == 0) return 115;\n    if(data[0] > bitdepth || data[1] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = info->sbit_g = info->sbit_b = data[0]; /*setting g and b is not required, but sensible*/\n    info->sbit_a = data[1];\n  } else if(info->color.colortype == LCT_RGBA) {\n    /*error: this chunk must be 4 bytes for grayscale image*/\n    if(chunkLength != 4) return 114;\n    if(data[0] == 0 || data[1] == 0 || data[2] == 0 || data[3] == 0) return 115;\n    if(data[0] > bitdepth || data[1] > bitdepth || data[2] > bitdepth || data[3] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = data[0];\n    info->sbit_g = data[1];\n    info->sbit_b = data[2];\n    info->sbit_a = data[3];\n  }\n\n  return 0; /* OK */\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nunsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,\n                               const unsigned char* in, size_t insize) {\n  const unsigned char* chunk = in + pos;\n  unsigned chunkLength;\n  const unsigned char* data;\n  unsigned unhandled = 0;\n  unsigned error = 0;\n\n  if(pos + 4 > insize) return 30;\n  chunkLength = lodepng_chunk_length(chunk);\n  if(chunkLength > 2147483647) return 63;\n  data = lodepng_chunk_data_const(chunk);\n  if(chunkLength + 12 > insize - pos) return 30;\n\n  if(lodepng_chunk_type_equals(chunk, \"PLTE\")) {\n    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"tRNS\")) {\n    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  } else if(lodepng_chunk_type_equals(chunk, \"bKGD\")) {\n    error = readChunk_bKGD(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"tEXt\")) {\n    error = readChunk_tEXt(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"zTXt\")) {\n    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"iTXt\")) {\n    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"tIME\")) {\n    error = readChunk_tIME(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"pHYs\")) {\n    error = readChunk_pHYs(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"gAMA\")) {\n    error = readChunk_gAMA(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"cHRM\")) {\n    error = readChunk_cHRM(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"sRGB\")) {\n    error = readChunk_sRGB(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"iCCP\")) {\n    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"sBIT\")) {\n    error = readChunk_sBIT(&state->info_png, data, chunkLength);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  } else {\n    /* unhandled chunk is ok (is not an error) */\n    unhandled = 1;\n  }\n\n  if(!error && !unhandled && !state->decoder.ignore_crc) {\n    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/\n  }\n\n  return error;\n}\n\n/*read a PNG, the result will be in the same color type as the PNG (hence \"generic\")*/\nstatic void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,\n                          LodePNGState* state,\n                          const unsigned char* in, size_t insize) {\n  unsigned char IEND = 0;\n  const unsigned char* chunk; /*points to beginning of next chunk*/\n  unsigned char* idat; /*the data from idat chunks, zlib compressed*/\n  size_t idatsize = 0;\n  unsigned char* scanlines = 0;\n  size_t scanlines_size = 0, expected_size = 0;\n  size_t outsize = 0;\n\n  /*for unknown chunk order*/\n  unsigned unknown = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n\n  /* safe output values in case error happens */\n  *out = 0;\n  *w = *h = 0;\n\n  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/\n  if(state->error) return;\n\n  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {\n    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/\n  }\n\n  /*the input filesize is a safe upper bound for the sum of idat chunks size*/\n  idat = (unsigned char*)lodepng_malloc(insize);\n  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/\n\n  chunk = &in[33]; /*first byte of the first chunk after the header*/\n\n  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.\n  IDAT data is put at the start of the in buffer*/\n  while(!IEND && !state->error) {\n    unsigned chunkLength;\n    const unsigned char* data; /*the data in the chunk*/\n    size_t pos = (size_t)(chunk - in);\n\n    /*error: next chunk out of bounds of the in buffer*/\n    if(chunk < in || pos + 12 > insize) {\n      if(state->decoder.ignore_end) break; /*other errors may still happen though*/\n      CERROR_BREAK(state->error, 30);\n    }\n\n    /*length of the data of the chunk, excluding the 12 bytes for length, chunk type and CRC*/\n    chunkLength = lodepng_chunk_length(chunk);\n    /*error: chunk length larger than the max PNG chunk size*/\n    if(chunkLength > 2147483647) {\n      if(state->decoder.ignore_end) break; /*other errors may still happen though*/\n      CERROR_BREAK(state->error, 63);\n    }\n\n    if(pos + (size_t)chunkLength + 12 > insize || pos + (size_t)chunkLength + 12 < pos) {\n      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk (or int overflow)*/\n    }\n\n    data = lodepng_chunk_data_const(chunk);\n\n    unknown = 0;\n\n    /*IDAT chunk, containing compressed image data*/\n    if(lodepng_chunk_type_equals(chunk, \"IDAT\")) {\n      size_t newsize;\n      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);\n      if(newsize > insize) CERROR_BREAK(state->error, 95);\n      lodepng_memcpy(idat + idatsize, data, chunkLength);\n      idatsize += chunkLength;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      critical_pos = 3;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    } else if(lodepng_chunk_type_equals(chunk, \"IEND\")) {\n      /*IEND chunk*/\n      IEND = 1;\n    } else if(lodepng_chunk_type_equals(chunk, \"PLTE\")) {\n      /*palette chunk (PLTE)*/\n      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);\n      if(state->error) break;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      critical_pos = 2;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    } else if(lodepng_chunk_type_equals(chunk, \"tRNS\")) {\n      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled\n      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that\n      affects the alpha channel of pixels. */\n      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);\n      if(state->error) break;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      /*background color chunk (bKGD)*/\n    } else if(lodepng_chunk_type_equals(chunk, \"bKGD\")) {\n      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"tEXt\")) {\n      /*text chunk (tEXt)*/\n      if(state->decoder.read_text_chunks) {\n        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);\n        if(state->error) break;\n      }\n    } else if(lodepng_chunk_type_equals(chunk, \"zTXt\")) {\n      /*compressed text chunk (zTXt)*/\n      if(state->decoder.read_text_chunks) {\n        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);\n        if(state->error) break;\n      }\n    } else if(lodepng_chunk_type_equals(chunk, \"iTXt\")) {\n      /*international text chunk (iTXt)*/\n      if(state->decoder.read_text_chunks) {\n        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);\n        if(state->error) break;\n      }\n    } else if(lodepng_chunk_type_equals(chunk, \"tIME\")) {\n      state->error = readChunk_tIME(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"pHYs\")) {\n      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"gAMA\")) {\n      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"cHRM\")) {\n      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"sRGB\")) {\n      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"iCCP\")) {\n      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"sBIT\")) {\n      state->error = readChunk_sBIT(&state->info_png, data, chunkLength);\n      if(state->error) break;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {\n      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/\n      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {\n        CERROR_BREAK(state->error, 69);\n      }\n\n      unknown = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      if(state->decoder.remember_unknown_chunks) {\n        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],\n                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);\n        if(state->error) break;\n      }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    }\n\n    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {\n      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/\n    }\n\n    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);\n  }\n\n  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {\n    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */\n  }\n\n  if(!state->error) {\n    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.\n    If the decompressed size does not match the prediction, the image must be corrupt.*/\n    if(state->info_png.interlace_method == 0) {\n      size_t bpp = lodepng_get_bpp(&state->info_png.color);\n      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);\n    } else {\n      size_t bpp = lodepng_get_bpp(&state->info_png.color);\n      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/\n      expected_size = 0;\n      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);\n      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);\n      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);\n      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);\n      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);\n      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);\n      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);\n    }\n\n    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);\n  }\n  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/\n  lodepng_free(idat);\n\n  if(!state->error) {\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);\n    *out = (unsigned char*)lodepng_malloc(outsize);\n    if(!*out) state->error = 83; /*alloc fail*/\n  }\n  if(!state->error) {\n    lodepng_memset(*out, 0, outsize);\n    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);\n  }\n  lodepng_free(scanlines);\n}\n\nunsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,\n                        LodePNGState* state,\n                        const unsigned char* in, size_t insize) {\n  *out = 0;\n  decodeGeneric(out, w, h, state, in, insize);\n  if(state->error) return state->error;\n  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {\n    /*same color type, no copying or converting of data needed*/\n    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype\n    the raw image has to the end user*/\n    if(!state->decoder.color_convert) {\n      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);\n      if(state->error) return state->error;\n    }\n  } else { /*color conversion needed*/\n    unsigned char* data = *out;\n    size_t outsize;\n\n    /*TODO: check if this works according to the statement in the documentation: \"The converter can convert\n    from grayscale input color type, to 8-bit grayscale or grayscale with alpha\"*/\n    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)\n       && !(state->info_raw.bitdepth == 8)) {\n      return 56; /*unsupported color mode conversion*/\n    }\n\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);\n    *out = (unsigned char*)lodepng_malloc(outsize);\n    if(!(*out)) {\n      state->error = 83; /*alloc fail*/\n    }\n    else state->error = lodepng_convert(*out, data, &state->info_raw,\n                                        &state->info_png.color, *w, *h);\n    lodepng_free(data);\n  }\n  return state->error;\n}\n\nunsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,\n                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned error;\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = colortype;\n  state.info_raw.bitdepth = bitdepth;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  /*disable reading things that this function doesn't output*/\n  state.decoder.read_text_chunks = 0;\n  state.decoder.remember_unknown_chunks = 0;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  error = lodepng_decode(out, w, h, &state, in, insize);\n  lodepng_state_cleanup(&state);\n  return error;\n}\n\nunsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}\n\nunsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,\n                             LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer = 0;\n  size_t buffersize;\n  unsigned error;\n  /* safe output values in case error happens */\n  *out = 0;\n  *w = *h = 0;\n  error = lodepng_load_file(&buffer, &buffersize, filename);\n  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {\n  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);\n}\n\nunsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {\n  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);\n}\n#endif /*LODEPNG_COMPILE_DISK*/\n\nvoid lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {\n  settings->color_convert = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->read_text_chunks = 1;\n  settings->remember_unknown_chunks = 0;\n  settings->max_text_size = 16777216;\n  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  settings->ignore_crc = 0;\n  settings->ignore_critical = 0;\n  settings->ignore_end = 0;\n  lodepng_decompress_settings_init(&settings->zlibsettings);\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)\n\nvoid lodepng_state_init(LodePNGState* state) {\n#ifdef LODEPNG_COMPILE_DECODER\n  lodepng_decoder_settings_init(&state->decoder);\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\n  lodepng_encoder_settings_init(&state->encoder);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n  lodepng_color_mode_init(&state->info_raw);\n  lodepng_info_init(&state->info_png);\n  state->error = 1;\n}\n\nvoid lodepng_state_cleanup(LodePNGState* state) {\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}\n\nvoid lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {\n  lodepng_state_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->info_raw);\n  lodepng_info_init(&dest->info_png);\n  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;\n  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;\n}\n\n#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG Encoder                                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n\nstatic unsigned writeSignature(ucvector* out) {\n  size_t pos = out->size;\n  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};\n  /*8 bytes PNG signature, aka the magic bytes*/\n  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/\n  lodepng_memcpy(out->data + pos, signature, 8);\n  return 0;\n}\n\nstatic unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,\n                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {\n  unsigned char *chunk, *data;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, \"IHDR\"));\n  data = chunk + 8;\n\n  lodepng_set32bitInt(data + 0, w); /*width*/\n  lodepng_set32bitInt(data + 4, h); /*height*/\n  data[8] = (unsigned char)bitdepth; /*bit depth*/\n  data[9] = (unsigned char)colortype; /*color type*/\n  data[10] = 0; /*compression method*/\n  data[11] = 0; /*filter method*/\n  data[12] = interlace_method; /*interlace method*/\n\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\n/* only adds the chunk if needed (there is a key or palette with alpha) */\nstatic unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {\n  unsigned char* chunk;\n  size_t i, j = 8;\n\n  if(info->palettesize == 0 || info->palettesize > 256) {\n    return 68; /*invalid palette size, it is only allowed to be 1-256*/\n  }\n\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, \"PLTE\"));\n\n  for(i = 0; i != info->palettesize; ++i) {\n    /*add all channels except alpha channel*/\n    chunk[j++] = info->palette[i * 4 + 0];\n    chunk[j++] = info->palette[i * 4 + 1];\n    chunk[j++] = info->palette[i * 4 + 2];\n  }\n\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {\n  unsigned char* chunk = 0;\n\n  if(info->colortype == LCT_PALETTE) {\n    size_t i, amount = info->palettesize;\n    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/\n    for(i = info->palettesize; i != 0; --i) {\n      if(info->palette[4 * (i - 1) + 3] != 255) break;\n      --amount;\n    }\n    if(amount) {\n      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, \"tRNS\"));\n      /*add the alpha channel values from the palette*/\n      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];\n    }\n  } else if(info->colortype == LCT_GREY) {\n    if(info->key_defined) {\n      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, \"tRNS\"));\n      chunk[8] = (unsigned char)(info->key_r >> 8);\n      chunk[9] = (unsigned char)(info->key_r & 255);\n    }\n  } else if(info->colortype == LCT_RGB) {\n    if(info->key_defined) {\n      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, \"tRNS\"));\n      chunk[8] = (unsigned char)(info->key_r >> 8);\n      chunk[9] = (unsigned char)(info->key_r & 255);\n      chunk[10] = (unsigned char)(info->key_g >> 8);\n      chunk[11] = (unsigned char)(info->key_g & 255);\n      chunk[12] = (unsigned char)(info->key_b >> 8);\n      chunk[13] = (unsigned char)(info->key_b & 255);\n    }\n  }\n\n  if(chunk) lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,\n                              LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* zlib = 0;\n  size_t zlibsize = 0;\n\n  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);\n  if(!error) {\n    error = lodepng_chunk_createv(out, zlibsize, \"IDAT\", zlib);\n  }\n  lodepng_free(zlib);\n  return error;\n}\n\nstatic unsigned addChunk_IEND(ucvector* out) {\n  return lodepng_chunk_createv(out, 0, \"IEND\", 0);\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\nstatic unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {\n  unsigned char* chunk = 0;\n  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);\n  size_t size = keysize + 1 + textsize;\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, \"tEXt\"));\n  lodepng_memcpy(chunk + 8, keyword, keysize);\n  chunk[8 + keysize] = 0; /*null termination char*/\n  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,\n                              LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* chunk = 0;\n  unsigned char* compressed = 0;\n  size_t compressedsize = 0;\n  size_t textsize = lodepng_strlen(textstring);\n  size_t keysize = lodepng_strlen(keyword);\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n\n  error = zlib_compress(&compressed, &compressedsize,\n                        (const unsigned char*)textstring, textsize, zlibsettings);\n  if(!error) {\n    size_t size = keysize + 2 + compressedsize;\n    error = lodepng_chunk_init(&chunk, out, size, \"zTXt\");\n  }\n  if(!error) {\n    lodepng_memcpy(chunk + 8, keyword, keysize);\n    chunk[8 + keysize] = 0; /*null termination char*/\n    chunk[9 + keysize] = 0; /*compression method: 0*/\n    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);\n    lodepng_chunk_generate_crc(chunk);\n  }\n\n  lodepng_free(compressed);\n  return error;\n}\n\nstatic unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* chunk = 0;\n  unsigned char* compressed = 0;\n  size_t compressedsize = 0;\n  size_t textsize = lodepng_strlen(textstring);\n  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);\n\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n\n  if(compress) {\n    error = zlib_compress(&compressed, &compressedsize,\n                          (const unsigned char*)textstring, textsize, zlibsettings);\n  }\n  if(!error) {\n    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);\n    error = lodepng_chunk_init(&chunk, out, size, \"iTXt\");\n  }\n  if(!error) {\n    size_t pos = 8;\n    lodepng_memcpy(chunk + pos, keyword, keysize);\n    pos += keysize;\n    chunk[pos++] = 0; /*null termination char*/\n    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/\n    chunk[pos++] = 0; /*compression method: 0*/\n    lodepng_memcpy(chunk + pos, langtag, langsize);\n    pos += langsize;\n    chunk[pos++] = 0; /*null termination char*/\n    lodepng_memcpy(chunk + pos, transkey, transsize);\n    pos += transsize;\n    chunk[pos++] = 0; /*null termination char*/\n    if(compress) {\n      lodepng_memcpy(chunk + pos, compressed, compressedsize);\n    } else {\n      lodepng_memcpy(chunk + pos, textstring, textsize);\n    }\n    lodepng_chunk_generate_crc(chunk);\n  }\n\n  lodepng_free(compressed);\n  return error;\n}\n\nstatic unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk = 0;\n  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, \"bKGD\"));\n    chunk[8] = (unsigned char)(info->background_r >> 8);\n    chunk[9] = (unsigned char)(info->background_r & 255);\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, \"bKGD\"));\n    chunk[8] = (unsigned char)(info->background_r >> 8);\n    chunk[9] = (unsigned char)(info->background_r & 255);\n    chunk[10] = (unsigned char)(info->background_g >> 8);\n    chunk[11] = (unsigned char)(info->background_g & 255);\n    chunk[12] = (unsigned char)(info->background_b >> 8);\n    chunk[13] = (unsigned char)(info->background_b & 255);\n  } else if(info->color.colortype == LCT_PALETTE) {\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, \"bKGD\"));\n    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/\n  }\n  if(chunk) lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, \"tIME\"));\n  chunk[8] = (unsigned char)(time->year >> 8);\n  chunk[9] = (unsigned char)(time->year & 255);\n  chunk[10] = (unsigned char)time->month;\n  chunk[11] = (unsigned char)time->day;\n  chunk[12] = (unsigned char)time->hour;\n  chunk[13] = (unsigned char)time->minute;\n  chunk[14] = (unsigned char)time->second;\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, \"pHYs\"));\n  lodepng_set32bitInt(chunk + 8, info->phys_x);\n  lodepng_set32bitInt(chunk + 12, info->phys_y);\n  chunk[16] = info->phys_unit;\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, \"gAMA\"));\n  lodepng_set32bitInt(chunk + 8, info->gama_gamma);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, \"cHRM\"));\n  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);\n  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);\n  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);\n  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);\n  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);\n  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);\n  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);\n  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {\n  unsigned char data = info->srgb_intent;\n  return lodepng_chunk_createv(out, 1, \"sRGB\", &data);\n}\n\nstatic unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* chunk = 0;\n  unsigned char* compressed = 0;\n  size_t compressedsize = 0;\n  size_t keysize = lodepng_strlen(info->iccp_name);\n\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n  error = zlib_compress(&compressed, &compressedsize,\n                        info->iccp_profile, info->iccp_profile_size, zlibsettings);\n  if(!error) {\n    size_t size = keysize + 2 + compressedsize;\n    error = lodepng_chunk_init(&chunk, out, size, \"iCCP\");\n  }\n  if(!error) {\n    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);\n    chunk[8 + keysize] = 0; /*null termination char*/\n    chunk[9 + keysize] = 0; /*compression method: 0*/\n    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);\n    lodepng_chunk_generate_crc(chunk);\n  }\n\n  lodepng_free(compressed);\n  return error;\n}\n\nstatic unsigned addChunk_sBIT(ucvector* out, const LodePNGInfo* info) {\n  unsigned bitdepth = (info->color.colortype == LCT_PALETTE) ? 8 : info->color.bitdepth;\n  unsigned char* chunk = 0;\n  if(info->color.colortype == LCT_GREY) {\n    if(info->sbit_r == 0 || info->sbit_r > bitdepth) return 115;\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_PALETTE) {\n    if(info->sbit_r == 0 || info->sbit_g == 0 || info->sbit_b == 0) return 115;\n    if(info->sbit_r > bitdepth || info->sbit_g > bitdepth || info->sbit_b > bitdepth) return 115;\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 3, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n    chunk[9] = info->sbit_g;\n    chunk[10] = info->sbit_b;\n  } else if(info->color.colortype == LCT_GREY_ALPHA) {\n    if(info->sbit_r == 0 || info->sbit_a == 0) return 115;\n    if(info->sbit_r > bitdepth || info->sbit_a > bitdepth) return 115;\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n    chunk[9] = info->sbit_a;\n  } else if(info->color.colortype == LCT_RGBA) {\n    if(info->sbit_r == 0 || info->sbit_g == 0 || info->sbit_b == 0 || info->sbit_a == 0 ||\n       info->sbit_r > bitdepth || info->sbit_g > bitdepth ||\n       info->sbit_b > bitdepth || info->sbit_a > bitdepth) {\n      return 115;\n    }\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n    chunk[9] = info->sbit_g;\n    chunk[10] = info->sbit_b;\n    chunk[11] = info->sbit_a;\n  }\n  if(chunk) lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nstatic void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,\n                           size_t length, size_t bytewidth, unsigned char filterType) {\n  size_t i;\n  switch(filterType) {\n    case 0: /*None*/\n      for(i = 0; i != length; ++i) out[i] = scanline[i];\n      break;\n    case 1: /*Sub*/\n      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\n      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];\n      break;\n    case 2: /*Up*/\n      if(prevline) {\n        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];\n      } else {\n        for(i = 0; i != length; ++i) out[i] = scanline[i];\n      }\n      break;\n    case 3: /*Average*/\n      if(prevline) {\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);\n        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);\n      } else {\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\n        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);\n      }\n      break;\n    case 4: /*Paeth*/\n      if(prevline) {\n        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/\n        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);\n        for(i = bytewidth; i < length; ++i) {\n          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));\n        }\n      } else {\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\n        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/\n        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);\n      }\n      break;\n    default: return; /*invalid filter type given*/\n  }\n}\n\n/* integer binary logarithm, max return value is 31 */\nstatic size_t ilog2(size_t i) {\n  size_t result = 0;\n  if(i >= 65536) { result += 16; i >>= 16; }\n  if(i >= 256) { result += 8; i >>= 8; }\n  if(i >= 16) { result += 4; i >>= 4; }\n  if(i >= 4) { result += 2; i >>= 2; }\n  if(i >= 2) { result += 1; /*i >>= 1;*/ }\n  return result;\n}\n\n/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */\nstatic size_t ilog2i(size_t i) {\n  size_t l;\n  if(i == 0) return 0;\n  l = ilog2(i);\n  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)\n  linearly approximates the missing fractional part multiplied by i */\n  return i * l + ((i - (1u << l)) << 1u);\n}\n\nstatic unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,\n                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {\n  /*\n  For PNG filter method 0\n  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are\n  the scanlines with 1 extra byte per scanline\n  */\n\n  unsigned bpp = lodepng_get_bpp(color);\n  /*the width of a scanline in bytes, not including the filter type*/\n  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;\n\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\n  size_t bytewidth = (bpp + 7u) / 8u;\n  const unsigned char* prevline = 0;\n  unsigned x, y;\n  unsigned error = 0;\n  LodePNGFilterStrategy strategy = settings->filter_strategy;\n\n  /*\n  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:\n   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.\n      use fixed filtering, with the filter None).\n   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is\n     not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply\n     all five filters and select the filter that produces the smallest sum of absolute values per row.\n  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.\n\n  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,\n  but for \"the other case\", whatever strategy filter_strategy is set to instead of the minimum sum\n  heuristic is used.\n  */\n  if(settings->filter_palette_zero &&\n     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;\n\n  if(bpp == 0) return 31; /*error: invalid color type*/\n\n  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {\n    unsigned char type = (unsigned char)strategy;\n    for(y = 0; y != h; ++y) {\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n      size_t inindex = linebytes * y;\n      out[outindex] = type; /*filter type byte*/\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);\n      prevline = &in[inindex];\n    }\n  } else if(strategy == LFS_MINSUM) {\n    /*adaptive filtering*/\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t smallest = 0;\n    unsigned char type, bestType = 0;\n\n    for(type = 0; type != 5; ++type) {\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\n      if(!attempt[type]) error = 83; /*alloc fail*/\n    }\n\n    if(!error) {\n      for(y = 0; y != h; ++y) {\n        /*try the 5 filter types*/\n        for(type = 0; type != 5; ++type) {\n          size_t sum = 0;\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\n\n          /*calculate the sum of the result*/\n          if(type == 0) {\n            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);\n          } else {\n            for(x = 0; x != linebytes; ++x) {\n              /*For differences, each byte should be treated as signed, values above 127 are negative\n              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.\n              This means filtertype 0 is almost never chosen, but that is justified.*/\n              unsigned char s = attempt[type][x];\n              sum += s < 128 ? s : (255U - s);\n            }\n          }\n\n          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || sum < smallest) {\n            bestType = type;\n            smallest = sum;\n          }\n        }\n\n        prevline = &in[y * linebytes];\n\n        /*now fill the out values*/\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\n      }\n    }\n\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\n  } else if(strategy == LFS_ENTROPY) {\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t bestSum = 0;\n    unsigned type, bestType = 0;\n    unsigned count[256];\n\n    for(type = 0; type != 5; ++type) {\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\n      if(!attempt[type]) error = 83; /*alloc fail*/\n    }\n\n    if(!error) {\n      for(y = 0; y != h; ++y) {\n        /*try the 5 filter types*/\n        for(type = 0; type != 5; ++type) {\n          size_t sum = 0;\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\n          lodepng_memset(count, 0, 256 * sizeof(*count));\n          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];\n          ++count[type]; /*the filter type itself is part of the scanline*/\n          for(x = 0; x != 256; ++x) {\n            sum += ilog2i(count[x]);\n          }\n          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || sum > bestSum) {\n            bestType = type;\n            bestSum = sum;\n          }\n        }\n\n        prevline = &in[y * linebytes];\n\n        /*now fill the out values*/\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\n      }\n    }\n\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\n  } else if(strategy == LFS_PREDEFINED) {\n    for(y = 0; y != h; ++y) {\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n      size_t inindex = linebytes * y;\n      unsigned char type = settings->predefined_filters[y];\n      out[outindex] = type; /*filter type byte*/\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);\n      prevline = &in[inindex];\n    }\n  } else if(strategy == LFS_BRUTE_FORCE) {\n    /*brute force filter chooser.\n    deflate the scanline after every filter attempt to see which one deflates best.\n    This is very slow and gives only slightly smaller, sometimes even larger, result*/\n    size_t size[5];\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t smallest = 0;\n    unsigned type = 0, bestType = 0;\n    unsigned char* dummy;\n    LodePNGCompressSettings zlibsettings;\n    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));\n    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,\n    to simulate the true case where the tree is the same for the whole image. Sometimes it gives\n    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare\n    cases better compression. It does make this a bit less slow, so it's worth doing this.*/\n    zlibsettings.btype = 1;\n    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG\n    images only, so disable it*/\n    zlibsettings.custom_zlib = 0;\n    zlibsettings.custom_deflate = 0;\n    for(type = 0; type != 5; ++type) {\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\n      if(!attempt[type]) error = 83; /*alloc fail*/\n    }\n    if(!error) {\n      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {\n        for(type = 0; type != 5; ++type) {\n          unsigned testsize = (unsigned)linebytes;\n          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/\n\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\n          size[type] = 0;\n          dummy = 0;\n          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);\n          lodepng_free(dummy);\n          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || size[type] < smallest) {\n            bestType = type;\n            smallest = size[type];\n          }\n        }\n        prevline = &in[y * linebytes];\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\n      }\n    }\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\n  }\n  else return 88; /* unknown filter strategy */\n\n  return error;\n}\n\nstatic void addPaddingBits(unsigned char* out, const unsigned char* in,\n                           size_t olinebits, size_t ilinebits, unsigned h) {\n  /*The opposite of the removePaddingBits function\n  olinebits must be >= ilinebits*/\n  unsigned y;\n  size_t diff = olinebits - ilinebits;\n  size_t obp = 0, ibp = 0; /*bit pointers*/\n  for(y = 0; y != h; ++y) {\n    size_t x;\n    for(x = 0; x < ilinebits; ++x) {\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\n      setBitOfReversedStream(&obp, out, bit);\n    }\n    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid\n    \"Use of uninitialised value of size ###\" warning from valgrind*/\n    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);\n  }\n}\n\n/*\nin: non-interlaced image with size w*h\nout: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with\n no padding bits between scanlines, but between reduced images so that each\n reduced image starts at a byte.\nbpp: bits per pixel\nthere are no padding bits, not between scanlines, not between reduced images\nin has the following size in bits: w * h * bpp.\nout is possibly bigger due to padding bits between reduced images\nNOTE: comments about padding bits are only relevant if bpp < 8\n*/\nstatic void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {\n  unsigned passw[7], passh[7];\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\n  unsigned i;\n\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n  if(bpp >= 8) {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      size_t bytewidth = bpp / 8u;\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;\n        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;\n        for(b = 0; b < bytewidth; ++b) {\n          out[pixeloutstart + b] = in[pixelinstart + b];\n        }\n      }\n    }\n  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      unsigned ilinebits = bpp * passw[i];\n      unsigned olinebits = bpp * w;\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;\n        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\n        for(b = 0; b < bpp; ++b) {\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\n          setBitOfReversedStream(&obp, out, bit);\n        }\n      }\n    }\n  }\n}\n\n/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.\nreturn value is error**/\nstatic unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                    unsigned w, unsigned h,\n                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {\n  /*\n  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:\n  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter\n  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter\n  */\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  unsigned error = 0;\n\n  if(info_png->interlace_method == 0) {\n    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/\n\n    if(!error) {\n      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/\n      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {\n        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));\n        if(!padded) error = 83; /*alloc fail*/\n        if(!error) {\n          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);\n          error = filter(*out, padded, w, h, &info_png->color, settings);\n        }\n        lodepng_free(padded);\n      } else {\n        /*we can immediately filter into the out buffer, no other steps needed*/\n        error = filter(*out, in, w, h, &info_png->color, settings);\n      }\n    }\n  } else /*interlace_method is 1 (Adam7)*/ {\n    unsigned passw[7], passh[7];\n    size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned char* adam7;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out)) error = 83; /*alloc fail*/\n\n    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);\n    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/\n\n    if(!error) {\n      unsigned i;\n\n      Adam7_interlace(adam7, in, w, h, bpp);\n      for(i = 0; i != 7; ++i) {\n        if(bpp < 8) {\n          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);\n          if(!padded) ERROR_BREAK(83); /*alloc fail*/\n          addPaddingBits(padded, &adam7[passstart[i]],\n                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);\n          error = filter(&(*out)[filter_passstart[i]], padded,\n                         passw[i], passh[i], &info_png->color, settings);\n          lodepng_free(padded);\n        } else {\n          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],\n                         passw[i], passh[i], &info_png->color, settings);\n        }\n\n        if(error) break;\n      }\n    }\n\n    lodepng_free(adam7);\n  }\n\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\nstatic unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {\n  unsigned char* inchunk = data;\n  while((size_t)(inchunk - data) < datasize) {\n    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));\n    out->allocsize = out->size; /*fix the allocsize again*/\n    inchunk = lodepng_chunk_next(inchunk, data + datasize);\n  }\n  return 0;\n}\n\nstatic unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {\n  /*\n  It is a gray profile if bytes 16-19 are \"GRAY\", rgb profile if bytes 16-19\n  are \"RGB \". We do not perform any full parsing of the ICC profile here, other\n  than check those 4 bytes to grayscale profile. Other than that, validity of\n  the profile is not checked. This is needed only because the PNG specification\n  requires using a non-gray color model if there is an ICC profile with \"RGB \"\n  (sadly limiting compression opportunities if the input data is grayscale RGB\n  data), and requires using a gray color model if it is \"GRAY\".\n  */\n  if(size < 20) return 0;\n  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';\n}\n\nstatic unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {\n  /* See comment in isGrayICCProfile*/\n  if(size < 20) return 0;\n  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nunsigned lodepng_encode(unsigned char** out, size_t* outsize,\n                        const unsigned char* image, unsigned w, unsigned h,\n                        LodePNGState* state) {\n  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/\n  size_t datasize = 0;\n  ucvector outv = ucvector_init(NULL, 0);\n  LodePNGInfo info;\n  const LodePNGInfo* info_png = &state->info_png;\n  LodePNGColorMode auto_color;\n\n  lodepng_info_init(&info);\n  lodepng_color_mode_init(&auto_color);\n\n  /*provide some proper output values if error will happen*/\n  *out = 0;\n  *outsize = 0;\n  state->error = 0;\n\n  /*check input values validity*/\n  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)\n      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {\n    /*this error is returned even if auto_convert is enabled and thus encoder could\n    generate the palette by itself: while allowing this could be possible in theory,\n    it may complicate the code or edge cases, and always requiring to give a palette\n    when setting this color type is a simpler contract*/\n    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/\n    goto cleanup;\n  }\n  if(state->encoder.zlibsettings.btype > 2) {\n    state->error = 61; /*error: invalid btype*/\n    goto cleanup;\n  }\n  if(info_png->interlace_method > 1) {\n    state->error = 71; /*error: invalid interlace mode*/\n    goto cleanup;\n  }\n  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);\n  if(state->error) goto cleanup; /*error: invalid color type given*/\n  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);\n  if(state->error) goto cleanup; /*error: invalid color type given*/\n\n  /* color convert and compute scanline filter types */\n  lodepng_info_copy(&info, &state->info_png);\n  if(state->encoder.auto_convert) {\n    LodePNGColorStats stats;\n    unsigned allow_convert = 1;\n    lodepng_color_stats_init(&stats);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    if(info_png->iccp_defined &&\n        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {\n      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even\n      if the palette has only gray colors, so disallow it.*/\n      stats.allow_palette = 0;\n    }\n    if(info_png->iccp_defined &&\n        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {\n      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/\n      stats.allow_greyscale = 0;\n    }\n#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */\n    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    if(info_png->background_defined) {\n      /*the background chunk's color must be taken into account as well*/\n      unsigned r = 0, g = 0, b = 0;\n      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);\n      lodepng_convert_rgb(&r, &g, &b,\n          info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);\n      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);\n      if(state->error) goto cleanup;\n    }\n#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */\n    state->error = auto_choose_color(&auto_color, &state->info_raw, &stats);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    if(info_png->sbit_defined) {\n      /*if sbit is defined, due to strict requirements of which sbit values can be present for which color modes,\n      auto_convert can't be done in many cases. However, do support a few cases here.\n      TODO: more conversions may be possible, and it may also be possible to get a more appropriate color type out of\n            auto_choose_color if knowledge about sbit is used beforehand\n      */\n      unsigned sbit_max = LODEPNG_MAX(LODEPNG_MAX(LODEPNG_MAX(info_png->sbit_r, info_png->sbit_g),\n                           info_png->sbit_b), info_png->sbit_a);\n      unsigned equal = (!info_png->sbit_g || info_png->sbit_g == info_png->sbit_r)\n                    && (!info_png->sbit_b || info_png->sbit_b == info_png->sbit_r)\n                    && (!info_png->sbit_a || info_png->sbit_a == info_png->sbit_r);\n      allow_convert = 0;\n      if(info.color.colortype == LCT_PALETTE &&\n         auto_color.colortype == LCT_PALETTE) {\n        /* input and output are palette, and in this case it may happen that palette data is\n        expected to be copied from info_raw into the info_png */\n        allow_convert = 1;\n      }\n      /*going from 8-bit RGB to palette (or 16-bit as long as sbit_max <= 8) is possible\n      since both are 8-bit RGB for sBIT's purposes*/\n      if(info.color.colortype == LCT_RGB &&\n         auto_color.colortype == LCT_PALETTE && sbit_max <= 8) {\n        allow_convert = 1;\n      }\n      /*going from 8-bit RGBA to palette is also ok but only if sbit_a is exactly 8*/\n      if(info.color.colortype == LCT_RGBA && auto_color.colortype == LCT_PALETTE &&\n         info_png->sbit_a == 8 && sbit_max <= 8) {\n        allow_convert = 1;\n      }\n      /*going from 16-bit RGB(A) to 8-bit RGB(A) is ok if all sbit values are <= 8*/\n      if((info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA) && info.color.bitdepth == 16 &&\n         auto_color.colortype == info.color.colortype && auto_color.bitdepth == 8 &&\n         sbit_max <= 8) {\n        allow_convert = 1;\n      }\n      /*going to less channels is ok if all bit values are equal (all possible values in sbit,\n        as well as the chosen bitdepth of the result). Due to how auto_convert works,\n        we already know that auto_color.colortype has less than or equal amount of channels than\n        info.colortype. Palette is not used here. This conversion is not allowed if\n        info_png->sbit_r < auto_color.bitdepth, because specifically for alpha, non-presence of\n        an sbit value heavily implies that alpha's bit depth is equal to the PNG bit depth (rather\n        than the bit depths set in the r, g and b sbit values, by how the PNG specification describes\n        handling tRNS chunk case with sBIT), so be conservative here about ignoring user input.*/\n      if(info.color.colortype != LCT_PALETTE && auto_color.colortype != LCT_PALETTE &&\n         equal && info_png->sbit_r == auto_color.bitdepth) {\n        allow_convert = 1;\n      }\n    }\n#endif\n    if(state->encoder.force_palette) {\n      if(info.color.colortype != LCT_GREY && info.color.colortype != LCT_GREY_ALPHA &&\n         (auto_color.colortype == LCT_GREY || auto_color.colortype == LCT_GREY_ALPHA)) {\n        /*user speficially forced a PLTE palette, so cannot convert to grayscale types because\n        the PNG specification only allows writing a suggested palette in PLTE for truecolor types*/\n        allow_convert = 0;\n      }\n    }\n    if(allow_convert) {\n      lodepng_color_mode_copy(&info.color, &auto_color);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      /*also convert the background chunk*/\n      if(info_png->background_defined) {\n        if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,\n            info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {\n          state->error = 104;\n          goto cleanup;\n        }\n      }\n#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */\n    }\n  }\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  if(info_png->iccp_defined) {\n    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);\n    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);\n    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;\n    if(!gray_icc && !rgb_icc) {\n      state->error = 100; /* Disallowed profile color type for PNG */\n      goto cleanup;\n    }\n    if(gray_icc != gray_png) {\n      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,\n      or in case of auto_convert, it wasn't possible to find appropriate model*/\n      state->error = state->encoder.auto_convert ? 102 : 101;\n      goto cleanup;\n    }\n  }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {\n    unsigned char* converted;\n    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;\n\n    converted = (unsigned char*)lodepng_malloc(size);\n    if(!converted && size) state->error = 83; /*alloc fail*/\n    if(!state->error) {\n      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);\n    }\n    if(!state->error) {\n      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);\n    }\n    lodepng_free(converted);\n    if(state->error) goto cleanup;\n  } else {\n    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);\n    if(state->error) goto cleanup;\n  }\n\n  /* output all PNG chunks */ {\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    size_t i;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*write signature and chunks*/\n    state->error = writeSignature(&outv);\n    if(state->error) goto cleanup;\n    /*IHDR*/\n    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*unknown chunks between IHDR and PLTE*/\n    if(info.unknown_chunks_data[0]) {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);\n      if(state->error) goto cleanup;\n    }\n    /*color profile chunks must come before PLTE */\n    if(info.iccp_defined) {\n      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);\n      if(state->error) goto cleanup;\n    }\n    if(info.srgb_defined) {\n      state->error = addChunk_sRGB(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.gama_defined) {\n      state->error = addChunk_gAMA(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.chrm_defined) {\n      state->error = addChunk_cHRM(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info_png->sbit_defined) {\n      state->error = addChunk_sBIT(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*PLTE*/\n    if(info.color.colortype == LCT_PALETTE) {\n      state->error = addChunk_PLTE(&outv, &info.color);\n      if(state->error) goto cleanup;\n    }\n    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {\n      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/\n      state->error = addChunk_PLTE(&outv, &info.color);\n      if(state->error) goto cleanup;\n    }\n    /*tRNS (this will only add if when necessary) */\n    state->error = addChunk_tRNS(&outv, &info.color);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*bKGD (must come between PLTE and the IDAt chunks*/\n    if(info.background_defined) {\n      state->error = addChunk_bKGD(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    /*pHYs (must come before the IDAT chunks)*/\n    if(info.phys_defined) {\n      state->error = addChunk_pHYs(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n\n    /*unknown chunks between PLTE and IDAT*/\n    if(info.unknown_chunks_data[1]) {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);\n      if(state->error) goto cleanup;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*IDAT (multiple IDAT chunks must be consecutive)*/\n    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*tIME*/\n    if(info.time_defined) {\n      state->error = addChunk_tIME(&outv, &info.time);\n      if(state->error) goto cleanup;\n    }\n    /*tEXt and/or zTXt*/\n    for(i = 0; i != info.text_num; ++i) {\n      if(lodepng_strlen(info.text_keys[i]) > 79) {\n        state->error = 66; /*text chunk too large*/\n        goto cleanup;\n      }\n      if(lodepng_strlen(info.text_keys[i]) < 1) {\n        state->error = 67; /*text chunk too small*/\n        goto cleanup;\n      }\n      if(state->encoder.text_compression) {\n        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);\n        if(state->error) goto cleanup;\n      } else {\n        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);\n        if(state->error) goto cleanup;\n      }\n    }\n    /*LodePNG version id in text chunk*/\n    if(state->encoder.add_id) {\n      unsigned already_added_id_text = 0;\n      for(i = 0; i != info.text_num; ++i) {\n        const char* k = info.text_keys[i];\n        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */\n        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&\n           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\\0') {\n          already_added_id_text = 1;\n          break;\n        }\n      }\n      if(already_added_id_text == 0) {\n        state->error = addChunk_tEXt(&outv, \"LodePNG\", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/\n        if(state->error) goto cleanup;\n      }\n    }\n    /*iTXt*/\n    for(i = 0; i != info.itext_num; ++i) {\n      if(lodepng_strlen(info.itext_keys[i]) > 79) {\n        state->error = 66; /*text chunk too large*/\n        goto cleanup;\n      }\n      if(lodepng_strlen(info.itext_keys[i]) < 1) {\n        state->error = 67; /*text chunk too small*/\n        goto cleanup;\n      }\n      state->error = addChunk_iTXt(\n          &outv, state->encoder.text_compression,\n          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],\n          &state->encoder.zlibsettings);\n      if(state->error) goto cleanup;\n    }\n\n    /*unknown chunks between IDAT and IEND*/\n    if(info.unknown_chunks_data[2]) {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);\n      if(state->error) goto cleanup;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    state->error = addChunk_IEND(&outv);\n    if(state->error) goto cleanup;\n  }\n\ncleanup:\n  lodepng_info_cleanup(&info);\n  lodepng_free(data);\n  lodepng_color_mode_cleanup(&auto_color);\n\n  /*instead of cleaning the vector up, give it to the output*/\n  *out = outv.data;\n  *outsize = outv.size;\n\n  return state->error;\n}\n\nunsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,\n                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned error;\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = colortype;\n  state.info_raw.bitdepth = bitdepth;\n  state.info_png.color.colortype = colortype;\n  state.info_png.color.bitdepth = bitdepth;\n  lodepng_encode(out, outsize, image, w, h, &state);\n  error = state.error;\n  lodepng_state_cleanup(&state);\n  return error;\n}\n\nunsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);\n}\n\nunsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,\n                             LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);\n  if(!error) error = lodepng_save_file(buffer, buffersize, filename);\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);\n}\n\nunsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);\n}\n#endif /*LODEPNG_COMPILE_DISK*/\n\nvoid lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {\n  lodepng_compress_settings_init(&settings->zlibsettings);\n  settings->filter_palette_zero = 1;\n  settings->filter_strategy = LFS_MINSUM;\n  settings->auto_convert = 1;\n  settings->force_palette = 0;\n  settings->predefined_filters = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->add_id = 0;\n  settings->text_compression = 1;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ERROR_TEXT\n/*\nThis returns the description of a numerical error code in English. This is also\nthe documentation of all the error codes.\n*/\nconst char* lodepng_error_text(unsigned code) {\n  switch(code) {\n    case 0: return \"no error, everything went ok\";\n    case 1: return \"nothing done yet\"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/\n    case 10: return \"end of input memory reached without huffman end code\"; /*while huffman decoding*/\n    case 11: return \"error in code tree made it jump outside of huffman tree\"; /*while huffman decoding*/\n    case 13: return \"problem while processing dynamic deflate block\";\n    case 14: return \"problem while processing dynamic deflate block\";\n    case 15: return \"problem while processing dynamic deflate block\";\n    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/\n    case 16: return \"invalid code while processing dynamic deflate block\";\n    case 17: return \"end of out buffer memory reached while inflating\";\n    case 18: return \"invalid distance code while inflating\";\n    case 19: return \"end of out buffer memory reached while inflating\";\n    case 20: return \"invalid deflate block BTYPE encountered while decoding\";\n    case 21: return \"NLEN is not ones complement of LEN in a deflate block\";\n\n    /*end of out buffer memory reached while inflating:\n    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up\n    all the pixels of the image, given the color depth and image dimensions. Something that doesn't\n    happen in a normal, well encoded, PNG image.*/\n    case 22: return \"end of out buffer memory reached while inflating\";\n    case 23: return \"end of in buffer memory reached while inflating\";\n    case 24: return \"invalid FCHECK in zlib header\";\n    case 25: return \"invalid compression method in zlib header\";\n    case 26: return \"FDICT encountered in zlib header while it's not used for PNG\";\n    case 27: return \"PNG file is smaller than a PNG header\";\n    /*Checks the magic file header, the first 8 bytes of the PNG file*/\n    case 28: return \"incorrect PNG signature, it's no PNG or corrupted\";\n    case 29: return \"first chunk is not the header chunk\";\n    case 30: return \"chunk length too large, chunk broken off at end of file\";\n    case 31: return \"illegal PNG color type or bpp\";\n    case 32: return \"illegal PNG compression method\";\n    case 33: return \"illegal PNG filter method\";\n    case 34: return \"illegal PNG interlace method\";\n    case 35: return \"chunk length of a chunk is too large or the chunk too small\";\n    case 36: return \"illegal PNG filter type encountered\";\n    case 37: return \"illegal bit depth for this color type given\";\n    case 38: return \"the palette is too small or too big\"; /*0, or more than 256 colors*/\n    case 39: return \"tRNS chunk before PLTE or has more entries than palette size\";\n    case 40: return \"tRNS chunk has wrong size for grayscale image\";\n    case 41: return \"tRNS chunk has wrong size for RGB image\";\n    case 42: return \"tRNS chunk appeared while it was not allowed for this color type\";\n    case 43: return \"bKGD chunk has wrong size for palette image\";\n    case 44: return \"bKGD chunk has wrong size for grayscale image\";\n    case 45: return \"bKGD chunk has wrong size for RGB image\";\n    case 48: return \"empty input buffer given to decoder. Maybe caused by non-existing file?\";\n    case 49: return \"jumped past memory while generating dynamic huffman tree\";\n    case 50: return \"jumped past memory while generating dynamic huffman tree\";\n    case 51: return \"jumped past memory while inflating huffman block\";\n    case 52: return \"jumped past memory while inflating\";\n    case 53: return \"size of zlib data too small\";\n    case 54: return \"repeat symbol in tree while there was no value symbol yet\";\n    /*jumped past tree while generating huffman tree, this could be when the\n    tree will have more leaves than symbols after generating it out of the\n    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/\n    case 55: return \"jumped past tree while generating huffman tree\";\n    case 56: return \"given output image colortype or bitdepth not supported for color conversion\";\n    case 57: return \"invalid CRC encountered (checking CRC can be disabled)\";\n    case 58: return \"invalid ADLER32 encountered (checking ADLER32 can be disabled)\";\n    case 59: return \"requested color conversion not supported\";\n    case 60: return \"invalid window size given in the settings of the encoder (must be 0-32768)\";\n    case 61: return \"invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)\";\n    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/\n    case 62: return \"conversion from color to grayscale not supported\";\n    /*(2^31-1)*/\n    case 63: return \"length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk\";\n    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/\n    case 64: return \"the length of the END symbol 256 in the Huffman tree is 0\";\n    case 66: return \"the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes\";\n    case 67: return \"the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte\";\n    case 68: return \"tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors\";\n    case 69: return \"unknown chunk type with 'critical' flag encountered by the decoder\";\n    case 71: return \"invalid interlace mode given to encoder (must be 0 or 1)\";\n    case 72: return \"while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)\";\n    case 73: return \"invalid tIME chunk size\";\n    case 74: return \"invalid pHYs chunk size\";\n    /*length could be wrong, or data chopped off*/\n    case 75: return \"no null termination char found while decoding text chunk\";\n    case 76: return \"iTXt chunk too short to contain required bytes\";\n    case 77: return \"integer overflow in buffer size\";\n    case 78: return \"failed to open file for reading\"; /*file doesn't exist or couldn't be opened for reading*/\n    case 79: return \"failed to open file for writing\";\n    case 80: return \"tried creating a tree of 0 symbols\";\n    case 81: return \"lazy matching at pos 0 is impossible\";\n    case 82: return \"color conversion to palette requested while a color isn't in palette, or index out of bounds\";\n    case 83: return \"memory allocation failed\";\n    case 84: return \"given image too small to contain all pixels to be encoded\";\n    case 86: return \"impossible offset in lz77 encoding (internal bug)\";\n    case 87: return \"must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined\";\n    case 88: return \"invalid filter strategy given for LodePNGEncoderSettings.filter_strategy\";\n    case 89: return \"text chunk keyword too short or long: must have size 1-79\";\n    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/\n    case 90: return \"windowsize must be a power of two\";\n    case 91: return \"invalid decompressed idat size\";\n    case 92: return \"integer overflow due to too many pixels\";\n    case 93: return \"zero width or height is invalid\";\n    case 94: return \"header chunk must have a size of 13 bytes\";\n    case 95: return \"integer overflow with combined idat chunk size\";\n    case 96: return \"invalid gAMA chunk size\";\n    case 97: return \"invalid cHRM chunk size\";\n    case 98: return \"invalid sRGB chunk size\";\n    case 99: return \"invalid sRGB rendering intent\";\n    case 100: return \"invalid ICC profile color type, the PNG specification only allows RGB or GRAY\";\n    case 101: return \"PNG specification does not allow RGB ICC profile on gray color types and vice versa\";\n    case 102: return \"not allowed to set grayscale ICC profile with colored pixels by PNG specification\";\n    case 103: return \"invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?\";\n    case 104: return \"invalid bKGD color while encoding (e.g. palette index out of range)\";\n    case 105: return \"integer overflow of bitsize\";\n    case 106: return \"PNG file must have PLTE chunk if color type is palette\";\n    case 107: return \"color convert from palette mode requested without setting the palette data in it\";\n    case 108: return \"tried to add more than 256 values to a palette\";\n    /*this limit can be configured in LodePNGDecompressSettings*/\n    case 109: return \"tried to decompress zlib or deflate data larger than desired max_output_size\";\n    case 110: return \"custom zlib or inflate decompression failed\";\n    case 111: return \"custom zlib or deflate compression failed\";\n    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents\n    unreasonable memory consumption when decoding due to impossibly large text sizes.*/\n    case 112: return \"compressed text unreasonably large\";\n    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents\n    unreasonable memory consumption when decoding due to impossibly large ICC profile*/\n    case 113: return \"ICC profile unreasonably large\";\n    case 114: return \"sBIT chunk has wrong size for the color type of the image\";\n    case 115: return \"sBIT value out of range\";\n  }\n  return \"unknown error code\";\n}\n#endif /*LODEPNG_COMPILE_ERROR_TEXT*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // C++ Wrapper                                                          // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_CPP\nnamespace lodepng {\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename) {\n  long size = lodepng_filesize(filename.c_str());\n  if(size < 0) return 78;\n  buffer.resize((size_t)size);\n  return size == 0 ? 0 : lodepng_buffer_file(&buffer[0], (size_t)size, filename.c_str());\n}\n\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\nunsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename) {\n  return lodepng_save_file(buffer.empty() ? 0 : &buffer[0], buffer.size(), filename.c_str());\n}\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_DECODER\nunsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                    const LodePNGDecompressSettings& settings) {\n  unsigned char* buffer = 0;\n  size_t buffersize = 0;\n  unsigned error = zlib_decompress(&buffer, &buffersize, 0, in, insize, &settings);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                    const LodePNGDecompressSettings& settings) {\n  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);\n}\n#endif /* LODEPNG_COMPILE_DECODER */\n\n#ifdef LODEPNG_COMPILE_ENCODER\nunsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                  const LodePNGCompressSettings& settings) {\n  unsigned char* buffer = 0;\n  size_t buffersize = 0;\n  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                  const LodePNGCompressSettings& settings) {\n  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);\n}\n#endif /* LODEPNG_COMPILE_ENCODER */\n#endif /* LODEPNG_COMPILE_ZLIB */\n\n\n#ifdef LODEPNG_COMPILE_PNG\n\nState::State() {\n  lodepng_state_init(this);\n}\n\nState::State(const State& other) {\n  lodepng_state_init(this);\n  lodepng_state_copy(this, &other);\n}\n\nState::~State() {\n  lodepng_state_cleanup(this);\n}\n\nState& State::operator=(const State& other) {\n  lodepng_state_copy(this, &other);\n  return *this;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,\n                size_t insize, LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer = 0;\n  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);\n  if(buffer && !error) {\n    State state;\n    state.info_raw.colortype = colortype;\n    state.info_raw.bitdepth = bitdepth;\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n  }\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth) {\n  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const unsigned char* in, size_t insize) {\n  unsigned char* buffer = NULL;\n  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);\n  if(buffer && !error) {\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n  }\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const std::vector<unsigned char>& in) {\n  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  std::vector<unsigned char> buffer;\n  /* safe output values in case error happens */\n  w = h = 0;\n  unsigned error = load_file(buffer, filename);\n  if(error) return error;\n  return decode(out, w, h, buffer, colortype, bitdepth);\n}\n#endif /* LODEPNG_COMPILE_DECODER */\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ENCODER\nunsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\n  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const unsigned char* in, unsigned w, unsigned h,\n                State& state) {\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                State& state) {\n  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;\n  return encode(out, in.empty() ? 0 : &in[0], w, h, state);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned encode(const std::string& filename,\n                const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  std::vector<unsigned char> buffer;\n  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);\n  if(!error) error = save_file(buffer, filename);\n  return error;\n}\n\nunsigned encode(const std::string& filename,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\n  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\n}\n#endif /* LODEPNG_COMPILE_DISK */\n#endif /* LODEPNG_COMPILE_ENCODER */\n#endif /* LODEPNG_COMPILE_PNG */\n} /* namespace lodepng */\n#endif /*LODEPNG_COMPILE_CPP*/\n","// Ogg Vorbis audio decoder - v1.22 - public domain\n// http://nothings.org/stb_vorbis/\n//\n// Original version written by Sean Barrett in 2007.\n//\n// Originally sponsored by RAD Game Tools. Seeking implementation\n// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,\n// Elias Software, Aras Pranckevicius, and Sean Barrett.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// Limitations:\n//\n//   - floor 0 not supported (used in old ogg vorbis files pre-2004)\n//   - lossless sample-truncation at beginning ignored\n//   - cannot concatenate multiple vorbis streams\n//   - sample positions are 32-bit, limiting seekable 192Khz\n//       files to around 6 hours (Ogg supports 64-bit)\n//\n// Feature contributors:\n//    Dougall Johnson (sample-exact seeking)\n//\n// Bugfix/warning contributors:\n//    Terje Mathisen     Niklas Frykholm     Andy Hill\n//    Casey Muratori     John Bolton         Gargaj\n//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier\n//    Bernhard Wodo      Evan Balster        github:alxprd\n//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot\n//    Phillip Bennefall  Rohit               Thiago Goulart\n//    github:manxorist   Saga Musix          github:infatum\n//    Timur Gagiev       Maxwell Koo         Peter Waller\n//    github:audinowho   Dougall Johnson     David Reid\n//    github:Clownacy    Pedro J. Estebanez  Remi Verschelde\n//    AnthoFoxo          github:morlat       Gabriel Ravier\n//\n// Partial history:\n//    1.22    - 2021-07-11 - various small fixes\n//    1.21    - 2021-07-02 - fix bug for files with no comments\n//    1.20    - 2020-07-11 - several small fixes\n//    1.19    - 2020-02-05 - warnings\n//    1.18    - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.\n//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)\n//    1.16    - 2019-03-04 - fix warnings\n//    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n//    1.14    - 2018-02-11 - delete bogus dealloca usage\n//    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n//    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n//    1.11    - 2017-07-23 - fix MinGW compilation\n//    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n//    1.09    - 2016-04-04 - back out 'truncation of last frame' fix from previous version\n//    1.08    - 2016-04-02 - warnings; setup memory leaks; truncation of last frame\n//    1.07    - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const\n//    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n//                           some crash fixes when out of memory or with corrupt files\n//                           fix some inappropriately signed shifts\n//    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n//    1.04    - 2014-08-27 - fix missing const-correct case in API\n//    1.03    - 2014-08-07 - warning fixes\n//    1.02    - 2014-07-09 - declare qsort comparison as explicitly _cdecl in Windows\n//    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float (interleaved was correct)\n//    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;\n//                           (API change) report sample rate for decode-full-file funcs\n//\n// See end of file for full version history.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  HEADER BEGINS HERE\n//\n\n#define STB_VORBIS_NO_CRT\n#define STB_VORBIS_NO_STDIO\n\n#ifndef STB_VORBIS_INCLUDE_STB_VORBIS_H\n#define STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n#define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n///////////   THREAD SAFETY\n\n// Individual stb_vorbis* handles are not thread-safe; you cannot decode from\n// them from multiple threads at the same time. However, you can have multiple\n// stb_vorbis* handles and decode from them independently in multiple thrads.\n\n\n///////////   MEMORY ALLOCATION\n\n// normally stb_vorbis uses malloc() to allocate memory at startup,\n// and alloca() to allocate temporary memory during a frame on the\n// stack. (Memory consumption will depend on the amount of setup\n// data in the file and how you set the compile flags for speed\n// vs. size. In my test files the maximal-size usage is ~150KB.)\n//\n// You can modify the wrapper functions in the source (setup_malloc,\n// setup_temp_malloc, temp_malloc) to change this behavior, or you\n// can use a simpler allocation model: you pass in a buffer from\n// which stb_vorbis will allocate _all_ its memory (including the\n// temp memory). \"open\" may fail with a VORBIS_outofmem if you\n// do not pass in enough data; there is no way to determine how\n// much you do need except to succeed (at which point you can\n// query get_info to find the exact amount required. yes I know\n// this is lame).\n//\n// If you pass in a non-NULL buffer of the type below, allocation\n// will occur from it as described above. Otherwise just pass NULL\n// to use malloc()/alloca()\n\ntypedef struct\n{\n   char *alloc_buffer;\n   int   alloc_buffer_length_in_bytes;\n} stb_vorbis_alloc;\n\n\n///////////   FUNCTIONS USEABLE WITH ALL INPUT MODES\n\ntypedef struct stb_vorbis stb_vorbis;\n\ntypedef struct\n{\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int setup_temp_memory_required;\n   unsigned int temp_memory_required;\n\n   int max_frame_size;\n} stb_vorbis_info;\n\ntypedef struct\n{\n   char *vendor;\n\n   int comment_list_length;\n   char **comment_list;\n} stb_vorbis_comment;\n\n// get general information about the file\nextern stb_vorbis_info stb_vorbis_get_info(stb_vorbis *f);\n\n// get ogg comments\nextern stb_vorbis_comment stb_vorbis_get_comment(stb_vorbis *f);\n\n// get the last error detected (clears it, too)\nextern int stb_vorbis_get_error(stb_vorbis *f);\n\n// close an ogg vorbis file and free all memory in use\nextern void stb_vorbis_close(stb_vorbis *f);\n\n// this function returns the offset (in samples) from the beginning of the\n// file that will be returned by the next decode, if it is known, or -1\n// otherwise. after a flush_pushdata() call, this may take a while before\n// it becomes valid again.\n// NOT WORKING YET after a seek with PULLDATA API\nextern int stb_vorbis_get_sample_offset(stb_vorbis *f);\n\n// returns the current seek point within the file, or offset from the beginning\n// of the memory buffer. In pushdata mode it returns 0.\nextern unsigned int stb_vorbis_get_file_offset(stb_vorbis *f);\n\n///////////   PUSHDATA API\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\n// this API allows you to get blocks of data from any source and hand\n// them to stb_vorbis. you have to buffer them; stb_vorbis will tell\n// you how much it used, and you have to give it the rest next time;\n// and stb_vorbis may not have enough data to work with and you will\n// need to give it the same data again PLUS more. Note that the Vorbis\n// specification does not bound the size of an individual frame.\n\nextern stb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char * datablock, int datablock_length_in_bytes,\n         int *datablock_memory_consumed_in_bytes,\n         int *error,\n         const stb_vorbis_alloc *alloc_buffer);\n// create a vorbis decoder by passing in the initial data block containing\n//    the ogg&vorbis headers (you don't need to do parse them, just provide\n//    the first N bytes of the file--you're told if it's not enough, see below)\n// on success, returns an stb_vorbis *, does not set error, returns the amount of\n//    data parsed/consumed on this call in *datablock_memory_consumed_in_bytes;\n// on failure, returns NULL on error and sets *error, does not change *datablock_memory_consumed\n// if returns NULL and *error is VORBIS_need_more_data, then the input block was\n//       incomplete and you need to pass in a larger block from the start of the file\n\nextern int stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,\n         const unsigned char *datablock, int datablock_length_in_bytes,\n         int *channels,             // place to write number of float * buffers\n         float ***output,           // place to write float ** array of float * buffers\n         int *samples               // place to write number of output samples\n     );\n// decode a frame of audio sample data if possible from the passed-in data block\n//\n// return value: number of bytes we used from datablock\n//\n// possible cases:\n//     0 bytes used, 0 samples output (need more data)\n//     N bytes used, 0 samples output (resynching the stream, keep going)\n//     N bytes used, M samples output (one frame of data)\n// note that after opening a file, you will ALWAYS get one N-bytes,0-sample\n// frame, because Vorbis always \"discards\" the first frame.\n//\n// Note that on resynch, stb_vorbis will rarely consume all of the buffer,\n// instead only datablock_length_in_bytes-3 or less. This is because it wants\n// to avoid missing parts of a page header if they cross a datablock boundary,\n// without writing state-machiney code to record a partial detection.\n//\n// The number of channels returned are stored in *channels (which can be\n// NULL--it is always the same as the number of channels reported by\n// get_info). *output will contain an array of float* buffers, one per\n// channel. In other words, (*output)[0][0] contains the first sample from\n// the first channel, and (*output)[1][0] contains the first sample from\n// the second channel.\n//\n// *output points into stb_vorbis's internal output buffer storage; these\n// buffers are owned by stb_vorbis and application code should not free\n// them or modify their contents. They are transient and will be overwritten\n// once you ask for more data to get decoded, so be sure to grab any data\n// you need before then.\n\nextern void stb_vorbis_flush_pushdata(stb_vorbis *f);\n// inform stb_vorbis that your next datablock will not be contiguous with\n// previous ones (e.g. you've seeked in the data); future attempts to decode\n// frames will cause stb_vorbis to resynchronize (as noted above), and\n// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it\n// will begin decoding the _next_ frame.\n//\n// if you want to seek using pushdata, you need to seek in your file, then\n// call stb_vorbis_flush_pushdata(), then start calling decoding, then once\n// decoding is returning you data, call stb_vorbis_get_sample_offset, and\n// if you don't like the result, seek your file again and repeat.\n#endif\n\n\n//////////   PULLING INPUT API\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n// This API assumes stb_vorbis is allowed to pull data from a source--\n// either a block of memory containing the _entire_ vorbis stream, or a\n// FILE * that you or it create, or possibly some other reading mechanism\n// if you go modify the source to replace the FILE * case with some kind\n// of callback to your code. (But if you don't support seeking, you may\n// just want to go ahead and use pushdata.)\n\n#if !defined(STB_VORBIS_NO_STDIO) && !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output);\n#endif\n#if !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_memory(const unsigned char *mem, int len, int *channels, int *sample_rate, short **output);\n#endif\n// decode an entire file and output the data interleaved into a malloc()ed\n// buffer stored in *output. The return value is the number of samples\n// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.\n// When you're done with it, just free() the pointer returned in *output.\n\nextern stb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an ogg vorbis stream in memory (note\n// this must be the entire stream!). on failure, returns NULL and sets *error\n\n#ifndef STB_VORBIS_NO_STDIO\nextern stb_vorbis * stb_vorbis_open_filename(const char *filename,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from a filename via fopen(). on failure,\n// returns NULL and sets *error (possibly to VORBIS_file_open_failure).\n\nextern stb_vorbis * stb_vorbis_open_file(FILE *f, int close_handle_on_close,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell). on failure, returns NULL and sets *error.\n// note that stb_vorbis must \"own\" this stream; if you seek it in between\n// calls to stb_vorbis, it will become confused. Moreover, if you attempt to\n// perform stb_vorbis_seek_*() operations on this file, it will assume it\n// owns the _entire_ rest of the file after the start point. Use the next\n// function, stb_vorbis_open_file_section(), to limit it.\n\nextern stb_vorbis * stb_vorbis_open_file_section(FILE *f, int close_handle_on_close,\n                int *error, const stb_vorbis_alloc *alloc_buffer, unsigned int len);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell); the stream will be of length 'len' bytes.\n// on failure, returns NULL and sets *error. note that stb_vorbis must \"own\"\n// this stream; if you seek it in between calls to stb_vorbis, it will become\n// confused.\n#endif\n\nextern int stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number);\nextern int stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number);\n// these functions seek in the Vorbis file to (approximately) 'sample_number'.\n// after calling seek_frame(), the next call to get_frame_*() will include\n// the specified sample. after calling stb_vorbis_seek(), the next call to\n// stb_vorbis_get_samples_* will start with the specified sample. If you\n// do not need to seek to EXACTLY the target sample when using get_samples_*,\n// you can also use seek_frame().\n\nextern int stb_vorbis_seek_start(stb_vorbis *f);\n// this function is equivalent to stb_vorbis_seek(f,0)\n\nextern unsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f);\nextern float        stb_vorbis_stream_length_in_seconds(stb_vorbis *f);\n// these functions return the total length of the vorbis stream\n\nextern int stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output);\n// decode the next frame and return the number of samples. the number of\n// channels returned are stored in *channels (which can be NULL--it is always\n// the same as the number of channels reported by get_info). *output will\n// contain an array of float* buffers, one per channel. These outputs will\n// be overwritten on the next call to stb_vorbis_get_frame_*.\n//\n// You generally should not intermix calls to stb_vorbis_get_frame_*()\n// and stb_vorbis_get_samples_*(), since the latter calls the former.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts);\nextern int stb_vorbis_get_frame_short            (stb_vorbis *f, int num_c, short **buffer, int num_samples);\n#endif\n// decode the next frame and return the number of *samples* per channel.\n// Note that for interleaved data, you pass in the number of shorts (the\n// size of your array), but the return value is the number of samples per\n// channel, not the total number of samples.\n//\n// The data is coerced to the number of channels you request according to the\n// channel coercion rules (see below). You must pass in the size of your\n// buffer(s) so that stb_vorbis will not overwrite the end of the buffer.\n// The maximum buffer size needed can be gotten from get_info(); however,\n// the Vorbis I specification implies an absolute maximum of 4096 samples\n// per channel.\n\n// Channel coercion rules:\n//    Let M be the number of channels requested, and N the number of channels present,\n//    and Cn be the nth channel; let stereo L be the sum of all L and center channels,\n//    and stereo R be the sum of all R and center channels (channel assignment from the\n//    vorbis spec).\n//        M    N       output\n//        1    k      sum(Ck) for all k\n//        2    *      stereo L, stereo R\n//        k    l      k > l, the first l channels, then 0s\n//        k    l      k <= l, the first k channels\n//    Note that this is not _good_ surround etc. mixing at all! It's just so\n//    you get something useful.\n\nextern int stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats);\nextern int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples);\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.\n// Returns the number of samples stored per channel; it may be less than requested\n// at the end of the file. If there are no more samples in the file, returns 0.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts);\nextern int stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int num_samples);\n#endif\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. Applies the coercion rules above\n// to produce 'channels' channels. Returns the number of samples stored per channel;\n// it may be less than requested at the end of the file. If there are no more\n// samples in the file, returns 0.\n\n#endif\n\n////////   ERROR CODES\n\nenum STBVorbisError\n{\n   VORBIS__no_error,\n\n   VORBIS_need_more_data=1,             // not a real error\n\n   VORBIS_invalid_api_mixing,           // can't mix API modes\n   VORBIS_outofmem,                     // not enough memory\n   VORBIS_feature_not_supported,        // uses floor 0\n   VORBIS_too_many_channels,            // STB_VORBIS_MAX_CHANNELS is too small\n   VORBIS_file_open_failure,            // fopen() failed\n   VORBIS_seek_without_length,          // can't seek in unknown-length file\n\n   VORBIS_unexpected_eof=10,            // file is truncated?\n   VORBIS_seek_invalid,                 // seek past EOF\n\n   // decoding errors (corrupt/invalid stream) -- you probably\n   // don't care about the exact details of these\n\n   // vorbis errors:\n   VORBIS_invalid_setup=20,\n   VORBIS_invalid_stream,\n\n   // ogg errors:\n   VORBIS_missing_capture_pattern=30,\n   VORBIS_invalid_stream_structure_version,\n   VORBIS_continued_packet_flag_invalid,\n   VORBIS_incorrect_stream_serial_number,\n   VORBIS_invalid_first_page,\n   VORBIS_bad_packet_type,\n   VORBIS_cant_find_last_page,\n   VORBIS_seek_failed,\n   VORBIS_ogg_skeleton_not_supported\n};\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H\n//\n//  HEADER ENDS HERE\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef STB_VORBIS_HEADER_ONLY\n\n#include \"../memory.h\"\n#include \"../math.h\"\n#include \"qsort.h\"\n\n#define STB_VORBIS_NO_CRT\n#define assert(x)       // or MyAssert(x)\n#define malloc(x)       MemAllocate(x, 0)\n#define free(x)         if (x) {MemRelease(x);}\n#define realloc         MemRealloc\n#define pow             MathPow\n#define floor           MathFloor\n#define log             MathLog\n#define exp             MathExp\n#define cos             MathCos\n#define sin             MathSin\n#define abs(x)          (x < 0? -x : x)\n#define alloca(a)    malloc(a)  // this is actually the macro above\n#define dealloca(p)  free(p)    // this is actually the macro above\n#define memset MemSet\n#define memcpy MemCopy\n#define memcmp MemCmp\n#define UINT_MAX 4294967295\n\nfloat vorbis_ldexp(float Value, int Exponent) {\n    return((float)((double)Value * pow(2.0, (double)Exponent)));\n}\n\nvoid qsort (void *base, unsigned num, unsigned width,\n            int (*comp)(const void *, const void *))\n{\n   // TODO: Gabor, provide an implementation\n   MemDbgPrintStr(\"qsort called\");\n}\n\n// global configuration settings (e.g. set these in the project/makefile),\n// or just set them in this file at the top (although ideally the first few\n// should be visible when the header file is compiled too, although it's not\n// crucial)\n\n// STB_VORBIS_NO_PUSHDATA_API\n//     does not compile the code for the various stb_vorbis_*_pushdata()\n//     functions\n// #define STB_VORBIS_NO_PUSHDATA_API\n\n// STB_VORBIS_NO_PULLDATA_API\n//     does not compile the code for the non-pushdata APIs\n// #define STB_VORBIS_NO_PULLDATA_API\n\n// STB_VORBIS_NO_STDIO\n//     does not compile the code for the APIs that use FILE *s internally\n//     or externally (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_STDIO\n\n// STB_VORBIS_NO_INTEGER_CONVERSION\n//     does not compile the code for converting audio sample data from\n//     float to integer (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_INTEGER_CONVERSION\n\n// STB_VORBIS_NO_FAST_SCALED_FLOAT\n//      does not use a fast float-to-int trick to accelerate float-to-int on\n//      most platforms which requires endianness be defined correctly.\n//#define STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n\n// STB_VORBIS_MAX_CHANNELS [number]\n//     globally define this to the maximum number of channels you need.\n//     The spec does not put a restriction on channels except that\n//     the count is stored in a byte, so 255 is the hard limit.\n//     Reducing this saves about 16 bytes per value, so using 16 saves\n//     (255-16)*16 or around 4KB. Plus anything other memory usage\n//     I forgot to account for. Can probably go as low as 8 (7.1 audio),\n//     6 (5.1 audio), or 2 (stereo only).\n#ifndef STB_VORBIS_MAX_CHANNELS\n#define STB_VORBIS_MAX_CHANNELS    16  // enough for anyone?\n#endif\n\n// STB_VORBIS_PUSHDATA_CRC_COUNT [number]\n//     after a flush_pushdata(), stb_vorbis begins scanning for the\n//     next valid page, without backtracking. when it finds something\n//     that looks like a page, it streams through it and verifies its\n//     CRC32. Should that validation fail, it keeps scanning. But it's\n//     possible that _while_ streaming through to check the CRC32 of\n//     one candidate page, it sees another candidate page. This #define\n//     determines how many \"overlapping\" candidate pages it can search\n//     at once. Note that \"real\" pages are typically ~4KB to ~8KB, whereas\n//     garbage pages could be as big as 64KB, but probably average ~16KB.\n//     So don't hose ourselves by scanning an apparent 64KB page and\n//     missing a ton of real ones in the interim; so minimum of 2\n#ifndef STB_VORBIS_PUSHDATA_CRC_COUNT\n#define STB_VORBIS_PUSHDATA_CRC_COUNT  4\n#endif\n\n// STB_VORBIS_FAST_HUFFMAN_LENGTH [number]\n//     sets the log size of the huffman-acceleration table.  Maximum\n//     supported value is 24. with larger numbers, more decodings are O(1),\n//     but the table size is larger so worse cache missing, so you'll have\n//     to probe (and try multiple ogg vorbis files) to find the sweet spot.\n#ifndef STB_VORBIS_FAST_HUFFMAN_LENGTH\n#define STB_VORBIS_FAST_HUFFMAN_LENGTH   10\n#endif\n\n// STB_VORBIS_FAST_BINARY_LENGTH [number]\n//     sets the log size of the binary-search acceleration table. this\n//     is used in similar fashion to the fast-huffman size to set initial\n//     parameters for the binary search\n\n// STB_VORBIS_FAST_HUFFMAN_INT\n//     The fast huffman tables are much more efficient if they can be\n//     stored as 16-bit results instead of 32-bit results. This restricts\n//     the codebooks to having only 65535 possible outcomes, though.\n//     (At least, accelerated by the huffman table.)\n#ifndef STB_VORBIS_FAST_HUFFMAN_INT\n#define STB_VORBIS_FAST_HUFFMAN_SHORT\n#endif\n\n// STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n//     If the 'fast huffman' search doesn't succeed, then stb_vorbis falls\n//     back on binary searching for the correct one. This requires storing\n//     extra tables with the huffman codes in sorted order. Defining this\n//     symbol trades off space for speed by forcing a linear search in the\n//     non-fast case, except for \"sparse\" codebooks.\n// #define STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n\n// STB_VORBIS_DIVIDES_IN_RESIDUE\n//     stb_vorbis precomputes the result of the scalar residue decoding\n//     that would otherwise require a divide per chunk. you can trade off\n//     space for time by defining this symbol.\n// #define STB_VORBIS_DIVIDES_IN_RESIDUE\n\n// STB_VORBIS_DIVIDES_IN_CODEBOOK\n//     vorbis VQ codebooks can be encoded two ways: with every case explicitly\n//     stored, or with all elements being chosen from a small range of values,\n//     and all values possible in all elements. By default, stb_vorbis expands\n//     this latter kind out to look like the former kind for ease of decoding,\n//     because otherwise an integer divide-per-vector-element is required to\n//     unpack the index. If you define STB_VORBIS_DIVIDES_IN_CODEBOOK, you can\n//     trade off storage for speed.\n//#define STB_VORBIS_DIVIDES_IN_CODEBOOK\n\n#ifdef STB_VORBIS_CODEBOOK_SHORTS\n#error \"STB_VORBIS_CODEBOOK_SHORTS is no longer supported as it produced incorrect results for some input formats\"\n#endif\n\n// STB_VORBIS_DIVIDE_TABLE\n//     this replaces small integer divides in the floor decode loop with\n//     table lookups. made less than 1% difference, so disabled by default.\n\n// STB_VORBIS_NO_INLINE_DECODE\n//     disables the inlining of the scalar codebook fast-huffman decode.\n//     might save a little codespace; useful for debugging\n// #define STB_VORBIS_NO_INLINE_DECODE\n\n// STB_VORBIS_NO_DEFER_FLOOR\n//     Normally we only decode the floor without synthesizing the actual\n//     full curve. We can instead synthesize the curve immediately. This\n//     requires more memory and is very likely slower, so I don't think\n//     you'd ever want to do it except for debugging.\n// #define STB_VORBIS_NO_DEFER_FLOOR\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef STB_VORBIS_NO_PULLDATA_API\n   #define STB_VORBIS_NO_INTEGER_CONVERSION\n   #define STB_VORBIS_NO_STDIO\n#endif\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n   #define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n   // only need endianness for fast-float-to-int, which we don't\n   // use for pushdata\n\n   #ifndef STB_VORBIS_BIG_ENDIAN\n     #define STB_VORBIS_ENDIAN  0\n   #else\n     #define STB_VORBIS_ENDIAN  1\n   #endif\n\n#endif\n#endif\n\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef STB_VORBIS_NO_CRT\n   #include <stdlib.h>\n   #include <string.h>\n   #include <assert.h>\n   #include <math.h>\n\n   // find definition of alloca if it's not in stdlib.h:\n   #if defined(_MSC_VER) || defined(__MINGW32__)\n      #include <malloc.h>\n   #endif\n   #if defined(__linux__) || defined(__linux) || defined(__sun__) || defined(__EMSCRIPTEN__) || defined(__NEWLIB__)\n      #include <alloca.h>\n   #endif\n#else // STB_VORBIS_NO_CRT\n   #define NULL 0\n#endif // STB_VORBIS_NO_CRT\n\n#ifdef __MINGW32__\n   // eff you mingw:\n   //     \"fixed\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32882927/\n   //     \"no that broke the build, reverted, who cares about C\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32890381/\n   #ifdef __forceinline\n   #undef __forceinline\n   #endif\n   #define __forceinline\n   #ifndef alloca\n   #define alloca __builtin_alloca\n   #endif\n#elif !defined(_MSC_VER)\n   #if __GNUC__\n      #define __forceinline inline\n   #else\n      #define __forceinline\n   #endif\n#endif\n\n#if STB_VORBIS_MAX_CHANNELS > 256\n#error \"Value of STB_VORBIS_MAX_CHANNELS outside of allowed range\"\n#endif\n\n#if STB_VORBIS_FAST_HUFFMAN_LENGTH > 24\n#error \"Value of STB_VORBIS_FAST_HUFFMAN_LENGTH outside of allowed range\"\n#endif\n\n\n#if 0\n#include <crtdbg.h>\n#define CHECK(f)   _CrtIsValidHeapPointer(f->channel_buffers[1])\n#else\n#define CHECK(f)   ((void) 0)\n#endif\n\n#define MAX_BLOCKSIZE_LOG  13   // from specification\n#define MAX_BLOCKSIZE      (1 << MAX_BLOCKSIZE_LOG)\n\n\ntypedef unsigned char  uint8;\ntypedef   signed char   int8;\ntypedef unsigned short uint16;\ntypedef   signed short  int16;\ntypedef unsigned int   uint32;\ntypedef   signed int    int32;\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n\ntypedef float codetype;\n\n#ifdef _MSC_VER\n#define STBV_NOTUSED(v)  (void)(v)\n#else\n#define STBV_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n// @NOTE\n//\n// Some arrays below are tagged \"//varies\", which means it's actually\n// a variable-sized piece of data, but rather than malloc I assume it's\n// small enough it's better to just allocate it all together with the\n// main thing\n//\n// Most of the variables are specified with the smallest size I could pack\n// them into. It might give better performance to make them all full-sized\n// integers. It should be safe to freely rearrange the structures or change\n// the sizes larger--nothing relies on silently truncating etc., nor the\n// order of variables.\n\n#define FAST_HUFFMAN_TABLE_SIZE   (1 << STB_VORBIS_FAST_HUFFMAN_LENGTH)\n#define FAST_HUFFMAN_TABLE_MASK   (FAST_HUFFMAN_TABLE_SIZE - 1)\n\ntypedef struct\n{\n   int dimensions, entries;\n   uint8 *codeword_lengths;\n   float  minimum_value;\n   float  delta_value;\n   uint8  value_bits;\n   uint8  lookup_type;\n   uint8  sequence_p;\n   uint8  sparse;\n   uint32 lookup_values;\n   codetype *multiplicands;\n   uint32 *codewords;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n    int16  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #else\n    int32  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #endif\n   uint32 *sorted_codewords;\n   int    *sorted_values;\n   int     sorted_entries;\n} Codebook;\n\ntypedef struct\n{\n   uint8 order;\n   uint16 rate;\n   uint16 bark_map_size;\n   uint8 amplitude_bits;\n   uint8 amplitude_offset;\n   uint8 number_of_books;\n   uint8 book_list[16]; // varies\n} Floor0;\n\ntypedef struct\n{\n   uint8 partitions;\n   uint8 partition_class_list[32]; // varies\n   uint8 class_dimensions[16]; // varies\n   uint8 class_subclasses[16]; // varies\n   uint8 class_masterbooks[16]; // varies\n   int16 subclass_books[16][8]; // varies\n   uint16 Xlist[31*8+2]; // varies\n   uint8 sorted_order[31*8+2];\n   uint8 neighbors[31*8+2][2];\n   uint8 floor1_multiplier;\n   uint8 rangebits;\n   int values;\n} Floor1;\n\ntypedef union\n{\n   Floor0 floor0;\n   Floor1 floor1;\n} Floor;\n\ntypedef struct\n{\n   uint32 begin, end;\n   uint32 part_size;\n   uint8 classifications;\n   uint8 classbook;\n   uint8 **classdata;\n   int16 (*residue_books)[8];\n} Residue;\n\ntypedef struct\n{\n   uint8 magnitude;\n   uint8 angle;\n   uint8 mux;\n} MappingChannel;\n\ntypedef struct\n{\n   uint16 coupling_steps;\n   MappingChannel *chan;\n   uint8  submaps;\n   uint8  submap_floor[15]; // varies\n   uint8  submap_residue[15]; // varies\n} Mapping;\n\ntypedef struct\n{\n   uint8 blockflag;\n   uint8 mapping;\n   uint16 windowtype;\n   uint16 transformtype;\n} Mode;\n\ntypedef struct\n{\n   uint32  goal_crc;    // expected crc if match\n   int     bytes_left;  // bytes left in packet\n   uint32  crc_so_far;  // running crc\n   int     bytes_done;  // bytes processed in _current_ chunk\n   uint32  sample_loc;  // granule pos encoded in page\n} CRCscan;\n\ntypedef struct\n{\n   uint32 page_start, page_end;\n   uint32 last_decoded_sample;\n} ProbedPage;\n\nstruct stb_vorbis\n{\n  // user-accessible info\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int temp_memory_required;\n   unsigned int setup_temp_memory_required;\n\n   char *vendor;\n   int comment_list_length;\n   char **comment_list;\n\n  // input config\n#ifndef STB_VORBIS_NO_STDIO\n   FILE *f;\n   uint32 f_start;\n   int close_on_free;\n#endif\n\n   uint8 *stream;\n   uint8 *stream_start;\n   uint8 *stream_end;\n\n   uint32 stream_len;\n\n   uint8  push_mode;\n\n   // the page to seek to when seeking to start, may be zero\n   uint32 first_audio_page_offset;\n\n   // p_first is the page on which the first audio packet ends\n   // (but not necessarily the page on which it starts)\n   ProbedPage p_first, p_last;\n\n  // memory management\n   stb_vorbis_alloc alloc;\n   int setup_offset;\n   int temp_offset;\n\n  // run-time results\n   int eof;\n   enum STBVorbisError error;\n\n  // user-useful data\n\n  // header info\n   int blocksize[2];\n   int blocksize_0, blocksize_1;\n   int codebook_count;\n   Codebook *codebooks;\n   int floor_count;\n   uint16 floor_types[64]; // varies\n   Floor *floor_config;\n   int residue_count;\n   uint16 residue_types[64]; // varies\n   Residue *residue_config;\n   int mapping_count;\n   Mapping *mapping;\n   int mode_count;\n   Mode mode_config[64];  // varies\n\n   uint32 total_samples;\n\n  // decode buffer\n   float *channel_buffers[STB_VORBIS_MAX_CHANNELS];\n   float *outputs        [STB_VORBIS_MAX_CHANNELS];\n\n   float *previous_window[STB_VORBIS_MAX_CHANNELS];\n   int previous_length;\n\n   #ifndef STB_VORBIS_NO_DEFER_FLOOR\n   int16 *finalY[STB_VORBIS_MAX_CHANNELS];\n   #else\n   float *floor_buffers[STB_VORBIS_MAX_CHANNELS];\n   #endif\n\n   uint32 current_loc; // sample location of next frame to decode\n   int    current_loc_valid;\n\n  // per-blocksize precomputed data\n\n   // twiddle factors\n   float *A[2],*B[2],*C[2];\n   float *window[2];\n   uint16 *bit_reverse[2];\n\n  // current page/packet/segment streaming info\n   uint32 serial; // stream serial number for verification\n   int last_page;\n   int segment_count;\n   uint8 segments[255];\n   uint8 page_flag;\n   uint8 bytes_in_seg;\n   uint8 first_decode;\n   int next_seg;\n   int last_seg;  // flag that we're on the last segment\n   int last_seg_which; // what was the segment number of the last seg?\n   uint32 acc;\n   int valid_bits;\n   int packet_bytes;\n   int end_seg_with_known_loc;\n   uint32 known_loc_for_packet;\n   int discard_samples_deferred;\n   uint32 samples_output;\n\n  // push mode scanning\n   int page_crc_tests; // only in push_mode: number of tests active; -1 if not searching\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n   CRCscan scan[STB_VORBIS_PUSHDATA_CRC_COUNT];\n#endif\n\n  // sample-access\n   int channel_buffer_start;\n   int channel_buffer_end;\n};\n\n#if defined(STB_VORBIS_NO_PUSHDATA_API)\n   #define IS_PUSH_MODE(f)   FALSE\n#elif defined(STB_VORBIS_NO_PULLDATA_API)\n   #define IS_PUSH_MODE(f)   TRUE\n#else\n   #define IS_PUSH_MODE(f)   ((f)->push_mode)\n#endif\n\ntypedef struct stb_vorbis vorb;\n\nstatic int error(vorb *f, enum STBVorbisError e)\n{\n   f->error = e;\n   if (!f->eof && e != VORBIS_need_more_data) {\n      f->error=e; // breakpoint for debugging\n   }\n   return 0;\n}\n\n\n// these functions are used for allocating temporary memory\n// while decoding. if you can afford the stack space, use\n// alloca(); otherwise, provide a temp buffer and it will\n// allocate out of those.\n\n#define array_size_required(count,size)  (count*(sizeof(void *)+(size)))\n\n#define temp_alloc(f,size)              (f->alloc.alloc_buffer ? setup_temp_malloc(f,size) : alloca(size))\n#define temp_free(f,p)                  (void)0\n#define temp_alloc_save(f)              ((f)->temp_offset)\n#define temp_alloc_restore(f,p)         ((f)->temp_offset = (p))\n\n#define temp_block_array(f,count,size)  make_block_array(temp_alloc(f,array_size_required(count,size)), count, size)\n\n// given a sufficiently large block of memory, make an array of pointers to subblocks of it\nstatic void *make_block_array(void *mem, int count, int size)\n{\n   int i;\n   void ** p = (void **) mem;\n   char *q = (char *) (p + count);\n   for (i=0; i < count; ++i) {\n      p[i] = q;\n      q += size;\n   }\n   return p;\n}\n\nstatic void *setup_malloc(vorb *f, int sz)\n{\n   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.\n   f->setup_memory_required += sz;\n   if (f->alloc.alloc_buffer) {\n      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset;\n      if (f->setup_offset + sz > f->temp_offset) return NULL;\n      f->setup_offset += sz;\n      return p;\n   }\n   return sz ? malloc(sz) : NULL;\n}\n\nstatic void setup_free(vorb *f, void *p)\n{\n   if (f->alloc.alloc_buffer) return; // do nothing; setup mem is a stack\n   free(p);\n}\n\nstatic void *setup_temp_malloc(vorb *f, int sz)\n{\n   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.\n   if (f->alloc.alloc_buffer) {\n      if (f->temp_offset - sz < f->setup_offset) return NULL;\n      f->temp_offset -= sz;\n      return (char *) f->alloc.alloc_buffer + f->temp_offset;\n   }\n   return malloc(sz);\n}\n\nstatic void setup_temp_free(vorb *f, void *p, int sz)\n{\n   if (f->alloc.alloc_buffer) {\n      f->temp_offset += (sz+7)&~7;\n      return;\n   }\n   free(p);\n}\n\n#define CRC32_POLY    0x04c11db7   // from spec\n\nstatic uint32 crc_table[256];\nstatic void crc32_init(void)\n{\n   int i,j;\n   uint32 s;\n   for(i=0; i < 256; i++) {\n      for (s=(uint32) i << 24, j=0; j < 8; ++j)\n         s = (s << 1) ^ (s >= (1U<<31) ? CRC32_POLY : 0);\n      crc_table[i] = s;\n   }\n}\n\nstatic __forceinline uint32 crc32_update(uint32 crc, uint8 byte)\n{\n   return (crc << 8) ^ crc_table[byte ^ (crc >> 24)];\n}\n\n\n// used in setup, and for huffman that doesn't go fast path\nstatic unsigned int bit_reverse(unsigned int n)\n{\n  n = ((n & 0xAAAAAAAA) >>  1) | ((n & 0x55555555) << 1);\n  n = ((n & 0xCCCCCCCC) >>  2) | ((n & 0x33333333) << 2);\n  n = ((n & 0xF0F0F0F0) >>  4) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n & 0xFF00FF00) >>  8) | ((n & 0x00FF00FF) << 8);\n  return (n >> 16) | (n << 16);\n}\n\nstatic float square(float x)\n{\n   return x*x;\n}\n\n// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3\n// as required by the specification. fast(?) implementation from stb.h\n// @OPTIMIZE: called multiple times per-packet with \"constants\"; move to setup\nstatic int ilog(int32 n)\n{\n   static signed char log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };\n\n   if (n < 0) return 0; // signed n returns 0\n\n   // 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)\n   if (n < (1 << 14))\n        if (n < (1 <<  4))            return  0 + log2_4[n      ];\n        else if (n < (1 <<  9))       return  5 + log2_4[n >>  5];\n             else                     return 10 + log2_4[n >> 10];\n   else if (n < (1 << 24))\n             if (n < (1 << 19))       return 15 + log2_4[n >> 15];\n             else                     return 20 + log2_4[n >> 20];\n        else if (n < (1 << 29))       return 25 + log2_4[n >> 25];\n             else                     return 30 + log2_4[n >> 30];\n}\n\n#ifndef M_PI\n  #define M_PI  3.14159265358979323846264f  // from CRC\n#endif\n\n// code length assigned to a value with no huffman encoding\n#define NO_CODE   255\n\n/////////////////////// LEAF SETUP FUNCTIONS //////////////////////////\n//\n// these functions are only called at setup, and only a few times\n// per file\n\nstatic float float32_unpack(uint32 x)\n{\n   // from the specification\n   uint32 mantissa = x & 0x1fffff;\n   uint32 sign = x & 0x80000000;\n   uint32 exp = (x & 0x7fe00000) >> 21;\n   double res = sign ? -(double)mantissa : (double)mantissa;\n   return (float) vorbis_ldexp((float)res, (int)exp-788);\n}\n\n\n// zlib & jpeg huffman tables assume that the output symbols\n// can either be arbitrarily arranged, or have monotonically\n// increasing frequencies--they rely on the lengths being sorted;\n// this makes for a very simple generation algorithm.\n// vorbis allows a huffman table with non-sorted lengths. This\n// requires a more sophisticated construction, since symbols in\n// order do not map to huffman codes \"in order\".\nstatic void add_entry(Codebook *c, uint32 huff_code, int symbol, int count, int len, uint32 *values)\n{\n   if (!c->sparse) {\n      c->codewords      [symbol] = huff_code;\n   } else {\n      c->codewords       [count] = huff_code;\n      c->codeword_lengths[count] = len;\n      values             [count] = symbol;\n   }\n}\n\nstatic int compute_codewords(Codebook *c, uint8 *len, int n, uint32 *values)\n{\n   int i,k,m=0;\n   uint32 available[32];\n\n   memset(available, 0, sizeof(available));\n   // find the first entry\n   for (k=0; k < n; ++k) if (len[k] < NO_CODE) break;\n   if (k == n) { assert(c->sorted_entries == 0); return TRUE; }\n   assert(len[k] < 32); // no error return required, code reading lens checks this\n   // add to the list\n   add_entry(c, 0, k, m++, len[k], values);\n   // add all available leaves\n   for (i=1; i <= len[k]; ++i)\n      available[i] = 1U << (32-i);\n   // note that the above code treats the first case specially,\n   // but it's really the same as the following code, so they\n   // could probably be combined (except the initial code is 0,\n   // and I use 0 in available[] to mean 'empty')\n   for (i=k+1; i < n; ++i) {\n      uint32 res;\n      int z = len[i], y;\n      if (z == NO_CODE) continue;\n      assert(z < 32); // no error return required, code reading lens checks this\n      // find lowest available leaf (should always be earliest,\n      // which is what the specification calls for)\n      // note that this property, and the fact we can never have\n      // more than one free leaf at a given level, isn't totally\n      // trivial to prove, but it seems true and the assert never\n      // fires, so!\n      while (z > 0 && !available[z]) --z;\n      if (z == 0) { return FALSE; }\n      res = available[z];\n      available[z] = 0;\n      add_entry(c, bit_reverse(res), i, m++, len[i], values);\n      // propagate availability up the tree\n      if (z != len[i]) {\n         for (y=len[i]; y > z; --y) {\n            assert(available[y] == 0);\n            available[y] = res + (1 << (32-y));\n         }\n      }\n   }\n   return TRUE;\n}\n\n// accelerated huffman table allows fast O(1) match of all symbols\n// of length <= STB_VORBIS_FAST_HUFFMAN_LENGTH\nstatic void compute_accelerated_huffman(Codebook *c)\n{\n   int i, len;\n   for (i=0; i < FAST_HUFFMAN_TABLE_SIZE; ++i)\n      c->fast_huffman[i] = -1;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n   if (len > 32767) len = 32767; // largest possible value we can encode!\n   #endif\n   for (i=0; i < len; ++i) {\n      if (c->codeword_lengths[i] <= STB_VORBIS_FAST_HUFFMAN_LENGTH) {\n         uint32 z = c->sparse ? bit_reverse(c->sorted_codewords[i]) : c->codewords[i];\n         // set table entries for all bit combinations in the higher bits\n         while (z < FAST_HUFFMAN_TABLE_SIZE) {\n             c->fast_huffman[z] = i;\n             z += 1 << c->codeword_lengths[i];\n         }\n      }\n   }\n}\n\n#ifdef _MSC_VER\n#define STBV_CDECL __cdecl\n#else\n#define STBV_CDECL\n#endif\n\nstatic int STBV_CDECL uint32_compare(const void *p, const void *q)\n{\n   uint32 x = * (uint32 *) p;\n   uint32 y = * (uint32 *) q;\n   return x < y ? -1 : x > y;\n}\n\nstatic int include_in_sort(Codebook *c, uint8 len)\n{\n   if (c->sparse) { assert(len != NO_CODE); return TRUE; }\n   if (len == NO_CODE) return FALSE;\n   if (len > STB_VORBIS_FAST_HUFFMAN_LENGTH) return TRUE;\n   return FALSE;\n}\n\n// if the fast table above doesn't work, we want to binary\n// search them... need to reverse the bits\nvoid SwapUInt32Values(uint32* a, uint32* b) {\n   uint32 tmp = *a;\n   *a = *b;\n   *b = tmp;\n}\n\nstatic void compute_sorted_huffman(Codebook *c, uint8 *lengths, uint32 *values)\n{\n   int i, len;\n   // build a list of all the entries\n   // OPTIMIZATION: don't include the short ones, since they'll be caught by FAST_HUFFMAN.\n   // this is kind of a frivolous optimization--I don't see any performance improvement,\n   // but it's like 4 extra lines of code, so.\n   if (!c->sparse) {\n      int k = 0;\n      for (i=0; i < c->entries; ++i)\n         if (include_in_sort(c, lengths[i]))\n            c->sorted_codewords[k++] = bit_reverse(c->codewords[i]);\n      assert(k == c->sorted_entries);\n   } else {\n      for (i=0; i < c->sorted_entries; ++i)\n         c->sorted_codewords[i] = bit_reverse(c->codewords[i]);\n   }\n\n   //qsort(c->sorted_codewords, c->sorted_entries, sizeof(c->sorted_codewords[0]), uint32_compare);\n   uint32 qsrt_swap = 0;\n   #define QSRT_LESS(x, y) (c->sorted_codewords[x] < c->sorted_codewords[y])\n   #define QSRT_SWAP(i, j) SwapUInt32Values(&c->sorted_codewords[i], &c->sorted_codewords[j])\n   QSORT(c->sorted_entries, QSRT_LESS, QSRT_SWAP);\n   #undef QSRT_LESS\n   #undef QSRT_SWAP\n\n   c->sorted_codewords[c->sorted_entries] = 0xffffffff;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   // now we need to indicate how they correspond; we could either\n   //   #1: sort a different data structure that says who they correspond to\n   //   #2: for each sorted entry, search the original list to find who corresponds\n   //   #3: for each original entry, find the sorted entry\n   // #1 requires extra storage, #2 is slow, #3 can use binary search!\n   for (i=0; i < len; ++i) {\n      int huff_len = c->sparse ? lengths[values[i]] : lengths[i];\n      if (include_in_sort(c,huff_len)) {\n         uint32 code = bit_reverse(c->codewords[i]);\n         int x=0, n=c->sorted_entries;\n         while (n > 1) {\n            // invariant: sc[x] <= code < sc[x+n]\n            int m = x + (n >> 1);\n            if (c->sorted_codewords[m] <= code) {\n               x = m;\n               n -= (n>>1);\n            } else {\n               n >>= 1;\n            }\n         }\n         assert(c->sorted_codewords[x] == code);\n         if (c->sparse) {\n            c->sorted_values[x] = values[i];\n            c->codeword_lengths[x] = huff_len;\n         } else {\n            c->sorted_values[x] = i;\n         }\n      }\n   }\n}\n\n// only run while parsing the header (3 times)\nstatic int vorbis_validate(uint8 *data)\n{\n   static uint8 vorbis[6] = { 'v', 'o', 'r', 'b', 'i', 's' };\n   return memcmp(data, vorbis, 6) == 0;\n}\n\n// called from setup only, once per code book\n// (formula implied by specification)\nstatic int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n   return r;\n}\n\n// called twice per file\nstatic void compute_twiddle_factors(int n, float *A, float *B, float *C)\n{\n   int n4 = n >> 2, n8 = n >> 3;\n   int k,k2;\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2) * 0.5f;\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2) * 0.5f;\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n}\n\nstatic void compute_window(int n, float *window)\n{\n   int n2 = n >> 1, i;\n   for (i=0; i < n2; ++i)\n      window[i] = (float) sin(0.5 * M_PI * square((float) sin((i - 0 + 0.5) / n2 * 0.5 * M_PI)));\n}\n\nstatic void compute_bitreverse(int n, uint16 *rev)\n{\n   int ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   int i, n8 = n >> 3;\n   for (i=0; i < n8; ++i)\n      rev[i] = (bit_reverse(i) >> (32-ld+3)) << 2;\n}\n\nstatic int init_blocksize(vorb *f, int b, int n)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3;\n   f->A[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->B[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->C[b] = (float *) setup_malloc(f, sizeof(float) * n4);\n   if (!f->A[b] || !f->B[b] || !f->C[b]) return error(f, VORBIS_outofmem);\n   compute_twiddle_factors(n, f->A[b], f->B[b], f->C[b]);\n   f->window[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   if (!f->window[b]) return error(f, VORBIS_outofmem);\n   compute_window(n, f->window[b]);\n   f->bit_reverse[b] = (uint16 *) setup_malloc(f, sizeof(uint16) * n8);\n   if (!f->bit_reverse[b]) return error(f, VORBIS_outofmem);\n   compute_bitreverse(n, f->bit_reverse[b]);\n   return TRUE;\n}\n\nstatic void neighbors(uint16 *x, int n, int *plow, int *phigh)\n{\n   int low = -1;\n   int high = 65536;\n   int i;\n   for (i=0; i < n; ++i) {\n      if (x[i] > low  && x[i] < x[n]) { *plow  = i; low = x[i]; }\n      if (x[i] < high && x[i] > x[n]) { *phigh = i; high = x[i]; }\n   }\n}\n\n// this has been repurposed so y is now the original index instead of y\ntypedef struct\n{\n   uint16 x,id;\n} stbv__floor_ordering;\n\nstatic int STBV_CDECL point_compare(const void *p, const void *q)\n{\n   stbv__floor_ordering *a = (stbv__floor_ordering *) p;\n   stbv__floor_ordering *b = (stbv__floor_ordering *) q;\n   return a->x < b->x ? -1 : a->x > b->x;\n}\n\n//\n/////////////////////// END LEAF SETUP FUNCTIONS //////////////////////////\n\n\n#if defined(STB_VORBIS_NO_STDIO)\n   #define USE_MEMORY(z)    TRUE\n#else\n   #define USE_MEMORY(z)    ((z)->stream)\n#endif\n\nstatic uint8 get8(vorb *z)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream >= z->stream_end) { z->eof = TRUE; return 0; }\n      return *z->stream++;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n   int c = fgetc(z->f);\n   if (c == EOF) { z->eof = TRUE; return 0; }\n   return c;\n   }\n   #endif\n}\n\nstatic uint32 get32(vorb *f)\n{\n   uint32 x;\n   x = get8(f);\n   x += get8(f) << 8;\n   x += get8(f) << 16;\n   x += (uint32) get8(f) << 24;\n   return x;\n}\n\nstatic int getn(vorb *z, uint8 *data, int n)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream+n > z->stream_end) { z->eof = 1; return 0; }\n      memcpy(data, z->stream, n);\n      z->stream += n;\n      return 1;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO\n   if (fread(data, n, 1, z->f) == 1)\n      return 1;\n   else {\n      z->eof = 1;\n      return 0;\n   }\n   #endif\n}\n\nstatic void skip(vorb *z, int n)\n{\n   if (USE_MEMORY(z)) {\n      z->stream += n;\n      if (z->stream >= z->stream_end) z->eof = 1;\n      return;\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n      long x = ftell(z->f);\n      fseek(z->f, x+n, SEEK_SET);\n   }\n   #endif\n}\n\nstatic int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n\n\nstatic uint8 ogg_page_header[4] = { 0x4f, 0x67, 0x67, 0x53 };\n\nstatic int capture_pattern(vorb *f)\n{\n   if (0x4f != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x53 != get8(f)) return FALSE;\n   return TRUE;\n}\n\n#define PAGEFLAG_continued_packet   1\n#define PAGEFLAG_first_page         2\n#define PAGEFLAG_last_page          4\n\nstatic int start_page_no_capturepattern(vorb *f)\n{\n   uint32 loc0,loc1,n;\n   if (f->first_decode && !IS_PUSH_MODE(f)) {\n      f->p_first.page_start = stb_vorbis_get_file_offset(f) - 4;\n   }\n   // stream structure version\n   if (0 != get8(f)) return error(f, VORBIS_invalid_stream_structure_version);\n   // header flag\n   f->page_flag = get8(f);\n   // absolute granule position\n   loc0 = get32(f);\n   loc1 = get32(f);\n   // validate loc0,loc1 as valid positions?\n   // stream serial number -- vorbis doesn't interleave, so discard\n   get32(f);\n   //if (f->serial != get32(f)) return error(f, VORBIS_incorrect_stream_serial_number);\n   // page sequence number\n   n = get32(f);\n   f->last_page = n;\n   // CRC32\n   get32(f);\n   // page_segments\n   f->segment_count = get8(f);\n   if (!getn(f, f->segments, f->segment_count))\n      return error(f, VORBIS_unexpected_eof);\n   // assume we _don't_ know any the sample position of any segments\n   f->end_seg_with_known_loc = -2;\n   if (loc0 != ~0U || loc1 != ~0U) {\n      int i;\n      // determine which packet is the last one that will complete\n      for (i=f->segment_count-1; i >= 0; --i)\n         if (f->segments[i] < 255)\n            break;\n      // 'i' is now the index of the _last_ segment of a packet that ends\n      if (i >= 0) {\n         f->end_seg_with_known_loc = i;\n         f->known_loc_for_packet   = loc0;\n      }\n   }\n   if (f->first_decode) {\n      int i,len;\n      len = 0;\n      for (i=0; i < f->segment_count; ++i)\n         len += f->segments[i];\n      len += 27 + f->segment_count;\n      f->p_first.page_end = f->p_first.page_start + len;\n      f->p_first.last_decoded_sample = loc0;\n   }\n   f->next_seg = 0;\n   return TRUE;\n}\n\nstatic int start_page(vorb *f)\n{\n   if (!capture_pattern(f)) return error(f, VORBIS_missing_capture_pattern);\n   return start_page_no_capturepattern(f);\n}\n\nstatic int start_packet(vorb *f)\n{\n   while (f->next_seg == -1) {\n      if (!start_page(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet)\n         return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   // f->next_seg is now valid\n   return TRUE;\n}\n\nstatic int maybe_start_packet(vorb *f)\n{\n   if (f->next_seg == -1) {\n      int x = get8(f);\n      if (f->eof) return FALSE; // EOF at page boundary is not an error!\n      if (0x4f != x      ) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x53 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (!start_page_no_capturepattern(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet) {\n         // set up enough state that we can read this packet if we want,\n         // e.g. during recovery\n         f->last_seg = FALSE;\n         f->bytes_in_seg = 0;\n         return error(f, VORBIS_continued_packet_flag_invalid);\n      }\n   }\n   return start_packet(f);\n}\n\nstatic int next_segment(vorb *f)\n{\n   int len;\n   if (f->last_seg) return 0;\n   if (f->next_seg == -1) {\n      f->last_seg_which = f->segment_count-1; // in case start_page fails\n      if (!start_page(f)) { f->last_seg = 1; return 0; }\n      if (!(f->page_flag & PAGEFLAG_continued_packet)) return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   len = f->segments[f->next_seg++];\n   if (len < 255) {\n      f->last_seg = TRUE;\n      f->last_seg_which = f->next_seg-1;\n   }\n   if (f->next_seg >= f->segment_count)\n      f->next_seg = -1;\n   assert(f->bytes_in_seg == 0);\n   f->bytes_in_seg = len;\n   return len;\n}\n\n#define EOP    (-1)\n#define INVALID_BITS  (-1)\n\nstatic int get8_packet_raw(vorb *f)\n{\n   if (!f->bytes_in_seg) {  // CLANG!\n      if (f->last_seg) return EOP;\n      else if (!next_segment(f)) return EOP;\n   }\n   assert(f->bytes_in_seg > 0);\n   --f->bytes_in_seg;\n   ++f->packet_bytes;\n   return get8(f);\n}\n\nstatic int get8_packet(vorb *f)\n{\n   int x = get8_packet_raw(f);\n   f->valid_bits = 0;\n   return x;\n}\n\nstatic int get32_packet(vorb *f)\n{\n   uint32 x;\n   x = get8_packet(f);\n   x += get8_packet(f) << 8;\n   x += get8_packet(f) << 16;\n   x += (uint32) get8_packet(f) << 24;\n   return x;\n}\n\nstatic void flush_packet(vorb *f)\n{\n   while (get8_packet_raw(f) != EOP);\n}\n\n// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important\n// as the huffman decoder?\nstatic uint32 get_bits(vorb *f, int n)\n{\n   uint32 z;\n\n   if (f->valid_bits < 0) return 0;\n   if (f->valid_bits < n) {\n      if (n > 24) {\n         // the accumulator technique below would not work correctly in this case\n         z = get_bits(f, 24);\n         z += get_bits(f, n-24) << 24;\n         return z;\n      }\n      if (f->valid_bits == 0) f->acc = 0;\n      while (f->valid_bits < n) {\n         int z = get8_packet_raw(f);\n         if (z == EOP) {\n            f->valid_bits = INVALID_BITS;\n            return 0;\n         }\n         f->acc += z << f->valid_bits;\n         f->valid_bits += 8;\n      }\n   }\n\n   assert(f->valid_bits >= n);\n   z = f->acc & ((1 << n)-1);\n   f->acc >>= n;\n   f->valid_bits -= n;\n   return z;\n}\n\n// @OPTIMIZE: primary accumulator for huffman\n// expand the buffer to as many bits as possible without reading off end of packet\n// it might be nice to allow f->valid_bits and f->acc to be stored in registers,\n// e.g. cache them locally and decode locally\nstatic __forceinline void prep_huffman(vorb *f)\n{\n   if (f->valid_bits <= 24) {\n      if (f->valid_bits == 0) f->acc = 0;\n      do {\n         int z;\n         if (f->last_seg && !f->bytes_in_seg) return;\n         z = get8_packet_raw(f);\n         if (z == EOP) return;\n         f->acc += (unsigned) z << f->valid_bits;\n         f->valid_bits += 8;\n      } while (f->valid_bits <= 24);\n   }\n}\n\nenum\n{\n   VORBIS_packet_id = 1,\n   VORBIS_packet_comment = 3,\n   VORBIS_packet_setup = 5\n};\n\nstatic int codebook_decode_scalar_raw(vorb *f, Codebook *c)\n{\n   int i;\n   prep_huffman(f);\n\n   if (c->codewords == NULL && c->sorted_codewords == NULL)\n      return -1;\n\n   // cases to use binary search: sorted_codewords && !c->codewords\n   //                             sorted_codewords && c->entries > 8\n   if (c->entries > 8 ? c->sorted_codewords!=NULL : !c->codewords) {\n      // binary search\n      uint32 code = bit_reverse(f->acc);\n      int x=0, n=c->sorted_entries, len;\n\n      while (n > 1) {\n         // invariant: sc[x] <= code < sc[x+n]\n         int m = x + (n >> 1);\n         if (c->sorted_codewords[m] <= code) {\n            x = m;\n            n -= (n>>1);\n         } else {\n            n >>= 1;\n         }\n      }\n      // x is now the sorted index\n      if (!c->sparse) x = c->sorted_values[x];\n      // x is now sorted index if sparse, or symbol otherwise\n      len = c->codeword_lengths[x];\n      if (f->valid_bits >= len) {\n         f->acc >>= len;\n         f->valid_bits -= len;\n         return x;\n      }\n\n      f->valid_bits = 0;\n      return -1;\n   }\n\n   // if small, linear search\n   assert(!c->sparse);\n   for (i=0; i < c->entries; ++i) {\n      if (c->codeword_lengths[i] == NO_CODE) continue;\n      if (c->codewords[i] == (f->acc & ((1 << c->codeword_lengths[i])-1))) {\n         if (f->valid_bits >= c->codeword_lengths[i]) {\n            f->acc >>= c->codeword_lengths[i];\n            f->valid_bits -= c->codeword_lengths[i];\n            return i;\n         }\n         f->valid_bits = 0;\n         return -1;\n      }\n   }\n\n   error(f, VORBIS_invalid_stream);\n   f->valid_bits = 0;\n   return -1;\n}\n\n#ifndef STB_VORBIS_NO_INLINE_DECODE\n\n#define DECODE_RAW(var, f,c)                                  \\\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)        \\\n      prep_huffman(f);                                        \\\n   var = f->acc & FAST_HUFFMAN_TABLE_MASK;                    \\\n   var = c->fast_huffman[var];                                \\\n   if (var >= 0) {                                            \\\n      int n = c->codeword_lengths[var];                       \\\n      f->acc >>= n;                                           \\\n      f->valid_bits -= n;                                     \\\n      if (f->valid_bits < 0) { f->valid_bits = 0; var = -1; } \\\n   } else {                                                   \\\n      var = codebook_decode_scalar_raw(f,c);                  \\\n   }\n\n#else\n\nstatic int codebook_decode_scalar(vorb *f, Codebook *c)\n{\n   int i;\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)\n      prep_huffman(f);\n   // fast huffman table lookup\n   i = f->acc & FAST_HUFFMAN_TABLE_MASK;\n   i = c->fast_huffman[i];\n   if (i >= 0) {\n      f->acc >>= c->codeword_lengths[i];\n      f->valid_bits -= c->codeword_lengths[i];\n      if (f->valid_bits < 0) { f->valid_bits = 0; return -1; }\n      return i;\n   }\n   return codebook_decode_scalar_raw(f,c);\n}\n\n#define DECODE_RAW(var,f,c)    var = codebook_decode_scalar(f,c);\n\n#endif\n\n#define DECODE(var,f,c)                                       \\\n   DECODE_RAW(var,f,c)                                        \\\n   if (c->sparse) var = c->sorted_values[var];\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n  #define DECODE_VQ(var,f,c)   DECODE_RAW(var,f,c)\n#else\n  #define DECODE_VQ(var,f,c)   DECODE(var,f,c)\n#endif\n\n\n\n\n\n\n// CODEBOOK_ELEMENT_FAST is an optimization for the CODEBOOK_FLOATS case\n// where we avoid one addition\n#define CODEBOOK_ELEMENT(c,off)          (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_FAST(c,off)     (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_BASE(c)         (0)\n\nstatic int codebook_decode_start(vorb *f, Codebook *c)\n{\n   int z = -1;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)\n      error(f, VORBIS_invalid_stream);\n   else {\n      DECODE_VQ(z,f,c);\n      if (c->sparse) assert(z < c->sorted_entries);\n      if (z < 0) {  // check for EOP\n         if (!f->bytes_in_seg)\n            if (f->last_seg)\n               return z;\n         error(f, VORBIS_invalid_stream);\n      }\n   }\n   return z;\n}\n\nstatic int codebook_decode(vorb *f, Codebook *c, float *output, int len)\n{\n   int i,z = codebook_decode_start(f,c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i] += val;\n         if (c->sequence_p) last = val + c->minimum_value;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   if (c->sequence_p) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n         output[i] += val;\n         last = val + c->minimum_value;\n      }\n   } else {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         output[i] += CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      }\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_step(vorb *f, Codebook *c, float *output, int len, int step)\n{\n   int i,z = codebook_decode_start(f,c);\n   float last = CODEBOOK_ELEMENT_BASE(c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i*step] += val;\n         if (c->sequence_p) last = val;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   for (i=0; i < len; ++i) {\n      float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      output[i*step] += val;\n      if (c->sequence_p) last = val;\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_deinterleave_repeat(vorb *f, Codebook *c, float **outputs, int ch, int *c_inter_p, int *p_inter_p, int len, int total_decode)\n{\n   int c_inter = *c_inter_p;\n   int p_inter = *p_inter_p;\n   int i,z, effective = c->dimensions;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)   return error(f, VORBIS_invalid_stream);\n\n   while (total_decode > 0) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      DECODE_VQ(z,f,c);\n      #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      assert(!c->sparse || z < c->sorted_entries);\n      #endif\n      if (z < 0) {\n         if (!f->bytes_in_seg)\n            if (f->last_seg) return FALSE;\n         return error(f, VORBIS_invalid_stream);\n      }\n\n      // if this will take us off the end of the buffers, stop short!\n      // we check by computing the length of the virtual interleaved\n      // buffer (len*ch), our current offset within it (p_inter*ch)+(c_inter),\n      // and the length we'll be using (effective)\n      if (c_inter + p_inter*ch + effective > len * ch) {\n         effective = len*ch - (p_inter*ch - c_inter);\n      }\n\n   #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      if (c->lookup_type == 1) {\n         int div = 1;\n         for (i=0; i < effective; ++i) {\n            int off = (z / div) % c->lookup_values;\n            float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n            if (outputs[c_inter])\n               outputs[c_inter][p_inter] += val;\n            if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            if (c->sequence_p) last = val;\n            div *= c->lookup_values;\n         }\n      } else\n   #endif\n      {\n         z *= c->dimensions;\n         if (c->sequence_p) {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n               last = val;\n            }\n         } else {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            }\n         }\n      }\n\n      total_decode -= effective;\n   }\n   *c_inter_p = c_inter;\n   *p_inter_p = p_inter;\n   return TRUE;\n}\n\nstatic int predict_point(int x, int x0, int x1, int y0, int y1)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   // @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?\n   int err = abs(dy) * (x - x0);\n   int off = err / adx;\n   return dy < 0 ? y0 - off : y0 + off;\n}\n\n// the following table is block-copied from the specification\nstatic float inverse_db_table[256] =\n{\n  1.0649863e-07f, 1.1341951e-07f, 1.2079015e-07f, 1.2863978e-07f,\n  1.3699951e-07f, 1.4590251e-07f, 1.5538408e-07f, 1.6548181e-07f,\n  1.7623575e-07f, 1.8768855e-07f, 1.9988561e-07f, 2.1287530e-07f,\n  2.2670913e-07f, 2.4144197e-07f, 2.5713223e-07f, 2.7384213e-07f,\n  2.9163793e-07f, 3.1059021e-07f, 3.3077411e-07f, 3.5226968e-07f,\n  3.7516214e-07f, 3.9954229e-07f, 4.2550680e-07f, 4.5315863e-07f,\n  4.8260743e-07f, 5.1396998e-07f, 5.4737065e-07f, 5.8294187e-07f,\n  6.2082472e-07f, 6.6116941e-07f, 7.0413592e-07f, 7.4989464e-07f,\n  7.9862701e-07f, 8.5052630e-07f, 9.0579828e-07f, 9.6466216e-07f,\n  1.0273513e-06f, 1.0941144e-06f, 1.1652161e-06f, 1.2409384e-06f,\n  1.3215816e-06f, 1.4074654e-06f, 1.4989305e-06f, 1.5963394e-06f,\n  1.7000785e-06f, 1.8105592e-06f, 1.9282195e-06f, 2.0535261e-06f,\n  2.1869758e-06f, 2.3290978e-06f, 2.4804557e-06f, 2.6416497e-06f,\n  2.8133190e-06f, 2.9961443e-06f, 3.1908506e-06f, 3.3982101e-06f,\n  3.6190449e-06f, 3.8542308e-06f, 4.1047004e-06f, 4.3714470e-06f,\n  4.6555282e-06f, 4.9580707e-06f, 5.2802740e-06f, 5.6234160e-06f,\n  5.9888572e-06f, 6.3780469e-06f, 6.7925283e-06f, 7.2339451e-06f,\n  7.7040476e-06f, 8.2047000e-06f, 8.7378876e-06f, 9.3057248e-06f,\n  9.9104632e-06f, 1.0554501e-05f, 1.1240392e-05f, 1.1970856e-05f,\n  1.2748789e-05f, 1.3577278e-05f, 1.4459606e-05f, 1.5399272e-05f,\n  1.6400004e-05f, 1.7465768e-05f, 1.8600792e-05f, 1.9809576e-05f,\n  2.1096914e-05f, 2.2467911e-05f, 2.3928002e-05f, 2.5482978e-05f,\n  2.7139006e-05f, 2.8902651e-05f, 3.0780908e-05f, 3.2781225e-05f,\n  3.4911534e-05f, 3.7180282e-05f, 3.9596466e-05f, 4.2169667e-05f,\n  4.4910090e-05f, 4.7828601e-05f, 5.0936773e-05f, 5.4246931e-05f,\n  5.7772202e-05f, 6.1526565e-05f, 6.5524908e-05f, 6.9783085e-05f,\n  7.4317983e-05f, 7.9147585e-05f, 8.4291040e-05f, 8.9768747e-05f,\n  9.5602426e-05f, 0.00010181521f, 0.00010843174f, 0.00011547824f,\n  0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f,\n  0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f,\n  0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f,\n  0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f,\n  0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f,\n  0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f,\n  0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f,\n  0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f,\n  0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f,\n  0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f,\n  0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f,\n  0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f,\n  0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f,\n  0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f,\n  0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f,\n  0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f,\n  0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f,\n  0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f,\n  0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f,\n  0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f,\n  0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f,\n  0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f,\n  0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f,\n  0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f,\n  0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f,\n  0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f,\n  0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f,\n  0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f,\n  0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f,\n  0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f,\n  0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f,\n  0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f,\n  0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f,\n  0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f,\n  0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f,\n  0.82788260f,    0.88168307f,    0.9389798f,     1.0f\n};\n\n\n// @OPTIMIZE: if you want to replace this bresenham line-drawing routine,\n// note that you must produce bit-identical output to decode correctly;\n// this specific sequence of operations is specified in the spec (it's\n// drawing integer-quantized frequency-space lines that the encoder\n// expects to be exactly the same)\n//     ... also, isn't the whole point of Bresenham's algorithm to NOT\n// have to divide in the setup? sigh.\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n#define LINE_OP(a,b)   a *= b\n#else\n#define LINE_OP(a,b)   a = b\n#endif\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n#define DIVTAB_NUMER   32\n#define DIVTAB_DENOM   64\nint8 integer_divide_table[DIVTAB_NUMER][DIVTAB_DENOM]; // 2KB\n#endif\n\nstatic __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n   ady -= abs(base) * adx;\n   if (x1 > n) x1 = n;\n   if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y&255]);\n      for (++x; x < x1; ++x) {\n         err += ady;\n         if (err >= adx) {\n            err -= adx;\n            y += sy;\n         } else\n            y += base;\n         LINE_OP(output[x], inverse_db_table[y&255]);\n      }\n   }\n}\n\nstatic int residue_decode(vorb *f, Codebook *book, float *target, int offset, int n, int rtype)\n{\n   int k;\n   if (rtype == 0) {\n      int step = n / book->dimensions;\n      for (k=0; k < step; ++k)\n         if (!codebook_decode_step(f, book, target+offset+k, n-offset-k, step))\n            return FALSE;\n   } else {\n      for (k=0; k < n; ) {\n         if (!codebook_decode(f, book, target+offset, n-k))\n            return FALSE;\n         k += book->dimensions;\n         offset += book->dimensions;\n      }\n   }\n   return TRUE;\n}\n\n// n is 1/2 of the blocksize --\n// specification: \"Correct per-vector decode length is [n]/2\"\nstatic void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)\n{\n   int i,j,pass;\n   Residue *r = f->residue_config + rn;\n   int rtype = f->residue_types[rn];\n   int c = r->classbook;\n   int classwords = f->codebooks[c].dimensions;\n   unsigned int actual_size = rtype == 2 ? n*2 : n;\n   unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);\n   unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);\n   int n_read = limit_r_end - limit_r_begin;\n   int part_read = n_read / r->part_size;\n   int temp_alloc_point = temp_alloc_save(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata));\n   #else\n   int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications));\n   #endif\n\n   CHECK(f);\n\n   for (i=0; i < ch; ++i)\n      if (!do_not_decode[i])\n         memset(residue_buffers[i], 0, sizeof(float) * n);\n\n   if (rtype == 2 && ch != 1) {\n      for (j=0; j < ch; ++j)\n         if (!do_not_decode[j])\n            break;\n      if (j == ch)\n         goto done;\n\n      for (pass=0; pass < 8; ++pass) {\n         int pcount = 0, class_set = 0;\n         if (ch == 2) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = (z & 1), p_inter = z>>1;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #else\n                     // saves 1%\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #endif\n                  } else {\n                     z += r->part_size;\n                     c_inter = z & 1;\n                     p_inter = z >> 1;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         } else if (ch > 2) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = z % ch, p_inter = z/ch;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                  } else {\n                     z += r->part_size;\n                     c_inter = z % ch;\n                     p_inter = z / ch;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         }\n      }\n      goto done;\n   }\n   CHECK(f);\n\n   for (pass=0; pass < 8; ++pass) {\n      int pcount = 0, class_set=0;\n      while (pcount < part_read) {\n         if (pass == 0) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int temp;\n                  DECODE(temp,f,c);\n                  if (temp == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[j][class_set] = r->classdata[temp];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[j][i+pcount] = temp % r->classifications;\n                     temp /= r->classifications;\n                  }\n                  #endif\n               }\n            }\n         }\n         for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[j][class_set][i];\n                  #else\n                  int c = classifications[j][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     float *target = residue_buffers[j];\n                     int offset = r->begin + pcount * r->part_size;\n                     int n = r->part_size;\n                     Codebook *book = f->codebooks + b;\n                     if (!residue_decode(f, book, target, offset, n, rtype))\n                        goto done;\n                  }\n               }\n            }\n         }\n         #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n         ++class_set;\n         #endif\n      }\n   }\n  done:\n   CHECK(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   temp_free(f,part_classdata);\n   #else\n   temp_free(f,classifications);\n   #endif\n   temp_alloc_restore(f,temp_alloc_point);\n}\n\n\n#if 0\n// slow way for debugging\nvoid inverse_mdct_slow(float *buffer, int n)\n{\n   int i,j;\n   int n2 = n >> 1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         // formula from paper:\n         //acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n         // formula from wikipedia\n         //acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         // these are equivalent, except the formula from the paper inverts the multiplier!\n         // however, what actually works is NO MULTIPLIER!?!\n         //acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         acc += x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// same as above, but just barely able to run in real time on modern machines\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   float mcos[16384];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 2) -1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < 4*n; ++i)\n      mcos[i] = (float) cos(M_PI / 2 * i / n);\n\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) & nmask];\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// transform to use a slow dct-iv; this is STILL basically trivial,\n// but only requires half as many ops\nvoid dct_iv_slow(float *buffer, int n)\n{\n   float mcos[16384];\n   float x[2048];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 3) - 1;\n   memcpy(x, buffer, sizeof(*x) * n);\n   for (i=0; i < 8*n; ++i)\n      mcos[i] = (float) cos(M_PI / 4 * i / n);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n; ++j)\n         acc += x[j] * mcos[((2 * i + 1)*(2*j+1)) & nmask];\n      buffer[i] = acc;\n   }\n}\n\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   int i, n4 = n >> 2, n2 = n >> 1, n3_4 = n - n4;\n   float temp[4096];\n\n   memcpy(temp, buffer, n2 * sizeof(float));\n   dct_iv_slow(temp, n2);  // returns -c'-d, a-b'\n\n   for (i=0; i < n4  ; ++i) buffer[i] = temp[i+n4];            // a-b'\n   for (   ; i < n3_4; ++i) buffer[i] = -temp[n3_4 - i - 1];   // b-a', c+d'\n   for (   ; i < n   ; ++i) buffer[i] = -temp[i - n3_4];       // c'+d\n}\n#endif\n\n#ifndef LIBVORBIS_MDCT\n#define LIBVORBIS_MDCT 0\n#endif\n\n#if LIBVORBIS_MDCT\n// directly call the vorbis MDCT using an interface documented\n// by Jeff Roberts... useful for performance comparison\ntypedef struct\n{\n  int n;\n  int log2n;\n\n  float *trig;\n  int   *bitrev;\n\n  float scale;\n} mdct_lookup;\n\nextern void mdct_init(mdct_lookup *lookup, int n);\nextern void mdct_clear(mdct_lookup *l);\nextern void mdct_backward(mdct_lookup *init, float *in, float *out);\n\nmdct_lookup M1,M2;\n\nvoid inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   mdct_lookup *M;\n   if (M1.n == n) M = &M1;\n   else if (M2.n == n) M = &M2;\n   else if (M1.n == 0) { mdct_init(&M1, n); M = &M1; }\n   else {\n      if (M2.n) __asm int 3;\n      mdct_init(&M2, n);\n      M = &M2;\n   }\n\n   mdct_backward(M, buffer, buffer);\n}\n#endif\n\n\n// the following were split out into separate functions while optimizing;\n// they could be pushed back up but eh. __forceinline showed no change;\n// they're probably already being inlined.\nstatic void imdct_step3_iter0_loop(int n, float *e, int i_off, int k_off, float *A)\n{\n   float *ee0 = e + i_off;\n   float *ee2 = ee0 + k_off;\n   int i;\n\n   assert((n & 3) == 0);\n   for (i=(n>>2); i > 0; --i) {\n      float k00_20, k01_21;\n      k00_20  = ee0[ 0] - ee2[ 0];\n      k01_21  = ee0[-1] - ee2[-1];\n      ee0[ 0] += ee2[ 0];//ee0[ 0] = ee0[ 0] + ee2[ 0];\n      ee0[-1] += ee2[-1];//ee0[-1] = ee0[-1] + ee2[-1];\n      ee2[ 0] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-1] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-2] - ee2[-2];\n      k01_21  = ee0[-3] - ee2[-3];\n      ee0[-2] += ee2[-2];//ee0[-2] = ee0[-2] + ee2[-2];\n      ee0[-3] += ee2[-3];//ee0[-3] = ee0[-3] + ee2[-3];\n      ee2[-2] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-3] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-4] - ee2[-4];\n      k01_21  = ee0[-5] - ee2[-5];\n      ee0[-4] += ee2[-4];//ee0[-4] = ee0[-4] + ee2[-4];\n      ee0[-5] += ee2[-5];//ee0[-5] = ee0[-5] + ee2[-5];\n      ee2[-4] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-5] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-6] - ee2[-6];\n      k01_21  = ee0[-7] - ee2[-7];\n      ee0[-6] += ee2[-6];//ee0[-6] = ee0[-6] + ee2[-6];\n      ee0[-7] += ee2[-7];//ee0[-7] = ee0[-7] + ee2[-7];\n      ee2[-6] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-7] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n      ee0 -= 8;\n      ee2 -= 8;\n   }\n}\n\nstatic void imdct_step3_inner_r_loop(int lim, float *e, int d0, int k_off, float *A, int k1)\n{\n   int i;\n   float k00_20, k01_21;\n\n   float *e0 = e + d0;\n   float *e2 = e0 + k_off;\n\n   for (i=lim >> 2; i > 0; --i) {\n      k00_20 = e0[-0] - e2[-0];\n      k01_21 = e0[-1] - e2[-1];\n      e0[-0] += e2[-0];//e0[-0] = e0[-0] + e2[-0];\n      e0[-1] += e2[-1];//e0[-1] = e0[-1] + e2[-1];\n      e2[-0] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-1] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-2] - e2[-2];\n      k01_21 = e0[-3] - e2[-3];\n      e0[-2] += e2[-2];//e0[-2] = e0[-2] + e2[-2];\n      e0[-3] += e2[-3];//e0[-3] = e0[-3] + e2[-3];\n      e2[-2] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-3] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-4] - e2[-4];\n      k01_21 = e0[-5] - e2[-5];\n      e0[-4] += e2[-4];//e0[-4] = e0[-4] + e2[-4];\n      e0[-5] += e2[-5];//e0[-5] = e0[-5] + e2[-5];\n      e2[-4] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-5] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-6] - e2[-6];\n      k01_21 = e0[-7] - e2[-7];\n      e0[-6] += e2[-6];//e0[-6] = e0[-6] + e2[-6];\n      e0[-7] += e2[-7];//e0[-7] = e0[-7] + e2[-7];\n      e2[-6] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-7] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      e0 -= 8;\n      e2 -= 8;\n\n      A += k1;\n   }\n}\n\nstatic void imdct_step3_inner_s_loop(int n, float *e, int i_off, int k_off, float *A, int a_off, int k0)\n{\n   int i;\n   float A0 = A[0];\n   float A1 = A[0+1];\n   float A2 = A[0+a_off];\n   float A3 = A[0+a_off+1];\n   float A4 = A[0+a_off*2+0];\n   float A5 = A[0+a_off*2+1];\n   float A6 = A[0+a_off*3+0];\n   float A7 = A[0+a_off*3+1];\n\n   float k00,k11;\n\n   float *ee0 = e  +i_off;\n   float *ee2 = ee0+k_off;\n\n   for (i=n; i > 0; --i) {\n      k00     = ee0[ 0] - ee2[ 0];\n      k11     = ee0[-1] - ee2[-1];\n      ee0[ 0] =  ee0[ 0] + ee2[ 0];\n      ee0[-1] =  ee0[-1] + ee2[-1];\n      ee2[ 0] = (k00) * A0 - (k11) * A1;\n      ee2[-1] = (k11) * A0 + (k00) * A1;\n\n      k00     = ee0[-2] - ee2[-2];\n      k11     = ee0[-3] - ee2[-3];\n      ee0[-2] =  ee0[-2] + ee2[-2];\n      ee0[-3] =  ee0[-3] + ee2[-3];\n      ee2[-2] = (k00) * A2 - (k11) * A3;\n      ee2[-3] = (k11) * A2 + (k00) * A3;\n\n      k00     = ee0[-4] - ee2[-4];\n      k11     = ee0[-5] - ee2[-5];\n      ee0[-4] =  ee0[-4] + ee2[-4];\n      ee0[-5] =  ee0[-5] + ee2[-5];\n      ee2[-4] = (k00) * A4 - (k11) * A5;\n      ee2[-5] = (k11) * A4 + (k00) * A5;\n\n      k00     = ee0[-6] - ee2[-6];\n      k11     = ee0[-7] - ee2[-7];\n      ee0[-6] =  ee0[-6] + ee2[-6];\n      ee0[-7] =  ee0[-7] + ee2[-7];\n      ee2[-6] = (k00) * A6 - (k11) * A7;\n      ee2[-7] = (k11) * A6 + (k00) * A7;\n\n      ee0 -= k0;\n      ee2 -= k0;\n   }\n}\n\nstatic __forceinline void iter_54(float *z)\n{\n   float k00,k11,k22,k33;\n   float y0,y1,y2,y3;\n\n   k00  = z[ 0] - z[-4];\n   y0   = z[ 0] + z[-4];\n   y2   = z[-2] + z[-6];\n   k22  = z[-2] - z[-6];\n\n   z[-0] = y0 + y2;      // z0 + z4 + z2 + z6\n   z[-2] = y0 - y2;      // z0 + z4 - z2 - z6\n\n   // done with y0,y2\n\n   k33  = z[-3] - z[-7];\n\n   z[-4] = k00 + k33;    // z0 - z4 + z3 - z7\n   z[-6] = k00 - k33;    // z0 - z4 - z3 + z7\n\n   // done with k33\n\n   k11  = z[-1] - z[-5];\n   y1   = z[-1] + z[-5];\n   y3   = z[-3] + z[-7];\n\n   z[-1] = y1 + y3;      // z1 + z5 + z3 + z7\n   z[-3] = y1 - y3;      // z1 + z5 - z3 - z7\n   z[-5] = k11 - k22;    // z1 - z5 + z2 - z6\n   z[-7] = k11 + k22;    // z1 - z5 - z2 + z6\n}\n\nstatic void imdct_step3_inner_s_loop_ld654(int n, float *e, int i_off, float *A, int base_n)\n{\n   int a_off = base_n >> 3;\n   float A2 = A[0+a_off];\n   float *z = e + i_off;\n   float *base = z - 16 * n;\n\n   while (z > base) {\n      float k00,k11;\n      float l00,l11;\n\n      k00    = z[-0] - z[ -8];\n      k11    = z[-1] - z[ -9];\n      l00    = z[-2] - z[-10];\n      l11    = z[-3] - z[-11];\n      z[ -0] = z[-0] + z[ -8];\n      z[ -1] = z[-1] + z[ -9];\n      z[ -2] = z[-2] + z[-10];\n      z[ -3] = z[-3] + z[-11];\n      z[ -8] = k00;\n      z[ -9] = k11;\n      z[-10] = (l00+l11) * A2;\n      z[-11] = (l11-l00) * A2;\n\n      k00    = z[ -4] - z[-12];\n      k11    = z[ -5] - z[-13];\n      l00    = z[ -6] - z[-14];\n      l11    = z[ -7] - z[-15];\n      z[ -4] = z[ -4] + z[-12];\n      z[ -5] = z[ -5] + z[-13];\n      z[ -6] = z[ -6] + z[-14];\n      z[ -7] = z[ -7] + z[-15];\n      z[-12] = k11;\n      z[-13] = -k00;\n      z[-14] = (l11-l00) * A2;\n      z[-15] = (l00+l11) * -A2;\n\n      iter_54(z);\n      iter_54(z-8);\n      z -= 16;\n   }\n}\n\nstatic void inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int ld;\n   // @OPTIMIZE: reduce register pressure by using fewer variables?\n   int save_point = temp_alloc_save(f);\n   float *buf2 = (float *) temp_alloc(f, n2 * sizeof(*buf2));\n   float *u=NULL,*v=NULL;\n   // twiddle factors\n   float *A = f->A[blocktype];\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // See notes about bugs in that paper in less-optimal implementation 'inverse_mdct_old' after this function.\n\n   // kernel from paper\n\n\n   // merged:\n   //   copy and reflect spectral data\n   //   step 0\n\n   // note that it turns out that the items added together during\n   // this step are, in fact, being added to themselves (as reflected\n   // by step 0). inexplicable inefficiency! this became obvious\n   // once I combined the passes.\n\n   // so there's a missing 'times 2' here (for adding X to itself).\n   // this propagates through linearly to the end, where the numbers\n   // are 1/2 too small, and need to be compensated for.\n\n   {\n      float *d,*e, *AA, *e_stop;\n      d = &buf2[n2-2];\n      AA = A;\n      e = &buffer[0];\n      e_stop = &buffer[n2];\n      while (e != e_stop) {\n         d[1] = (e[0] * AA[0] - e[2]*AA[1]);\n         d[0] = (e[0] * AA[1] + e[2]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e += 4;\n      }\n\n      e = &buffer[n2-3];\n      while (d >= buf2) {\n         d[1] = (-e[2] * AA[0] - -e[0]*AA[1]);\n         d[0] = (-e[2] * AA[1] + -e[0]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e -= 4;\n      }\n   }\n\n   // now we use symbolic names for these, so that we can\n   // possibly swap their meaning as we change which operations\n   // are in place\n\n   u = buffer;\n   v = buf2;\n\n   // step 2    (paper output is w, now u)\n   // this could be in place, but the data ends up in the wrong\n   // place... _somebody_'s got to swap it, so this is nominated\n   {\n      float *AA = &A[n2-8];\n      float *d0,*d1, *e0, *e1;\n\n      e0 = &v[n4];\n      e1 = &v[0];\n\n      d0 = &u[n4];\n      d1 = &u[0];\n\n      while (AA >= A) {\n         float v40_20, v41_21;\n\n         v41_21 = e0[1] - e1[1];\n         v40_20 = e0[0] - e1[0];\n         d0[1]  = e0[1] + e1[1];\n         d0[0]  = e0[0] + e1[0];\n         d1[1]  = v41_21*AA[4] - v40_20*AA[5];\n         d1[0]  = v40_20*AA[4] + v41_21*AA[5];\n\n         v41_21 = e0[3] - e1[3];\n         v40_20 = e0[2] - e1[2];\n         d0[3]  = e0[3] + e1[3];\n         d0[2]  = e0[2] + e1[2];\n         d1[3]  = v41_21*AA[0] - v40_20*AA[1];\n         d1[2]  = v40_20*AA[0] + v41_21*AA[1];\n\n         AA -= 8;\n\n         d0 += 4;\n         d1 += 4;\n         e0 += 4;\n         e1 += 4;\n      }\n   }\n\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n\n   // optimized step 3:\n\n   // the original step3 loop can be nested r inside s or s inside r;\n   // it's written originally as s inside r, but this is dumb when r\n   // iterates many times, and s few. So I have two copies of it and\n   // switch between them halfway.\n\n   // this is iteration 0 of step 3\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*0, -(n >> 3), A);\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*1, -(n >> 3), A);\n\n   // this is iteration 1 of step 3\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*0, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*1, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*2, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*3, -(n >> 4), A, 16);\n\n   l=2;\n   for (; l < (ld-3)>>1; ++l) {\n      int k0 = n >> (l+2), k0_2 = k0>>1;\n      int lim = 1 << (l+1);\n      int i;\n      for (i=0; i < lim; ++i)\n         imdct_step3_inner_r_loop(n >> (l+4), u, n2-1 - k0*i, -k0_2, A, 1 << (l+3));\n   }\n\n   for (; l < ld-6; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3), k0_2 = k0>>1;\n      int rlim = n >> (l+6), r;\n      int lim = 1 << (l+1);\n      int i_off;\n      float *A0 = A;\n      i_off = n2-1;\n      for (r=rlim; r > 0; --r) {\n         imdct_step3_inner_s_loop(lim, u, i_off, -k0_2, A0, k1, k0);\n         A0 += k1*4;\n         i_off -= 8;\n      }\n   }\n\n   // iterations with count:\n   //   ld-6,-5,-4 all interleaved together\n   //       the big win comes from getting rid of needless flops\n   //         due to the constants on pass 5 & 4 being all 1 and 0;\n   //       combining them to be simultaneous to improve cache made little difference\n   imdct_step3_inner_s_loop_ld654(n >> 5, u, n2-1, A, n);\n\n   // output is u\n\n   // step 4, 5, and 6\n   // cannot be in-place because of step 5\n   {\n      uint16 *bitrev = f->bit_reverse[blocktype];\n      // weirdly, I'd have thought reading sequentially and writing\n      // erratically would have been better than vice-versa, but in\n      // fact that's not what my testing showed. (That is, with\n      // j = bitreverse(i), do you read i and write j, or read j and write i.)\n\n      float *d0 = &v[n4-4];\n      float *d1 = &v[n2-4];\n      while (d0 >= v) {\n         int k4;\n\n         k4 = bitrev[0];\n         d1[3] = u[k4+0];\n         d1[2] = u[k4+1];\n         d0[3] = u[k4+2];\n         d0[2] = u[k4+3];\n\n         k4 = bitrev[1];\n         d1[1] = u[k4+0];\n         d1[0] = u[k4+1];\n         d0[1] = u[k4+2];\n         d0[0] = u[k4+3];\n\n         d0 -= 4;\n         d1 -= 4;\n         bitrev += 2;\n      }\n   }\n   // (paper output is u, now v)\n\n\n   // data must be in buf2\n   assert(v == buf2);\n\n   // step 7   (paper output is v, now v)\n   // this is now in place\n   {\n      float *C = f->C[blocktype];\n      float *d, *e;\n\n      d = v;\n      e = v + n2 - 4;\n\n      while (d < e) {\n         float a02,a11,b0,b1,b2,b3;\n\n         a02 = d[0] - e[2];\n         a11 = d[1] + e[3];\n\n         b0 = C[1]*a02 + C[0]*a11;\n         b1 = C[1]*a11 - C[0]*a02;\n\n         b2 = d[0] + e[ 2];\n         b3 = d[1] - e[ 3];\n\n         d[0] = b2 + b0;\n         d[1] = b3 + b1;\n         e[2] = b2 - b0;\n         e[3] = b1 - b3;\n\n         a02 = d[2] - e[0];\n         a11 = d[3] + e[1];\n\n         b0 = C[3]*a02 + C[2]*a11;\n         b1 = C[3]*a11 - C[2]*a02;\n\n         b2 = d[2] + e[ 0];\n         b3 = d[3] - e[ 1];\n\n         d[2] = b2 + b0;\n         d[3] = b3 + b1;\n         e[0] = b2 - b0;\n         e[1] = b1 - b3;\n\n         C += 4;\n         d += 4;\n         e -= 4;\n      }\n   }\n\n   // data must be in buf2\n\n\n   // step 8+decode   (paper output is X, now buffer)\n   // this generates pairs of data a la 8 and pushes them directly through\n   // the decode kernel (pushing rather than pulling) to avoid having\n   // to make another pass later\n\n   // this cannot POSSIBLY be in place, so we refer to the buffers directly\n\n   {\n      float *d0,*d1,*d2,*d3;\n\n      float *B = f->B[blocktype] + n2 - 8;\n      float *e = buf2 + n2 - 8;\n      d0 = &buffer[0];\n      d1 = &buffer[n2-4];\n      d2 = &buffer[n2];\n      d3 = &buffer[n-4];\n      while (e >= v) {\n         float p0,p1,p2,p3;\n\n         p3 =  e[6]*B[7] - e[7]*B[6];\n         p2 = -e[6]*B[6] - e[7]*B[7];\n\n         d0[0] =   p3;\n         d1[3] = - p3;\n         d2[0] =   p2;\n         d3[3] =   p2;\n\n         p1 =  e[4]*B[5] - e[5]*B[4];\n         p0 = -e[4]*B[4] - e[5]*B[5];\n\n         d0[1] =   p1;\n         d1[2] = - p1;\n         d2[1] =   p0;\n         d3[2] =   p0;\n\n         p3 =  e[2]*B[3] - e[3]*B[2];\n         p2 = -e[2]*B[2] - e[3]*B[3];\n\n         d0[2] =   p3;\n         d1[1] = - p3;\n         d2[2] =   p2;\n         d3[1] =   p2;\n\n         p1 =  e[0]*B[1] - e[1]*B[0];\n         p0 = -e[0]*B[0] - e[1]*B[1];\n\n         d0[3] =   p1;\n         d1[0] = - p1;\n         d2[3] =   p0;\n         d3[0] =   p0;\n\n         B -= 8;\n         e -= 8;\n         d0 += 4;\n         d2 += 4;\n         d1 -= 4;\n         d3 -= 4;\n      }\n   }\n\n   temp_free(f,buf2);\n   temp_alloc_restore(f,save_point);\n}\n\n#if 0\n// this is the original version of the above code, if you want to optimize it from scratch\nvoid inverse_mdct_naive(float *buffer, int n)\n{\n   float s;\n   float A[1 << 12], B[1 << 12], C[1 << 11];\n   int i,k,k2,k4, n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int n3_4 = n - n4, ld;\n   // how can they claim this only uses N words?!\n   // oh, because they're only used sparsely, whoops\n   float u[1 << 13], X[1 << 13], v[1 << 13], w[1 << 13];\n   // set up twiddle factors\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2);\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2);\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // Note there are bugs in that pseudocode, presumably due to them attempting\n   // to rename the arrays nicely rather than representing the way their actual\n   // implementation bounces buffers back and forth. As a result, even in the\n   // \"some formulars corrected\" version, a direct implementation fails. These\n   // are noted below as \"paper bug\".\n\n   // copy and reflect spectral data\n   for (k=0; k < n2; ++k) u[k] = buffer[k];\n   for (   ; k < n ; ++k) u[k] = -buffer[n - k - 1];\n   // kernel from paper\n   // step 1\n   for (k=k2=k4=0; k < n4; k+=1, k2+=2, k4+=4) {\n      v[n-k4-1] = (u[k4] - u[n-k4-1]) * A[k2]   - (u[k4+2] - u[n-k4-3])*A[k2+1];\n      v[n-k4-3] = (u[k4] - u[n-k4-1]) * A[k2+1] + (u[k4+2] - u[n-k4-3])*A[k2];\n   }\n   // step 2\n   for (k=k4=0; k < n8; k+=1, k4+=4) {\n      w[n2+3+k4] = v[n2+3+k4] + v[k4+3];\n      w[n2+1+k4] = v[n2+1+k4] + v[k4+1];\n      w[k4+3]    = (v[n2+3+k4] - v[k4+3])*A[n2-4-k4] - (v[n2+1+k4]-v[k4+1])*A[n2-3-k4];\n      w[k4+1]    = (v[n2+1+k4] - v[k4+1])*A[n2-4-k4] + (v[n2+3+k4]-v[k4+3])*A[n2-3-k4];\n   }\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   for (l=0; l < ld-3; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3);\n      int rlim = n >> (l+4), r4, r;\n      int s2lim = 1 << (l+2), s2;\n      for (r=r4=0; r < rlim; r4+=4,++r) {\n         for (s2=0; s2 < s2lim; s2+=2) {\n            u[n-1-k0*s2-r4] = w[n-1-k0*s2-r4] + w[n-1-k0*(s2+1)-r4];\n            u[n-3-k0*s2-r4] = w[n-3-k0*s2-r4] + w[n-3-k0*(s2+1)-r4];\n            u[n-1-k0*(s2+1)-r4] = (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1]\n                                - (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1+1];\n            u[n-3-k0*(s2+1)-r4] = (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1]\n                                + (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1+1];\n         }\n      }\n      if (l+1 < ld-3) {\n         // paper bug: ping-ponging of u&w here is omitted\n         memcpy(w, u, sizeof(u));\n      }\n   }\n\n   // step 4\n   for (i=0; i < n8; ++i) {\n      int j = bit_reverse(i) >> (32-ld+3);\n      assert(j < n8);\n      if (i == j) {\n         // paper bug: original code probably swapped in place; if copying,\n         //            need to directly copy in this case\n         int i8 = i << 3;\n         v[i8+1] = u[i8+1];\n         v[i8+3] = u[i8+3];\n         v[i8+5] = u[i8+5];\n         v[i8+7] = u[i8+7];\n      } else if (i < j) {\n         int i8 = i << 3, j8 = j << 3;\n         v[j8+1] = u[i8+1], v[i8+1] = u[j8 + 1];\n         v[j8+3] = u[i8+3], v[i8+3] = u[j8 + 3];\n         v[j8+5] = u[i8+5], v[i8+5] = u[j8 + 5];\n         v[j8+7] = u[i8+7], v[i8+7] = u[j8 + 7];\n      }\n   }\n   // step 5\n   for (k=0; k < n2; ++k) {\n      w[k] = v[k*2+1];\n   }\n   // step 6\n   for (k=k2=k4=0; k < n8; ++k, k2 += 2, k4 += 4) {\n      u[n-1-k2] = w[k4];\n      u[n-2-k2] = w[k4+1];\n      u[n3_4 - 1 - k2] = w[k4+2];\n      u[n3_4 - 2 - k2] = w[k4+3];\n   }\n   // step 7\n   for (k=k2=0; k < n8; ++k, k2 += 2) {\n      v[n2 + k2 ] = ( u[n2 + k2] + u[n-2-k2] + C[k2+1]*(u[n2+k2]-u[n-2-k2]) + C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n-2 - k2] = ( u[n2 + k2] + u[n-2-k2] - C[k2+1]*(u[n2+k2]-u[n-2-k2]) - C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n2+1+ k2] = ( u[n2+1+k2] - u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n      v[n-1 - k2] = (-u[n2+1+k2] + u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n   }\n   // step 8\n   for (k=k2=0; k < n4; ++k,k2 += 2) {\n      X[k]      = v[k2+n2]*B[k2  ] + v[k2+1+n2]*B[k2+1];\n      X[n2-1-k] = v[k2+n2]*B[k2+1] - v[k2+1+n2]*B[k2  ];\n   }\n\n   // decode kernel to output\n   // determined the following value experimentally\n   // (by first figuring out what made inverse_mdct_slow work); then matching that here\n   // (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)\n   s = 0.5; // theoretically would be n4\n\n   // [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,\n   //     so it needs to use the \"old\" B values to behave correctly, or else\n   //     set s to 1.0 ]]]\n   for (i=0; i < n4  ; ++i) buffer[i] = s * X[i+n4];\n   for (   ; i < n3_4; ++i) buffer[i] = -s * X[n3_4 - i - 1];\n   for (   ; i < n   ; ++i) buffer[i] = -s * X[i - n3_4];\n}\n#endif\n\nstatic float *get_window(vorb *f, int len)\n{\n   len <<= 1;\n   if (len == f->blocksize_0) return f->window[0];\n   if (len == f->blocksize_1) return f->window[1];\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\ntypedef int16 YTYPE;\n#else\ntypedef int YTYPE;\n#endif\nstatic int do_floor(vorb *f, Mapping *map, int i, int n, float *target, YTYPE *finalY, uint8 *step2_flag)\n{\n   int n2 = n >> 1;\n   int s = map->chan[i].mux, floor;\n   floor = map->submap_floor[s];\n   if (f->floor_types[floor] == 0) {\n      return error(f, VORBIS_invalid_stream);\n   } else {\n      Floor1 *g = &f->floor_config[floor].floor1;\n      int j,q;\n      int lx = 0, ly = finalY[0] * g->floor1_multiplier;\n      for (q=1; q < g->values; ++q) {\n         j = g->sorted_order[q];\n         #ifndef STB_VORBIS_NO_DEFER_FLOOR\n         STBV_NOTUSED(step2_flag);\n         if (finalY[j] >= 0)\n         #else\n         if (step2_flag[j])\n         #endif\n         {\n            int hy = finalY[j] * g->floor1_multiplier;\n            int hx = g->Xlist[j];\n            if (lx != hx)\n               draw_line(target, lx,ly, hx,hy, n2);\n            CHECK(f);\n            lx = hx, ly = hy;\n         }\n      }\n      if (lx < n2) {\n         // optimization of: draw_line(target, lx,ly, n,ly, n2);\n         for (j=lx; j < n2; ++j)\n            LINE_OP(target[j], inverse_db_table[ly]);\n         CHECK(f);\n      }\n   }\n   return TRUE;\n}\n\n// The meaning of \"left\" and \"right\"\n//\n// For a given frame:\n//     we compute samples from 0..n\n//     window_center is n/2\n//     we'll window and mix the samples from left_start to left_end with data from the previous frame\n//     all of the samples from left_end to right_start can be output without mixing; however,\n//        this interval is 0-length except when transitioning between short and long frames\n//     all of the samples from right_start to right_end need to be mixed with the next frame,\n//        which we don't have, so those get saved in a buffer\n//     frame N's right_end-right_start, the number of samples to mix with the next frame,\n//        has to be the same as frame N+1's left_end-left_start (which they are by\n//        construction)\n\nstatic int vorbis_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   Mode *m;\n   int i, n, prev, next, window_center;\n   f->channel_buffer_start = f->channel_buffer_end = 0;\n\n  retry:\n   if (f->eof) return FALSE;\n   if (!maybe_start_packet(f))\n      return FALSE;\n   // check packet type\n   if (get_bits(f,1) != 0) {\n      if (IS_PUSH_MODE(f))\n         return error(f,VORBIS_bad_packet_type);\n      while (EOP != get8_packet(f));\n      goto retry;\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   i = get_bits(f, ilog(f->mode_count-1));\n   if (i == EOP) return FALSE;\n   if (i >= f->mode_count) return FALSE;\n   *mode = i;\n   m = f->mode_config + i;\n   if (m->blockflag) {\n      n = f->blocksize_1;\n      prev = get_bits(f,1);\n      next = get_bits(f,1);\n   } else {\n      prev = next = 0;\n      n = f->blocksize_0;\n   }\n\n// WINDOWING\n\n   window_center = n >> 1;\n   if (m->blockflag && !prev) {\n      *p_left_start = (n - f->blocksize_0) >> 2;\n      *p_left_end   = (n + f->blocksize_0) >> 2;\n   } else {\n      *p_left_start = 0;\n      *p_left_end   = window_center;\n   }\n   if (m->blockflag && !next) {\n      *p_right_start = (n*3 - f->blocksize_0) >> 2;\n      *p_right_end   = (n*3 + f->blocksize_0) >> 2;\n   } else {\n      *p_right_start = window_center;\n      *p_right_end   = n;\n   }\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet_rest(vorb *f, int *len, Mode *m, int left_start, int left_end, int right_start, int right_end, int *p_left)\n{\n   Mapping *map;\n   int i,j,k,n,n2;\n   int zero_channel[256];\n   int really_zero_channel[256];\n\n// WINDOWING\n\n   STBV_NOTUSED(left_end);\n   n = f->blocksize[m->blockflag];\n   map = &f->mapping[m->mapping];\n\n// FLOORS\n   n2 = n >> 1;\n\n   CHECK(f);\n\n   for (i=0; i < f->channels; ++i) {\n      int s = map->chan[i].mux, floor;\n      zero_channel[i] = FALSE;\n      floor = map->submap_floor[s];\n      if (f->floor_types[floor] == 0) {\n         return error(f, VORBIS_invalid_stream);\n      } else {\n         Floor1 *g = &f->floor_config[floor].floor1;\n         if (get_bits(f, 1)) {\n            short *finalY;\n            uint8 step2_flag[256];\n            static int range_list[4] = { 256, 128, 86, 64 };\n            int range = range_list[g->floor1_multiplier-1];\n            int offset = 2;\n            finalY = f->finalY[i];\n            finalY[0] = get_bits(f, ilog(range)-1);\n            finalY[1] = get_bits(f, ilog(range)-1);\n            for (j=0; j < g->partitions; ++j) {\n               int pclass = g->partition_class_list[j];\n               int cdim = g->class_dimensions[pclass];\n               int cbits = g->class_subclasses[pclass];\n               int csub = (1 << cbits)-1;\n               int cval = 0;\n               if (cbits) {\n                  Codebook *c = f->codebooks + g->class_masterbooks[pclass];\n                  DECODE(cval,f,c);\n               }\n               for (k=0; k < cdim; ++k) {\n                  int book = g->subclass_books[pclass][cval & csub];\n                  cval = cval >> cbits;\n                  if (book >= 0) {\n                     int temp;\n                     Codebook *c = f->codebooks + book;\n                     DECODE(temp,f,c);\n                     finalY[offset++] = temp;\n                  } else\n                     finalY[offset++] = 0;\n               }\n            }\n            if (f->valid_bits == INVALID_BITS) goto error; // behavior according to spec\n            step2_flag[0] = step2_flag[1] = 1;\n            for (j=2; j < g->values; ++j) {\n               int low, high, pred, highroom, lowroom, room, val;\n               low = g->neighbors[j][0];\n               high = g->neighbors[j][1];\n               //neighbors(g->Xlist, j, &low, &high);\n               pred = predict_point(g->Xlist[j], g->Xlist[low], g->Xlist[high], finalY[low], finalY[high]);\n               val = finalY[j];\n               highroom = range - pred;\n               lowroom = pred;\n               if (highroom < lowroom)\n                  room = highroom * 2;\n               else\n                  room = lowroom * 2;\n               if (val) {\n                  step2_flag[low] = step2_flag[high] = 1;\n                  step2_flag[j] = 1;\n                  if (val >= room)\n                     if (highroom > lowroom)\n                        finalY[j] = val - lowroom + pred;\n                     else\n                        finalY[j] = pred - val + highroom - 1;\n                  else\n                     if (val & 1)\n                        finalY[j] = pred - ((val+1)>>1);\n                     else\n                        finalY[j] = pred + (val>>1);\n               } else {\n                  step2_flag[j] = 0;\n                  finalY[j] = pred;\n               }\n            }\n\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n            do_floor(f, map, i, n, f->floor_buffers[i], finalY, step2_flag);\n#else\n            // defer final floor computation until _after_ residue\n            for (j=0; j < g->values; ++j) {\n               if (!step2_flag[j])\n                  finalY[j] = -1;\n            }\n#endif\n         } else {\n           error:\n            zero_channel[i] = TRUE;\n         }\n         // So we just defer everything else to later\n\n         // at this point we've decoded the floor into buffer\n      }\n   }\n   CHECK(f);\n   // at this point we've decoded all floors\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   // re-enable coupled channels if necessary\n   memcpy(really_zero_channel, zero_channel, sizeof(really_zero_channel[0]) * f->channels);\n   for (i=0; i < map->coupling_steps; ++i)\n      if (!zero_channel[map->chan[i].magnitude] || !zero_channel[map->chan[i].angle]) {\n         zero_channel[map->chan[i].magnitude] = zero_channel[map->chan[i].angle] = FALSE;\n      }\n\n   CHECK(f);\n// RESIDUE DECODE\n   for (i=0; i < map->submaps; ++i) {\n      float *residue_buffers[STB_VORBIS_MAX_CHANNELS];\n      int r;\n      uint8 do_not_decode[256];\n      int ch = 0;\n      for (j=0; j < f->channels; ++j) {\n         if (map->chan[j].mux == i) {\n            if (zero_channel[j]) {\n               do_not_decode[ch] = TRUE;\n               residue_buffers[ch] = NULL;\n            } else {\n               do_not_decode[ch] = FALSE;\n               residue_buffers[ch] = f->channel_buffers[j];\n            }\n            ++ch;\n         }\n      }\n      r = map->submap_residue[i];\n      decode_residue(f, residue_buffers, ch, n2, r, do_not_decode);\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   CHECK(f);\n\n// INVERSE COUPLING\n   for (i = map->coupling_steps-1; i >= 0; --i) {\n      int n2 = n >> 1;\n      float *m = f->channel_buffers[map->chan[i].magnitude];\n      float *a = f->channel_buffers[map->chan[i].angle    ];\n      for (j=0; j < n2; ++j) {\n         float a2,m2;\n         if (m[j] > 0)\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] - a[j];\n            else\n               a2 = m[j], m2 = m[j] + a[j];\n         else\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] + a[j];\n            else\n               a2 = m[j], m2 = m[j] - a[j];\n         m[j] = m2;\n         a[j] = a2;\n      }\n   }\n   CHECK(f);\n\n   // finish decoding the floors\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         do_floor(f, map, i, n, f->channel_buffers[i], f->finalY[i], NULL);\n      }\n   }\n#else\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         for (j=0; j < n2; ++j)\n            f->channel_buffers[i][j] *= f->floor_buffers[i][j];\n      }\n   }\n#endif\n\n// INVERSE MDCT\n   CHECK(f);\n   for (i=0; i < f->channels; ++i)\n      inverse_mdct(f->channel_buffers[i], n, f, m->blockflag);\n   CHECK(f);\n\n   // this shouldn't be necessary, unless we exited on an error\n   // and want to flush to get to the next packet\n   flush_packet(f);\n\n   if (f->first_decode) {\n      // assume we start so first non-discarded sample is sample 0\n      // this isn't to spec, but spec would require us to read ahead\n      // and decode the size of all current frames--could be done,\n      // but presumably it's not a commonly used feature\n      f->current_loc = 0u - n2; // start of first frame is positioned for discard (NB this is an intentional unsigned overflow/wrap-around)\n      // we might have to discard samples \"from\" the next frame too,\n      // if we're lapping a large block then a small at the start?\n      f->discard_samples_deferred = n - right_end;\n      f->current_loc_valid = TRUE;\n      f->first_decode = FALSE;\n   } else if (f->discard_samples_deferred) {\n      if (f->discard_samples_deferred >= right_start - left_start) {\n         f->discard_samples_deferred -= (right_start - left_start);\n         left_start = right_start;\n         *p_left = left_start;\n      } else {\n         left_start += f->discard_samples_deferred;\n         *p_left = left_start;\n         f->discard_samples_deferred = 0;\n      }\n   } else if (f->previous_length == 0 && f->current_loc_valid) {\n      // we're recovering from a seek... that means we're going to discard\n      // the samples from this packet even though we know our position from\n      // the last page header, so we need to update the position based on\n      // the discarded samples here\n      // but wait, the code below is going to add this in itself even\n      // on a discard, so we don't need to do it here...\n   }\n\n   // check if we have ogg information about the sample # for this packet\n   if (f->last_seg_which == f->end_seg_with_known_loc) {\n      // if we have a valid current loc, and this is final:\n      if (f->current_loc_valid && (f->page_flag & PAGEFLAG_last_page)) {\n         uint32 current_end = f->known_loc_for_packet;\n         // then let's infer the size of the (probably) short final frame\n         if (current_end < f->current_loc + (right_end-left_start)) {\n            if (current_end < f->current_loc) {\n               // negative truncation, that's impossible!\n               *len = 0;\n            } else {\n               *len = current_end - f->current_loc;\n            }\n            *len += left_start; // this doesn't seem right, but has no ill effect on my test files\n            if (*len > right_end) *len = right_end; // this should never happen\n            f->current_loc += *len;\n            return TRUE;\n         }\n      }\n      // otherwise, just set our sample loc\n      // guess that the ogg granule pos refers to the _middle_ of the\n      // last frame?\n      // set f->current_loc to the position of left_start\n      f->current_loc = f->known_loc_for_packet - (n2-left_start);\n      f->current_loc_valid = TRUE;\n   }\n   if (f->current_loc_valid)\n      f->current_loc += (right_start - left_start);\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   *len = right_end;  // ignore samples after the window goes to 0\n   CHECK(f);\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet(vorb *f, int *len, int *p_left, int *p_right)\n{\n   int mode, left_end, right_end;\n   if (!vorbis_decode_initial(f, p_left, &left_end, p_right, &right_end, &mode)) return 0;\n   return vorbis_decode_packet_rest(f, len, f->mode_config + mode, *p_left, left_end, *p_right, right_end, p_left);\n}\n\nstatic int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n{\n   int prev,i,j;\n   // we use right&left (the start of the right- and left-window sin()-regions)\n   // to determine how much to return, rather than inferring from the rules\n   // (same result, clearer code); 'left' indicates where our sin() window\n   // starts, therefore where the previous window's right edge starts, and\n   // therefore where to start mixing from the previous buffer. 'right'\n   // indicates where our sin() ending-window starts, therefore that's where\n   // we start saving, and where our returned-data ends.\n\n   // mixin from previous window\n   if (f->previous_length) {\n      int i,j, n = f->previous_length;\n      float *w = get_window(f, n);\n      if (w == NULL) return 0;\n      for (i=0; i < f->channels; ++i) {\n         for (j=0; j < n; ++j)\n            f->channel_buffers[i][left+j] =\n               f->channel_buffers[i][left+j]*w[    j] +\n               f->previous_window[i][     j]*w[n-1-j];\n      }\n   }\n\n   prev = f->previous_length;\n\n   // last half of this data becomes previous window\n   f->previous_length = len - right;\n\n   // @OPTIMIZE: could avoid this copy by double-buffering the\n   // output (flipping previous_window with channel_buffers), but\n   // then previous_window would have to be 2x as large, and\n   // channel_buffers couldn't be temp mem (although they're NOT\n   // currently temp mem, they could be (unless we want to level\n   // performance by spreading out the computation))\n   for (i=0; i < f->channels; ++i)\n      for (j=0; right+j < len; ++j)\n         f->previous_window[i][j] = f->channel_buffers[i][right+j];\n\n   if (!prev)\n      // there was no previous packet, so this data isn't valid...\n      // this isn't entirely true, only the would-have-overlapped data\n      // isn't valid, but this seems to be what the spec requires\n      return 0;\n\n   // truncate a short frame\n   if (len < right) right = len;\n\n   f->samples_output += right-left;\n\n   return right - left;\n}\n\nstatic int vorbis_pump_first_frame(stb_vorbis *f)\n{\n   int len, right, left, res;\n   res = vorbis_decode_packet(f, &len, &left, &right);\n   if (res)\n      vorbis_finish_frame(f, len, left, right);\n   return res;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\nstatic int is_whole_packet_present(stb_vorbis *f)\n{\n   // make sure that we have the packet available before continuing...\n   // this requires a full ogg parse, but we know we can fetch from f->stream\n\n   // instead of coding this out explicitly, we could save the current read state,\n   // read the next packet with get8() until end-of-packet, check f->eof, then\n   // reset the state? but that would be slower, esp. since we'd have over 256 bytes\n   // of state to restore (primarily the page segment table)\n\n   int s = f->next_seg, first = TRUE;\n   uint8 *p = f->stream;\n\n   if (s != -1) { // if we're not starting the packet with a 'continue on next page' flag\n      for (; s < f->segment_count; ++s) {\n         p += f->segments[s];\n         if (f->segments[s] < 255)               // stop at first short segment\n            break;\n      }\n      // either this continues, or it ends it...\n      if (s == f->segment_count)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   for (; s == -1;) {\n      uint8 *q;\n      int n;\n\n      // check that we have the page header ready\n      if (p + 26 >= f->stream_end)               return error(f, VORBIS_need_more_data);\n      // validate the page\n      if (memcmp(p, ogg_page_header, 4))         return error(f, VORBIS_invalid_stream);\n      if (p[4] != 0)                             return error(f, VORBIS_invalid_stream);\n      if (first) { // the first segment must NOT have 'continued_packet', later ones MUST\n         if (f->previous_length)\n            if ((p[5] & PAGEFLAG_continued_packet))  return error(f, VORBIS_invalid_stream);\n         // if no previous length, we're resynching, so we can come in on a continued-packet,\n         // which we'll just drop\n      } else {\n         if (!(p[5] & PAGEFLAG_continued_packet)) return error(f, VORBIS_invalid_stream);\n      }\n      n = p[26]; // segment counts\n      q = p+27;  // q points to segment table\n      p = q + n; // advance past header\n      // make sure we've read the segment table\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      for (s=0; s < n; ++s) {\n         p += q[s];\n         if (q[s] < 255)\n            break;\n      }\n      if (s == n)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   return TRUE;\n}\n#endif // !STB_VORBIS_NO_PUSHDATA_API\n\nstatic int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n   f->first_decode = TRUE;\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n\n   if (!next_segment(f))                            return FALSE;\n\n   if (get8_packet(f) != VORBIS_packet_comment)            return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n   //file vendor\n   len = get32_packet(f);\n   f->vendor = (char*)setup_malloc(f, sizeof(char) * (len+1));\n   if (f->vendor == NULL)                           return error(f, VORBIS_outofmem);\n   for(i=0; i < len; ++i) {\n      f->vendor[i] = get8_packet(f);\n   }\n   f->vendor[len] = (char)'\\0';\n   //user comments\n   f->comment_list_length = get32_packet(f);\n   f->comment_list = NULL;\n   if (f->comment_list_length > 0)\n   {\n      f->comment_list = (char**) setup_malloc(f, sizeof(char*) * (f->comment_list_length));\n      if (f->comment_list == NULL)                  return error(f, VORBIS_outofmem);\n   }\n\n   for(i=0; i < f->comment_list_length; ++i) {\n      len = get32_packet(f);\n      f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len+1));\n      if (f->comment_list[i] == NULL)               return error(f, VORBIS_outofmem);\n\n      for(j=0; j < len; ++j) {\n         f->comment_list[i][j] = get8_packet(f);\n      }\n      f->comment_list[i][len] = (char)'\\0';\n   }\n\n   // framing_flag\n   x = get8_packet(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_setup);\n\n\n   skip(f, f->bytes_in_seg);\n   f->bytes_in_seg = 0;\n\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            int values = lookup1_values(c->entries, c->dimensions);\n            if (values < 0) return error(f, VORBIS_invalid_setup);\n            c->lookup_values = (uint32) values;\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1;\n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = (int16)get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         //qsort(p, g->values, sizeof(p[0]), point_compare);\n         uint32 qsrt_swap = 0;\n         #define QSRT_LESS(i, y) (p[i].x < p[y].x)\n         #define QSRT_SWAP(i, j) qsrt_swap = p[i].x, p[i].x = p[j].x, p[j].x = qsrt_swap, qsrt_swap = p[i].id, p[i].id = p[j].id, p[j].id = qsrt_swap\n         QSORT(g->values, QSRT_LESS, QSRT_SWAP);\n         #undef QSRT_LESS\n         #undef QSRT_SWAP\n         //\n         for (j=0; j < g->values-1; ++j)\n            if (p[j].x == p[j+1].x)\n               return error(f, VORBIS_invalid_setup);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low = 0,hi = 0;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;\n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   // stb_vorbis_seek_start expects first_audio_page_offset to point to a page\n   // without PAGEFLAG_continued_packet, so this either points to the first page, or\n   // the page after the end of the headers. It might be cleaner to point to a page\n   // in the middle of the headers, when that's the page where the first audio packet\n   // starts, but we'd have to also correctly skip the end of any continued packet in\n   // stb_vorbis_seek_start.\n   if (f->next_seg == -1) {\n      f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n   } else {\n      f->first_audio_page_offset = 0;\n   }\n\n   return TRUE;\n}\n\nstatic void vorbis_deinit(stb_vorbis *p)\n{\n   int i,j;\n\n   setup_free(p, p->vendor);\n   for (i=0; i < p->comment_list_length; ++i) {\n      setup_free(p, p->comment_list[i]);\n   }\n   setup_free(p, p->comment_list);\n\n   if (p->residue_config) {\n      for (i=0; i < p->residue_count; ++i) {\n         Residue *r = p->residue_config+i;\n         if (r->classdata) {\n            for (j=0; j < p->codebooks[r->classbook].entries; ++j)\n               setup_free(p, r->classdata[j]);\n            setup_free(p, r->classdata);\n         }\n         setup_free(p, r->residue_books);\n      }\n   }\n\n   if (p->codebooks) {\n      CHECK(p);\n      for (i=0; i < p->codebook_count; ++i) {\n         Codebook *c = p->codebooks + i;\n         setup_free(p, c->codeword_lengths);\n         setup_free(p, c->multiplicands);\n         setup_free(p, c->codewords);\n         setup_free(p, c->sorted_codewords);\n         // c->sorted_values[-1] is the first entry in the array\n         setup_free(p, c->sorted_values ? c->sorted_values-1 : NULL);\n      }\n      setup_free(p, p->codebooks);\n   }\n   setup_free(p, p->floor_config);\n   setup_free(p, p->residue_config);\n   if (p->mapping) {\n      for (i=0; i < p->mapping_count; ++i)\n         setup_free(p, p->mapping[i].chan);\n      setup_free(p, p->mapping);\n   }\n   CHECK(p);\n   for (i=0; i < p->channels && i < STB_VORBIS_MAX_CHANNELS; ++i) {\n      setup_free(p, p->channel_buffers[i]);\n      setup_free(p, p->previous_window[i]);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      setup_free(p, p->floor_buffers[i]);\n      #endif\n      setup_free(p, p->finalY[i]);\n   }\n   for (i=0; i < 2; ++i) {\n      setup_free(p, p->A[i]);\n      setup_free(p, p->B[i]);\n      setup_free(p, p->C[i]);\n      setup_free(p, p->window[i]);\n      setup_free(p, p->bit_reverse[i]);\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (p->close_on_free) fclose(p->f);\n   #endif\n}\n\nvoid stb_vorbis_close(stb_vorbis *p)\n{\n   if (p == NULL) return;\n   vorbis_deinit(p);\n   setup_free(p,p);\n}\n\nstatic void vorbis_init(stb_vorbis *p, const stb_vorbis_alloc *z)\n{\n   memset(p, 0, sizeof(*p)); // NULL out all malloc'd pointers to start\n   if (z) {\n      p->alloc = *z;\n      p->alloc.alloc_buffer_length_in_bytes &= ~7;\n      p->temp_offset = p->alloc.alloc_buffer_length_in_bytes;\n   }\n   p->eof = 0;\n   p->error = VORBIS__no_error;\n   p->stream = NULL;\n   p->codebooks = NULL;\n   p->page_crc_tests = -1;\n   #ifndef STB_VORBIS_NO_STDIO\n   p->close_on_free = FALSE;\n   p->f = NULL;\n   #endif\n}\n\nint stb_vorbis_get_sample_offset(stb_vorbis *f)\n{\n   if (f->current_loc_valid)\n      return f->current_loc;\n   else\n      return -1;\n}\n\nstb_vorbis_info stb_vorbis_get_info(stb_vorbis *f)\n{\n   stb_vorbis_info d;\n   d.channels = f->channels;\n   d.sample_rate = f->sample_rate;\n   d.setup_memory_required = f->setup_memory_required;\n   d.setup_temp_memory_required = f->setup_temp_memory_required;\n   d.temp_memory_required = f->temp_memory_required;\n   d.max_frame_size = f->blocksize_1 >> 1;\n   return d;\n}\n\nstb_vorbis_comment stb_vorbis_get_comment(stb_vorbis *f)\n{\n   stb_vorbis_comment d;\n   d.vendor = f->vendor;\n   d.comment_list_length = f->comment_list_length;\n   d.comment_list = f->comment_list;\n   return d;\n}\n\nint stb_vorbis_get_error(stb_vorbis *f)\n{\n   int e = f->error;\n   f->error = VORBIS__no_error;\n   return e;\n}\n\nstatic stb_vorbis * vorbis_alloc(stb_vorbis *f)\n{\n   stb_vorbis *p = (stb_vorbis *) setup_malloc(f, sizeof(*p));\n   return p;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\nvoid stb_vorbis_flush_pushdata(stb_vorbis *f)\n{\n   f->previous_length = 0;\n   f->page_crc_tests  = 0;\n   f->discard_samples_deferred = 0;\n   f->current_loc_valid = FALSE;\n   f->first_decode = FALSE;\n   f->samples_output = 0;\n   f->channel_buffer_start = 0;\n   f->channel_buffer_end = 0;\n}\n\nstatic int vorbis_search_for_page_pushdata(vorb *f, uint8 *data, int data_len)\n{\n   int i,n;\n   for (i=0; i < f->page_crc_tests; ++i)\n      f->scan[i].bytes_done = 0;\n\n   // if we have room for more scans, search for them first, because\n   // they may cause us to stop early if their header is incomplete\n   if (f->page_crc_tests < STB_VORBIS_PUSHDATA_CRC_COUNT) {\n      if (data_len < 4) return 0;\n      data_len -= 3; // need to look for 4-byte sequence, so don't miss\n                     // one that straddles a boundary\n      for (i=0; i < data_len; ++i) {\n         if (data[i] == 0x4f) {\n            if (0==memcmp(data+i, ogg_page_header, 4)) {\n               int j,len;\n               uint32 crc;\n               // make sure we have the whole page header\n               if (i+26 >= data_len || i+27+data[i+26] >= data_len) {\n                  // only read up to this page start, so hopefully we'll\n                  // have the whole page header start next time\n                  data_len = i;\n                  break;\n               }\n               // ok, we have it all; compute the length of the page\n               len = 27 + data[i+26];\n               for (j=0; j < data[i+26]; ++j)\n                  len += data[i+27+j];\n               // scan everything up to the embedded crc (which we must 0)\n               crc = 0;\n               for (j=0; j < 22; ++j)\n                  crc = crc32_update(crc, data[i+j]);\n               // now process 4 0-bytes\n               for (   ; j < 26; ++j)\n                  crc = crc32_update(crc, 0);\n               // len is the total number of bytes we need to scan\n               n = f->page_crc_tests++;\n               f->scan[n].bytes_left = len-j;\n               f->scan[n].crc_so_far = crc;\n               f->scan[n].goal_crc = data[i+22] + (data[i+23] << 8) + (data[i+24]<<16) + (data[i+25]<<24);\n               // if the last frame on a page is continued to the next, then\n               // we can't recover the sample_loc immediately\n               if (data[i+27+data[i+26]-1] == 255)\n                  f->scan[n].sample_loc = ~0;\n               else\n                  f->scan[n].sample_loc = data[i+6] + (data[i+7] << 8) + (data[i+ 8]<<16) + (data[i+ 9]<<24);\n               f->scan[n].bytes_done = i+j;\n               if (f->page_crc_tests == STB_VORBIS_PUSHDATA_CRC_COUNT)\n                  break;\n               // keep going if we still have room for more\n            }\n         }\n      }\n   }\n\n   for (i=0; i < f->page_crc_tests;) {\n      uint32 crc;\n      int j;\n      int n = f->scan[i].bytes_done;\n      int m = f->scan[i].bytes_left;\n      if (m > data_len - n) m = data_len - n;\n      // m is the bytes to scan in the current chunk\n      crc = f->scan[i].crc_so_far;\n      for (j=0; j < m; ++j)\n         crc = crc32_update(crc, data[n+j]);\n      f->scan[i].bytes_left -= m;\n      f->scan[i].crc_so_far = crc;\n      if (f->scan[i].bytes_left == 0) {\n         // does it match?\n         if (f->scan[i].crc_so_far == f->scan[i].goal_crc) {\n            // Houston, we have page\n            data_len = n+m; // consumption amount is wherever that scan ended\n            f->page_crc_tests = -1; // drop out of page scan mode\n            f->previous_length = 0; // decode-but-don't-output one frame\n            f->next_seg = -1;       // start a new page\n            f->current_loc = f->scan[i].sample_loc; // set the current sample location\n                                    // to the amount we'd have decoded had we decoded this page\n            f->current_loc_valid = f->current_loc != ~0U;\n            return data_len;\n         }\n         // delete entry\n         f->scan[i] = f->scan[--f->page_crc_tests];\n      } else {\n         ++i;\n      }\n   }\n\n   return data_len;\n}\n\n// return value: number of bytes we used\nint stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,                   // the file we're decoding\n         const uint8 *data, int data_len, // the memory available for decoding\n         int *channels,                   // place to write number of float * buffers\n         float ***output,                 // place to write float ** array of float * buffers\n         int *samples                     // place to write number of output samples\n     )\n{\n   int i;\n   int len,right,left;\n\n   if (!IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (f->page_crc_tests >= 0) {\n      *samples = 0;\n      return vorbis_search_for_page_pushdata(f, (uint8 *) data, data_len);\n   }\n\n   f->stream     = (uint8 *) data;\n   f->stream_end = (uint8 *) data + data_len;\n   f->error      = VORBIS__no_error;\n\n   // check that we have the entire packet in memory\n   if (!is_whole_packet_present(f)) {\n      *samples = 0;\n      return 0;\n   }\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      // save the actual error we encountered\n      enum STBVorbisError error = f->error;\n      if (error == VORBIS_bad_packet_type) {\n         // flush and resynch\n         f->error = VORBIS__no_error;\n         while (get8_packet(f) != EOP)\n            if (f->eof) break;\n         *samples = 0;\n         return (int) (f->stream - data);\n      }\n      if (error == VORBIS_continued_packet_flag_invalid) {\n         if (f->previous_length == 0) {\n            // we may be resynching, in which case it's ok to hit one\n            // of these; just discard the packet\n            f->error = VORBIS__no_error;\n            while (get8_packet(f) != EOP)\n               if (f->eof) break;\n            *samples = 0;\n            return (int) (f->stream - data);\n         }\n      }\n      // if we get an error while parsing, what to do?\n      // well, it DEFINITELY won't work to continue from where we are!\n      stb_vorbis_flush_pushdata(f);\n      // restore the error that actually made us bail\n      f->error = error;\n      *samples = 0;\n      return 1;\n   }\n\n   // success!\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   if (channels) *channels = f->channels;\n   *samples = len;\n   *output = f->outputs;\n   return (int) (f->stream - data);\n}\n\nstb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char *data, int data_len, // the memory available for decoding\n         int *data_used,              // only defined if result is not NULL\n         int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.stream     = (uint8 *) data;\n   p.stream_end = (uint8 *) data + data_len;\n   p.push_mode  = TRUE;\n   if (!start_decoder(&p)) {\n      if (p.eof)\n         *error = VORBIS_need_more_data;\n      else\n         *error = p.error;\n      vorbis_deinit(&p);\n      return NULL;\n   }\n   f = vorbis_alloc(&p);\n   if (f) {\n      *f = p;\n      *data_used = (int) (f->stream - data);\n      *error = 0;\n      return f;\n   } else {\n      vorbis_deinit(&p);\n      return NULL;\n   }\n}\n#endif // STB_VORBIS_NO_PUSHDATA_API\n\nunsigned int stb_vorbis_get_file_offset(stb_vorbis *f)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   if (USE_MEMORY(f)) return (unsigned int) (f->stream - f->stream_start);\n   #ifndef STB_VORBIS_NO_STDIO\n   return (unsigned int) (ftell(f->f) - f->f_start);\n   #endif\n}\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n//\n// DATA-PULLING API\n//\n\nstatic uint32 vorbis_find_page(stb_vorbis *f, uint32 *end, uint32 *last)\n{\n   for(;;) {\n      int n;\n      if (f->eof) return 0;\n      n = get8(f);\n      if (n == 0x4f) { // page header candidate\n         unsigned int retry_loc = stb_vorbis_get_file_offset(f);\n         int i;\n         // check if we're off the end of a file_section stream\n         if (retry_loc - 25 > f->stream_len)\n            return 0;\n         // check the rest of the header\n         for (i=1; i < 4; ++i)\n            if (get8(f) != ogg_page_header[i])\n               break;\n         if (f->eof) return 0;\n         if (i == 4) {\n            uint8 header[27];\n            uint32 i, crc, goal, len;\n            for (i=0; i < 4; ++i)\n               header[i] = ogg_page_header[i];\n            for (; i < 27; ++i)\n               header[i] = get8(f);\n            if (f->eof) return 0;\n            if (header[4] != 0) goto invalid;\n            goal = header[22] + (header[23] << 8) + (header[24]<<16) + ((uint32)header[25]<<24);\n            for (i=22; i < 26; ++i)\n               header[i] = 0;\n            crc = 0;\n            for (i=0; i < 27; ++i)\n               crc = crc32_update(crc, header[i]);\n            len = 0;\n            for (i=0; i < header[26]; ++i) {\n               int s = get8(f);\n               crc = crc32_update(crc, s);\n               len += s;\n            }\n            if (len && f->eof) return 0;\n            for (i=0; i < len; ++i)\n               crc = crc32_update(crc, get8(f));\n            // finished parsing probable page\n            if (crc == goal) {\n               // we could now check that it's either got the last\n               // page flag set, OR it's followed by the capture\n               // pattern, but I guess TECHNICALLY you could have\n               // a file with garbage between each ogg page and recover\n               // from it automatically? So even though that paranoia\n               // might decrease the chance of an invalid decode by\n               // another 2^32, not worth it since it would hose those\n               // invalid-but-useful files?\n               if (end)\n                  *end = stb_vorbis_get_file_offset(f);\n               if (last) {\n                  if (header[5] & 0x04)\n                     *last = 1;\n                  else\n                     *last = 0;\n               }\n               set_file_offset(f, retry_loc-1);\n               return 1;\n            }\n         }\n        invalid:\n         // not a valid page, so rewind and look for next one\n         set_file_offset(f, retry_loc);\n      }\n   }\n}\n\n\n#define SAMPLE_unknown  0xffffffff\n\n// seeking is implemented with a binary search, which narrows down the range to\n// 64K, before using a linear search (because finding the synchronization\n// pattern can be expensive, and the chance we'd find the end page again is\n// relatively high for small ranges)\n//\n// two initial interpolation-style probes are used at the start of the search\n// to try to bound either side of the binary search sensibly, while still\n// working in O(log n) time if they fail.\n\nstatic int get_seek_page_info(stb_vorbis *f, ProbedPage *z)\n{\n   uint8 header[27], lacing[255];\n   int i,len;\n\n   // record where the page starts\n   z->page_start = stb_vorbis_get_file_offset(f);\n\n   // parse the header\n   getn(f, header, 27);\n   if (header[0] != 'O' || header[1] != 'g' || header[2] != 'g' || header[3] != 'S')\n      return 0;\n   getn(f, lacing, header[26]);\n\n   // determine the length of the payload\n   len = 0;\n   for (i=0; i < header[26]; ++i)\n      len += lacing[i];\n\n   // this implies where the page ends\n   z->page_end = z->page_start + 27 + header[26] + len;\n\n   // read the last-decoded sample out of the data\n   z->last_decoded_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);\n\n   // restore file state to where we were\n   set_file_offset(f, z->page_start);\n   return 1;\n}\n\n// rarely used function to seek back to the preceding page while finding the\n// start of a packet\nstatic int go_to_page_before(stb_vorbis *f, unsigned int limit_offset)\n{\n   unsigned int previous_safe, end;\n\n   // now we want to seek back 64K from the limit\n   if (limit_offset >= 65536 && limit_offset-65536 >= f->first_audio_page_offset)\n      previous_safe = limit_offset - 65536;\n   else\n      previous_safe = f->first_audio_page_offset;\n\n   set_file_offset(f, previous_safe);\n\n   while (vorbis_find_page(f, &end, NULL)) {\n      if (end >= limit_offset && stb_vorbis_get_file_offset(f) < limit_offset)\n         return 1;\n      set_file_offset(f, end);\n   }\n\n   return 0;\n}\n\n// implements the search logic for finding a page and starting decoding. if\n// the function succeeds, current_loc_valid will be true and current_loc will\n// be less than or equal to the provided sample number (the closer the\n// better).\nstatic int seek_to_sample_coarse(stb_vorbis *f, uint32 sample_number)\n{\n   ProbedPage left, right, mid;\n   int i, start_seg_with_known_loc, end_pos, page_start;\n   uint32 delta, stream_length, padding, last_sample_limit;\n   double offset = 0.0, bytes_per_sample = 0.0;\n   int probe = 0;\n\n   // find the last page and validate the target sample\n   stream_length = stb_vorbis_stream_length_in_samples(f);\n   if (stream_length == 0)            return error(f, VORBIS_seek_without_length);\n   if (sample_number > stream_length) return error(f, VORBIS_seek_invalid);\n\n   // this is the maximum difference between the window-center (which is the\n   // actual granule position value), and the right-start (which the spec\n   // indicates should be the granule position (give or take one)).\n   padding = ((f->blocksize_1 - f->blocksize_0) >> 2);\n   if (sample_number < padding)\n      last_sample_limit = 0;\n   else\n      last_sample_limit = sample_number - padding;\n\n   left = f->p_first;\n   while (left.last_decoded_sample == ~0U) {\n      // (untested) the first page does not have a 'last_decoded_sample'\n      set_file_offset(f, left.page_end);\n      if (!get_seek_page_info(f, &left)) goto error;\n   }\n\n   right = f->p_last;\n   assert(right.last_decoded_sample != ~0U);\n\n   // starting from the start is handled differently\n   if (last_sample_limit <= left.last_decoded_sample) {\n      if (stb_vorbis_seek_start(f)) {\n         if (f->current_loc > sample_number)\n            return error(f, VORBIS_seek_failed);\n         return 1;\n      }\n      return 0;\n   }\n\n   while (left.page_end != right.page_start) {\n      assert(left.page_end < right.page_start);\n      // search range in bytes\n      delta = right.page_start - left.page_end;\n      if (delta <= 65536) {\n         // there's only 64K left to search - handle it linearly\n         set_file_offset(f, left.page_end);\n      } else {\n         if (probe < 2) {\n            if (probe == 0) {\n               // first probe (interpolate)\n               double data_bytes = right.page_end - left.page_start;\n               bytes_per_sample = data_bytes / right.last_decoded_sample;\n               offset = left.page_start + bytes_per_sample * (last_sample_limit - left.last_decoded_sample);\n            } else {\n               // second probe (try to bound the other side)\n               double error = ((double) last_sample_limit - mid.last_decoded_sample) * bytes_per_sample;\n               if (error >= 0 && error <  8000) error =  8000;\n               if (error <  0 && error > -8000) error = -8000;\n               offset += error * 2;\n            }\n\n            // ensure the offset is valid\n            if (offset < left.page_end)\n               offset = left.page_end;\n            if (offset > right.page_start - 65536)\n               offset = right.page_start - 65536;\n\n            set_file_offset(f, (unsigned int) offset);\n         } else {\n            // binary search for large ranges (offset by 32K to ensure\n            // we don't hit the right page)\n            set_file_offset(f, left.page_end + (delta / 2) - 32768);\n         }\n\n         if (!vorbis_find_page(f, NULL, NULL)) goto error;\n      }\n\n      for (;;) {\n         if (!get_seek_page_info(f, &mid)) goto error;\n         if (mid.last_decoded_sample != ~0U) break;\n         // (untested) no frames end on this page\n         set_file_offset(f, mid.page_end);\n         assert(mid.page_start < right.page_start);\n      }\n\n      // if we've just found the last page again then we're in a tricky file,\n      // and we're close enough (if it wasn't an interpolation probe).\n      if (mid.page_start == right.page_start) {\n         if (probe >= 2 || delta <= 65536)\n            break;\n      } else {\n         if (last_sample_limit < mid.last_decoded_sample)\n            right = mid;\n         else\n            left = mid;\n      }\n\n      ++probe;\n   }\n\n   // seek back to start of the last packet\n   page_start = left.page_start;\n   set_file_offset(f, page_start);\n   if (!start_page(f)) return error(f, VORBIS_seek_failed);\n   end_pos = f->end_seg_with_known_loc;\n   assert(end_pos >= 0);\n\n   for (;;) {\n      for (i = end_pos; i > 0; --i)\n         if (f->segments[i-1] != 255)\n            break;\n\n      start_seg_with_known_loc = i;\n\n      if (start_seg_with_known_loc > 0 || !(f->page_flag & PAGEFLAG_continued_packet))\n         break;\n\n      // (untested) the final packet begins on an earlier page\n      if (!go_to_page_before(f, page_start))\n         goto error;\n\n      page_start = stb_vorbis_get_file_offset(f);\n      if (!start_page(f)) goto error;\n      end_pos = f->segment_count - 1;\n   }\n\n   // prepare to start decoding\n   f->current_loc_valid = FALSE;\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   f->previous_length = 0;\n   f->next_seg = start_seg_with_known_loc;\n\n   for (i = 0; i < start_seg_with_known_loc; i++)\n      skip(f, f->segments[i]);\n\n   // start decoding (optimizable - this frame is generally discarded)\n   if (!vorbis_pump_first_frame(f))\n      return 0;\n   if (f->current_loc > sample_number)\n      return error(f, VORBIS_seek_failed);\n   return 1;\n\nerror:\n   // try to restore the file to a valid state\n   stb_vorbis_seek_start(f);\n   return error(f, VORBIS_seek_failed);\n}\n\n// the same as vorbis_decode_initial, but without advancing\nstatic int peek_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   int bits_read, bytes_read;\n\n   if (!vorbis_decode_initial(f, p_left_start, p_left_end, p_right_start, p_right_end, mode))\n      return 0;\n\n   // either 1 or 2 bytes were read, figure out which so we can rewind\n   bits_read = 1 + ilog(f->mode_count-1);\n   if (f->mode_config[*mode].blockflag)\n      bits_read += 2;\n   bytes_read = (bits_read + 7) / 8;\n\n   f->bytes_in_seg += bytes_read;\n   f->packet_bytes -= bytes_read;\n   skip(f, -bytes_read);\n   if (f->next_seg == -1)\n      f->next_seg = f->segment_count - 1;\n   else\n      f->next_seg--;\n   f->valid_bits = 0;\n\n   return 1;\n}\n\nint stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number)\n{\n   uint32 max_frame_samples;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   // fast page-level search\n   if (!seek_to_sample_coarse(f, sample_number))\n      return 0;\n\n   assert(f->current_loc_valid);\n   assert(f->current_loc <= sample_number);\n\n   // linear search for the relevant packet\n   max_frame_samples = (f->blocksize_1*3 - f->blocksize_0) >> 2;\n   while (f->current_loc < sample_number) {\n      int left_start, left_end, right_start, right_end, mode, frame_samples;\n      if (!peek_decode_initial(f, &left_start, &left_end, &right_start, &right_end, &mode))\n         return error(f, VORBIS_seek_failed);\n      // calculate the number of samples returned by the next frame\n      frame_samples = right_start - left_start;\n      if (f->current_loc + frame_samples > sample_number) {\n         return 1; // the next frame will contain the sample\n      } else if (f->current_loc + frame_samples + max_frame_samples > sample_number) {\n         // there's a chance the frame after this could contain the sample\n         vorbis_pump_first_frame(f);\n      } else {\n         // this frame is too early to be relevant\n         f->current_loc += frame_samples;\n         f->previous_length = 0;\n         maybe_start_packet(f);\n         flush_packet(f);\n      }\n   }\n   // the next frame should start with the sample\n   if (f->current_loc != sample_number) return error(f, VORBIS_seek_failed);\n   return 1;\n}\n\nint stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number)\n{\n   if (!stb_vorbis_seek_frame(f, sample_number))\n      return 0;\n\n   if (sample_number != f->current_loc) {\n      int n;\n      uint32 frame_start = f->current_loc;\n      stb_vorbis_get_frame_float(f, &n, NULL);\n      assert(sample_number > frame_start);\n      assert(f->channel_buffer_start + (int) (sample_number-frame_start) <= f->channel_buffer_end);\n      f->channel_buffer_start += (sample_number - frame_start);\n   }\n\n   return 1;\n}\n\nint stb_vorbis_seek_start(stb_vorbis *f)\n{\n   if (IS_PUSH_MODE(f)) { return error(f, VORBIS_invalid_api_mixing); }\n   set_file_offset(f, f->first_audio_page_offset);\n   f->previous_length = 0;\n   f->first_decode = TRUE;\n   f->next_seg = -1;\n   return vorbis_pump_first_frame(f);\n}\n\nunsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f)\n{\n   unsigned int restore_offset, previous_safe;\n   unsigned int end, last_page_loc;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n   if (!f->total_samples) {\n      unsigned int last;\n      uint32 lo,hi;\n      char header[6];\n\n      // first, store the current decode position so we can restore it\n      restore_offset = stb_vorbis_get_file_offset(f);\n\n      // now we want to seek back 64K from the end (the last page must\n      // be at most a little less than 64K, but let's allow a little slop)\n      if (f->stream_len >= 65536 && f->stream_len-65536 >= f->first_audio_page_offset)\n         previous_safe = f->stream_len - 65536;\n      else\n         previous_safe = f->first_audio_page_offset;\n\n      set_file_offset(f, previous_safe);\n      // previous_safe is now our candidate 'earliest known place that seeking\n      // to will lead to the final page'\n\n      if (!vorbis_find_page(f, &end, &last)) {\n         // if we can't find a page, we're hosed!\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = 0xffffffff;\n         goto done;\n      }\n\n      // check if there are more pages\n      last_page_loc = stb_vorbis_get_file_offset(f);\n\n      // stop when the last_page flag is set, not when we reach eof;\n      // this allows us to stop short of a 'file_section' end without\n      // explicitly checking the length of the section\n      while (!last) {\n         set_file_offset(f, end);\n         if (!vorbis_find_page(f, &end, &last)) {\n            // the last page we found didn't have the 'last page' flag\n            // set. whoops!\n            break;\n         }\n         //previous_safe = last_page_loc+1; // NOTE: not used after this point, but note for debugging\n         last_page_loc = stb_vorbis_get_file_offset(f);\n      }\n\n      set_file_offset(f, last_page_loc);\n\n      // parse the header\n      getn(f, (unsigned char *)header, 6);\n      // extract the absolute granule position\n      lo = get32(f);\n      hi = get32(f);\n      if (lo == 0xffffffff && hi == 0xffffffff) {\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = SAMPLE_unknown;\n         goto done;\n      }\n      if (hi)\n         lo = 0xfffffffe; // saturate\n      f->total_samples = lo;\n\n      f->p_last.page_start = last_page_loc;\n      f->p_last.page_end   = end;\n      f->p_last.last_decoded_sample = lo;\n\n     done:\n      set_file_offset(f, restore_offset);\n   }\n   return f->total_samples == SAMPLE_unknown ? 0 : f->total_samples;\n}\n\nfloat stb_vorbis_stream_length_in_seconds(stb_vorbis *f)\n{\n   return stb_vorbis_stream_length_in_samples(f) / (float) f->sample_rate;\n}\n\n\n\nint stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output)\n{\n   int len, right,left,i;\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      f->channel_buffer_start = f->channel_buffer_end = 0;\n      return 0;\n   }\n\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   f->channel_buffer_start = left;\n   f->channel_buffer_end   = left+len;\n\n   if (channels) *channels = f->channels;\n   if (output)   *output = f->outputs;\n   return len;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_file_section(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc, unsigned int length)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.f = file;\n   p.f_start = (uint32) ftell(file);\n   p.stream_len   = length;\n   p.close_on_free = close_on_free;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\nstb_vorbis * stb_vorbis_open_file(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc)\n{\n   unsigned int len, start;\n   start = (unsigned int) ftell(file);\n   fseek(file, 0, SEEK_END);\n   len = (unsigned int) (ftell(file) - start);\n   fseek(file, start, SEEK_SET);\n   return stb_vorbis_open_file_section(file, close_on_free, error, alloc, len);\n}\n\nstb_vorbis * stb_vorbis_open_filename(const char *filename, int *error, const stb_vorbis_alloc *alloc)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   if (0 != fopen_s(&f, filename, \"rb\"))\n      f = NULL;\n#else\n   f = fopen(filename, \"rb\");\n#endif\n   if (f)\n      return stb_vorbis_open_file(f, TRUE, error, alloc);\n   if (error) *error = VORBIS_file_open_failure;\n   return NULL;\n}\n#endif // STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len, int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   if (!data) {\n      if (error) *error = VORBIS_unexpected_eof;\n      return NULL;\n   }\n   vorbis_init(&p, alloc);\n   p.stream = (uint8 *) data;\n   p.stream_end = (uint8 *) data + len;\n   p.stream_start = (uint8 *) p.stream;\n   p.stream_len = len;\n   p.push_mode = FALSE;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         if (error) *error = VORBIS__no_error;\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#define PLAYBACK_MONO     1\n#define PLAYBACK_LEFT     2\n#define PLAYBACK_RIGHT    4\n\n#define L  (PLAYBACK_LEFT  | PLAYBACK_MONO)\n#define C  (PLAYBACK_LEFT  | PLAYBACK_RIGHT | PLAYBACK_MONO)\n#define R  (PLAYBACK_RIGHT | PLAYBACK_MONO)\n\nstatic int8 channel_position[7][6] =\n{\n   { 0 },\n   { C },\n   { L, R },\n   { L, C, R },\n   { L, R, L, R },\n   { L, C, R, L, R },\n   { L, C, R, L, R, C },\n};\n\n\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n   typedef union {\n      float f;\n      int i;\n   } float_conv;\n   typedef char stb_vorbis_float_size_test[sizeof(float)==4 && sizeof(int) == 4];\n   #define FASTDEF(x) float_conv x\n   // add (1<<23) to convert to int, then divide by 2^SHIFT, then add 0.5/2^SHIFT to round\n   #define MAGIC(SHIFT) (1.5f * (1 << (23-SHIFT)) + 0.5f/(1 << SHIFT))\n   #define ADDEND(SHIFT) (((150-SHIFT) << 23) + (1 << 22))\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) (temp.f = (x) + MAGIC(s), temp.i - ADDEND(s))\n   #define check_endianness()\n#else\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) ((int) ((x) * (1 << (s))))\n   #define check_endianness()\n   #define FASTDEF(x)\n#endif\n\nstatic void copy_samples(short *dest, float *src, int len)\n{\n   int i;\n   check_endianness();\n   for (i=0; i < len; ++i) {\n      FASTDEF(temp);\n      int v = FAST_SCALED_FLOAT_TO_INT(temp, src[i],15);\n      if ((unsigned int) (v + 32768) > 65535)\n         v = v < 0 ? -32768 : 32767;\n      dest[i] = v;\n   }\n}\n\nstatic void compute_samples(int mask, short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define STB_BUFFER_SIZE  32\n   float buffer[STB_BUFFER_SIZE];\n   int i,j,o,n = STB_BUFFER_SIZE;\n   check_endianness();\n   for (o = 0; o < len; o += STB_BUFFER_SIZE) {\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         if (channel_position[num_c][j] & mask) {\n            for (i=0; i < n; ++i)\n               buffer[i] += data[j][d_offset+o+i];\n         }\n      }\n      for (i=0; i < n; ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o+i] = v;\n      }\n   }\n   #undef STB_BUFFER_SIZE\n}\n\nstatic void compute_stereo_samples(short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define STB_BUFFER_SIZE  32\n   float buffer[STB_BUFFER_SIZE];\n   int i,j,o,n = STB_BUFFER_SIZE >> 1;\n   // o is the offset in the source data\n   check_endianness();\n   for (o = 0; o < len; o += STB_BUFFER_SIZE >> 1) {\n      // o2 is the offset in the output data\n      int o2 = o << 1;\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         int m = channel_position[num_c][j] & (PLAYBACK_LEFT | PLAYBACK_RIGHT);\n         if (m == (PLAYBACK_LEFT | PLAYBACK_RIGHT)) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_LEFT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_RIGHT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         }\n      }\n      for (i=0; i < (n<<1); ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o2+i] = v;\n      }\n   }\n   #undef STB_BUFFER_SIZE\n}\n\nstatic void convert_samples_short(int buf_c, short **buffer, int b_offset, int data_c, float **data, int d_offset, int samples)\n{\n   int i;\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      static int channel_selector[3][2] = { {0}, {PLAYBACK_MONO}, {PLAYBACK_LEFT, PLAYBACK_RIGHT} };\n      for (i=0; i < buf_c; ++i)\n         compute_samples(channel_selector[buf_c][i], buffer[i]+b_offset, data_c, data, d_offset, samples);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      for (i=0; i < limit; ++i)\n         copy_samples(buffer[i]+b_offset, data[i]+d_offset, samples);\n      for (   ; i < buf_c; ++i)\n         memset(buffer[i]+b_offset, 0, sizeof(short) * samples);\n   }\n}\n\nint stb_vorbis_get_frame_short(stb_vorbis *f, int num_c, short **buffer, int num_samples)\n{\n   float **output = NULL;\n   int len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len > num_samples) len = num_samples;\n   if (len)\n      convert_samples_short(num_c, buffer, 0, f->channels, output, 0, len);\n   return len;\n}\n\nstatic void convert_channels_short_interleaved(int buf_c, short *buffer, int data_c, float **data, int d_offset, int len)\n{\n   int i;\n   check_endianness();\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      assert(buf_c == 2);\n      for (i=0; i < buf_c; ++i)\n         compute_stereo_samples(buffer, data_c, data, d_offset, len);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      int j;\n      for (j=0; j < len; ++j) {\n         for (i=0; i < limit; ++i) {\n            FASTDEF(temp);\n            float f = data[i][d_offset+j];\n            int v = FAST_SCALED_FLOAT_TO_INT(temp, f,15);//data[i][d_offset+j],15);\n            if ((unsigned int) (v + 32768) > 65535)\n               v = v < 0 ? -32768 : 32767;\n            *buffer++ = v;\n         }\n         for (   ; i < buf_c; ++i)\n            *buffer++ = 0;\n      }\n   }\n}\n\nint stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts)\n{\n   float **output;\n   int len;\n   if (num_c == 1) return stb_vorbis_get_frame_short(f,num_c,&buffer, num_shorts);\n   len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len) {\n      if (len*num_c > num_shorts) len = num_shorts / num_c;\n      convert_channels_short_interleaved(num_c, buffer, f->channels, output, 0, len);\n   }\n   return len;\n}\n\nint stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts)\n{\n   float **outputs;\n   int len = num_shorts / channels;\n   int n=0;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_channels_short_interleaved(channels, buffer, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      buffer += k*channels;\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int len)\n{\n   float **outputs;\n   int n=0;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_samples_short(channels, buffer, n, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\nint stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_filename(filename, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // NO_STDIO\n\nint stb_vorbis_decode_memory(const uint8 *mem, int len, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_memory(mem, len, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // STB_VORBIS_NO_INTEGER_CONVERSION\n\nint stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats)\n{\n   float **outputs;\n   int len = num_floats / channels;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int i,j;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      for (j=0; j < k; ++j) {\n         for (i=0; i < z; ++i)\n            *buffer++ = f->channel_buffers[i][f->channel_buffer_start+j];\n         for (   ; i < channels; ++i)\n            *buffer++ = 0;\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples)\n{\n   float **outputs;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < num_samples) {\n      int i;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= num_samples) k = num_samples - n;\n      if (k) {\n         for (i=0; i < z; ++i)\n            memcpy(buffer[i]+n, f->channel_buffers[i]+f->channel_buffer_start, sizeof(float)*k);\n         for (   ; i < channels; ++i)\n            memset(buffer[i]+n, 0, sizeof(float) * k);\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == num_samples)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n#endif // STB_VORBIS_NO_PULLDATA_API\n\n/* Version history\n    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13222, -13223\n                           found with Mayhem by ForAllSecure\n    1.16    - 2019-03-04 - fix warnings\n    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n    1.14    - 2018-02-11 - delete bogus dealloca usage\n    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n    1.11    - 2017-07-23 - fix MinGW compilation\n    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n    1.09    - 2016-04-04 - back out 'avoid discarding last frame' fix from previous version\n    1.08    - 2016-04-02 - fixed multiple warnings; fix setup memory leaks;\n                           avoid discarding last frame of audio data\n    1.07    - 2015-01-16 - fixed some warnings, fix mingw, const-correct API\n                           some more crash fixes when out of memory or with corrupt files\n    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n                           some crash fixes when out of memory or with corrupt files\n    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n    1.04    - 2014-08-27 - fix missing const-correct case in API\n    1.03    - 2014-08-07 - Warning fixes\n    1.02    - 2014-07-09 - Declare qsort compare function _cdecl on windows\n    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float\n    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in multichannel\n                           (API change) report sample rate for decode-full-file funcs\n    0.99996 - bracket #include <malloc.h> for macintosh compilation by Laurent Gomila\n    0.99995 - use union instead of pointer-cast for fast-float-to-int to avoid alias-optimization problem\n    0.99994 - change fast-float-to-int to work in single-precision FPU mode, remove endian-dependence\n    0.99993 - remove assert that fired on legal files with empty tables\n    0.99992 - rewind-to-start\n    0.99991 - bugfix to stb_vorbis_get_samples_short by Bernhard Wodo\n    0.9999 - (should have been 0.99990) fix no-CRT support, compiling as C++\n    0.9998 - add a full-decode function with a memory source\n    0.9997 - fix a bug in the read-from-FILE case in 0.9996 addition\n    0.9996 - query length of vorbis stream in samples/seconds\n    0.9995 - bugfix to another optimization that only happened in certain files\n    0.9994 - bugfix to one of the optimizations that caused significant (but inaudible?) errors\n    0.9993 - performance improvements; runs in 99% to 104% of time of reference implementation\n    0.9992 - performance improvement of IMDCT; now performs close to reference implementation\n    0.9991 - performance improvement of IMDCT\n    0.999 - (should have been 0.9990) performance improvement of IMDCT\n    0.998 - no-CRT support from Casey Muratori\n    0.997 - bugfixes for bugs found by Terje Mathisen\n    0.996 - bugfix: fast-huffman decode initialized incorrectly for sparse codebooks; fixing gives 10% speedup - found by Terje Mathisen\n    0.995 - bugfix: fix to 'effective' overrun detection - found by Terje Mathisen\n    0.994 - bugfix: garbage decode on final VQ symbol of a non-multiple - found by Terje Mathisen\n    0.993 - bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) - found by Terje Mathisen\n    0.992 - fixes for MinGW warning\n    0.991 - turn fast-float-conversion on by default\n    0.990 - fix push-mode seek recovery if you seek into the headers\n    0.98b - fix to bad release of 0.98\n    0.98 - fix push-mode seek recovery; robustify float-to-int and support non-fast mode\n    0.97 - builds under c++ (typecasting, don't use 'class' keyword)\n    0.96 - somehow MY 0.95 was right, but the web one was wrong, so here's my 0.95 rereleased as 0.96, fixes a typo in the clamping code\n    0.95 - clamping code for 16-bit functions\n    0.94 - not publically released\n    0.93 - fixed all-zero-floor case (was decoding garbage)\n    0.92 - fixed a memory leak\n    0.91 - conditional compiles to omit parts of the API and the infrastructure to support them: STB_VORBIS_NO_PULLDATA_API, STB_VORBIS_NO_PUSHDATA_API, STB_VORBIS_NO_STDIO, STB_VORBIS_NO_INTEGER_CONVERSION\n    0.90 - first public release\n*/\n\n#undef assert\n#undef malloc\n#undef free     \n#undef realloc  \n#undef pow      \n#undef floor    \n#undef log      \n#undef exp      \n#undef cos      \n#undef sin      \n#undef abs\n#undef alloca\n#undef dealloca\n#undef memset\n#undef memcpy\n#undef memcmp\n\n#endif // STB_VORBIS_HEADER_ONLY\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#define VEC3_EPSILON 0.000001f\n#define MAT4_EPSILON 0.000001f\n#define QUAT_EPSILON 0.000001f\n#define QUAT_DEG2RAD 0.0174533f\n#define QUAT_RAD2DEG 57.2958f\n\nnamespace CalculateMeshTangents {\n    \n\n    float FastSin(float x);\n    float FastCos(float x);\n\n    template<typename T>\n    struct TVec2 {\n        union {\n            struct {\n                T x;\n                T y;\n            };\n            T v[2];\n        };\n        inline TVec2() : x(T(0)), y(T(0)) { }\n        inline TVec2(T _x, T _y) :\n            x(_x), y(_y) { }\n        inline TVec2(T* fv) :\n            x(fv[0]), y(fv[1]) { }\n    };\n\n    typedef TVec2<float> vec2;\n    typedef TVec2<int> ivec2;\n    typedef TVec2<unsigned int> uivec2;\n\n    struct vec3 {\n        union {\n            struct {\n                float x;\n                float y;\n                float z;\n            };\n            float v[3];\n        };\n        inline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n        inline vec3(float _x, float _y, float _z) :\n            x(_x), y(_y), z(_z) { }\n        inline vec3(float* fv) :\n            x(fv[0]), y(fv[1]), z(fv[2]) { }\n    };\n\n    vec3 operator+(const vec3& l, const vec3& r);\n    vec3 operator-(const vec3& l, const vec3& r);\n    vec3 operator*(const vec3& v, float f);\n    vec3 operator*(const vec3& l, const vec3& r);\n    float dot(const vec3& l, const vec3& r);\n    float lenSq(const vec3& v);\n    float len(const vec3& v);\n    void normalize(vec3& v);\n    vec3 normalized(const vec3& v);\n    vec3 project(const vec3& a, const vec3& b);\n    vec3 reject(const vec3& a, const vec3& b);\n    vec3 reflect(const vec3& a, const vec3& b);\n    vec3 cross(const vec3& l, const vec3& r);\n    vec3 lerp(const vec3& s, const vec3& e, float t);\n    vec3 nlerp(const vec3& s, const vec3& e, float t);\n    bool operator==(const vec3& l, const vec3& r);\n    bool operator!=(const vec3& l, const vec3& r);\n\n    template<typename T>\n    struct TVec4 {\n        union {\n            struct {\n                T x;\n                T y;\n                T z;\n                T w;\n            };\n            T v[4];\n        };\n        inline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n        inline TVec4(T _x, T _y, T _z, T _w) :\n            x(_x), y(_y), z(_z), w(_w) { }\n        inline TVec4(T* fv) :\n            x(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n    };\n\n    typedef TVec4<float> vec4;\n    typedef TVec4<int> ivec4;\n    typedef TVec4<unsigned int> uivec4;\n\n\n    struct mat4 {\n        union {\n            float v[16];\n            struct {\n                vec4 right;\n                vec4 up;\n                vec4 forward;\n                vec4 position;\n            };\n            struct {\n                //            row 1     row 2     row 3     row 4\n                /* column 1 */float xx; float xy; float xz; float xw;\n                /* column 2 */float yx; float yy; float yz; float yw;\n                /* column 3 */float zx; float zy; float zz; float zw;\n                /* column 4 */float tx; float ty; float tz; float tw;\n            };\n            struct {\n                float c0r0; float c0r1; float c0r2; float c0r3;\n                float c1r0; float c1r1; float c1r2; float c1r3;\n                float c2r0; float c2r1; float c2r2; float c2r3;\n                float c3r0; float c3r1; float c3r2; float c3r3;\n            };\n            struct {\n                float r0c0; float r1c0; float r2c0; float r3c0;\n                float r0c1; float r1c1; float r2c1; float r3c1;\n                float r0c2; float r1c2; float r2c2; float r3c2;\n                float r0c3; float r1c3; float r2c3; float r3c3;\n            };\n        };\n        inline mat4() :\n            xx(1), xy(0), xz(0), xw(0),\n            yx(0), yy(1), yz(0), yw(0),\n            zx(0), zy(0), zz(1), zw(0),\n            tx(0), ty(0), tz(0), tw(1) {}\n\n        inline mat4(float* fv) :\n            xx(fv[0]), xy(fv[1]), xz(fv[2]), xw(fv[3]),\n            yx(fv[4]), yy(fv[5]), yz(fv[6]), yw(fv[7]),\n            zx(fv[8]), zy(fv[9]), zz(fv[10]), zw(fv[11]),\n            tx(fv[12]), ty(fv[13]), tz(fv[14]), tw(fv[15]) { }\n\n        inline mat4(\n            float _00, float _01, float _02, float _03,\n            float _10, float _11, float _12, float _13,\n            float _20, float _21, float _22, float _23,\n            float _30, float _31, float _32, float _33) :\n            xx(_00), xy(_01), xz(_02), xw(_03),\n            yx(_10), yy(_11), yz(_12), yw(_13),\n            zx(_20), zy(_21), zz(_22), zw(_23),\n            tx(_30), ty(_31), tz(_32), tw(_33) { }\n    }; // end mat4 struct\n\n    bool operator==(const mat4& a, const mat4& b);\n    bool operator!=(const mat4& a, const mat4& b);\n    mat4 operator+(const mat4& a, const mat4& b);\n    mat4 operator*(const mat4& m, float f);\n    mat4 operator*(const mat4& a, const mat4& b);\n    vec4 operator*(const mat4& m, const vec4& v);\n    vec3 transformVector(const mat4& m, const vec3& v);\n    vec3 transformPoint(const mat4& m, const vec3& v);\n    vec3 transformPoint(const mat4& m, const vec3& v, float& w);\n    void transpose(mat4& m);\n    mat4 transposed(const mat4& m);\n    float determinant(const mat4& m);\n    mat4 adjugate(const mat4& m);\n    mat4 inverse(const mat4& m);\n    void invert(mat4& m);\n    mat4 frustum(float l, float r, float b, float t, float n, float f);\n    mat4 perspective(float fov, float aspect, float znear, float zfar);\n    mat4 ortho(float l, float r, float b, float t, float n, float f);\n    mat4 lookAt(const vec3& position, const vec3& target, const vec3& up);\n\n    struct quat {\n        union {\n            struct {\n                float x;\n                float y;\n                float z;\n                float w;\n            };\n            struct {\n                vec3 vector;\n                float scalar;\n            };\n            float v[4];\n        };\n\n        inline quat() :\n            x(0), y(0), z(0), w(1) { }\n        inline quat(float _x, float _y, float _z, float _w) :\n            x(_x), y(_y), z(_z), w(_w) {}\n    };\n\n    quat angleAxis(float angle, const vec3& axis);\n    quat fromTo(const vec3& from, const vec3& to);\n    vec3 getAxis(const quat& quat);\n    float getAngle(const quat& quat);\n    quat operator+(const quat& a, const quat& b);\n    quat operator-(const quat& a, const quat& b);\n    quat operator*(const quat& a, float b);\n    quat operator-(const quat& q);\n    bool operator==(const quat& left, const quat& right);\n    bool operator!=(const quat& a, const quat& b);\n    bool sameOrientation(const quat& left, const quat& right);\n    float dot(const quat& a, const quat& b);\n    float lenSq(const quat& q);\n    float len(const quat& q);\n    void normalize(quat& q);\n    quat normalized(const quat& q);\n    quat conjugate(const quat& q);\n    quat inverse(const quat& q);\n    quat operator*(const quat& Q1, const quat& Q2);\n    vec3 operator*(const quat& q, const vec3& v);\n    quat mix(const quat& from, const quat& to, float t);\n    quat nlerp(const quat& from, const quat& to, float t);\n    quat operator^(const quat& q, float f);\n    quat operator^(const quat& q, float f);\n    quat slerp(const quat& start, const quat& end, float t);\n    quat lookRotation(const vec3& direcion, const vec3& up);\n    mat4 quatToMat4(const quat& q);\n    quat mat4ToQuat(const mat4& m);\n\n    float Sqrtf(const float& n) {\n        if (n == 0.0f) {\n            return 0.0f;\n        }\n\n        int i = 0x2035AD0C + (*(int*)&n >> 1);\n        return n / *(float*)&i + *(float*)&i * 0.25f;\n    }\n\n    float Fabsf(const float& f) {\n        if (f < 0.0f) {\n            return f * -1.0f;\n        }\n        return f;\n    }\n\n    double Sin(const double& x) {\n        int i = 1;\n        double cur = x;\n        double acc = 1;\n        double fact = 1;\n        double pow = x;\n        while (acc > .00000001 && i < 100) {\n            fact *= ((2 * i) * (2 * i + 1));\n            pow *= -1 * x * x;\n            acc = pow / fact;\n            if (acc < 0.0) { // fabs\n                acc *= -1.0;\n            }\n            cur += acc;\n            i++;\n        }\n        return cur;\n    }\n\n    #define PI         (3.1415926535f)\n    #define HALF_PI    (0.5f * PI)\n    #define TWO_PI     (2.0f * PI)\n    #define TWO_PI_INV (1.0f / TWO_PI)\n\n    inline float Hill(float x)\n    {\n        const float a0 = 1.0f;\n        const float a2 = 2.0f / PI - 12.0f / (PI * PI);\n        const float a3 = 16.0f / (PI * PI * PI) - 4.0f / (PI * PI);\n        const float xx = x * x;\n        const float xxx = xx * x;\n\n        return a0 + a2 * xx + a3 * xxx;\n    }\n\n    float FastSin(float x)\n    {\n        // wrap x within [0, TWO_PI)\n        const float a = x * TWO_PI_INV;\n        x -= static_cast<int>(a) * TWO_PI;\n        if (x < 0.0f)\n            x += TWO_PI;\n\n        // 4 pieces of hills\n        if (x < HALF_PI)\n            return Hill(HALF_PI - x);\n        else if (x < PI)\n            return Hill(x - HALF_PI);\n        else if (x < 3.0f * HALF_PI)\n            return -Hill(3.0f * HALF_PI - x);\n        else\n            return -Hill(x - 3.0f * HALF_PI);\n    }\n\n    float FastCos(float x)\n    {\n        return FastSin(x + HALF_PI);\n    }\n\n    float Tan(const float& d) {\n        return FastSin(d) / FastCos(d);\n    }\n\n\n    vec3 operator+(const vec3& l, const vec3& r) {\n        return vec3(l.x + r.x, l.y + r.y, l.z + r.z);\n    }\n\n    vec3 operator-(const vec3& l, const vec3& r) {\n        return vec3(l.x - r.x, l.y - r.y, l.z - r.z);\n    }\n\n    vec3 operator*(const vec3& v, float f) {\n        return vec3(v.x * f, v.y * f, v.z * f);\n    }\n\n    vec3 operator*(const vec3& l, const vec3& r) {\n        return vec3(l.x * r.x, l.y * r.y, l.z * r.z);\n    }\n\n    float dot(const vec3& l, const vec3& r) {\n        return l.x * r.x + l.y * r.y + l.z * r.z;\n    }\n\n    float lenSq(const vec3& v) {\n        return v.x * v.x + v.y * v.y + v.z * v.z;\n    }\n\n    float len(const vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return 0.0f;\n        }\n        return Sqrtf(lenSq);\n    }\n\n    void normalize(vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return;\n        }\n        float invLen = 1.0f / Sqrtf(lenSq);\n\n        v.x *= invLen;\n        v.y *= invLen;\n        v.z *= invLen;\n    }\n\n    vec3 normalized(const vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return v;\n        }\n        float invLen = 1.0f / Sqrtf(lenSq);\n\n        return vec3(\n            v.x * invLen,\n            v.y * invLen,\n            v.z * invLen\n        );\n    }\n\n    vec3 project(const vec3& a, const vec3& b) {\n        float magBSq = len(b);\n        if (magBSq < VEC3_EPSILON) {\n            return vec3();\n        }\n        float scale = dot(a, b) / magBSq;\n        return b * scale;\n    }\n\n    vec3 reject(const vec3& a, const vec3& b) {\n        vec3 projection = project(a, b);\n        return a - projection;\n    }\n\n    vec3 reflect(const vec3& a, const vec3& b) {\n        float magBSq = len(b);\n        if (magBSq < VEC3_EPSILON) {\n            return vec3();\n        }\n        float scale = dot(a, b) / magBSq;\n        vec3 proj2 = b * (scale * 2);\n        return a - proj2;\n    }\n\n    vec3 cross(const vec3& l, const vec3& r) {\n        return vec3(\n            l.y * r.z - l.z * r.y,\n            l.z * r.x - l.x * r.z,\n            l.x * r.y - l.y * r.x\n        );\n    }\n\n    vec3 lerp(const vec3& s, const vec3& e, float t) {\n        return vec3(\n            s.x + (e.x - s.x) * t,\n            s.y + (e.y - s.y) * t,\n            s.z + (e.z - s.z) * t\n        );\n    }\n\n    vec3 nlerp(const vec3& s, const vec3& e, float t) {\n        vec3 linear(\n            s.x + (e.x - s.x) * t,\n            s.y + (e.y - s.y) * t,\n            s.z + (e.z - s.z) * t\n        );\n        return normalized(linear);\n    }\n\n    bool operator==(const vec3& l, const vec3& r) {\n        vec3 diff(l - r);\n        return lenSq(diff) < VEC3_EPSILON;\n    }\n\n    bool operator!=(const vec3& l, const vec3& r) {\n        return !(l == r);\n    }\n\n    bool operator==(const mat4& a, const mat4& b) {\n        for (int i = 0; i < 16; ++i) {\n            if (Fabsf(a.v[i] - b.v[i]) > MAT4_EPSILON) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool operator!=(const mat4& a, const mat4& b) {\n        return !(a == b);\n    }\n\n    mat4 operator+(const mat4& a, const mat4& b) {\n        return mat4(\n            a.xx + b.xx, a.xy + b.xy, a.xz + b.xz, a.xw + b.xw,\n            a.yx + b.yx, a.yy + b.yy, a.yz + b.yz, a.yw + b.yw,\n            a.zx + b.zx, a.zy + b.zy, a.zz + b.zz, a.zw + b.zw,\n            a.tx + b.tx, a.ty + b.ty, a.tz + b.tz, a.tw + b.tw\n        );\n    }\n\n    mat4 operator*(const mat4& m, float f) {\n        return mat4(\n            m.xx * f, m.xy * f, m.xz * f, m.xw * f,\n            m.yx * f, m.yy * f, m.yz * f, m.yw * f,\n            m.zx * f, m.zy * f, m.zz * f, m.zw * f,\n            m.tx * f, m.ty * f, m.tz * f, m.tw * f\n        );\n    }\n\n    #define M4D(aRow, bCol) \\\n        a.v[0 * 4 + aRow] * b.v[bCol * 4 + 0] + \\\n        a.v[1 * 4 + aRow] * b.v[bCol * 4 + 1] + \\\n        a.v[2 * 4 + aRow] * b.v[bCol * 4 + 2] + \\\n        a.v[3 * 4 + aRow] * b.v[bCol * 4 + 3]\n\n    mat4 operator*(const mat4& a, const mat4& b) {\n        return mat4(\n            M4D(0, 0), M4D(1, 0), M4D(2, 0), M4D(3, 0), // Column 0\n            M4D(0, 1), M4D(1, 1), M4D(2, 1), M4D(3, 1), // Column 1\n            M4D(0, 2), M4D(1, 2), M4D(2, 2), M4D(3, 2), // Column 2\n            M4D(0, 3), M4D(1, 3), M4D(2, 3), M4D(3, 3)  // Column 3\n        );\n    }\n\n    #define M4V4D(mRow, x, y, z, w) \\\n        x * m.v[0 * 4 + mRow] + \\\n        y * m.v[1 * 4 + mRow] + \\\n        z * m.v[2 * 4 + mRow] + \\\n        w * m.v[3 * 4 + mRow]\n\n    vec4 operator*(const mat4& m, const vec4& v) {\n        return vec4(\n            M4V4D(0, v.x, v.y, v.z, v.w),\n            M4V4D(1, v.x, v.y, v.z, v.w),\n            M4V4D(2, v.x, v.y, v.z, v.w),\n            M4V4D(3, v.x, v.y, v.z, v.w)\n        );\n    }\n\n    vec3 transformVector(const mat4& m, const vec3& v) {\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, 0.0f),\n            M4V4D(1, v.x, v.y, v.z, 0.0f),\n            M4V4D(2, v.x, v.y, v.z, 0.0f)\n        );\n    }\n\n    vec3 transformPoint(const mat4& m, const vec3& v) {\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, 1.0f),\n            M4V4D(1, v.x, v.y, v.z, 1.0f),\n            M4V4D(2, v.x, v.y, v.z, 1.0f)\n        );\n    }\n\n    vec3 transformPoint(const mat4& m, const vec3& v, float& w) {\n        float _w = w;\n        w = M4V4D(3, v.x, v.y, v.z, _w);\n\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, _w),\n            M4V4D(1, v.x, v.y, v.z, _w),\n            M4V4D(2, v.x, v.y, v.z, _w)\n        );\n    }\n\n    #define M4SWAP(x, y) \\\n        {float t = x; x = y; y = t; }\n\n    void transpose(mat4& m) {\n        M4SWAP(m.yx, m.xy);\n        M4SWAP(m.zx, m.xz);\n        M4SWAP(m.tx, m.xw);\n        M4SWAP(m.zy, m.yz);\n        M4SWAP(m.ty, m.yw);\n        M4SWAP(m.tz, m.zw);\n    }\n\n    mat4 transposed(const mat4& m) {\n        return mat4(\n            m.xx, m.yx, m.zx, m.tx,\n            m.xy, m.yy, m.zy, m.ty,\n            m.xz, m.yz, m.zz, m.tz,\n            m.xw, m.yw, m.zw, m.tw\n        );\n    }\n\n    #define M4_3X3MINOR(c0, c1, c2, r0, r1, r2) \\\n        (m.v[c0 * 4 + r0] * (m.v[c1 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c1 * 4 + r2] * m.v[c2 * 4 + r1]) - \\\n        m.v[c1 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c2 * 4 + r1]) + \\\n        m.v[c2 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c1 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c1 * 4 + r1]))\n\n    float determinant(const mat4& m) {\n        return  m.v[0] * M4_3X3MINOR(1, 2, 3, 1, 2, 3)\n            - m.v[4] * M4_3X3MINOR(0, 2, 3, 1, 2, 3)\n            + m.v[8] * M4_3X3MINOR(0, 1, 3, 1, 2, 3)\n            - m.v[12] * M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n    }\n\n    mat4 adjugate(const mat4& m) {\n        // Cofactor(M[i, j]) = Minor(M[i, j]] * pow(-1, i + j)\n        mat4 cofactor;\n\n        cofactor.v[0] = M4_3X3MINOR(1, 2, 3, 1, 2, 3);\n        cofactor.v[1] = -M4_3X3MINOR(1, 2, 3, 0, 2, 3);\n        cofactor.v[2] = M4_3X3MINOR(1, 2, 3, 0, 1, 3);\n        cofactor.v[3] = -M4_3X3MINOR(1, 2, 3, 0, 1, 2);\n\n        cofactor.v[4] = -M4_3X3MINOR(0, 2, 3, 1, 2, 3);\n        cofactor.v[5] = M4_3X3MINOR(0, 2, 3, 0, 2, 3);\n        cofactor.v[6] = -M4_3X3MINOR(0, 2, 3, 0, 1, 3);\n        cofactor.v[7] = M4_3X3MINOR(0, 2, 3, 0, 1, 2);\n\n        cofactor.v[8] = M4_3X3MINOR(0, 1, 3, 1, 2, 3);\n        cofactor.v[9] = -M4_3X3MINOR(0, 1, 3, 0, 2, 3);\n        cofactor.v[10] = M4_3X3MINOR(0, 1, 3, 0, 1, 3);\n        cofactor.v[11] = -M4_3X3MINOR(0, 1, 3, 0, 1, 2);\n\n        cofactor.v[12] = -M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n        cofactor.v[13] = M4_3X3MINOR(0, 1, 2, 0, 2, 3);\n        cofactor.v[14] = -M4_3X3MINOR(0, 1, 2, 0, 1, 3);\n        cofactor.v[15] = M4_3X3MINOR(0, 1, 2, 0, 1, 2);\n\n        return transposed(cofactor);\n    }\n\n    mat4 inverse(const mat4& m) {\n        float det = determinant(m);\n\n        if (det == 0.0f) { // Epsilon check would need to be REALLY small\n            return mat4();\n        }\n        mat4 adj = adjugate(m);\n\n        return adj * (1.0f / det);\n    }\n\n    void invert(mat4& m) {\n        float det = determinant(m);\n\n        if (det == 0.0f) {\n            m = mat4();\n            return;\n        }\n\n        m = adjugate(m) * (1.0f / det);\n    }\n\n    mat4 frustum(float l, float r, float b, float t, float n, float f) {\n        if (l == r || t == b || n == f) {\n            return mat4(); // Error\n        }\n        return mat4(\n            (2.0f * n) / (r - l), 0, 0, 0,\n            0, (2.0f * n) / (t - b), 0, 0,\n            (r + l) / (r - l), (t + b) / (t - b), (-(f + n)) / (f - n), -1,\n            0, 0, (-2 * f * n) / (f - n), 0\n        );\n    }\n\n    mat4 perspective(float fov, float aspect, float znear, float zfar) {\n        float ymax = znear * (float)Tan(fov * 3.14159265359f / 360.0f);\n        float xmax = ymax * aspect;\n\n        return frustum(-xmax, xmax, -ymax, ymax, znear, zfar);\n    }\n\n    mat4 ortho(float l, float r, float b, float t, float n, float f) {\n        if (l == r || t == b || n == f) {\n            return mat4(); // Error\n        }\n        return mat4(\n            2.0f / (r - l), 0, 0, 0,\n            0, 2.0f / (t - b), 0, 0,\n            0, 0, -2.0f / (f - n), 0,\n            -((r + l) / (r - l)), -((t + b) / (t - b)), -((f + n) / (f - n)), 1\n        );\n    }\n\n    mat4 lookAt(const vec3& position, const vec3& target, const vec3& up) {\n        // Remember, forward is negative z\n        vec3 f = normalized(target - position) * -1.0f;\n        vec3 r = cross(up, f); // Right handed\n        if (r == vec3(0, 0, 0)) {\n            return mat4(); // Error\n        }\n        normalize(r);\n        vec3 u = normalized(cross(f, r)); // Right handed\n\n        vec3 t = vec3(\n            -dot(r, position),\n            -dot(u, position),\n            -dot(f, position)\n        );\n\n        return mat4(\n            // Transpose upper 3x3 matrix to invert it\n            r.x, u.x, f.x, 0,\n            r.y, u.y, f.y, 0,\n            r.z, u.z, f.z, 0,\n            t.x, t.y, t.z, 1\n        );\n    }\n\n    quat angleAxis(float angle, const vec3& axis) {\n        vec3 norm = normalized(axis);\n        float s = FastSin(angle * 0.5f);\n\n        return quat(\n            norm.x * s,\n            norm.y * s,\n            norm.z * s,\n            FastCos(angle * 0.5f)\n        );\n    }\n\n    quat fromTo(const vec3& from, const vec3& to) {\n        vec3 f = normalized(from);\n        vec3 t = normalized(to);\n\n        if (f == t) {\n            return quat();\n        }\n        else if (f == t * -1.0f) {\n            vec3 ortho = vec3(1, 0, 0);\n            if (Fabsf(f.y) < Fabsf(f.x)) {\n                ortho = vec3(0, 1, 0);\n            }\n            if (Fabsf(f.z) < Fabsf(f.y) && Fabsf(f.z) < Fabsf(f.x)) {\n                ortho = vec3(0, 0, 1);\n            }\n\n            vec3 axis = normalized(cross(f, ortho));\n            return quat(axis.x, axis.y, axis.z, 0);\n        }\n\n        vec3 half = normalized(f + t);\n        vec3 axis = cross(f, half);\n\n        return quat(\n            axis.x,\n            axis.y,\n            axis.z,\n            dot(f, half)\n        );\n    }\n\n    vec3 getAxis(const quat& quat) {\n        return normalized(vec3(quat.x, quat.y, quat.z));\n    }\n\n    float getAngle(const quat& quat) {\n        return 2.0f * (1.0f / FastCos(quat.w));\n    }\n\n    quat operator+(const quat& a, const quat& b) {\n        return quat(\n            a.x + b.x,\n            a.y + b.y,\n            a.z + b.z,\n            a.w + b.w\n        );\n    }\n\n    quat operator-(const quat& a, const quat& b) {\n        return quat(\n            a.x - b.x,\n            a.y - b.y,\n            a.z - b.z,\n            a.w - b.w\n        );\n    }\n\n    quat operator*(const quat& a, float b) {\n        return quat(\n            a.x * b,\n            a.y * b,\n            a.z * b,\n            a.w * b\n        );\n    }\n\n    quat operator-(const quat& q) {\n        return quat(\n            -q.x,\n            -q.y,\n            -q.z,\n            -q.w\n        );\n    }\n\n    bool operator==(const quat& left, const quat& right) {\n        return (Fabsf(left.x - right.x) <= QUAT_EPSILON &&\n            Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n            Fabsf(left.z - right.z) <= QUAT_EPSILON &&\n            Fabsf(left.w - left.w) <= QUAT_EPSILON);\n    }\n\n    bool operator!=(const quat& a, const quat& b) {\n        return !(a == b);\n    }\n\n    bool sameOrientation(const quat& left, const quat& right) {\n        return (Fabsf(left.x - right.x) <= QUAT_EPSILON && Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n            Fabsf(left.z - right.z) <= QUAT_EPSILON && Fabsf(left.w - left.w) <= QUAT_EPSILON)\n            || (Fabsf(left.x + right.x) <= QUAT_EPSILON && Fabsf(left.y + right.y) <= QUAT_EPSILON &&\n                Fabsf(left.z + right.z) <= QUAT_EPSILON && Fabsf(left.w + left.w) <= QUAT_EPSILON);\n    }\n\n    float dot(const quat& a, const quat& b) {\n        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n    }\n\n    float lenSq(const quat& q) {\n        return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n    }\n\n    float len(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return 0.0f;\n        }\n        return Sqrtf(lenSq);\n    }\n\n    void normalize(quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return;\n        }\n        float i_len = 1.0f / Sqrtf(lenSq);\n\n        q.x *= i_len;\n        q.y *= i_len;\n        q.z *= i_len;\n        q.w *= i_len;\n    }\n\n    quat normalized(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return quat();\n        }\n        float i_len = 1.0f / Sqrtf(lenSq);\n\n        return quat(\n            q.x * i_len,\n            q.y * i_len,\n            q.z * i_len,\n            q.w * i_len\n        );\n    }\n\n    quat conjugate(const quat& q) {\n        return quat(\n            -q.x,\n            -q.y,\n            -q.z,\n            q.w\n        );\n    }\n\n    quat inverse(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return quat();\n        }\n        float recip = 1.0f / lenSq;\n\n        // conjugate / norm\n        return quat(\n            -q.x * recip,\n            -q.y * recip,\n            -q.z * recip,\n            q.w * recip\n        );\n    }\n\n    #if 1\n    quat operator*(const quat& Q1, const quat& Q2) {\n        return quat(\n            Q2.x * Q1.w + Q2.y * Q1.z - Q2.z * Q1.y + Q2.w * Q1.x,\n            -Q2.x * Q1.z + Q2.y * Q1.w + Q2.z * Q1.x + Q2.w * Q1.y,\n            Q2.x * Q1.y - Q2.y * Q1.x + Q2.z * Q1.w + Q2.w * Q1.z,\n            -Q2.x * Q1.x - Q2.y * Q1.y - Q2.z * Q1.z + Q2.w * Q1.w\n        );\n    }\n    #else\n    quat operator*(const quat& Q1, const quat& Q2) {\n        quat result;\n        result.scalar = Q2.scalar * Q1.scalar - dot(Q2.vector, Q1.vector);\n        result.vector = (Q1.vector * Q2.scalar) + (Q2.vector * Q1.scalar) + cross(Q2.vector, Q1.vector);\n        return result;\n    }\n    #endif\n\n    vec3 operator*(const quat& q, const vec3& v) {\n        return q.vector * 2.0f * dot(q.vector, v) +\n            v * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n            cross(q.vector, v) * 2.0f * q.scalar;\n    }\n\n    quat mix(const quat& from, const quat& to, float t) {\n        return from * (1.0f - t) + to * t;\n    }\n\n    quat nlerp(const quat& from, const quat& to, float t) {\n        return normalized(from + (to - from) * t);\n    }\n\n    quat operator^(const quat& q, float f) {\n        float angle = 2.0f * (1.0f / FastCos(q.scalar));\n        vec3 axis = normalized(q.vector);\n\n        float halfCos = FastCos(f * angle * 0.5f);\n        float halfSin = FastSin(f * angle * 0.5f);\n\n        return quat(\n            axis.x * halfSin,\n            axis.y * halfSin,\n            axis.z * halfSin,\n            halfCos\n        );\n    }\n\n    quat slerp(const quat& start, const quat& end, float t) {\n        if (Fabsf(dot(start, end)) > 1.0f - QUAT_EPSILON) {\n            return nlerp(start, end, t);\n        }\n\n        return normalized(((inverse(start) * end) ^ t) * start);\n    }\n\n    quat lookRotation(const vec3& direcion, const vec3& up) {\n        // Find orthonormal basis vectors\n        vec3 f = normalized(direcion);\n        vec3 u = normalized(up);\n        vec3 r = cross(u, f);\n        u = cross(f, r);\n\n        // From world forward to object forward\n        quat f2d = fromTo(vec3(0, 0, 1), f);\n\n        // what direction is the new object up?\n        vec3 objectUp = f2d * vec3(0, 1, 0);\n        // From object up to desired up\n        quat u2u = fromTo(objectUp, u);\n\n        // Rotate to forward direction first, then twist to correct up\n        quat result = f2d * u2u;\n        // Don\u00ef\u00bf\u00bdt forget to normalize the result\n        return normalized(result);\n    }\n\n    mat4 quatToMat4(const quat& q) {\n        vec3 r = q * vec3(1, 0, 0);\n        vec3 u = q * vec3(0, 1, 0);\n        vec3 f = q * vec3(0, 0, 1);\n\n        return mat4(\n            r.x, r.y, r.z, 0,\n            u.x, u.y, u.z, 0,\n            f.x, f.y, f.z, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    quat mat4ToQuat(const mat4& m) {\n        vec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n        vec3 forward = normalized(vec3(m.forward.x, m.forward.y, m.forward.z));\n        vec3 right = cross(up, forward);\n        up = cross(forward, right);\n\n        return lookRotation(forward, up);\n    }\n\n\n    void CalculateTangentArray(unsigned int vertexCount, float* _vertex, float* _normal,\n\t\tfloat* _texcoord, float* _outTangent) {\n\n        vec3* vertex = (vec3*)_vertex;\n        vec3* normal = (vec3*)_normal;\n        vec2* texcoord = (vec2*)_texcoord;\n        vec3* outTangent = (vec3*)_outTangent;\n\n\t\tvec3* tan1 = (vec3*)MemAllocate(vertexCount * 2 * sizeof(vec3), 0);\n\t\tvec3* tan2 = tan1 + vertexCount;\n\n\t\tfor (long a = 0; a < vertexCount; a += 3)\n\t\t{\n\t\t\tvec3 v1 = vertex[a + 0];\n\t\t\tvec3 v2 = vertex[a + 1];\n\t\t\tvec3 v3 = vertex[a + 2];\n\n\t\t\tvec2 w1 = texcoord[a + 0];\n\t\t\tvec2 w2 = texcoord[a + 1];\n\t\t\tvec2 w3 = texcoord[a + 2];\n\n\t\t\tfloat x1 = v2.x - v1.x;\n\t\t\tfloat x2 = v3.x - v1.x;\n\t\t\tfloat y1 = v2.y - v1.y;\n\t\t\tfloat y2 = v3.y - v1.y;\n\t\t\tfloat z1 = v2.z - v1.z;\n\t\t\tfloat z2 = v3.z - v1.z;\n\n\t\t\tfloat s1 = w2.x - w1.x;\n\t\t\tfloat s2 = w3.x - w1.x;\n\t\t\tfloat t1 = w2.y - w1.y;\n\t\t\tfloat t2 = w3.y - w1.y;\n\n\t\t\tfloat r = 1.0f / (s1 * t2 - s2 * t1);\n\t\t\tvec3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,\n\t\t\t\t(t2 * z1 - t1 * z2) * r);\n\t\t\tvec3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,\n\t\t\t\t(s1 * z2 - s2 * z1) * r);\n\n\t\t\ttan1[a + 0] = tan1[a + 0] + sdir;\n\t\t\ttan1[a + 1] = tan1[a + 1] + sdir;\n\t\t\ttan1[a + 2] = tan1[a + 2] + sdir;\n\n\t\t\ttan2[a + 0] = tan2[a + 0] + tdir;\n\t\t\ttan2[a + 1] = tan2[a + 1] + tdir;\n\t\t\ttan2[a + 2] = tan2[a + 2] + tdir;\n\t\t}\n\n\t\tfor (long a = 0; a < vertexCount; a++) {\n\t\t\tvec3 n = normal[a];\n\t\t\tvec3 t = tan1[a];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\t\t\toutTangent[a] = normalized(t - n * dot(n, t));\n\n\t\t\t// Calculate handedness\n\t\t\t//tangent[a].w = (dot(cross(n, t), tan2[a]) < 0.0F) ? -1.0F : 1.0F;\n\t\t}\n\n\t\tMemRelease(tan1);\n\t}\n}","#ifndef _H_GRAPHICS_\n#define _H_GRAPHICS_\n\ntypedef unsigned int u32;\ntypedef float f32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(f32) == 4, \"f32 should be a 4 byte type\");\nstatic_assert (sizeof(void*) >= 4, \"pointer should be >= 4 byte type\");\n\n#define GfxBufferTypeFloat32            0\n#define GfxBufferTypeInt16              3\n#define GfxBufferTypeInt32              5\n\n#define GfxIndexTypeByte                1\n#define GfxIndexTypeShort               2\n#define GfxIndexTypeInt                 4\n\n#define GfxTextureFormatRGB8            0\n#define GfxTextureFormatRGBA8           1\n#define GfxTextureFormatR32F            2\n#define GfxTextureFormatRGB32F          3\n#define GfxTextureFormatDepth           4\n// GfxTextureFormatDepth is only a target format, not a source format\n\n#define GfxFilterNearest                0\n#define GfxFilterLinear                 1\n#define GfxFilterNone                   2\n\n#define GfxWrapRepeat                   0\n#define GfxWrapClamp                    1\n\n#define GfxUniformTypeInt1              0\n#define GfxUniformTypeInt2              1\n#define GfxUniformTypeInt3              2\n#define GfxUniformTypeInt4              3\n#define GfxUniformTypeFloat1            4\n#define GfxUniformTypeFloat2            5\n#define GfxUniformTypeFloat3            6\n#define GfxUniformTypeFloat4            7\n#define GfxUniformTypeFloat9            8\n#define GfxUniformTypeFloat16           9\n#define GfxUniformTypeTexture           10\n\n#define GfxDepthFuncAlways              0\n#define GfxDepthFuncNever               1\n#define GfxDepthFuncEqual               2\n#define GfxDepthFuncLEqual              3\n#define GfxDepthFuncGreater             4\n#define GfxDepthFuncGEqual              5\n#define GfxDepthFuncNotEqual            6\n#define GfxDepthFuncLess                7\n\n#define GfxCullFaceOff                  0\n#define GfxCullFaceBack                 1\n#define GfxCullFaceFront                2\n#define GfxCullFaceFrontAndBack         3\n\n#define GfxFaceWindCounterClockwise     0\n#define GfxFaceWindClockwise            1\n\n#define GfxBlendFuncZero                1\n#define GfxBlendFuncOne                 2\n#define GfxBlendFuncSrcColor            3\n#define GfxBlendFuncOneMinusSrcColor    4\n#define GfxBlendFuncDstColor            5\n#define GfxBlendFuncOneMinusDstColor    6\n#define GfxBlendFuncSrcAlpha            7\n#define GfxBlendFuncOneMinusSrcAlpha    8\n#define GfxBlendFuncDstAlpha            9\n#define GfxBlendFuncOneMinusDstAlpha    10\n#define GfxBlendFuncConstColor          11\n#define GfxBlendFuncOneMinusConstColor  12\n#define GfxBlendFuncConstAlpha          13\n#define GfxBlendFuncOneMinusconstAlpha  14\n#define GfxBlendFuncSrcAlphaSaturate    15\n\n#define GfxBlendEquationAdd             0\n#define GfxBlendEquationSubtract        1\n#define GfxBlendEquationReverseSubtract 2\n#define GfxBlendEquationMin             3\n#define GfxBlendEquationMax             4\n\n#define GfxDrawModePoints               0\n#define GfxDrawModeLines                1\n#define GfxDrawModeLineStrip            2\n#define GfxDrawModeTriangles            3\n#define GfxDrawModeTriangleStrip        4\n#define GfxDrawModeTriangleFan          5\n\nextern \"C\" u32 GfxCreateBuffer();\nextern \"C\" void GfxDestroyBuffer(u32 bufferId);\n\nextern \"C\" void GfxFillArrayBuffer(u32 bufferId, void* input, u32 bytes, bool _static);\nextern \"C\" void GfxFillIndexBuffer(u32 bufferId, void* input, u32 bytes, u32 indexType);\n\nextern \"C\" u32 GfxCreateShader(const char* vsource, const char* fsource);\nextern \"C\" u32 GfxGetUniformSlot(u32 shaderId, const char* name);\nextern \"C\" void GfxDestroyShader(u32 shaderId);\n\nextern \"C\" u32 GfxCreateShaderVertexLayout(u32 shaderId);\nextern \"C\" void GfxAddBufferToLayout(u32 layoutId, const char* name, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\nextern \"C\" void GfxDestroyShaderVertexLayout(u32 layoutId);\n\nextern \"C\" u32 GfxCreateTexture(void* data, u32 width, u32 height, u32 sourceFormat, u32 targetFormat, bool genMips);\ninline u32 GfxCreateDepthTexture(u32 width, u32 height) {\n    return GfxCreateTexture(0, width, height, GfxTextureFormatDepth, GfxTextureFormatDepth, false);\n}\nextern \"C\" void GfxSetTextureSampler(u32 textureId, u32 wrapS, u32 wrapT, u32 min, u32 mip, u32 mag);\nextern \"C\" void GfxDestroyTexture(u32 textureId);\n\nextern \"C\" void GfxSetUniform(u32 shaderId, u32 uniformSlot, void* data, u32 uniformType, u32 count); \ninline void GfxSetUniformTexture(u32 shaderId, u32 uniformSlot, u32 textureId) {\n    GfxSetUniform(shaderId, uniformSlot, (void*)textureId, 10, 1);\n}\n\nextern \"C\" void GfxClearAll(u32 colorTargetId, u32 depthTargetId, float r, float g, float b, float d);\nextern \"C\" void GfxClearColor(u32 colorTargetTextureId, u32 depthTargetTextureId, float r, float g, float b);\nextern \"C\" void GfxClearDepth(u32 colorTargetTextureId, u32 depthTargetTextureId, float depth);\nextern \"C\" void GfxDraw(u32 colorTargetTextureId, u32 depthTargetTextureId, u32 vertexLayoutId, u32 drawMode, u32 startIndex, u32 indexCount, u32 instanceCount);\n\nextern \"C\" void GfxSetBlendState(bool blend, f32* optBlendColor, u32 blendDstRgb, u32 blendDstAlpha, u32 blendEquationRgb, u32 blendEquationAlpha, u32 blendSrcRgb, u32 blendSrcAlpha);\nextern \"C\" void GfxSetCullState(u32 cullFace, u32 faceWind);\nextern \"C\" void GfxSetDepthState(bool enable, u32 depthFunc, f32* depthRange);\ninline void GfxEnableDepthTest() {\n    GfxSetDepthState(true, GfxDepthFuncLess, 0);\n}\n\nextern \"C\" void GfxSetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\nextern \"C\" void GfxSetWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void GfxSetViewport(u32 x, u32 y, u32 w, u32 h);\n\n#endif","#ifndef _H_WINDOW_\n#define _H_WINDOW_\n\ntypedef unsigned int u32;\ntypedef int i32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(i32) == 4, \"i32 should be a 4 byte type\");\n\n#define KeyboardCodeLeftMouse         1  //  \n#define KeyboardCodeRightMouse        2  //  \n#define KeyboardCodeBackspace         3  //  Backspace\n#define KeyboardCodeMiddleMouse       4  //  \n#define KeyboardCodeReturn            5  //  Enter\n#define KeyboardCodeShift             6  //  Shift \n#define KeyboardCodeControl           7  //  Control key\n#define KeyboardCodeMenu              8  //  Alt key\n#define KeyboardCodeCapslock          9  //  Capslock\n#define KeyboardCodeEscape           10  //  Escape\n#define KeyboardCodeSpace            11  //  Spacebar\n#define KeyboardCodeLEft             12  //  Left arrow\n#define KeyboardCodeUp               13  //  Up arrow\n#define KeyboardCodeRight            14  //  Right arrow\n#define KeyboardCodeDown             15  //  Down arrow\n#define KeyboardCodeDelete           16  //  Delete key\n#define KeyboardCode0                17  //  Key 0\n#define KeyboardCode1                18  //  Key 1\n#define KeyboardCode2                19  //  Key 2\n#define KeyboardCode3                20  //  Key 3\n#define KeyboardCode4                21  //  Key 4\n#define KeyboardCode5                22  //  Key 5\n#define KeyboardCode6                23  //  Key 6\n#define KeyboardCode7                24  //  Key 7\n#define KeyboardCode8                25  //  Key 8\n#define KeyboardCode9                26  //  Key 9\n#define KeyboardCodeA                27  //  Key A\n#define KeyboardCodeB                28  //  Key B\n#define KeyboardCodeC                29  //  Key C\n#define KeyboardCodeD                30  //  Key D\n#define KeyboardCodeE                31  //  Key E\n#define KeyboardCodeF                32  //  Key F\n#define KeyboardCodeG                33  //  Key G\n#define KeyboardCodeH                34  //  Key H\n#define KeyboardCodeI                35  //  Key I\n#define KeyboardCodeJ                36  //  Key J\n#define KeyboardCodeK                37  //  Key K\n#define KeyboardCodeL                38  //  Key L\n#define KeyboardCodeM                39  //  Key M\n#define KeyboardCodeN                40  //  Key N\n#define KeyboardCodeO                41  //  Key O\n#define KeyboardCodeP                42  //  Key P\n#define KeyboardCodeQ                43  //  Key Q\n#define KeyboardCodeR                44  //  Key R\n#define KeyboardCodeS                45  //  Key S\n#define KeyboardCodeT                46  //  Key T\n#define KeyboardCodeU                47  //  Key U\n#define KeyboardCodeV                48  //  Key V\n#define KeyboardCodeW                49  //  Key W\n#define KeyboardCodeX                50  //  Key X\n#define KeyboardCodeY                51  //  Key Y\n#define KeyboardCodeZ                52  //  Key Z\n#define KeyboardCodeSemicolon        53  //  ;:\n#define KeyboardCodeColon            53  //  ;:\n#define KeyboardCodePlus             54  //  +=\n#define KeyboardCodeEquals           54  //  +=\n#define KeyboardCodeComma            55  //  ,<\n#define KeyboardCodeLess             55  //  ,<\n#define KeyboardCodeMinus            56  //  -_\n#define KeyboardCodeUnderscore       56  //  -_\n#define KeyboardCodePeriod           57  //  .>\n#define KeyboardCodeGreater          57  //  .>\n#define KeyboardCodeSlash            58  //  /?\n#define KeyboardCodeQuestionmark     58  //  /?\n#define KeyboardCodeTilde            59  //  ~`\n#define KeyboardCodeTick             59  //  ~`\n#define KeyboardCodeLBracket         60  //  [{\n#define KeyboardCodeLBrace           60  //  [{\n#define KeyboardCodeBackslash        61  //  \\|\n#define KeyboardCodeCarray           61  //  \\|\n#define KeyboardCodeRbracket         62  //  ]}\n#define KeyboardCodeRBrace           62  //  ]}\n#define KeyboardCodeQoute            63  //  \"'\n#define KeyboardCodeTab              64  //  Tab\n\nextern \"C\" u32 AsciiToScancode(char val);\nextern \"C\" char ScanCodeToAscii(u32 scanCode);\n\nextern \"C\" bool KeyboardDown(u32 scanCode);\nextern \"C\" bool KeyboardPrevDown(u32 scanCode);\n\ninline bool KeyboardUp(u32 scanCode) {\n    return !KeyboardDown(scanCode);\n}\n\ninline bool KeyboardPrevUp(u32 scanCode) {\n    return !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardPressed(u32 scanCode) {\n    return KeyboardDown(scanCode) && !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardReleased(u32 scanCode) {\n    return !KeyboardDown(scanCode) && KeyboardPrevDown(scanCode);\n}\n\n// Mouse API\n#define MouseButtonLeft         KeyboardCodeLeftMouse\n#define MouseButtonMiddle       KeyboardCodeRightMouse\n#define MouseButtonRight        KeyboardCodeMiddleMouse\n\nextern \"C\" u32 MouseGetX();\nextern \"C\" u32 MouseGetY();\nextern \"C\" i32 MouseGetScroll();\nextern \"C\" bool MouseDown(u32 button);\n\nextern \"C\" u32 MousePrevLastX();\nextern \"C\" u32 MousePrevLastY();\nextern \"C\" i32 MousePrevLastScroll();\nextern \"C\" bool MousePrevDown(u32 button);\n\ninline bool MouseUp(u32 button) {\n    return !MouseDown(button);\n}\n\ninline bool MousePrevUp(u32 button) {\n    return !MousePrevDown(button);\n}\n\ninline bool MousePressed(u32 button) {\n    return MouseDown(button) && !MousePrevDown(button);\n}\n\ninline bool MouseReleased(u32 button) {\n    return !MouseDown(button) && MousePrevDown(button);\n}\n\n// Touch API\nextern \"C\" u32 TouchGetMaxContacts();\n\nextern \"C\" u32 TouchGetX(u32 touchIndex);\nextern \"C\" u32 TouchGetY(u32 touchIndex);\nextern \"C\" bool TouchIsActive(u32 touchIndex);\n\nextern \"C\" u32 TouchGetPrevX(u32 touchIndex);\nextern \"C\" u32 TouchGetPrevY(u32 touchIndex);\nextern \"C\" bool TouchWasActive(u32 touchIndex);\n\ninline bool TouchPressed(u32 touchIndex) {\n    return TouchIsActive(touchIndex) && !TouchWasActive(touchIndex);\n}\n\ninline bool TouchReleased(u32 touchIndex) {\n    return !TouchIsActive(touchIndex) && TouchWasActive(touchIndex);\n}\n\n// Window API\n// The following functions need to be declared. Initialize returns the userdata pointer that is passed to the other functions.\n/*#define WasmExport __attribute__ (( visibility( \"default\" ) )) extern \"C\"\nWasmExport void* Initialize();\nWasmExport void Update(float dt, void* userData);\nWasmExport void Render(unsigned int x, unsigned int y, unsigned int w, unsigned int h, void* userData);\nWasmExport void Shutdown(void* userData);*/\n\n#endif"],"mappings":"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"}