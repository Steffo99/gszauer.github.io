{"version":3,"names":[],"sources":["test.cpp","calcTangents.cpp","graphics.h"],"sourcesContent":["// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    __wasm_call_ctors();\n}\n\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\"\n\n#include \"graphics.h\"\n#include \"memory.h\"\n#include \"loader.h\"\n\n#include \"calcTangents.cpp\"\n\n#define LOAD_BUFFER_SIZE (1024 * 1024 * 26)\n\nMemExposeHeap\nFileLoaderEnableCallbacks\n\nstruct AppData {\n    u32 vbo;\n    u32 shader;\n    u32 vao;\n\n    u32 planeVBO;\n    u32 planeVAO;\n    u32 planeNumVerts;\n    u32 planeShader;\n    u32 planeUniformModel;\n    u32 planeUniformView;\n    u32 planeUniformProj;\n    u32 planeUniformShadow;\n    u32 PlaneUniformColorSpec;\n    u32 PlaneUniformNormal;\n    u32 PlaneUniformShadowMap; \n    u32 PlaneUniformLightDirection;\n    u32 PlaneUniformLightColor;\n    u32 PlaneUniformViewPos;\n    u32 PlaneTextureColorSpec;\n    u32 PlaneTextureNormal;\n\n    u32 shadowMapShader;\n    u32 shadowMapUniformMvp;\n    u32 shadowMapTexture;\n    u32 shadowMapVao;\n\n    u32 skullShader;\n    u32 skullVbo;\n    u32 skullVao;\n    u32 skullNumVerts;\n    u32 skullUniformModel;\n    u32 skullUniformView;\n    u32 skullUniformProj;\n    u32 skullUniformAlbedo;\n    u32 skullUniformNormal;\n    u32 skullUniformTop;\n    u32 skullUniformBottom;\n    u32 skullUniformLightDir;\n    u32 skullUniformLightColor;\n    u32 skullUniformViewPos;\n    u32 skullUniformTexture;\n    u32 skullNormalTexture;\n    bool canDisplaySkull;\n\n    float* model;\n    float* view;\n    float* proj;\n    float cam[3];\n};\n\nexport void* Initialize() {\n    float vertices[] = {\n        -0.5f, -0.5f, 0.0f,\n        0.5f, -0.5f, 0.0f,\n        0.0f,  0.5f, 0.0f\n    };  \n\n    AppData* app = (AppData*)MemAllocate(sizeof(AppData), 0);\n    app->canDisplaySkull = false;\n\n    app->model = (float*)MemAllocate(sizeof(float) * 16, 0);\n    app->view = (float*)MemAllocate(sizeof(float) * 16, 0);\n    app->proj = (float*)MemAllocate(sizeof(float) * 16, 0);\n\n    for (int i = 0; i < 16; ++i) {\n        app->model[i] = 0.0f;\n        app->view[i] = 0.0f;\n        app->proj[i] = 0.0f;\n    }\n    app->model[0] = app->model[5] = app->model[10] = 0.1f;\n    app->model[12] = 1.5f;\n    app->model[14] = -0.5;\n    app->model[15] = 1.0f;\n\n    app->proj[0] = 1.82434f;\n    app->proj[5] = 2.43245f;\n    app->proj[10] = -1.00020f;\n    app->proj[11] = -1.00000f;\n    app->proj[14] = -0.20002f;\n    app->proj[15] =  0.00000f;\n     \n    app->view[0]  = 0.98773f;\n    app->view[1]  = -0.05942f;\n    app->view[2]  = 0.13843f;\n    app->view[5]  = 0.91813f;\n    app->view[6]  = 0.39411f;\n    app->view[8]  = -0.15065f;\n    app->view[9]  = -0.38962f;\n    app->view[10] = 0.90761f;\n    app->view[14] = -7.59863f;\n    app->view[15] = 1.00000f;\n\n    app->cam[0] = 1.05370f;\n    app->cam[1] = 3.00000f;\n    app->cam[2] = 6.90875f;\n\n    app->shadowMapTexture = GfxCreateDepthTexture(4096, 4096);\n    GfxSetTextureSampler(app->shadowMapTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterNearest, GfxFilterNone, GfxFilterNearest);\n\n    app->vbo = GfxCreateBuffer();\n    GfxFillArrayBuffer(app->vbo, vertices, sizeof(float) * 9, true);\n\n    const char* v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                            \"layout (location = 0) in vec3 aPos;\\n\"\n                            \"void main() {\\n\"\n                            \"    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"\n                            \"}\";\n    const char* f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                            \"out vec4 FragColor;\\n\"\n                            \"void main() {\\n\"\n                            \"    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"\n                            \"}\";\n    app->shader = GfxCreateShader(v_shader, f_shader);\n\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 position;\\n\"\n                \"uniform mat4 mvp;\\n\"\n                \"void main (void) {\\n\"\n                \"  gl_Position = mvp * vec4(position, 1.0);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"void main (void) {\\n\"\n                \"  FragColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);\\n\"\n                \"}\\n\";\n    app->shadowMapShader = GfxCreateShader(v_shader, f_shader);\n    app->shadowMapUniformMvp = GfxGetUniformSlot(app->shadowMapShader, \"mvp\");\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 aPos;\\n\"\n                \"in vec3 aNorm;\\n\"\n                \"in vec3 aTan;\\n\"\n                \"in vec2 aTexCoord;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform mat4 view;\\n\"\n                \"uniform mat4 projection;\\n\"\n                \"uniform mat4 shadow;\\n\"\n                \"out mat3 TBN;\\n\"\n                \"out vec2 TexCoord;\\n\"\n                \"out vec3 FragPos;\\n\"\n                \"out vec4 LightViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tgl_Position = projection * view * model * vec4(aPos, 1.0);\\n\"\n                \"\tFragPos = vec3(model * vec4(aPos, 1.0));\\n\"\n                \"\tLightViewPos = shadow * vec4(aPos, 1.0);\\n\"\n                \"\tvec3 biTangent = cross(aNorm, aTan);\\n\"\n                \"\tvec3 T = normalize(vec3(model * vec4(aTan,   0.0)));\\n\"\n                \"\tvec3 B = normalize(vec3(model * vec4(biTangent, 0.0)));\\n\"\n                \"\tvec3 N = normalize(vec3(model * vec4(aNorm,    0.0)));\\n\"\n                \"\tTBN = mat3(T, B, N);\\n\"\n                \"\tTexCoord = vec2(aTexCoord.x, aTexCoord.y);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec2 TexCoord;\\n\"\n                \"in vec3 FragPos;\\n\"\n                \"in mat3 TBN;\\n\"\n                \"in vec4 LightViewPos;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"uniform sampler2D uColorSpec;\\n\"\n                \"uniform sampler2D uNormal;\\n\"\n                \"uniform sampler2D uShadowMap; \\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform vec3 LightDirection;\\n\"\n                \"uniform vec3 LightColor;\\n\"\n                \"uniform vec3 ViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tvec3 normal = texture(uNormal, TexCoord).rgb; \\n\"\n                \"\tnormal = normal * 2.0 - 1.0;\\n\"\n                \"\tnormal = normalize(TBN * normal); // World space normal\\n\"\n                \"\tvec4 colorSpec = texture(uColorSpec, TexCoord);\\n\"\n                \"\tvec3 objectColor = colorSpec.rgb;\\n\"\n                \"\tvec3 lightDir = normalize(-LightDirection);\\n\"\n                \"\tfloat diff = max(dot(normal, lightDir), 0.0);\\n\"\n                \"\tvec3 diffuse = diff * LightColor;\\n\"\n                \"\tvec3 ambient = 0.2 * LightColor;\\n\"\n                \"\tvec3 viewDir = normalize(ViewPos - FragPos);\\n\"\n                \"\tvec3 reflectDir = reflect(-lightDir, normal);\\n\"\n                \"\tfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n\"\n                \"\tvec3 specular = colorSpec.a * spec * LightColor;  \\n\"\n                \"\tvec4 FinalColor = vec4((ambient+diffuse+specular) * objectColor, 1.0);\\n\"\n                \"\tvec3 p = LightViewPos.xyz / LightViewPos.w;\\n\"\n                \"\tFragColor = FinalColor * (texture(uShadowMap, p.xy).r < p.z? 0.0 : 1.0);\\n\"\n                \"}\\n\";\n    app->planeShader = GfxCreateShader(v_shader, f_shader);\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 aPos;\\n\"\n                \"in vec3 aNorm;\\n\"\n                \"in vec3 aTan;\\n\"\n                \"in vec2 aTexCoord;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform mat4 view;\\n\"\n                \"uniform mat4 projection;\\n\"\n                \"out mat3 TBN;\\n\"\n                \"out vec2 TexCoord;\\n\"\n                \"out vec3 FragPos;\\n\"\n                \"void main() {\\n\"\n                \"\tgl_Position = projection * view * model * vec4(aPos, 1.0);\\n\"\n                \"\tFragPos = vec3(model * vec4(aPos, 1.0));\\n\"\n                \"\tvec3 biTangent = cross(aNorm, aTan);\\n\"\n                \"\tvec3 T = normalize(vec3(model * vec4(aTan,   0.0)));\\n\"\n                \"\tvec3 B = normalize(vec3(model * vec4(biTangent, 0.0)));\\n\"\n                \"\tvec3 N = normalize(vec3(model * vec4(aNorm,    0.0)));\\n\"\n                \"\tTBN = mat3(T, B, N);\\n\"\n                \"\tTexCoord = vec2(aTexCoord.x, aTexCoord.y);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                \"in vec2 TexCoord;\\n\"\n                \"in vec3 FragPos;\\n\"\n                \"in mat3 TBN;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"uniform sampler2D uColorSpec;\\n\"\n                \"uniform sampler2D uNormal;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform vec3 HemiTop;\\n\"\n                \"uniform vec3 HemiBottom;\\n\"\n                \"uniform vec3 LightDirection;\\n\"\n                \"uniform vec3 LightColor;\\n\"\n                \"uniform vec3 ViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tvec3 normal = texture(uNormal, TexCoord).rgb;\\n\" \n                \"\tnormal = normal * 2.0 - 1.0;\\n\"\n                \"\tnormal = normalize(TBN * normal); // World space normal\\n\"\n                \"\tvec4 colorSpec = texture(uColorSpec, TexCoord);\\n\"\n                \"\tvec3 color = colorSpec.rgb;\\n\"\n                \"\tvec3 lightDir = normalize(-LightDirection);\\n\"\n                \"\tfloat diff = max(dot(normal, lightDir), 0.0);\\n\"\n                \"\tvec3 diffuse = diff * LightColor;\\n\"\n                \"\tdiff = max(dot(normal, normalize(vec3(-0.25, -1, 1))), 0.0);\\n\"\n                \"\tvec3 ambient = mix(HemiBottom, HemiTop, diff) * LightColor;\\n\"\n                \"\tvec3 viewDir = normalize(ViewPos - FragPos);\\n\"\n                \"\tvec3 reflectDir = reflect(-lightDir, normal);\\n\"\n                \"\tfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n\"\n                \"\tvec3 specular = colorSpec.a * spec * LightColor;  \\n\"\n                \"\tFragColor = vec4((ambient + diffuse + specular) * color, 1.0);\\n\"\n                \"}\\n\";\n    app->skullShader = GfxCreateShader(v_shader, f_shader);\n    app->skullUniformAlbedo = GfxGetUniformSlot(app->skullShader, \"uColorSpec\");\n\n    app->skullUniformNormal= GfxGetUniformSlot(app->skullShader, \"uNormal\");\n    app->skullUniformTop= GfxGetUniformSlot(app->skullShader, \"HemiTop\");\n    app->skullUniformBottom= GfxGetUniformSlot(app->skullShader, \"HemiBottom\");\n    app->skullUniformLightDir= GfxGetUniformSlot(app->skullShader, \"LightDirection\");\n    app->skullUniformLightColor= GfxGetUniformSlot(app->skullShader, \"LightColor\");\n    app->skullUniformViewPos= GfxGetUniformSlot(app->skullShader, \"ViewPos\");\n\n    app->vao = GfxCreateShaderVertexLayout(app->shader);\n    GfxAddBufferToLayout(app->vao, \"aPos\", app->vbo, 3, 0, GfxBufferTypeFloat32, 0);\n\n\n    void* loadArena = MemAllocate(LOAD_BUFFER_SIZE, 0);\n    LoadFileAsynch(\"assets/skull.mesh\", false, loadArena, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n        AppData* app = (AppData*)userData;\n\n        unsigned int* uint_data = (unsigned int*)data;\n        unsigned int numVerts = uint_data[0];  // Ignore 1, and 2. Always the same anyway\n        app->skullNumVerts = numVerts;\n       \n        float* srcPos = (float*)(uint_data + 3);\n        float* srcNrm = srcPos + numVerts * 3;\n        float* srcTex = srcNrm + numVerts * 3;\n\n        unsigned int tanArray_size = sizeof(float) * 3 * numVerts;\n        float* tanArray = (float*)MemAllocate(tanArray_size, 0);\n        MemClear(tanArray, tanArray_size);\n        CalculateMeshTangents::CalculateTangentArray(numVerts, srcPos, srcNrm, srcTex, tanArray);\n\n        unsigned int interleaved_size = sizeof(float) * numVerts * (3 + 3 + 3 + 2);\n        float* interleaved = (float*)MemAllocate(interleaved_size, 0);\n\n        for (int i = 0, j = 0; i < numVerts; ++i, j += 11) {\n            interleaved[j + 0] = srcPos[i * 3 + 0];\n            interleaved[j + 1] = srcPos[i * 3 + 1];\n            interleaved[j + 2] = srcPos[i * 3 + 2];\n\n            interleaved[j + 3] = srcNrm[i * 3 + 0];\n            interleaved[j + 4] = srcNrm[i * 3 + 1];\n            interleaved[j + 5] = srcNrm[i * 3 + 2];\n\n            interleaved[j + 6] = srcTex[i * 2 + 0];\n            interleaved[j + 7] = srcTex[i * 2 + 1];\n\n            interleaved[j + 8] = tanArray[i * 3 + 0];\n            interleaved[j + 9] = tanArray[i * 3 + 1];\n            interleaved[j + 10] = tanArray[i * 3 + 2];\n        }\n\n        app->skullVbo = GfxCreateBuffer();\n        GfxFillArrayBuffer(app->skullVbo, interleaved, interleaved_size, true);\n\n        app->skullVao = GfxCreateShaderVertexLayout(app->skullShader);\n        GfxAddBufferToLayout(app->skullVao, \"aPos\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n        GfxAddBufferToLayout(app->skullVao, \"aNorm\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 3); \n        GfxAddBufferToLayout(app->skullVao, \"aTexCoord\", app->skullVbo, 2, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 6);\n        GfxAddBufferToLayout(app->skullVao, \"aTan\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 8); \n\n        app->skullUniformModel = GfxGetUniformSlot(app->skullShader, \"model\");\n        app->skullUniformView  = GfxGetUniformSlot(app->skullShader, \"view\");\n        app->skullUniformProj  = GfxGetUniformSlot(app->skullShader, \"projection\");\n\n        app->shadowMapVao = GfxCreateShaderVertexLayout(app->shadowMapShader);\n        GfxAddBufferToLayout(app->shadowMapVao, \"position\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n\n        MemRelease(interleaved);\n        MemRelease(tanArray);\n\n        LoadFileAsynch(\"assets/Skull_AlbedoSpec.texture\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n            AppData* app = (AppData*)userData;\n\n            u32* u32_data = (u32*)data;\n\n            u32 width = u32_data[0];\n            u32 height = u32_data[1];\n            u32 channels = u32_data[2];\n            unsigned char* img_data = (unsigned char*)data;\n            img_data = img_data + 12; // Skip width / height / channels\n\n            unsigned int format = GfxTextureFormatRGB8;\n            if (channels == 4) {\n                format = GfxTextureFormatRGBA8;\n            }            \n\n            app->skullUniformTexture = GfxCreateTexture(img_data, width, height, format, format, true);\n            GfxSetTextureSampler(app->skullUniformTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n\n            LoadFileAsynch(\"assets/Skull_Normal.texture\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                AppData* app = (AppData*)userData;\n                u32* u32_data = (u32*)data;\n                u32 width = u32_data[0];\n                u32 height = u32_data[1];\n                u32 channels = u32_data[2];\n                unsigned char* img_data = (unsigned char*)data;\n                img_data = img_data + 12; // Skip width / height / channels\n                unsigned int format = GfxTextureFormatRGB8;\n                if (channels == 4) {\n                    format = GfxTextureFormatRGBA8;\n                }            \n                \n                app->skullNormalTexture =  GfxCreateTexture(img_data, width, height, format, format, true);\n                GfxSetTextureSampler(app->skullUniformTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                \n                LoadFileAsynch(\"assets/plane.mesh\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                    AppData* app = (AppData*)userData;\n                    unsigned int* uint_data = (unsigned int*)data;\n                    unsigned int numVerts = uint_data[0];  // Ignore 1, and 2. Always the same anyway\n                    app->planeNumVerts = numVerts;\n                \n                    float* srcPos = (float*)(uint_data + 3);\n                    float* srcNrm = srcPos + numVerts * 3;\n                    float* srcTex = srcNrm + numVerts * 3;\n\n                    unsigned int tanArray_size = sizeof(float) * 3 * numVerts;\n                    float* tanArray = (float*)MemAllocate(tanArray_size, 0);\n                    MemClear(tanArray, tanArray_size);\n                    CalculateMeshTangents::CalculateTangentArray(numVerts, srcPos, srcNrm, srcTex, tanArray);\n                    unsigned int interleaved_size = sizeof(float) * numVerts * (3 + 3 + 3 + 2);\n                    float* interleaved = (float*)MemAllocate(interleaved_size, 0);\n                    for (int i = 0, j = 0; i < numVerts; ++i, j += 11) {\n                        interleaved[j + 0] = srcPos[i * 3 + 0];\n                        interleaved[j + 1] = srcPos[i * 3 + 1];\n                        interleaved[j + 2] = srcPos[i * 3 + 2];\n\n                        interleaved[j + 3] = srcNrm[i * 3 + 0];\n                        interleaved[j + 4] = srcNrm[i * 3 + 1];\n                        interleaved[j + 5] = srcNrm[i * 3 + 2];\n\n                        interleaved[j + 6] = srcTex[i * 2 + 0];\n                        interleaved[j + 7] = srcTex[i * 2 + 1];\n\n                        interleaved[j + 8] = tanArray[i * 3 + 0];\n                        interleaved[j + 9] = tanArray[i * 3 + 1];\n                        interleaved[j + 10] = tanArray[i * 3 + 2];\n                    }\n\n                    app->planeVBO = GfxCreateBuffer();\n                    GfxFillArrayBuffer(app->planeVBO, interleaved, interleaved_size, true);\n\n                    app->planeVAO = GfxCreateShaderVertexLayout(app->planeShader);\n                    GfxAddBufferToLayout(app->planeVAO, \"aPos\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n                    GfxAddBufferToLayout(app->planeVAO, \"aNorm\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 3); \n                    GfxAddBufferToLayout(app->planeVAO, \"aTexCoord\", app->planeVBO, 2, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 6);\n                    GfxAddBufferToLayout(app->planeVAO, \"aTan\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 8); \n\n                    app->planeUniformModel = GfxGetUniformSlot(app->planeShader, \"model\");\n                    app->planeUniformView = GfxGetUniformSlot(app->planeShader, \"view\");\n                    app->planeUniformProj = GfxGetUniformSlot(app->planeShader, \"projection\");\n                    app->planeUniformShadow = GfxGetUniformSlot(app->planeShader, \"shadow\");\n\n                    app->PlaneUniformColorSpec = GfxGetUniformSlot(app->planeShader, \"uColorSpec\");\n                    app->PlaneUniformNormal = GfxGetUniformSlot(app->planeShader, \"uNormal\");\n                    app->PlaneUniformShadowMap = GfxGetUniformSlot(app->planeShader, \"uShadowMap\");\n\n                    app->PlaneUniformLightDirection = GfxGetUniformSlot(app->planeShader, \"LightDirection\");\n                    app->PlaneUniformLightColor = GfxGetUniformSlot(app->planeShader, \"LightColor\");\n                    app->PlaneUniformViewPos = GfxGetUniformSlot(app->planeShader, \"ViewPos\");\n\n                    MemRelease(interleaved);\n                    MemRelease(tanArray);\n\n                    LoadFileAsynch(\"assets/Plane_AlbedoSpec.texture\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                        AppData* app = (AppData*)userData;\n                        u32* u32_data = (u32*)data;\n                        u32 width = u32_data[0];\n                        u32 height = u32_data[1];\n                        u32 channels = u32_data[2];\n                        unsigned char* img_data = (unsigned char*)data;\n                        img_data = img_data + 12; // Skip width / height / channels\n                        unsigned int format = GfxTextureFormatRGB8;\n                        if (channels == 4) {\n                            format = GfxTextureFormatRGBA8;\n                        }            \n                        app->PlaneTextureColorSpec =  GfxCreateTexture(img_data, width, height, format, format, true);\n                        GfxSetTextureSampler(app->PlaneTextureColorSpec, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                \n                        LoadFileAsynch(\"assets/Plane_Normal.texture\", false, data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                            AppData* app = (AppData*)userData;\n                            u32* u32_data = (u32*)data;\n                            u32 width = u32_data[0];\n                            u32 height = u32_data[1];\n                            u32 channels = u32_data[2];\n                            unsigned char* img_data = (unsigned char*)data;\n                            img_data = img_data + 12; // Skip width / height / channels\n                            unsigned int format = GfxTextureFormatRGB8;\n                            if (channels == 4) {\n                                format = GfxTextureFormatRGBA8;\n                            }            \n                            app->PlaneTextureNormal =  GfxCreateTexture(img_data, width, height, format, format, true);\n                            GfxSetTextureSampler(app->PlaneTextureNormal, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n\n                            MemRelease(data);\n                            app->canDisplaySkull = true;\n                        }, app);\n                    }, app);\n                }, app);\n            }, app);\n        }, app);\n    }, app);\n\n    GfxEnableDepthTest();\n\n    return app;\n}\n\nexport void Update(AppData* app) {\n    /*GfxClearColor(0, 0, 0.5f, 0.6f, 0.7f);\n    GfxClearDepth(0, 0, 1.0f);\n    GfxDraw(0, 0, app->vao, GfxDrawModeTriangles, 0, 3, 1);*/\n\n    const float plane_shadow[16] = {0.13074f, 0.01829f, 0.01400f, 0.00000f,0.00000f, 0.09512f, -0.06999f, 0.00000f,0.02615f, -0.09146f, -0.06999f, 0.00000f,0.50000f, 0.42866f, 0.54184f, 1.00000f };\n    const float plane_model[16] = {2.00000f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 2.00000f, 0.00000f, 0.00000f,0.00000f, 0.00000f, 2.00000f, 0.00000f,0.00000f, -1.50000f, 0.00000f, 1.00000f };\n    const float skull_model[16] = {0.10000f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 0.10000f, 0.00000f, 0.00000f,0.00000f, 0.00000f, 0.10000f, 0.00000f,1.50000f, 0.00000f, -0.50000f, 1.00000f };\n    const float shadow_mvp[16] = {0.01307f, 0.00183f, 0.00140f, 0.00000f,0.00000f, 0.00951f, -0.00700f, 0.00000f,0.00261f, -0.00915f, -0.00700f, 0.00000f,0.18304f, 0.07317f, 0.05468f, 1.00000f };\n    const float view[16] = {0.99916f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 0.91836f, 0.39357f, 0.00000f,0.00000f, -0.39358f, 0.91833f, 0.00000f,0.00000f, 0.00000f, -7.60905f, 1.00000f };\n    const float proj[16] = {1.82434f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 2.43245f, 0.00000f, 0.00000f,0.00000f, 0.00000f, -1.00020f, -1.00000f,0.00000f, 0.00000f, -0.20002f, 0.00000f };\n\n    if (app->canDisplaySkull) {\n        { // Draw lightmap\n            GfxSetViewport(0, 0, 4096, 4096);\n            GfxClearDepth(0, 0, 1.0f);\n            GfxSetCullState(GfxCullFaceFront, GfxFaceWindCounterClockwise);\n            GfxSetUniform(app->shadowMapShader, app->shadowMapUniformMvp, (void*)shadow_mvp, GfxUniformTypeFloat16, 1); \n            GfxDraw(0, app->shadowMapTexture, app->shadowMapVao, GfxDrawModeTriangles, 0, app->skullNumVerts, 1);\n            GfxSetCullState(GfxCullFaceBack, GfxFaceWindCounterClockwise);\n            GfxSetViewport(0, 0, 800, 600);\n        }\n\n        GfxClearAll(0, 0, 0.5f, 0.6f, 0.7f, 1.0f);\n\n        const float lightDir[3] = {0.2f, -1.0f, -1.0f};\n        const float lightColor[3] = {1.0f, 1.0f, 1.0f};\n\n        { // Draw Skull\n            const float hemiTop[3] = {0.2f, 0.2f, 0.2f};\n            const float hemiBottom[3] = {0.1f, 0.1f, 0.1f};\n\n            GfxSetUniform(app->skullShader, app->skullUniformModel, (void*)skull_model, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformView, (void*)view, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformProj, (void*)proj, GfxUniformTypeFloat16, 1); \n            \n            GfxSetUniformTexture(app->skullShader, app->skullUniformAlbedo, app->skullUniformTexture);\n            GfxSetUniformTexture(app->skullShader, app->skullUniformNormal, app->skullNormalTexture);\n            \n            GfxSetUniform(app->skullShader, app->skullUniformTop, (void*)hemiTop, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformBottom, (void*)hemiBottom, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformLightDir, (void*)lightDir, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformLightColor, (void*)lightColor, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->skullShader, app->skullUniformViewPos, app->cam, GfxUniformTypeFloat3, 1); \n\n            GfxDraw(0, 0, app->skullVao, GfxDrawModeTriangles, 0, app->skullNumVerts, 1);\n        }\n\n        { // Draw plane\n            GfxSetUniform(app->planeShader, app->planeUniformModel, (void*)plane_model, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->planeShader, app->planeUniformView, (void*)view, GfxUniformTypeFloat16, 1); \n            GfxSetUniform(app->planeShader, app->planeUniformProj, (void*)proj, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->planeShader, app->planeUniformShadow,  (void*)plane_shadow, GfxUniformTypeFloat16, 1); \n\n            GfxSetUniform(app->planeShader, app->PlaneUniformLightDirection,(void*)lightDir, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->planeShader, app->PlaneUniformLightColor, (void*)lightColor, GfxUniformTypeFloat3, 1); \n            GfxSetUniform(app->planeShader, app->PlaneUniformViewPos, app->cam, GfxUniformTypeFloat3, 1); \n\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformColorSpec, app->PlaneTextureColorSpec);\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformNormal, app->PlaneTextureNormal);\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformShadowMap, app->shadowMapTexture);\n\n            GfxDraw(0, 0, app->planeVAO, GfxDrawModeTriangles, 0, app->planeNumVerts, 1);\n        }\n    }\n}","#define VEC3_EPSILON 0.000001f\n#define MAT4_EPSILON 0.000001f\n#define QUAT_EPSILON 0.000001f\n#define QUAT_DEG2RAD 0.0174533f\n#define QUAT_RAD2DEG 57.2958f\n\nnamespace CalculateMeshTangents {\n    \n\n    float FastSin(float x);\n    float FastCos(float x);\n\n    template<typename T>\n    struct TVec2 {\n        union {\n            struct {\n                T x;\n                T y;\n            };\n            T v[2];\n        };\n        inline TVec2() : x(T(0)), y(T(0)) { }\n        inline TVec2(T _x, T _y) :\n            x(_x), y(_y) { }\n        inline TVec2(T* fv) :\n            x(fv[0]), y(fv[1]) { }\n    };\n\n    typedef TVec2<float> vec2;\n    typedef TVec2<int> ivec2;\n    typedef TVec2<unsigned int> uivec2;\n\n    struct vec3 {\n        union {\n            struct {\n                float x;\n                float y;\n                float z;\n            };\n            float v[3];\n        };\n        inline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n        inline vec3(float _x, float _y, float _z) :\n            x(_x), y(_y), z(_z) { }\n        inline vec3(float* fv) :\n            x(fv[0]), y(fv[1]), z(fv[2]) { }\n    };\n\n    vec3 operator+(const vec3& l, const vec3& r);\n    vec3 operator-(const vec3& l, const vec3& r);\n    vec3 operator*(const vec3& v, float f);\n    vec3 operator*(const vec3& l, const vec3& r);\n    float dot(const vec3& l, const vec3& r);\n    float lenSq(const vec3& v);\n    float len(const vec3& v);\n    void normalize(vec3& v);\n    vec3 normalized(const vec3& v);\n    vec3 project(const vec3& a, const vec3& b);\n    vec3 reject(const vec3& a, const vec3& b);\n    vec3 reflect(const vec3& a, const vec3& b);\n    vec3 cross(const vec3& l, const vec3& r);\n    vec3 lerp(const vec3& s, const vec3& e, float t);\n    vec3 nlerp(const vec3& s, const vec3& e, float t);\n    bool operator==(const vec3& l, const vec3& r);\n    bool operator!=(const vec3& l, const vec3& r);\n\n    template<typename T>\n    struct TVec4 {\n        union {\n            struct {\n                T x;\n                T y;\n                T z;\n                T w;\n            };\n            T v[4];\n        };\n        inline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n        inline TVec4(T _x, T _y, T _z, T _w) :\n            x(_x), y(_y), z(_z), w(_w) { }\n        inline TVec4(T* fv) :\n            x(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n    };\n\n    typedef TVec4<float> vec4;\n    typedef TVec4<int> ivec4;\n    typedef TVec4<unsigned int> uivec4;\n\n\n    struct mat4 {\n        union {\n            float v[16];\n            struct {\n                vec4 right;\n                vec4 up;\n                vec4 forward;\n                vec4 position;\n            };\n            struct {\n                //            row 1     row 2     row 3     row 4\n                /* column 1 */float xx; float xy; float xz; float xw;\n                /* column 2 */float yx; float yy; float yz; float yw;\n                /* column 3 */float zx; float zy; float zz; float zw;\n                /* column 4 */float tx; float ty; float tz; float tw;\n            };\n            struct {\n                float c0r0; float c0r1; float c0r2; float c0r3;\n                float c1r0; float c1r1; float c1r2; float c1r3;\n                float c2r0; float c2r1; float c2r2; float c2r3;\n                float c3r0; float c3r1; float c3r2; float c3r3;\n            };\n            struct {\n                float r0c0; float r1c0; float r2c0; float r3c0;\n                float r0c1; float r1c1; float r2c1; float r3c1;\n                float r0c2; float r1c2; float r2c2; float r3c2;\n                float r0c3; float r1c3; float r2c3; float r3c3;\n            };\n        };\n        inline mat4() :\n            xx(1), xy(0), xz(0), xw(0),\n            yx(0), yy(1), yz(0), yw(0),\n            zx(0), zy(0), zz(1), zw(0),\n            tx(0), ty(0), tz(0), tw(1) {}\n\n        inline mat4(float* fv) :\n            xx(fv[0]), xy(fv[1]), xz(fv[2]), xw(fv[3]),\n            yx(fv[4]), yy(fv[5]), yz(fv[6]), yw(fv[7]),\n            zx(fv[8]), zy(fv[9]), zz(fv[10]), zw(fv[11]),\n            tx(fv[12]), ty(fv[13]), tz(fv[14]), tw(fv[15]) { }\n\n        inline mat4(\n            float _00, float _01, float _02, float _03,\n            float _10, float _11, float _12, float _13,\n            float _20, float _21, float _22, float _23,\n            float _30, float _31, float _32, float _33) :\n            xx(_00), xy(_01), xz(_02), xw(_03),\n            yx(_10), yy(_11), yz(_12), yw(_13),\n            zx(_20), zy(_21), zz(_22), zw(_23),\n            tx(_30), ty(_31), tz(_32), tw(_33) { }\n    }; // end mat4 struct\n\n    bool operator==(const mat4& a, const mat4& b);\n    bool operator!=(const mat4& a, const mat4& b);\n    mat4 operator+(const mat4& a, const mat4& b);\n    mat4 operator*(const mat4& m, float f);\n    mat4 operator*(const mat4& a, const mat4& b);\n    vec4 operator*(const mat4& m, const vec4& v);\n    vec3 transformVector(const mat4& m, const vec3& v);\n    vec3 transformPoint(const mat4& m, const vec3& v);\n    vec3 transformPoint(const mat4& m, const vec3& v, float& w);\n    void transpose(mat4& m);\n    mat4 transposed(const mat4& m);\n    float determinant(const mat4& m);\n    mat4 adjugate(const mat4& m);\n    mat4 inverse(const mat4& m);\n    void invert(mat4& m);\n    mat4 frustum(float l, float r, float b, float t, float n, float f);\n    mat4 perspective(float fov, float aspect, float znear, float zfar);\n    mat4 ortho(float l, float r, float b, float t, float n, float f);\n    mat4 lookAt(const vec3& position, const vec3& target, const vec3& up);\n\n    struct quat {\n        union {\n            struct {\n                float x;\n                float y;\n                float z;\n                float w;\n            };\n            struct {\n                vec3 vector;\n                float scalar;\n            };\n            float v[4];\n        };\n\n        inline quat() :\n            x(0), y(0), z(0), w(1) { }\n        inline quat(float _x, float _y, float _z, float _w) :\n            x(_x), y(_y), z(_z), w(_w) {}\n    };\n\n    quat angleAxis(float angle, const vec3& axis);\n    quat fromTo(const vec3& from, const vec3& to);\n    vec3 getAxis(const quat& quat);\n    float getAngle(const quat& quat);\n    quat operator+(const quat& a, const quat& b);\n    quat operator-(const quat& a, const quat& b);\n    quat operator*(const quat& a, float b);\n    quat operator-(const quat& q);\n    bool operator==(const quat& left, const quat& right);\n    bool operator!=(const quat& a, const quat& b);\n    bool sameOrientation(const quat& left, const quat& right);\n    float dot(const quat& a, const quat& b);\n    float lenSq(const quat& q);\n    float len(const quat& q);\n    void normalize(quat& q);\n    quat normalized(const quat& q);\n    quat conjugate(const quat& q);\n    quat inverse(const quat& q);\n    quat operator*(const quat& Q1, const quat& Q2);\n    vec3 operator*(const quat& q, const vec3& v);\n    quat mix(const quat& from, const quat& to, float t);\n    quat nlerp(const quat& from, const quat& to, float t);\n    quat operator^(const quat& q, float f);\n    quat operator^(const quat& q, float f);\n    quat slerp(const quat& start, const quat& end, float t);\n    quat lookRotation(const vec3& direcion, const vec3& up);\n    mat4 quatToMat4(const quat& q);\n    quat mat4ToQuat(const mat4& m);\n\n    float Sqrtf(const float& n) {\n        if (n == 0.0f) {\n            return 0.0f;\n        }\n\n        int i = 0x2035AD0C + (*(int*)&n >> 1);\n        return n / *(float*)&i + *(float*)&i * 0.25f;\n    }\n\n    float Fabsf(const float& f) {\n        if (f < 0.0f) {\n            return f * -1.0f;\n        }\n        return f;\n    }\n\n    double Sin(const double& x) {\n        int i = 1;\n        double cur = x;\n        double acc = 1;\n        double fact = 1;\n        double pow = x;\n        while (acc > .00000001 && i < 100) {\n            fact *= ((2 * i) * (2 * i + 1));\n            pow *= -1 * x * x;\n            acc = pow / fact;\n            if (acc < 0.0) { // fabs\n                acc *= -1.0;\n            }\n            cur += acc;\n            i++;\n        }\n        return cur;\n    }\n\n    #define PI         (3.1415926535f)\n    #define HALF_PI    (0.5f * PI)\n    #define TWO_PI     (2.0f * PI)\n    #define TWO_PI_INV (1.0f / TWO_PI)\n\n    inline float Hill(float x)\n    {\n        const float a0 = 1.0f;\n        const float a2 = 2.0f / PI - 12.0f / (PI * PI);\n        const float a3 = 16.0f / (PI * PI * PI) - 4.0f / (PI * PI);\n        const float xx = x * x;\n        const float xxx = xx * x;\n\n        return a0 + a2 * xx + a3 * xxx;\n    }\n\n    float FastSin(float x)\n    {\n        // wrap x within [0, TWO_PI)\n        const float a = x * TWO_PI_INV;\n        x -= static_cast<int>(a) * TWO_PI;\n        if (x < 0.0f)\n            x += TWO_PI;\n\n        // 4 pieces of hills\n        if (x < HALF_PI)\n            return Hill(HALF_PI - x);\n        else if (x < PI)\n            return Hill(x - HALF_PI);\n        else if (x < 3.0f * HALF_PI)\n            return -Hill(3.0f * HALF_PI - x);\n        else\n            return -Hill(x - 3.0f * HALF_PI);\n    }\n\n    float FastCos(float x)\n    {\n        return FastSin(x + HALF_PI);\n    }\n\n    float Tan(const float& d) {\n        return FastSin(d) / FastCos(d);\n    }\n\n\n    vec3 operator+(const vec3& l, const vec3& r) {\n        return vec3(l.x + r.x, l.y + r.y, l.z + r.z);\n    }\n\n    vec3 operator-(const vec3& l, const vec3& r) {\n        return vec3(l.x - r.x, l.y - r.y, l.z - r.z);\n    }\n\n    vec3 operator*(const vec3& v, float f) {\n        return vec3(v.x * f, v.y * f, v.z * f);\n    }\n\n    vec3 operator*(const vec3& l, const vec3& r) {\n        return vec3(l.x * r.x, l.y * r.y, l.z * r.z);\n    }\n\n    float dot(const vec3& l, const vec3& r) {\n        return l.x * r.x + l.y * r.y + l.z * r.z;\n    }\n\n    float lenSq(const vec3& v) {\n        return v.x * v.x + v.y * v.y + v.z * v.z;\n    }\n\n    float len(const vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return 0.0f;\n        }\n        return Sqrtf(lenSq);\n    }\n\n    void normalize(vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return;\n        }\n        float invLen = 1.0f / Sqrtf(lenSq);\n\n        v.x *= invLen;\n        v.y *= invLen;\n        v.z *= invLen;\n    }\n\n    vec3 normalized(const vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return v;\n        }\n        float invLen = 1.0f / Sqrtf(lenSq);\n\n        return vec3(\n            v.x * invLen,\n            v.y * invLen,\n            v.z * invLen\n        );\n    }\n\n    vec3 project(const vec3& a, const vec3& b) {\n        float magBSq = len(b);\n        if (magBSq < VEC3_EPSILON) {\n            return vec3();\n        }\n        float scale = dot(a, b) / magBSq;\n        return b * scale;\n    }\n\n    vec3 reject(const vec3& a, const vec3& b) {\n        vec3 projection = project(a, b);\n        return a - projection;\n    }\n\n    vec3 reflect(const vec3& a, const vec3& b) {\n        float magBSq = len(b);\n        if (magBSq < VEC3_EPSILON) {\n            return vec3();\n        }\n        float scale = dot(a, b) / magBSq;\n        vec3 proj2 = b * (scale * 2);\n        return a - proj2;\n    }\n\n    vec3 cross(const vec3& l, const vec3& r) {\n        return vec3(\n            l.y * r.z - l.z * r.y,\n            l.z * r.x - l.x * r.z,\n            l.x * r.y - l.y * r.x\n        );\n    }\n\n    vec3 lerp(const vec3& s, const vec3& e, float t) {\n        return vec3(\n            s.x + (e.x - s.x) * t,\n            s.y + (e.y - s.y) * t,\n            s.z + (e.z - s.z) * t\n        );\n    }\n\n    vec3 nlerp(const vec3& s, const vec3& e, float t) {\n        vec3 linear(\n            s.x + (e.x - s.x) * t,\n            s.y + (e.y - s.y) * t,\n            s.z + (e.z - s.z) * t\n        );\n        return normalized(linear);\n    }\n\n    bool operator==(const vec3& l, const vec3& r) {\n        vec3 diff(l - r);\n        return lenSq(diff) < VEC3_EPSILON;\n    }\n\n    bool operator!=(const vec3& l, const vec3& r) {\n        return !(l == r);\n    }\n\n    bool operator==(const mat4& a, const mat4& b) {\n        for (int i = 0; i < 16; ++i) {\n            if (Fabsf(a.v[i] - b.v[i]) > MAT4_EPSILON) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool operator!=(const mat4& a, const mat4& b) {\n        return !(a == b);\n    }\n\n    mat4 operator+(const mat4& a, const mat4& b) {\n        return mat4(\n            a.xx + b.xx, a.xy + b.xy, a.xz + b.xz, a.xw + b.xw,\n            a.yx + b.yx, a.yy + b.yy, a.yz + b.yz, a.yw + b.yw,\n            a.zx + b.zx, a.zy + b.zy, a.zz + b.zz, a.zw + b.zw,\n            a.tx + b.tx, a.ty + b.ty, a.tz + b.tz, a.tw + b.tw\n        );\n    }\n\n    mat4 operator*(const mat4& m, float f) {\n        return mat4(\n            m.xx * f, m.xy * f, m.xz * f, m.xw * f,\n            m.yx * f, m.yy * f, m.yz * f, m.yw * f,\n            m.zx * f, m.zy * f, m.zz * f, m.zw * f,\n            m.tx * f, m.ty * f, m.tz * f, m.tw * f\n        );\n    }\n\n    #define M4D(aRow, bCol) \\\n        a.v[0 * 4 + aRow] * b.v[bCol * 4 + 0] + \\\n        a.v[1 * 4 + aRow] * b.v[bCol * 4 + 1] + \\\n        a.v[2 * 4 + aRow] * b.v[bCol * 4 + 2] + \\\n        a.v[3 * 4 + aRow] * b.v[bCol * 4 + 3]\n\n    mat4 operator*(const mat4& a, const mat4& b) {\n        return mat4(\n            M4D(0, 0), M4D(1, 0), M4D(2, 0), M4D(3, 0), // Column 0\n            M4D(0, 1), M4D(1, 1), M4D(2, 1), M4D(3, 1), // Column 1\n            M4D(0, 2), M4D(1, 2), M4D(2, 2), M4D(3, 2), // Column 2\n            M4D(0, 3), M4D(1, 3), M4D(2, 3), M4D(3, 3)  // Column 3\n        );\n    }\n\n    #define M4V4D(mRow, x, y, z, w) \\\n        x * m.v[0 * 4 + mRow] + \\\n        y * m.v[1 * 4 + mRow] + \\\n        z * m.v[2 * 4 + mRow] + \\\n        w * m.v[3 * 4 + mRow]\n\n    vec4 operator*(const mat4& m, const vec4& v) {\n        return vec4(\n            M4V4D(0, v.x, v.y, v.z, v.w),\n            M4V4D(1, v.x, v.y, v.z, v.w),\n            M4V4D(2, v.x, v.y, v.z, v.w),\n            M4V4D(3, v.x, v.y, v.z, v.w)\n        );\n    }\n\n    vec3 transformVector(const mat4& m, const vec3& v) {\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, 0.0f),\n            M4V4D(1, v.x, v.y, v.z, 0.0f),\n            M4V4D(2, v.x, v.y, v.z, 0.0f)\n        );\n    }\n\n    vec3 transformPoint(const mat4& m, const vec3& v) {\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, 1.0f),\n            M4V4D(1, v.x, v.y, v.z, 1.0f),\n            M4V4D(2, v.x, v.y, v.z, 1.0f)\n        );\n    }\n\n    vec3 transformPoint(const mat4& m, const vec3& v, float& w) {\n        float _w = w;\n        w = M4V4D(3, v.x, v.y, v.z, _w);\n\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, _w),\n            M4V4D(1, v.x, v.y, v.z, _w),\n            M4V4D(2, v.x, v.y, v.z, _w)\n        );\n    }\n\n    #define M4SWAP(x, y) \\\n        {float t = x; x = y; y = t; }\n\n    void transpose(mat4& m) {\n        M4SWAP(m.yx, m.xy);\n        M4SWAP(m.zx, m.xz);\n        M4SWAP(m.tx, m.xw);\n        M4SWAP(m.zy, m.yz);\n        M4SWAP(m.ty, m.yw);\n        M4SWAP(m.tz, m.zw);\n    }\n\n    mat4 transposed(const mat4& m) {\n        return mat4(\n            m.xx, m.yx, m.zx, m.tx,\n            m.xy, m.yy, m.zy, m.ty,\n            m.xz, m.yz, m.zz, m.tz,\n            m.xw, m.yw, m.zw, m.tw\n        );\n    }\n\n    #define M4_3X3MINOR(c0, c1, c2, r0, r1, r2) \\\n        (m.v[c0 * 4 + r0] * (m.v[c1 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c1 * 4 + r2] * m.v[c2 * 4 + r1]) - \\\n        m.v[c1 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c2 * 4 + r1]) + \\\n        m.v[c2 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c1 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c1 * 4 + r1]))\n\n    float determinant(const mat4& m) {\n        return  m.v[0] * M4_3X3MINOR(1, 2, 3, 1, 2, 3)\n            - m.v[4] * M4_3X3MINOR(0, 2, 3, 1, 2, 3)\n            + m.v[8] * M4_3X3MINOR(0, 1, 3, 1, 2, 3)\n            - m.v[12] * M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n    }\n\n    mat4 adjugate(const mat4& m) {\n        // Cofactor(M[i, j]) = Minor(M[i, j]] * pow(-1, i + j)\n        mat4 cofactor;\n\n        cofactor.v[0] = M4_3X3MINOR(1, 2, 3, 1, 2, 3);\n        cofactor.v[1] = -M4_3X3MINOR(1, 2, 3, 0, 2, 3);\n        cofactor.v[2] = M4_3X3MINOR(1, 2, 3, 0, 1, 3);\n        cofactor.v[3] = -M4_3X3MINOR(1, 2, 3, 0, 1, 2);\n\n        cofactor.v[4] = -M4_3X3MINOR(0, 2, 3, 1, 2, 3);\n        cofactor.v[5] = M4_3X3MINOR(0, 2, 3, 0, 2, 3);\n        cofactor.v[6] = -M4_3X3MINOR(0, 2, 3, 0, 1, 3);\n        cofactor.v[7] = M4_3X3MINOR(0, 2, 3, 0, 1, 2);\n\n        cofactor.v[8] = M4_3X3MINOR(0, 1, 3, 1, 2, 3);\n        cofactor.v[9] = -M4_3X3MINOR(0, 1, 3, 0, 2, 3);\n        cofactor.v[10] = M4_3X3MINOR(0, 1, 3, 0, 1, 3);\n        cofactor.v[11] = -M4_3X3MINOR(0, 1, 3, 0, 1, 2);\n\n        cofactor.v[12] = -M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n        cofactor.v[13] = M4_3X3MINOR(0, 1, 2, 0, 2, 3);\n        cofactor.v[14] = -M4_3X3MINOR(0, 1, 2, 0, 1, 3);\n        cofactor.v[15] = M4_3X3MINOR(0, 1, 2, 0, 1, 2);\n\n        return transposed(cofactor);\n    }\n\n    mat4 inverse(const mat4& m) {\n        float det = determinant(m);\n\n        if (det == 0.0f) { // Epsilon check would need to be REALLY small\n            return mat4();\n        }\n        mat4 adj = adjugate(m);\n\n        return adj * (1.0f / det);\n    }\n\n    void invert(mat4& m) {\n        float det = determinant(m);\n\n        if (det == 0.0f) {\n            m = mat4();\n            return;\n        }\n\n        m = adjugate(m) * (1.0f / det);\n    }\n\n    mat4 frustum(float l, float r, float b, float t, float n, float f) {\n        if (l == r || t == b || n == f) {\n            return mat4(); // Error\n        }\n        return mat4(\n            (2.0f * n) / (r - l), 0, 0, 0,\n            0, (2.0f * n) / (t - b), 0, 0,\n            (r + l) / (r - l), (t + b) / (t - b), (-(f + n)) / (f - n), -1,\n            0, 0, (-2 * f * n) / (f - n), 0\n        );\n    }\n\n    mat4 perspective(float fov, float aspect, float znear, float zfar) {\n        float ymax = znear * (float)Tan(fov * 3.14159265359f / 360.0f);\n        float xmax = ymax * aspect;\n\n        return frustum(-xmax, xmax, -ymax, ymax, znear, zfar);\n    }\n\n    mat4 ortho(float l, float r, float b, float t, float n, float f) {\n        if (l == r || t == b || n == f) {\n            return mat4(); // Error\n        }\n        return mat4(\n            2.0f / (r - l), 0, 0, 0,\n            0, 2.0f / (t - b), 0, 0,\n            0, 0, -2.0f / (f - n), 0,\n            -((r + l) / (r - l)), -((t + b) / (t - b)), -((f + n) / (f - n)), 1\n        );\n    }\n\n    mat4 lookAt(const vec3& position, const vec3& target, const vec3& up) {\n        // Remember, forward is negative z\n        vec3 f = normalized(target - position) * -1.0f;\n        vec3 r = cross(up, f); // Right handed\n        if (r == vec3(0, 0, 0)) {\n            return mat4(); // Error\n        }\n        normalize(r);\n        vec3 u = normalized(cross(f, r)); // Right handed\n\n        vec3 t = vec3(\n            -dot(r, position),\n            -dot(u, position),\n            -dot(f, position)\n        );\n\n        return mat4(\n            // Transpose upper 3x3 matrix to invert it\n            r.x, u.x, f.x, 0,\n            r.y, u.y, f.y, 0,\n            r.z, u.z, f.z, 0,\n            t.x, t.y, t.z, 1\n        );\n    }\n\n    quat angleAxis(float angle, const vec3& axis) {\n        vec3 norm = normalized(axis);\n        float s = FastSin(angle * 0.5f);\n\n        return quat(\n            norm.x * s,\n            norm.y * s,\n            norm.z * s,\n            FastCos(angle * 0.5f)\n        );\n    }\n\n    quat fromTo(const vec3& from, const vec3& to) {\n        vec3 f = normalized(from);\n        vec3 t = normalized(to);\n\n        if (f == t) {\n            return quat();\n        }\n        else if (f == t * -1.0f) {\n            vec3 ortho = vec3(1, 0, 0);\n            if (Fabsf(f.y) < Fabsf(f.x)) {\n                ortho = vec3(0, 1, 0);\n            }\n            if (Fabsf(f.z) < Fabsf(f.y) && Fabsf(f.z) < Fabsf(f.x)) {\n                ortho = vec3(0, 0, 1);\n            }\n\n            vec3 axis = normalized(cross(f, ortho));\n            return quat(axis.x, axis.y, axis.z, 0);\n        }\n\n        vec3 half = normalized(f + t);\n        vec3 axis = cross(f, half);\n\n        return quat(\n            axis.x,\n            axis.y,\n            axis.z,\n            dot(f, half)\n        );\n    }\n\n    vec3 getAxis(const quat& quat) {\n        return normalized(vec3(quat.x, quat.y, quat.z));\n    }\n\n    float getAngle(const quat& quat) {\n        return 2.0f * (1.0f / FastCos(quat.w));\n    }\n\n    quat operator+(const quat& a, const quat& b) {\n        return quat(\n            a.x + b.x,\n            a.y + b.y,\n            a.z + b.z,\n            a.w + b.w\n        );\n    }\n\n    quat operator-(const quat& a, const quat& b) {\n        return quat(\n            a.x - b.x,\n            a.y - b.y,\n            a.z - b.z,\n            a.w - b.w\n        );\n    }\n\n    quat operator*(const quat& a, float b) {\n        return quat(\n            a.x * b,\n            a.y * b,\n            a.z * b,\n            a.w * b\n        );\n    }\n\n    quat operator-(const quat& q) {\n        return quat(\n            -q.x,\n            -q.y,\n            -q.z,\n            -q.w\n        );\n    }\n\n    bool operator==(const quat& left, const quat& right) {\n        return (Fabsf(left.x - right.x) <= QUAT_EPSILON &&\n            Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n            Fabsf(left.z - right.z) <= QUAT_EPSILON &&\n            Fabsf(left.w - left.w) <= QUAT_EPSILON);\n    }\n\n    bool operator!=(const quat& a, const quat& b) {\n        return !(a == b);\n    }\n\n    bool sameOrientation(const quat& left, const quat& right) {\n        return (Fabsf(left.x - right.x) <= QUAT_EPSILON && Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n            Fabsf(left.z - right.z) <= QUAT_EPSILON && Fabsf(left.w - left.w) <= QUAT_EPSILON)\n            || (Fabsf(left.x + right.x) <= QUAT_EPSILON && Fabsf(left.y + right.y) <= QUAT_EPSILON &&\n                Fabsf(left.z + right.z) <= QUAT_EPSILON && Fabsf(left.w + left.w) <= QUAT_EPSILON);\n    }\n\n    float dot(const quat& a, const quat& b) {\n        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n    }\n\n    float lenSq(const quat& q) {\n        return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n    }\n\n    float len(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return 0.0f;\n        }\n        return Sqrtf(lenSq);\n    }\n\n    void normalize(quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return;\n        }\n        float i_len = 1.0f / Sqrtf(lenSq);\n\n        q.x *= i_len;\n        q.y *= i_len;\n        q.z *= i_len;\n        q.w *= i_len;\n    }\n\n    quat normalized(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return quat();\n        }\n        float i_len = 1.0f / Sqrtf(lenSq);\n\n        return quat(\n            q.x * i_len,\n            q.y * i_len,\n            q.z * i_len,\n            q.w * i_len\n        );\n    }\n\n    quat conjugate(const quat& q) {\n        return quat(\n            -q.x,\n            -q.y,\n            -q.z,\n            q.w\n        );\n    }\n\n    quat inverse(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return quat();\n        }\n        float recip = 1.0f / lenSq;\n\n        // conjugate / norm\n        return quat(\n            -q.x * recip,\n            -q.y * recip,\n            -q.z * recip,\n            q.w * recip\n        );\n    }\n\n    #if 1\n    quat operator*(const quat& Q1, const quat& Q2) {\n        return quat(\n            Q2.x * Q1.w + Q2.y * Q1.z - Q2.z * Q1.y + Q2.w * Q1.x,\n            -Q2.x * Q1.z + Q2.y * Q1.w + Q2.z * Q1.x + Q2.w * Q1.y,\n            Q2.x * Q1.y - Q2.y * Q1.x + Q2.z * Q1.w + Q2.w * Q1.z,\n            -Q2.x * Q1.x - Q2.y * Q1.y - Q2.z * Q1.z + Q2.w * Q1.w\n        );\n    }\n    #else\n    quat operator*(const quat& Q1, const quat& Q2) {\n        quat result;\n        result.scalar = Q2.scalar * Q1.scalar - dot(Q2.vector, Q1.vector);\n        result.vector = (Q1.vector * Q2.scalar) + (Q2.vector * Q1.scalar) + cross(Q2.vector, Q1.vector);\n        return result;\n    }\n    #endif\n\n    vec3 operator*(const quat& q, const vec3& v) {\n        return q.vector * 2.0f * dot(q.vector, v) +\n            v * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n            cross(q.vector, v) * 2.0f * q.scalar;\n    }\n\n    quat mix(const quat& from, const quat& to, float t) {\n        return from * (1.0f - t) + to * t;\n    }\n\n    quat nlerp(const quat& from, const quat& to, float t) {\n        return normalized(from + (to - from) * t);\n    }\n\n    quat operator^(const quat& q, float f) {\n        float angle = 2.0f * (1.0f / FastCos(q.scalar));\n        vec3 axis = normalized(q.vector);\n\n        float halfCos = FastCos(f * angle * 0.5f);\n        float halfSin = FastSin(f * angle * 0.5f);\n\n        return quat(\n            axis.x * halfSin,\n            axis.y * halfSin,\n            axis.z * halfSin,\n            halfCos\n        );\n    }\n\n    quat slerp(const quat& start, const quat& end, float t) {\n        if (Fabsf(dot(start, end)) > 1.0f - QUAT_EPSILON) {\n            return nlerp(start, end, t);\n        }\n\n        return normalized(((inverse(start) * end) ^ t) * start);\n    }\n\n    quat lookRotation(const vec3& direcion, const vec3& up) {\n        // Find orthonormal basis vectors\n        vec3 f = normalized(direcion);\n        vec3 u = normalized(up);\n        vec3 r = cross(u, f);\n        u = cross(f, r);\n\n        // From world forward to object forward\n        quat f2d = fromTo(vec3(0, 0, 1), f);\n\n        // what direction is the new object up?\n        vec3 objectUp = f2d * vec3(0, 1, 0);\n        // From object up to desired up\n        quat u2u = fromTo(objectUp, u);\n\n        // Rotate to forward direction first, then twist to correct up\n        quat result = f2d * u2u;\n        // Don\u00ef\u00bf\u00bdt forget to normalize the result\n        return normalized(result);\n    }\n\n    mat4 quatToMat4(const quat& q) {\n        vec3 r = q * vec3(1, 0, 0);\n        vec3 u = q * vec3(0, 1, 0);\n        vec3 f = q * vec3(0, 0, 1);\n\n        return mat4(\n            r.x, r.y, r.z, 0,\n            u.x, u.y, u.z, 0,\n            f.x, f.y, f.z, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    quat mat4ToQuat(const mat4& m) {\n        vec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n        vec3 forward = normalized(vec3(m.forward.x, m.forward.y, m.forward.z));\n        vec3 right = cross(up, forward);\n        up = cross(forward, right);\n\n        return lookRotation(forward, up);\n    }\n\n\n    void CalculateTangentArray(unsigned int vertexCount, float* _vertex, float* _normal,\n\t\tfloat* _texcoord, float* _outTangent) {\n\n        vec3* vertex = (vec3*)_vertex;\n        vec3* normal = (vec3*)_normal;\n        vec2* texcoord = (vec2*)_texcoord;\n        vec3* outTangent = (vec3*)_outTangent;\n\n\t\tvec3* tan1 = (vec3*)MemAllocate(vertexCount * 2 * sizeof(vec3), 0);\n\t\tvec3* tan2 = tan1 + vertexCount;\n\n\t\tfor (long a = 0; a < vertexCount; a += 3)\n\t\t{\n\t\t\tvec3 v1 = vertex[a + 0];\n\t\t\tvec3 v2 = vertex[a + 1];\n\t\t\tvec3 v3 = vertex[a + 2];\n\n\t\t\tvec2 w1 = texcoord[a + 0];\n\t\t\tvec2 w2 = texcoord[a + 1];\n\t\t\tvec2 w3 = texcoord[a + 2];\n\n\t\t\tfloat x1 = v2.x - v1.x;\n\t\t\tfloat x2 = v3.x - v1.x;\n\t\t\tfloat y1 = v2.y - v1.y;\n\t\t\tfloat y2 = v3.y - v1.y;\n\t\t\tfloat z1 = v2.z - v1.z;\n\t\t\tfloat z2 = v3.z - v1.z;\n\n\t\t\tfloat s1 = w2.x - w1.x;\n\t\t\tfloat s2 = w3.x - w1.x;\n\t\t\tfloat t1 = w2.y - w1.y;\n\t\t\tfloat t2 = w3.y - w1.y;\n\n\t\t\tfloat r = 1.0f / (s1 * t2 - s2 * t1);\n\t\t\tvec3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,\n\t\t\t\t(t2 * z1 - t1 * z2) * r);\n\t\t\tvec3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,\n\t\t\t\t(s1 * z2 - s2 * z1) * r);\n\n\t\t\ttan1[a + 0] = tan1[a + 0] + sdir;\n\t\t\ttan1[a + 1] = tan1[a + 1] + sdir;\n\t\t\ttan1[a + 2] = tan1[a + 2] + sdir;\n\n\t\t\ttan2[a + 0] = tan2[a + 0] + tdir;\n\t\t\ttan2[a + 1] = tan2[a + 1] + tdir;\n\t\t\ttan2[a + 2] = tan2[a + 2] + tdir;\n\t\t}\n\n\t\tfor (long a = 0; a < vertexCount; a++) {\n\t\t\tvec3 n = normal[a];\n\t\t\tvec3 t = tan1[a];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\t\t\toutTangent[a] = normalized(t - n * dot(n, t));\n\n\t\t\t// Calculate handedness\n\t\t\t//tangent[a].w = (dot(cross(n, t), tan2[a]) < 0.0F) ? -1.0F : 1.0F;\n\t\t}\n\n\t\tMemRelease(tan1);\n\t}\n}","#ifndef _H_GRAPHICS_\n#define _H_GRAPHICS_\n\ntypedef unsigned int u32;\ntypedef float f32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(f32) == 4, \"f32 should be a 4 byte type\");\nstatic_assert (sizeof(void*) >= 4, \"pointer should be >= 4 byte type\");\n\n#define GfxBufferTypeFloat32            0\n#define GfxBufferTypeInt16              3\n#define GfxBufferTypeInt32              5\n\n#define GfxIndexTypeByte                1\n#define GfxIndexTypeShort               2\n#define GfxIndexTypeInt                 4\n\n#define GfxTextureFormatRGB8            0\n#define GfxTextureFormatRGBA8           1\n#define GfxTextureFormatR32F            2\n#define GfxTextureFormatRGB32F          3\n#define GfxTextureFormatDepth           4\n// GfxTextureFormatDepth is only a target format, not a source format\n\n#define GfxFilterNearest                0\n#define GfxFilterLinear                 1\n#define GfxFilterNone                   2\n\n#define GfxWrapRepeat                   0\n#define GfxWrapClamp                    1\n\n#define GfxUniformTypeInt1              0\n#define GfxUniformTypeInt2              1\n#define GfxUniformTypeInt3              2\n#define GfxUniformTypeInt4              3\n#define GfxUniformTypeFloat1            4\n#define GfxUniformTypeFloat2            5\n#define GfxUniformTypeFloat3            6\n#define GfxUniformTypeFloat4            7\n#define GfxUniformTypeFloat9            8\n#define GfxUniformTypeFloat16           9\n#define GfxUniformTypeTexture           10\n\n#define GfxDepthFuncAlways              0\n#define GfxDepthFuncNever               1\n#define GfxDepthFuncEqual               2\n#define GfxDepthFuncLEqual              3\n#define GfxDepthFuncGreater             4\n#define GfxDepthFuncGEqual              5\n#define GfxDepthFuncNotEqual            6\n#define GfxDepthFuncLess                7\n\n#define GfxCullFaceOff                  0\n#define GfxCullFaceBack                 1\n#define GfxCullFaceFront                2\n#define GfxCullFaceFrontAndBack         3\n\n#define GfxFaceWindCounterClockwise     0\n#define GfxFaceWindClockwise            1\n\n#define GfxBlendFuncZero                1\n#define GfxBlendFuncOne                 2\n#define GfxBlendFuncSrcColor            3\n#define GfxBlendFuncOneMinusSrcColor    4\n#define GfxBlendFuncDstColor            5\n#define GfxBlendFuncOneMinusDstColor    6\n#define GfxBlendFuncSrcAlpha            7\n#define GfxBlendFuncOneMinusSrcAlpha    8\n#define GfxBlendFuncDstAlpha            9\n#define GfxBlendFuncOneMinusDstAlpha    10\n#define GfxBlendFuncConstColor          11\n#define GfxBlendFuncOneMinusConstColor  12\n#define GfxBlendFuncConstAlpha          13\n#define GfxBlendFuncOneMinusconstAlpha  14\n#define GfxBlendFuncSrcAlphaSaturate    15\n\n#define GfxBlendEquationAdd             0\n#define GfxBlendEquationSubtract        1\n#define GfxBlendEquationReverseSubtract 2\n#define GfxBlendEquationMin             3\n#define GfxBlendEquationMax             4\n\n#define GfxDrawModePoints               0\n#define GfxDrawModeLines                1\n#define GfxDrawModeLineStrip            2\n#define GfxDrawModeTriangles            3\n#define GfxDrawModeTriangleStrip        4\n#define GfxDrawModeTriangleFan          5\n\nextern \"C\" u32 GfxCreateBuffer();\nextern \"C\" void GfxDestroyBuffer(u32 bufferId);\n\nextern \"C\" void GfxFillArrayBuffer(u32 bufferId, void* input, u32 bytes, bool _static);\nextern \"C\" void GfxFillIndexBuffer(u32 bufferId, void* input, u32 bytes, u32 indexType);\n\nextern \"C\" u32 GfxCreateShader(const char* vsource, const char* fsource);\nextern \"C\" u32 GfxGetUniformSlot(u32 shaderId, const char* name);\nextern \"C\" void GfxDestroyShader(u32 shaderId);\n\nextern \"C\" u32 GfxCreateShaderVertexLayout(u32 shaderId);\nextern \"C\" void GfxAddBufferToLayout(u32 layoutId, const char* name, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\nextern \"C\" void GfxDestroyShaderVertexLayout(u32 layoutId);\n\nextern \"C\" u32 GfxCreateTexture(void* data, u32 width, u32 height, u32 sourceFormat, u32 targetFormat, bool genMips);\ninline u32 GfxCreateDepthTexture(u32 width, u32 height) {\n    return GfxCreateTexture(0, width, height, GfxTextureFormatDepth, GfxTextureFormatDepth, false);\n}\nextern \"C\" void GfxSetTextureSampler(u32 textureId, u32 wrapS, u32 wrapT, u32 min, u32 mip, u32 mag);\nextern \"C\" void GfxDestroyTexture(u32 textureId);\n\nextern \"C\" void GfxSetUniform(u32 shaderId, u32 uniformSlot, void* data, u32 uniformType, u32 count); \ninline void GfxSetUniformTexture(u32 shaderId, u32 uniformSlot, u32 textureId) {\n    GfxSetUniform(shaderId, uniformSlot, (void*)textureId, 10, 1);\n}\n\nextern \"C\" void GfxClearAll(u32 colorTargetId, u32 depthTargetId, float r, float g, float b, float d);\nextern \"C\" void GfxClearColor(u32 colorTargetTextureId, u32 depthTargetTextureId, float r, float g, float b);\nextern \"C\" void GfxClearDepth(u32 colorTargetTextureId, u32 depthTargetTextureId, float depth);\nextern \"C\" void GfxDraw(u32 colorTargetTextureId, u32 depthTargetTextureId, u32 vertexLayoutId, u32 drawMode, u32 startIndex, u32 indexCount, u32 instanceCount);\n\nextern \"C\" void GfxSetBlendState(bool blend, f32* optBlendColor, u32 blendDstRgb, u32 blendDstAlpha, u32 blendEquationRgb, u32 blendEquationAlpha, u32 blendSrcRgb, u32 blendSrcAlpha);\nextern \"C\" void GfxSetCullState(u32 cullFace, u32 faceWind);\nextern \"C\" void GfxSetDepthState(bool enable, u32 depthFunc, f32* depthRange);\ninline void GfxEnableDepthTest() {\n    GfxSetDepthState(true, GfxDepthFuncLess, 0);\n}\n\nextern \"C\" void GfxSetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\nextern \"C\" void GfxSetWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void GfxSetViewport(u32 x, u32 y, u32 w, u32 h);\n\n#endif"],"mappings":"0sBAGA,CACI,MACJ,CAAA,GC8MA,2CACY,cAAE,gBAAF,oBACA,mBAG0B,OAAR,OAAU,WAAb,eAAf,OACG,cAAI,OAAF,OAAgB,OAAY,cAAd,OAAvB,QACJ,UAAA,GAyEJ,oEACoB,OAAE,OAAI,OAAE,OAAJ,OAAO,OAAE,OAAI,OAAE,OAAJ,OAAO,OAAE,OAAI,OAAE,OAAJ,OAA/B,eAAP,oBAAA,EAzPR,2DAAc,OAAF,OAAS,OAAF,OAAS,OAAF,OAAQ,GAAA,GA4PlC,oEACoB,OAAE,OAAI,OAAE,OAAJ,OAAO,OAAE,OAAI,OAAE,OAAJ,OAAO,OAAE,OAAI,OAAE,OAAJ,OAA/B,eAAP,oBAAA,GAGR,wDACoB,OAAE,OAAI,OAAF,OAAK,OAAE,OAAI,OAAF,OAAK,OAAE,OAAI,OAAF,OAA3B,eAAP,oBAAA,GAOR,0DACe,OAAE,OAAI,OAAE,OAAJ,OAAQ,OAAE,OAAI,OAAE,OAAJ,OAAN,OAAc,OAAE,OAAI,OAAE,OAAJ,OAAN,OAA7B,GAAA,GA2BR,iFACsB,OAAE,OAAI,OAAE,OAAJ,OAAQ,OAAE,OAAI,OAAE,OAAJ,OAAN,OAAc,OAAE,OAAI,OAAE,OAAJ,OAAN,OAA9B,OACF,OAAM,cAAN,oBACO,qDAAP,GAEkB,yBAAF,cAAd,OAGF,OAAE,OAAI,OAAF,OACJ,OAAE,OAAI,OAAF,OACJ,OAAE,OAAI,OAAF,OAHD,gBAKX,oBAAA,GAgjBJ,6IAE8B,QAAhB,QACgB,QAAhB,QACkB,QAAlB,QACoB,QAApB,QAEoB,QAAY,WAAI,WAA5B,gBAAd,QACO,QAAO,QAAF,kBAAZ,QAEI,YAAO,YAAI,QAAF,eAAnB,gBAEW,QAAO,QAAE,WAAT,gFACA,QAAO,QAAE,WAAT,gFACA,QAAO,QAAE,WAAT,gFAEA,QAAS,QAAE,WAAX,gDACA,QAAS,QAAE,WAAX,gDACA,QAAS,QAAE,WAAX,gDAEI,QAAO,QAAL,OAAV,QACQ,QAAO,QAAL,OAAV,QACQ,QAAO,QAAL,OAAV,QACQ,QAAO,QAAL,OAAV,QACQ,QAAO,QAAL,OAAV,QACQ,QAAO,QAAL,OAAV,QAEQ,SAAO,SAAL,UAAV,SACQ,SAAO,SAAL,UAAV,SACQ,SAAO,SAAL,UAAV,SACQ,SAAO,SAAL,UAAV,SAEY,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAX,kBAAT,SACK,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAa,SAAF,UAAM,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAa,SAAF,UACrD,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAa,SAAF,UADhB,wCAEM,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAa,SAAF,UAAM,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAa,SAAF,UACrD,SAAK,SAAF,UAAO,SAAK,SAAF,UAAL,UAAa,SAAF,UADhB,wCAGS,SAAK,SAAE,eAAP,yBAAY,yDAA1B,SAAK,SAAE,eAAP,yBAAY,kFACE,SAAK,SAAE,eAAP,yBAAY,yDAA1B,SAAK,SAAE,eAAP,yBAAY,kFACE,SAAK,SAAE,eAAP,yBAAY,yDAA1B,SAAK,SAAE,eAAP,yBAAY,kFAEE,SAAK,SAAE,eAAP,yBAAY,yDAA1B,SAAK,SAAE,eAAP,yBAAY,kFACE,SAAK,SAAE,eAAP,yBAAY,yDAA1B,SAAK,SAAE,eAAP,yBAAY,kFACE,SAAK,SAAE,eAAP,yBAAY,yDAA1B,SAAK,SAAE,eAAP,yBAAY,kFAlCuB,iCAApC,EAAA,EAqCU,aAAO,YAAI,SAAF,sBAAnB,qBACU,SAAO,QAAP,2GACA,SAAK,QAAL,0GAG0B,wDAAF,yCAAJ,4DAAb,oDAAhB,SAAW,QAAX,yBAAc,iFALoB,+BAAnC,EAAA,EAWW,SAAX,SACD,yBAAA,EDr7BD,GAAA,WAAA,GACA,iEAAA,wEAAA,GAqDA,uJACU,4KAMmB,qBAAhB,OACT,OAAqB,YAEA,qBAArB,OAAW,QACS,qBAApB,OAAU,QACU,qBAApB,OAAU,QAED,WAAO,WAAE,mBAAlB,gBACI,OAAK,QAAM,OAAX,kBAAc,gBACd,OAAK,QAAK,OAAV,kBAAa,gBACb,OAAK,QAAK,OAAV,kBAAa,gBAHO,yBAAxB,EAAA,EAKgC,OAAK,QAAU,cAA/B,OAAK,QAAS,cAA9B,OAAK,QAAS,cACd,OAAK,QAAU,cACf,OAAK,QAAU,cACf,OAAK,QAAU,cAEf,OAAK,QAAQ,cACb,OAAK,QAAQ,cACb,OAAK,QAAS,cACd,OAAK,QAAS,cACd,OAAK,QAAS,cACd,OAAK,QAAS,gBAEd,OAAK,QAAS,cACd,OAAK,QAAS,cACd,OAAK,QAAS,cACd,OAAK,QAAS,cACd,OAAK,QAAS,cACd,OAAK,QAAS,cACd,QAAK,UAAS,iBACd,QAAK,UAAS,iBACd,QAAK,UAAS,iBACd,QAAK,UAAS,iBAEd,QAAY,kBACZ,QAAY,kBACZ,QAAY,kBAEY,qBAAxB,QAAsB,SACD,QAAK,SAA1B,uCAEW,SAAX,QAAS,SACU,QAAK,SAAK,oBAA7B,2CAEY,iBAKA,iBAKkB,QAAU,QAA1B,eAAd,QAAY,SAGH,iBAMA,iBAK8B,QAAU,QAA1B,eAAvB,QAAqB,SACwB,QAAK,SAAvB,wBAA3B,QAAyB,SAEhB,iBAwBA,iBA+B0B,QAAU,QAA1B,eAAnB,QAAiB,SAER,iBAqBA,iBA8B0B,QAAU,QAA1B,eAAnB,QAAiB,SAC2B,QAAK,SAAvB,wBAA1B,QAAwB,SAEmB,QAAK,SAAvB,wBAAzB,QAAuB,SACiB,QAAK,SAAvB,wBAAtB,QAAoB,UACuB,QAAK,SAAvB,wBAAzB,QAAuB,UACsB,QAAK,SAAvB,wBAA3B,QAAyB,UACsB,QAAK,SAAvB,wBAA7B,QAA2B,UACiB,QAAK,SAAvB,wBAA1B,QAAwB,UAEe,QAAK,SAAjC,YAAX,QAAS,SACY,QAAK,SAAa,QAAK,SAA5C,8CAGkB,4BAAZ,QACqC,QAA6B,gCAyLrE,QAzLH,6DA2LA,MAEO,QAAP,4BAAA,EEtWJ,4CAC+B,OAAO,OAA3B,2CAAP,sBAAA,EFwKJ,6BAA4E,WAAA,EEtJ5E,GACI,mCACJ,CAAA,EFoJA,0DAA4E,gEAAA,GAgM5E,4KAKgB,iPACA,oOACA,mPACA,iPACA,mPACA,0RAER,SAAK,UAAL,uBAEI,6BACA,4BACA,sBACc,SAAK,SAAiB,SAAK,SAA4B,qBAArE,+BACW,SAAK,SAAkB,SAAK,SAAuC,SAAK,SAAnF,0CACA,sBACA,mCAGJ,6DAEY,oFACA,oFAGI,oFACA,qEAEE,SAAK,SAAa,SAAK,SAA0B,qBAA/D,+BACc,SAAK,SAAa,SAAK,SAAyB,qBAA9D,+BACc,SAAK,SAAa,SAAK,SAAyB,oBAA9D,+BAEqB,SAAK,SAAa,SAAK,SAAoB,SAAK,UAArE,eACqB,SAAK,SAAa,SAAK,SAAoB,SAAK,UAArE,eAEc,SAAK,SAAa,SAAK,UAAwB,oBAA7D,+BACc,SAAK,SAAa,SAAK,UAA2B,KAAhE,+BACc,SAAK,SAAa,SAAK,UAA6B,oBAAlE,+BACc,SAAK,SAAa,SAAK,UAA+B,oBAApE,+BACc,SAAK,SAAa,SAAK,UAAqB,SAAK,gBAA/D,+BAEc,SAAK,SAAmC,SAAK,SAA3D,0CAIc,SAAK,SAAa,SAAK,SAA0B,qBAA/D,+BACc,SAAK,SAAa,SAAK,SAAyB,qBAA9D,+BACc,SAAK,SAAa,SAAK,SAAyB,oBAA9D,+BACc,SAAK,SAAa,SAAK,SAA4B,qBAAjE,+BAEc,SAAK,SAAa,SAAK,SAAkC,oBAAvE,+BACc,SAAK,SAAa,SAAK,SAA+B,oBAApE,+BACc,SAAK,SAAa,SAAK,SAAqB,SAAK,gBAA/D,+BAEqB,SAAK,SAAa,SAAK,SAAuB,SAAK,SAAxE,eACqB,SAAK,SAAa,SAAK,SAAoB,SAAK,SAArE,eACqB,SAAK,SAAa,SAAK,SAAuB,SAAK,SAAxE,eAEc,SAAK,SAAmC,SAAK,SAA3D,2CAGZ,yBAAA,EEnaA,mDACkB,OAAU,OAAoB,OAA5C,wBACJ,oBAAA,GFgKA,8GACiC,OAAhB,OAEgC,OAA3B,OACU,cAAX,OACQ,OAArB,OAAmB,OAEM,OAAU,WAA5B,OACS,OAAS,OAAS,WAAX,kBAAhB,OACS,OAAS,OAAS,WAAX,kBAAhB,OAE0C,OAAF,WAAlC,OACyB,OAAZ,gBAAnB,OACE,OAAU,OAAnB,WAC6C,OAAU,OAAQ,OAAQ,OAAQ,OAA/E,gBAEgD,OAAF,WAAW,WAA5C,OAC4B,OAAZ,gBAAtB,OAEE,WAAO,WAAO,WAAI,OAAF,eAAzB,gBACyB,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,kBAAmB,OACE,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,kBAAmB,OACE,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,kBAAmB,OAEE,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,mBAAmB,QACE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SAEE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SAEE,QAAS,QAAE,eAAI,eAAf,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACE,QAAS,QAAE,eAAI,eAAf,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACG,QAAS,QAAE,eAAI,eAAf,kCAAtB,QAAY,QAAE,eAAd,yBAAoB,SAda,+BAAO,+BAA5C,EAAA,EAiBgB,SAAhB,QAAc,SACK,QAAK,SAAU,QAAa,QAA/C,sCAE4C,QAAK,SAAjC,YAAhB,QAAc,SACO,QAAK,SAAkB,QAAK,SAAjD,mDACqB,QAAK,SAAmB,QAAK,SAAlD,wDACqB,QAAK,SAAuB,QAAK,SAAtD,wDACqB,QAAK,SAAkB,QAAK,SAAjD,wDAE2C,QAAK,SAAvB,wBAAzB,QAAuB,SACoB,QAAK,SAAvB,wBAAzB,QAAuB,SACoB,QAAK,SAAvB,wBAAzB,QAAuB,SAEyB,QAAK,SAAjC,YAApB,QAAkB,SACG,QAAK,SAA0B,QAAK,SAAzD,mDAEW,QAAX,SACW,QAAX,SAEyD,QAAwB,gCAiI9E,QAjIH,6DAkIJ,yBAAA,EAlIJ,6BAAyF,WAAA,EAAzF,0DAAyF,gEAAA,GAAzF,kEACqC,OAAhB,OAEa,OAAjB,OAEO,cAAR,OACS,cAAT,OACW,cAAX,OACsC,OAA3B,OACJ,OAAS,WAAX,OAEI,WACT,OAAS,mBAAT,kBACO,YAGiC,OAAU,OAAO,OAAQ,OAAQ,OAAlD,mCAA3B,OAAyB,QACJ,OAAK,QAA1B,sBAEqD,OAAwB,yBA6G1E,OA7GH,gDA8GJ,qBAAA,EA9GR,6BAAyF,WAAA,EAAzF,0DAAyF,gEAAA,GAAzF,kEACyC,OAAhB,OACa,OAAjB,OACO,cAAR,OACS,cAAT,OACW,cAAX,OACsC,OAA3B,OACJ,OAAS,WAAX,OACI,WACT,OAAS,mBAAT,kBACO,YAGiC,OAAU,OAAO,OAAQ,OAAQ,OAAlD,mCAA3B,OAAwB,QACH,OAAK,QAA1B,sBAE2C,OAAwB,yBA4FhE,OA5FH,gDA6FJ,qBAAA,EA7FZ,6BAAmF,WAAA,EAAnF,0DAAmF,gEAAA,GAAnF,8GAC6C,OAAhB,OACgC,OAA3B,OACU,cAAX,OACQ,OAArB,OAAmB,OAEM,OAAU,WAA5B,OACS,OAAS,OAAS,WAAX,kBAAhB,OACS,OAAS,OAAS,WAAX,kBAAhB,OAE0C,OAAF,WAAlC,OACyB,OAAZ,gBAAnB,OACE,OAAU,OAAnB,WAC6C,OAAU,OAAQ,OAAQ,OAAQ,OAA/E,gBACgD,OAAF,WAAW,WAA5C,OAC4B,OAAZ,gBAAtB,OACE,WAAO,WAAO,WAAI,OAAF,eAAzB,gBACyB,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,kBAAmB,OACE,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,kBAAmB,OACE,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,kBAAmB,OAEE,OAAO,OAAE,WAAI,WAAb,yBAArB,OAAY,OAAE,WAAd,mBAAmB,QACE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SAEE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACE,QAAO,QAAE,eAAI,eAAb,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SAEE,QAAS,QAAE,eAAI,eAAf,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACE,QAAS,QAAE,eAAI,eAAf,kCAArB,QAAY,QAAE,eAAd,yBAAmB,SACG,QAAS,QAAE,eAAI,eAAf,kCAAtB,QAAY,QAAE,eAAd,yBAAoB,SAda,+BAAO,+BAA5C,EAAA,EAiBgB,SAAhB,QAAc,SACK,QAAK,SAAU,QAAa,QAA/C,sCAE4C,QAAK,SAAjC,YAAhB,QAAc,SACO,QAAK,SAAkB,QAAK,SAAjD,mDACqB,QAAK,SAAmB,QAAK,SAAlD,wDACqB,QAAK,SAAuB,QAAK,SAAtD,wDACqB,QAAK,SAAkB,QAAK,SAAjD,wDAE2C,QAAK,SAAvB,wBAAzB,QAAuB,SACmB,QAAK,SAAvB,wBAAxB,QAAsB,SACoB,QAAK,SAAvB,wBAAxB,QAAsB,SACsB,QAAK,SAAvB,wBAA1B,QAAwB,SAEuB,QAAK,SAAvB,wBAA7B,QAA2B,SACiB,QAAK,SAAvB,wBAA1B,QAAwB,SACuB,QAAK,SAAvB,wBAA7B,QAA2B,SAEyB,QAAK,SAAvB,wBAAlC,QAAgC,SACgB,QAAK,SAAvB,wBAA9B,QAA4B,SACiB,QAAK,SAAvB,wBAA3B,QAAyB,SAEd,QAAX,SACW,QAAX,SAEyD,QAAwB,gCAiC9E,QAjCH,6DAkCJ,yBAAA,EAlChB,6BAAqG,WAAA,EAArG,0DAAqG,gEAAA,GAArG,kEACiD,OAAhB,OACa,OAAjB,OACO,cAAR,OACS,cAAT,OACW,cAAX,OACsC,OAA3B,OACJ,OAAS,WAAX,OACI,WACT,OAAS,mBAAT,kBACO,YAEoC,OAAU,OAAO,OAAQ,OAAQ,OAAlD,mCAA9B,OAA2B,OACN,OAAK,OAA1B,sBAEqD,OAAwB,yBAiB1E,OAjBH,gDAkBJ,qBAAA,EAlBpB,6BAAqG,WAAA,EAArG,0DAAqG,gEAAA,GAArG,iEACqD,OAAhB,OACa,OAAjB,OACO,cAAR,OACS,cAAT,OACW,cAAX,OACsC,OAA3B,OACJ,OAAS,WAAX,OACI,WACT,OAAS,mBAAT,kBACO,YAEiC,OAAU,OAAO,OAAQ,OAAQ,OAAlD,mCAA3B,OAAwB,OACH,OAAK,OAA1B,sBAEW,OAAX,QACA,OAAqB,YACzB,oBAAA"}