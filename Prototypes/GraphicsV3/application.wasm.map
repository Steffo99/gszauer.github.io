{"version":3,"names":[],"sources":["test.cpp","debt/calcTangents.cpp","platform/memory.cpp","framework/sort.cpp","framework/draw2d.cpp","platform/assert.h","platform/graphics.h","framework/vector.h","debt/stb_image.h","framework/vec2.h","framework/vec2.cpp","framework/vec4.h","debt/stb_vorbis.cpp","debt/fast_obj.h","framework/vec3.h","platform/window.h","platform/math.h"],"sourcesContent":["#include \"platform/memory.h\"\n#if MEM_PLATFORM_WASM\n// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    __wasm_call_ctors();\n}\n\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\" \n#else\n#define export extern \"C\"\n#endif\n\n#include \"platform/platform.h\"\n#include \"debt/stb_vorbis.h\"\n#include \"debt/stb_image.h\"\n#include \"debt/stb_truetype.h\"\n#include \"framework/vec2.h\"\n#include \"framework/vec3.h\"\n#include \"framework/vec4.h\"\n#include \"debt/fast_obj.h\"\n#include \"framework/vector.h\"\n#include \"framework/draw2d.h\"\n\n#include \"debt/calcTangents.cpp\"\n\n#if MEM_PLATFORM_WASM\n    #include \"platform/memory.cpp\"\n    #include \"framework/sort.cpp\"\n    #include \"framework/draw2d.cpp\"\n    #include \"framework/vec2.cpp\"\n    #include \"debt/stb_vorbis.cpp\"\n    #include \"debt/fast_obj.cpp\"\n    #include \"debt/stb_image.cpp\"\n    #include \"debt/stb_truetype.cpp\"\n\n    WASM_LOADER_ENABLE_CALLBACKS\n#endif\n\ntypedef unsigned char uint8;\n#define LOAD_BUFFER_SIZE (1024 * 1024 * 12)\n#define LIGHTMAP_SIZE 1024\n\nstruct ObjBufferData {\n    unsigned int numVerts;\n    u32 buffer;\n};\n\nObjBufferData ObjToBuffer(void* data, unsigned int bytes) {\n    fastObjMesh* mesh = fast_obj_parse_from_memory((const char*)data, bytes);\n    unsigned int numVerts = mesh->face_count * 3;\n    unsigned int interleaved_size = sizeof(float) * (mesh->face_count * 3) * (3 + 3 + 3 + 2);\n    float* interleaved = (float*)MemAllocate(interleaved_size, 4, (void*)__LOCATION__);\n\n    for (unsigned int face = 0, index = 0, j = 0; face < mesh->face_count; ++face) {\n        unsigned int faceIndexCount = mesh->face_vertices[face];\n        if (faceIndexCount != 3) {\n            PrintDebugString(\"Non triangulated mesh!\");\n        }\n\n        for (int i = 0; i < 3; ++i) {\n            fastObjIndex* faceIndex = &mesh->indices[index++];\n\n            if (mesh->position_count == 0) {\n                interleaved[j++] = 0.0f;\n                interleaved[j++] = 0.0f;\n                interleaved[j++] = 0.0f;\n            }\n            else {\n                interleaved[j++] = mesh->positions[faceIndex->p * 3 + 0];\n                interleaved[j++] = mesh->positions[faceIndex->p * 3 + 1];\n                interleaved[j++] = mesh->positions[faceIndex->p * 3 + 2];\n            }\n\n            if (mesh->normal_count == 0) {\n                interleaved[j++] = 0.0f;\n                interleaved[j++] = 0.0f;\n                interleaved[j++] = 0.0f;\n            }\n            else {\n                interleaved[j++] = mesh->normals[faceIndex->n * 3 + 0];\n                interleaved[j++] = mesh->normals[faceIndex->n * 3 + 1];\n                interleaved[j++] = mesh->normals[faceIndex->n * 3 + 2];\n            }\n            \n            if (mesh->texcoord_count == 0) {\n                interleaved[j++] = 0.0f;\n                interleaved[j++] = 0.0f;\n            }\n            else {\n                interleaved[j++] = mesh->texcoords[faceIndex->t * 2 + 0];\n                interleaved[j++] = mesh->texcoords[faceIndex->t * 2 + 1];\n            }\n            \n            interleaved[j++] = 0.0f;\n            interleaved[j++] = 0.0f;\n            interleaved[j++] = 0.0f;\n        }\n    }\n    if (mesh->position_count != 0 && mesh->texcoord_count != 0) { \n        CalculateMeshTangents::CalculateTangentArrayInline(numVerts, interleaved);\n    }\n    fast_obj_destroy(mesh);\n\n    u32 buffer = GfxCreateBuffer();\n    GfxFillArrayBuffer(buffer, interleaved, interleaved_size, true);\n    MemRelease(interleaved);\n\n    ObjBufferData result;\n    result.numVerts = numVerts;\n    result.buffer = buffer;\n\n    return result;\n}\n\nu32 PngToTexture(void* data, unsigned int bytes) {\n    static int counter = 0;\n    counter += 1;\n\n    i32 width = 0;\n    i32 height = 0;\n    i32 components = 0;\n\n    unsigned char* img_data = stbi_load_from_memory((unsigned char*)data, bytes, &width, &height, &components, 0);\n    unsigned int format = (components == 4)? GfxTextureFormatRGBA8  : GfxTextureFormatRGB8;\n    u32 result = GfxCreateTexture(img_data, width, height, format, format, true);\n    MemRelease(img_data);\n\n    return result;\n}\n\nstruct AppData {\n    u32 vbo;\n    u32 shader;\n    u32 vao;\n\n    u32 gltfShader;\n\n    u32 planeVBO;\n    u32 planeVAO;\n    u32 planeNumVerts;\n    u32 planeShader;\n    u32 planeUniformModel;\n    u32 planeUniformView;\n    u32 planeUniformProj;\n    u32 planeUniformShadow;\n    u32 PlaneUniformColorSpec;\n    u32 PlaneUniformShadowMap; \n    u32 PlaneTextureColorSpec;\n\n    u32 shadowMapShader;\n    u32 shadowMapUniformMvp;\n    u32 shadowMapTexture;\n    u32 shadowMapColorTexture;\n    u32 shadowMapVao;\n\n    u32 gltfVBO;\n    u32 gltfVAO;\n    u32 gltfNumVerts;\n\n    u32 skullShader;\n    u32 skullVbo;\n    u32 skullVao;\n    u32 skullNumVerts;\n    u32 skullUniformModel;\n    u32 skullUniformView;\n    u32 skullUniformProj;\n    u32 skullUniformAlbedo;\n    u32 skullUniformNormal;\n    u32 skullUniformTop;\n    u32 skullUniformBottom;\n    u32 skullUniformLightDir;\n    u32 skullUniformLightColor;\n    u32 skullUniformViewPos;\n    u32 skullAlbedoTexture;\n    u32 skullNormalTexture;\n    bool canDisplaySkull;\n\n    float cam[3];\n\n    u32 oneShotBufffer;\n    u32 oneShotBus;\n    u32 loopingBus;\n    u32 loopingBuffer;\n    u32 loopingSound;\n\n    float audioPos[3];\n\n    u32 draw2DImage;\n    u32 draw2DAux1;\n    u32 draw2DAux2;\n    u32 draw2DGuide;\n    float rotation;\n};\n\n\nexport void* Initialize() {\n    void* mem = (unsigned char*)MemPlatformAllocate(128 * 2048 * 2048);\n    void* heap = MemInitializeHeap(mem, 128 * 2048 * 2048);\n\n    float vertices[] = {\n        -0.5f, -0.5f, 0.0f,\n        0.5f, -0.5f, 0.0f,\n        0.0f,  0.5f, 0.0f\n    };  \n\n    AudioSetListener(0, 0, 0, 0, 1, 0, 0, 0, -1);\n\n    Vector<vec3> vertvecs;\n    vertvecs.PushBack(vec3(0, 1, 0));\n    vertvecs.PushBack(vec3(1, 0, 0));\n    vertvecs.PushBack(vec3(0, 0, 1));\n\n    //std::cout << \"verts[1] = (\" << vertvecs[1].x << vertvecs[1].y << vertvecs[1].z << \")\\n\";\n\n    AppData* app = (AppData*)MemAllocate(sizeof(AppData), 4, (void*)__LOCATION__);\n    app->canDisplaySkull = false;\n    app->oneShotBus = AudioCreateBus();\n    app->loopingBus = AudioCreateBus();\n\n    app->audioPos[0] = 0.0f;\n    app->audioPos[1] = 0.0f;\n    app->audioPos[2] = 1.0f;\n\n    app->cam[0] = 1.05370f;\n    app->cam[1] = 3.00000f;\n    app->cam[2] = 6.90875f;\n\n    \n    app->vbo = GfxCreateBuffer();\n    GfxFillArrayBuffer(app->vbo, vertices, sizeof(float) * 9, true);\n\n    const char* v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                            \"layout (location = 0) in vec3 aPos;\\n\"\n                            \"void main() {\\n\"\n                            \"    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"\n                            \"}\";\n    const char* f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                            \"out vec4 FragColor;\\n\"\n                            \"void main() {\\n\"\n                            \"    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"\n                            \"}\";\n    app->shader = GfxCreateShader(v_shader, f_shader);\n\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 position;\\n\"\n                \"uniform mat4 mvp;\\n\"\n                \"void main (void) {\\n\"\n                \"  gl_Position = mvp * vec4(position, 1.0);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"void main (void) {\\n\"\n                \"  FragColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);\\n\"\n                \"}\\n\";\n    app->shadowMapShader = GfxCreateShader(v_shader, f_shader);\n    app->shadowMapUniformMvp = GfxGetUniformSlot(app->shadowMapShader, \"mvp\");\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 aPos;\\n\"\n                \"in vec2 aTexCoord;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform mat4 view;\\n\"\n                \"uniform mat4 projection;\\n\"\n                \"uniform mat4 shadow;\\n\"\n                \"out vec2 TexCoord;\\n\"\n                \"out vec4 LightViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tLightViewPos = shadow * vec4(aPos, 1.0);\\n\"\n                \"\tTexCoord = vec2(aTexCoord.x, aTexCoord.y);\\n\"\n                \"\tgl_Position = projection * view * model * vec4(aPos, 1.0);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec2 TexCoord;\\n\"\n                \"in vec4 LightViewPos;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"uniform sampler2D uColorSpec;\\n\"\n                \"uniform sampler2D uShadowMap; \\n\"\n                \"void main() {\\n\"\n                \"\tvec4 colorSpec = texture(uColorSpec, TexCoord);\\n\"\n                \"\tvec3 p = LightViewPos.xyz / LightViewPos.w;\\n\"\n                \"\tFragColor = vec4(colorSpec.rgb * (texture(uShadowMap, p.xy).r < p.z? 0.5 : 1.0), 1.0);\\n\"\n                \"}\\n\";\n    app->planeShader = GfxCreateShader(v_shader, f_shader);\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 position;\\n\"\n                \"uniform mat4 mvp;\\n\"\n                \"void main() {\\n\"\n                \"\tgl_Position = mvp * vec4(position, 1.0);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"void main() {\\n\"\n                \"\tFragColor = vec4(0.9, 0.0, 0.2, 1.0);\\n\"\n                \"}\\n\";\n    app->gltfShader = GfxCreateShader(v_shader, f_shader);\n\n    v_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\"\n                \"in vec3 aPos;\\n\"\n                \"in vec3 aNorm;\\n\"\n                \"in vec3 aTan;\\n\"\n                \"in vec2 aTexCoord;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform mat4 view;\\n\"\n                \"uniform mat4 projection;\\n\"\n                \"out mat3 TBN;\\n\"\n                \"out vec2 TexCoord;\\n\"\n                \"out vec3 FragPos;\\n\"\n                \"void main() {\\n\"\n                \"\tgl_Position = projection * view * model * vec4(aPos, 1.0);\\n\"\n                \"\tFragPos = vec3(model * vec4(aPos, 1.0));\\n\"\n                \"\tvec3 biTangent = cross(aNorm, aTan);\\n\"\n                \"\tvec3 T = normalize(vec3(model * vec4(aTan,   0.0)));\\n\"\n                \"\tvec3 B = normalize(vec3(model * vec4(biTangent, 0.0)));\\n\"\n                \"\tvec3 N = normalize(vec3(model * vec4(aNorm,    0.0)));\\n\"\n                \"\tTBN = mat3(T, B, N);\\n\"\n                \"\tTexCoord = vec2(aTexCoord.x, aTexCoord.y);\\n\"\n                \"}\\n\";\n    f_shader =  \"#version 300 es\\nprecision highp float;\\nprecision highp int;\"\n                \"in vec2 TexCoord;\\n\"\n                \"in vec3 FragPos;\\n\"\n                \"in mat3 TBN;\\n\"\n                \"out vec4 FragColor;\\n\"\n                \"uniform sampler2D uColorSpec;\\n\"\n                \"uniform sampler2D uNormal;\\n\"\n                \"uniform mat4 model;\\n\"\n                \"uniform vec3 HemiTop;\\n\"\n                \"uniform vec3 HemiBottom;\\n\"\n                \"uniform vec3 LightDirection;\\n\"\n                \"uniform vec3 LightColor;\\n\"\n                \"uniform vec3 ViewPos;\\n\"\n                \"void main() {\\n\"\n                \"\tvec3 normal = texture(uNormal, TexCoord).rgb;\\n\" \n                \"\tnormal = normal * 2.0 - 1.0;\\n\"\n                \"\tnormal = normalize(TBN * normal); // World space normal\\n\"\n                \"\tvec4 colorSpec = texture(uColorSpec, TexCoord);\\n\"\n                \"\tvec3 color = colorSpec.rgb;\\n\"\n                \"\tvec3 lightDir = normalize(-LightDirection);\\n\"\n                \"\tfloat diff = max(dot(normal, lightDir), 0.0);\\n\"\n                \"\tvec3 diffuse = diff * LightColor;\\n\"\n                \"\tdiff = max(dot(normal, normalize(vec3(-0.25, -1, 1))), 0.0);\\n\"\n                \"\tvec3 ambient = mix(HemiBottom, HemiTop, diff) * LightColor;\\n\"\n                \"\tvec3 viewDir = normalize(ViewPos - FragPos);\\n\"\n                \"\tvec3 reflectDir = reflect(-lightDir, normal);\\n\"\n                \"\tfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n\"\n                \"\tvec3 specular = colorSpec.a * spec * LightColor;  \\n\"\n                \"\tFragColor = vec4((ambient + diffuse + specular) * color, 1.0);\\n\"\n                \"}\\n\";\n    app->skullShader = GfxCreateShader(v_shader, f_shader);\n    app->skullUniformAlbedo = GfxGetUniformSlot(app->skullShader, \"uColorSpec\");\n\n    app->skullUniformNormal= GfxGetUniformSlot(app->skullShader, \"uNormal\");\n    app->skullUniformTop= GfxGetUniformSlot(app->skullShader, \"HemiTop\");\n    app->skullUniformBottom= GfxGetUniformSlot(app->skullShader, \"HemiBottom\");\n    app->skullUniformLightDir= GfxGetUniformSlot(app->skullShader, \"LightDirection\");\n    app->skullUniformLightColor= GfxGetUniformSlot(app->skullShader, \"LightColor\");\n    app->skullUniformViewPos= GfxGetUniformSlot(app->skullShader, \"ViewPos\");\n\n    app->vao = GfxCreateShaderVertexLayout(app->shader);\n    GfxAddBufferToLayout(app->vao, \"aPos\", app->vbo, 3, 0, GfxBufferTypeFloat32, 0);\n\n    Draw2D::Initialize();\n\n    void* loadArena = MemAlloc(LOAD_BUFFER_SIZE);\n    LoadFileAsynch(\"assets/skull.obj\",  loadArena, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n        AppData* app = (AppData*)userData;\n\n        auto objMesh = ObjToBuffer(data, bytes);\n        app->skullNumVerts = objMesh.numVerts;\n        app->skullVbo = objMesh.buffer;\n\n        app->skullVao = GfxCreateShaderVertexLayout(app->skullShader);\n        GfxAddBufferToLayout(app->skullVao, \"aPos\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n        GfxAddBufferToLayout(app->skullVao, \"aNorm\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 3); \n        GfxAddBufferToLayout(app->skullVao, \"aTexCoord\", app->skullVbo, 2, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 6);\n        GfxAddBufferToLayout(app->skullVao, \"aTan\", app->skullVbo , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 8); \n\n        app->skullUniformModel = GfxGetUniformSlot(app->skullShader, \"model\");\n        app->skullUniformView  = GfxGetUniformSlot(app->skullShader, \"view\");\n        app->skullUniformProj  = GfxGetUniformSlot(app->skullShader, \"projection\");\n\n        LoadFileAsynch(\"assets/piano.ogg\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n            AppData* app = (AppData*)userData;\n\n            int channels = 0;\n            int sampleRate = 0;\n            short* decodedData = 0;\n            int numSamples = stb_vorbis_decode_memory((const uint8*)data, (int)bytes, &channels, &sampleRate, &decodedData);\n            app->loopingBuffer = AudioCreateBuffer(channels, sampleRate, numSamples, decodedData);\n\n            if (numSamples <= 0 || decodedData == 0) {\n                PlatformAssert(false, __LOCATION__);\n            }\n\n            MemRelease(decodedData);\n\n            //app->loopingSound = AudioPlay2D(app->loopingBuffer, app->loopingBus, true, 0.75f, 0.0f);\n            app->loopingSound = AudioPlay3D(app->loopingBuffer, app->loopingBus, true, 0.75f, app->audioPos[0], app->audioPos[1], app->audioPos[2], 2.0f, 6.0f);\n\n            LoadFileAsynch(\"assets/Skull_Normal.png\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                AppData* app = (AppData*)userData;\n               \n                \n                app->skullNormalTexture = PngToTexture(data, bytes);\n                GfxSetTextureSampler(app->skullNormalTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                \n                app->draw2DAux1 = Draw2D::LoadImage(data, bytes, Draw2D::Interpolation::Linear);\n\n                LoadFileAsynch(\"assets/plane.obj\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                    AppData* app = (AppData*)userData;\n                   \n                    auto objMesh = ObjToBuffer(data, bytes);\n                    app->planeNumVerts = objMesh.numVerts;\n                    app->planeVBO = objMesh.buffer;\n\n                    app->planeVAO = GfxCreateShaderVertexLayout(app->planeShader);\n                    GfxAddBufferToLayout(app->planeVAO, \"aPos\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0); \n                    GfxAddBufferToLayout(app->planeVAO, \"aNorm\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 3); \n                    GfxAddBufferToLayout(app->planeVAO, \"aTexCoord\", app->planeVBO, 2, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 6);\n                    GfxAddBufferToLayout(app->planeVAO, \"aTan\", app->planeVBO , 3, sizeof(float) * 11, GfxBufferTypeFloat32, sizeof(float) * 8); \n\n                    app->planeUniformModel = GfxGetUniformSlot(app->planeShader, \"model\");\n                    app->planeUniformView = GfxGetUniformSlot(app->planeShader, \"view\");\n                    app->planeUniformProj = GfxGetUniformSlot(app->planeShader, \"projection\");\n                    app->planeUniformShadow = GfxGetUniformSlot(app->planeShader, \"shadow\");\n\n                    app->PlaneUniformColorSpec = GfxGetUniformSlot(app->planeShader, \"uColorSpec\");\n                    app->PlaneUniformShadowMap = GfxGetUniformSlot(app->planeShader, \"uShadowMap\");\n\n                    LoadFileAsynch(\"assets/Plane_AlbedoSpec.png\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                        AppData* app = (AppData*)userData;\n\n                        app->PlaneTextureColorSpec = PngToTexture(data, bytes);\n                        GfxSetTextureSampler(app->PlaneTextureColorSpec, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear,GfxFilterLinear, GfxFilterLinear);\n                 \n                        LoadFileAsynch(\"assets/oneshot.ogg\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                            AppData* app = (AppData*)userData;\n\n                            int channels = 0;\n                            int sampleRate = 0;\n                            short* decodedData = 0;\n                            int numSamples = stb_vorbis_decode_memory((const uint8*)data, (int)bytes, &channels, &sampleRate, &decodedData);\n                            app->oneShotBufffer = AudioCreateBuffer(channels, sampleRate, numSamples, decodedData);\n\n                            MemRelease(decodedData);\n\n                            if (numSamples <= 0 || decodedData == 0) {\n                                PlatformAssert(false, __LOCATION__);\n                            }\n                            \n                            LoadFileAsynch(\"assets/Skull_AlbedoSpec.png\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                                AppData* app = (AppData*)userData;\n\n                                app->draw2DAux2 = Draw2D::LoadImage(data, bytes, Draw2D::Interpolation::Linear);\n\n                                app->skullAlbedoTexture = PngToTexture(data, bytes);\n                                GfxSetTextureSampler(app->skullAlbedoTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear, GfxFilterLinear, GfxFilterLinear);\n\n\n                                LoadFileAsynch(\"assets/roboguide.png\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                                    AppData* app = (AppData*)userData;\n\n                                    app->draw2DGuide = Draw2D::LoadImage(data, bytes, Draw2D::Interpolation::Linear);\n\n                                    LoadFileAsynch(\"assets/BigRobot.png\", data, LOAD_BUFFER_SIZE, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                                        AppData* app = (AppData*)userData;\n\n                                        app->draw2DImage = Draw2D::LoadImage(data, bytes, Draw2D::Interpolation::Linear);\n\n                                        { // Done loading\n                                            MemRelease(data);\n                                            app->shadowMapTexture = GfxCreateDepthTexture(LIGHTMAP_SIZE, LIGHTMAP_SIZE);\n                                            app->shadowMapColorTexture = GfxCreateTexture(0, LIGHTMAP_SIZE, LIGHTMAP_SIZE, GfxTextureFormatRGBA8, GfxTextureFormatRGBA8, false);\n                                            GfxSetTextureSampler(app->shadowMapTexture, GfxWrapClamp, GfxWrapClamp, GfxFilterNearest, GfxFilterNone, GfxFilterNearest);\n                                            app->shadowMapVao = GfxCreateShaderVertexLayout(app->shadowMapShader);\n                                            GfxAddBufferToLayout(app->shadowMapVao, \"position\", app->skullVbo, 3, sizeof(float) * 11, GfxBufferTypeFloat32, 0);\n                                            app->canDisplaySkull = true;\n                                        }\n                                        }, app);\n                                    }, app);\n                            }, app);\n                        }, app);\n                    }, app);\n                }, app);\n            }, app);\n        }, app);\n    }, app);\n\n    GfxEnableDepthTest();\n\n    return app;\n}\n\nexport void Render(unsigned int x, unsigned int y, unsigned int w, unsigned int h, float dpi, void* userData) {\n    AppData* app = (AppData*)userData;\n\n    if (MousePressed(MouseButtonLeft)) {\n        AudioPlay2D(app->oneShotBufffer, app->oneShotBus, false, 1.0f, 0.0f);\n        PrintDebugString(\"Left mouse pressed\");\n    }\n    else if (MouseReleased(MouseButtonLeft)) {\n        PrintDebugString(\"Left mouse released\");\n    }\n\n    if (KeyboardPressed(KeyboardCodeSpace)) {\n        PrintDebugString(\"space pressed\");\n        AudioSetVolume(app->oneShotBus, 0.5f);\n    }\n    else if (KeyboardReleased(KeyboardCodeSpace)) {\n        PrintDebugString(\"space released\");\n    }\n\n    if (KeyboardDown(KeyboardCodeSpace)) {\n        PrintDebugString(\"space down\");\n    }\n    \n    if (TouchPressed(0)) {\n        if (app->loopingSound != 0) {\n            AudioStop(app->loopingSound);\n            app->loopingSound = 0;\n        }\n        else {\n            //app->loopingSound = AudioPlay2D(app->loopingBuffer, app->loopingBus, true, 0.75f, 0.0f);\n            app->loopingSound = AudioPlay3D(app->loopingBuffer, app->loopingBus, true, 0.75f, app->audioPos[0], app->audioPos[1], app->audioPos[2], 2.0f, 6.0f);\n        }\n        PrintDebugString(\"touch 0 pressed\");\n    }\n    if (TouchReleased(0)) {\n        PrintDebugString(\"touch 0 released\");\n    }\n\n    if (TouchPressed(1)) {\n        if (app->loopingSound != 0) {\n            AudioSetPan(app->loopingSound, -1.0f);\n        }\n        PrintDebugString(\"touch 1 pressed\");\n    }\n    if (TouchReleased(1)) {\n        PrintDebugString(\"touch 1 released\");\n    }\n\n    if (app->loopingSound != 0) {\n        if (KeyboardReleased(KeyboardCode1)) {\n            app->audioPos[2] = 1;\n        }\n        else if (KeyboardReleased(KeyboardCode2)) {\n            app->audioPos[2] = 2;\n        }\n        else if (KeyboardReleased(KeyboardCode3)) {\n            app->audioPos[2] = 3;\n        }\n        else if (KeyboardReleased(KeyboardCode4)) {\n            app->audioPos[2] = 4;\n        }\n        else if (KeyboardReleased(KeyboardCode5)) {\n            app->audioPos[2] = 5;\n        }\n        else if (KeyboardReleased(KeyboardCode6)) {\n            app->audioPos[2] = 6;\n        }\n        else if (KeyboardReleased(KeyboardCode7)) {\n            app->audioPos[2] = 7;\n        }\n\n        if (KeyboardReleased(KeyboardCode8)) {\n            app->audioPos[0] = -4;\n        }\n        else if (KeyboardReleased(KeyboardCode9)) {\n            app->audioPos[0] = 4;\n        }\n        else if (KeyboardReleased(KeyboardCode0)) {\n            app->audioPos[0] = 0;\n        }\n\n        AudioSetPosition(app->loopingSound, app->audioPos[0], app->audioPos[1], app->audioPos[2]);\n\n        if (KeyboardReleased(KeyboardCodeMinus)) {\n            AudioSetAttenuation(app->loopingSound, 3, 9);\n        }\n        else if (KeyboardReleased(KeyboardCodeEquals)) {\n            AudioSetAttenuation(app->loopingSound, 1, 6);\n        }\n    }\n\n    GfxEnableDepthTest();\n    GfxSetViewport(x, y, w, h);\n\n    const float plane_shadow[16] = { 0.13074f, 0.01829f, 0.01400f, 0.00000f,0.00000f, 0.09512f, -0.06999f, 0.00000f,0.02615f, -0.09146f, -0.06999f, 0.00000f,0.50000f, 0.42866f, 0.54184f, 1.00000f };\n    const float plane_model[16] = { 2.00000f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 2.00000f, 0.00000f, 0.00000f,0.00000f, 0.00000f, 2.00000f, 0.00000f,0.00000f, -1.50000f, 0.00000f, 1.00000f };\n    const float skull_model[16] = { 0.10000f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 0.10000f, 0.00000f, 0.00000f,0.00000f, 0.00000f, 0.10000f, 0.00000f,1.50000f, 0.00000f, -0.50000f, 1.00000f };\n    const float shadow_mvp[16] = { 0.01307f, 0.00183f, 0.00140f, 0.00000f,0.00000f, 0.00951f, -0.00700f, 0.00000f,0.00261f, -0.00915f, -0.00700f, 0.00000f,0.18304f, 0.07317f, 0.05468f, 1.00000f };\n    const float view[16] = { 0.99916f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 0.91836f, 0.39357f, 0.00000f,0.00000f, -0.39358f, 0.91833f, 0.00000f,0.00000f, 0.00000f, -7.60905f, 1.00000f };\n    const float proj[16] = { 1.82434f, 0.00000f, 0.00000f, 0.00000f,0.00000f, 2.43245f, 0.00000f, 0.00000f,0.00000f, 0.00000f, -1.00020f, -1.00000f,0.00000f, 0.00000f, -0.20002f, 0.00000f };\n\n    if (app->canDisplaySkull) {\n        { // Draw lightmap\n            GfxSetViewport(0, 0, LIGHTMAP_SIZE, LIGHTMAP_SIZE);\n            //GfxClearColor(app->shadowMapColorTexture, app->shadowMapTexture, 1.0f, 1.0f, 1.0f);\n            //GfxClearDepth(app->shadowMapColorTexture, app->shadowMapTexture, 1.0f);\n            GfxClearAll(app->shadowMapColorTexture, app->shadowMapTexture, 0.5f, 0.6f, 0.7f, 1.0f);\n            GfxSetCullState(GfxCullFaceFront, GfxFaceWindCounterClockwise);\n            GfxSetUniform(app->shadowMapShader, app->shadowMapUniformMvp, (void*)shadow_mvp, GfxUniformTypeFloat16, 1);\n            GfxDraw(app->shadowMapColorTexture, app->shadowMapTexture, app->shadowMapVao, GfxDrawModeTriangles, 0, app->skullNumVerts, 1);\n            GfxSetCullState(GfxCullFaceBack, GfxFaceWindCounterClockwise);\n            GfxSetViewport(x, y, w, h);\n        }\n\n        GfxClearAll(0, 0, 0.5f, 0.6f, 0.7f, 1.0f);\n\n        const float lightDir[3] = { 0.2f, -1.0f, -1.0f };\n        const float lightColor[3] = { 1.0f, 1.0f, 1.0f };\n\n        { // Draw Skull\n            const float hemiTop[3] = { 0.2f, 0.2f, 0.2f };\n            const float hemiBottom[3] = { 0.1f, 0.1f, 0.1f };\n\n            GfxSetUniform(app->skullShader, app->skullUniformModel, (void*)skull_model, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->skullShader, app->skullUniformView, (void*)view, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->skullShader, app->skullUniformProj, (void*)proj, GfxUniformTypeFloat16, 1);\n\n            GfxSetUniformTexture(app->skullShader, app->skullUniformAlbedo, app->skullAlbedoTexture);\n            GfxSetUniformTexture(app->skullShader, app->skullUniformNormal, app->skullNormalTexture);\n\n            GfxSetUniform(app->skullShader, app->skullUniformTop, (void*)hemiTop, GfxUniformTypeFloat3, 1);\n            GfxSetUniform(app->skullShader, app->skullUniformBottom, (void*)hemiBottom, GfxUniformTypeFloat3, 1);\n            GfxSetUniform(app->skullShader, app->skullUniformLightDir, (void*)lightDir, GfxUniformTypeFloat3, 1);\n            GfxSetUniform(app->skullShader, app->skullUniformLightColor, (void*)lightColor, GfxUniformTypeFloat3, 1);\n            GfxSetUniform(app->skullShader, app->skullUniformViewPos, app->cam, GfxUniformTypeFloat3, 1);\n\n            GfxDraw(0, 0, app->skullVao, GfxDrawModeTriangles, 0, app->skullNumVerts, 1);\n        }\n\n        { // Draw plane\n            GfxSetUniform(app->planeShader, app->planeUniformModel, (void*)plane_model, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->planeShader, app->planeUniformView, (void*)view, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->planeShader, app->planeUniformProj, (void*)proj, GfxUniformTypeFloat16, 1);\n            GfxSetUniform(app->planeShader, app->planeUniformShadow, (void*)plane_shadow, GfxUniformTypeFloat16, 1);\n\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformColorSpec, app->PlaneTextureColorSpec);\n            GfxSetUniformTexture(app->planeShader, app->PlaneUniformShadowMap, app->shadowMapTexture);\n\n            GfxDraw(0, 0, app->planeVAO, GfxDrawModeTriangles, 0, app->planeNumVerts, 1);\n        }\n\n        Draw2D::Begin(w, h);\n    \n        Draw2D::EnableAlphaBlending();\n\n        //Draw2D::DrawImage(app->draw2DImage, 20, 20, 1.0f, 1.0f, 0.0f, 0.0f, 128, 128);\n\n        //Draw2D::DrawImage(app->draw2DImage, 300, 20, 1.0f, 1.0f, 128.0f, 0.0f, 128, 128);\n\n        //Draw2D::DrawImage(app->draw2DImage, 200, 200, 2.0f, 2.0f, 0.0f, 0.0f, 256, 128);\n\n        vec4 body(128, 0, 256 - 128, 128 - 0);\n        vec4 head(0, 64, 64 - 0, 128 - 64);\n        vec4 leg(64, 0, 128 - 64, 64 - 0);\n        vec4 arm(64, 0, 128 - 64, 64 - 0);\n        vec4 bicep(64, 64, 128 - 64, 128 - 64);\n        vec4 hand(0, 0, 64 - 0, 64 - 0);\n\n        Draw2D::PushClip(157, 75, 226 - 157, 100);\n        Draw2D::PushClip(157, 75, (226 - 157) * 2, 50);\n        Draw2D::PushClip(157, 75, (226-157) * 2, 25);\n\n        Draw2D::DrawImage(app->draw2DImage, 212, 85, 0.75f, 0.75f, leg.x, leg.y, leg.z, leg.w, 0, 0);\n        Draw2D::DrawImage(app->draw2DImage, 172, 85, -0.75f, 0.75f, leg.x, leg.y, leg.z, leg.w, 0, 0);\n        Draw2D::DrawImage(app->draw2DImage, 128, 0, 1.0f, 1.0f, body.x, body.y, body.z, body.w, 0, 0);\n        Draw2D::DrawImage(app->draw2DImage, 168 + 32, 31 + 32, -0.75f, 0.75f, head.x, head.y, head.z, head.w, 32, 32);\n        Draw2D::DrawImage(app->draw2DImage, 219, 41, 0.75f, 0.75f, bicep.x, bicep.y, bicep.z, bicep.w, 0, 0);\n        Draw2D::DrawImage(app->draw2DImage, 165, 41, -0.75f, 0.75f, bicep.x, bicep.y, bicep.z, bicep.w, 0, 0);\n        Draw2D::DrawImage(app->draw2DImage, 224, 111, 0.75f, -0.75f, arm.x, arm.y, arm.z, arm.w, 0, 0);\n        Draw2D::DrawImage(app->draw2DImage, 159, 111, 0.75f, 0.75f, arm.x, arm.y, arm.z, arm.w, 0, 0, DegToRad(180));\n        Draw2D::DrawImage(app->draw2DImage, 226, 75, 0.75f, 0.75f, hand.x, hand.y, hand.z, hand.w, 32, 32, DegToRad(app->rotation));\n        Draw2D::DrawImage(app->draw2DImage, 157, 75, -2.0f, -0.75f, hand.x, hand.y, hand.z, hand.w, 32, 32, DegToRad(app->rotation));\n\n\n        Draw2D::DrawImage(app->draw2DImage, 368, 31, 0.75f, 0.75f, head.x, head.y, head.z, head.w, 0, 0, 0, 1.0f, 0.0f, 0.0f);\n        Draw2D::DrawImage(app->draw2DAux1, 368, 231, 0.75f, 0.75f, head.x, head.y, head.z, head.w, 0, 0, 0, 1.0f, 0.0f, 0.0f);\n        Draw2D::DrawImage(app->draw2DImage, 368, 331, 0.75f, 0.75f, head.x, head.y, head.z, head.w, 0, 0, 0, 0.0f, 1.0f, 0.0f);\n        Draw2D::DrawImage(app->draw2DAux2, 368, 431, 0.75f, 0.75f, head.x, head.y, head.z, head.w, 0, 0, 0, 0.0f, 1.0f, 0.0f);\n\n        Draw2D::PopClip();\n        Draw2D::PopClip();\n        Draw2D::PopClip();\n\n        Draw2D::DrawImage(app->draw2DGuide, 0, 0, 1.0f, 1.0f, 0, 0, 256, 256);\n       \n\n        Draw2D::DisableAlphaBlending();\n\n        Draw2D::End();\n    }\n}\n\nexport void Update(float dt, void* userData) {\n    AppData* app = (AppData*)userData;\n    static int frame = 0;\n    app->rotation += dt * 0.1f;\n    if (++frame == 10) {\n        WindowUpdateTitle(\"Custom title\");\n    }\n}\n\nexport void Shutdown(void* userData) {\n    AppData* app = (AppData*)userData;\n    Draw2D::DestroyImage(app->draw2DImage);\n    Draw2D::DestroyImage(app->draw2DGuide);\n    Draw2D::DestroyImage(app->draw2DAux1);\n    Draw2D::DestroyImage(app->draw2DAux2);\n    Draw2D::Shutdown();\n    MemRelease(userData);\n}","#define VEC3_EPSILON 0.000001f\n#define MAT4_EPSILON 0.000001f\n#define QUAT_EPSILON 0.000001f\n#define QUAT_DEG2RAD 0.0174533f\n#define QUAT_RAD2DEG 57.2958f\n\nnamespace CalculateMeshTangents {\n    \n\n    float FastSin(float x);\n    float FastCos(float x);\n\n    template<typename T>\n    struct TVec2 {\n        union {\n            struct {\n                T x;\n                T y;\n            };\n            T v[2];\n        };\n        inline TVec2() : x(T(0)), y(T(0)) { }\n        inline TVec2(T _x, T _y) :\n            x(_x), y(_y) { }\n        inline TVec2(T* fv) :\n            x(fv[0]), y(fv[1]) { }\n    };\n\n    typedef TVec2<float> vec2;\n    typedef TVec2<int> ivec2;\n    typedef TVec2<unsigned int> uivec2;\n\n    struct vec3 {\n        union {\n            struct {\n                float x;\n                float y;\n                float z;\n            };\n            float v[3];\n        };\n        inline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n        inline vec3(float _x, float _y, float _z) :\n            x(_x), y(_y), z(_z) { }\n        inline vec3(float* fv) :\n            x(fv[0]), y(fv[1]), z(fv[2]) { }\n    };\n\n    vec3 operator+(const vec3& l, const vec3& r);\n    vec3 operator-(const vec3& l, const vec3& r);\n    vec3 operator*(const vec3& v, float f);\n    vec3 operator*(const vec3& l, const vec3& r);\n    float dot(const vec3& l, const vec3& r);\n    float lenSq(const vec3& v);\n    float len(const vec3& v);\n    void normalize(vec3& v);\n    vec3 normalized(const vec3& v);\n    vec3 project(const vec3& a, const vec3& b);\n    vec3 reject(const vec3& a, const vec3& b);\n    vec3 reflect(const vec3& a, const vec3& b);\n    vec3 cross(const vec3& l, const vec3& r);\n    vec3 lerp(const vec3& s, const vec3& e, float t);\n    vec3 nlerp(const vec3& s, const vec3& e, float t);\n    bool operator==(const vec3& l, const vec3& r);\n    bool operator!=(const vec3& l, const vec3& r);\n\n    template<typename T>\n    struct TVec4 {\n        union {\n            struct {\n                T x;\n                T y;\n                T z;\n                T w;\n            };\n            T v[4];\n        };\n        inline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n        inline TVec4(T _x, T _y, T _z, T _w) :\n            x(_x), y(_y), z(_z), w(_w) { }\n        inline TVec4(T* fv) :\n            x(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n    };\n\n    typedef TVec4<float> vec4;\n    typedef TVec4<int> ivec4;\n    typedef TVec4<unsigned int> uivec4;\n\n\n    struct mat4 {\n        union {\n            float v[16];\n            struct {\n                vec4 right;\n                vec4 up;\n                vec4 forward;\n                vec4 position;\n            };\n            struct {\n                //            row 1     row 2     row 3     row 4\n                /* column 1 */float xx; float xy; float xz; float xw;\n                /* column 2 */float yx; float yy; float yz; float yw;\n                /* column 3 */float zx; float zy; float zz; float zw;\n                /* column 4 */float tx; float ty; float tz; float tw;\n            };\n            struct {\n                float c0r0; float c0r1; float c0r2; float c0r3;\n                float c1r0; float c1r1; float c1r2; float c1r3;\n                float c2r0; float c2r1; float c2r2; float c2r3;\n                float c3r0; float c3r1; float c3r2; float c3r3;\n            };\n            struct {\n                float r0c0; float r1c0; float r2c0; float r3c0;\n                float r0c1; float r1c1; float r2c1; float r3c1;\n                float r0c2; float r1c2; float r2c2; float r3c2;\n                float r0c3; float r1c3; float r2c3; float r3c3;\n            };\n        };\n        inline mat4() :\n            xx(1), xy(0), xz(0), xw(0),\n            yx(0), yy(1), yz(0), yw(0),\n            zx(0), zy(0), zz(1), zw(0),\n            tx(0), ty(0), tz(0), tw(1) {}\n\n        inline mat4(float* fv) :\n            xx(fv[0]), xy(fv[1]), xz(fv[2]), xw(fv[3]),\n            yx(fv[4]), yy(fv[5]), yz(fv[6]), yw(fv[7]),\n            zx(fv[8]), zy(fv[9]), zz(fv[10]), zw(fv[11]),\n            tx(fv[12]), ty(fv[13]), tz(fv[14]), tw(fv[15]) { }\n\n        inline mat4(\n            float _00, float _01, float _02, float _03,\n            float _10, float _11, float _12, float _13,\n            float _20, float _21, float _22, float _23,\n            float _30, float _31, float _32, float _33) :\n            xx(_00), xy(_01), xz(_02), xw(_03),\n            yx(_10), yy(_11), yz(_12), yw(_13),\n            zx(_20), zy(_21), zz(_22), zw(_23),\n            tx(_30), ty(_31), tz(_32), tw(_33) { }\n    }; // end mat4 struct\n\n    bool operator==(const mat4& a, const mat4& b);\n    bool operator!=(const mat4& a, const mat4& b);\n    mat4 operator+(const mat4& a, const mat4& b);\n    mat4 operator*(const mat4& m, float f);\n    mat4 operator*(const mat4& a, const mat4& b);\n    vec4 operator*(const mat4& m, const vec4& v);\n    vec3 transformVector(const mat4& m, const vec3& v);\n    vec3 transformPoint(const mat4& m, const vec3& v);\n    vec3 transformPoint(const mat4& m, const vec3& v, float& w);\n    void transpose(mat4& m);\n    mat4 transposed(const mat4& m);\n    float determinant(const mat4& m);\n    mat4 adjugate(const mat4& m);\n    mat4 inverse(const mat4& m);\n    void invert(mat4& m);\n    mat4 frustum(float l, float r, float b, float t, float n, float f);\n    mat4 perspective(float fov, float aspect, float znear, float zfar);\n    mat4 ortho(float l, float r, float b, float t, float n, float f);\n    mat4 lookAt(const vec3& position, const vec3& target, const vec3& up);\n\n    struct quat {\n        union {\n            struct {\n                float x;\n                float y;\n                float z;\n                float w;\n            };\n            struct {\n                vec3 vector;\n                float scalar;\n            };\n            float v[4];\n        };\n\n        inline quat() :\n            x(0), y(0), z(0), w(1) { }\n        inline quat(float _x, float _y, float _z, float _w) :\n            x(_x), y(_y), z(_z), w(_w) {}\n    };\n\n    quat angleAxis(float angle, const vec3& axis);\n    quat fromTo(const vec3& from, const vec3& to);\n    vec3 getAxis(const quat& quat);\n    float getAngle(const quat& quat);\n    quat operator+(const quat& a, const quat& b);\n    quat operator-(const quat& a, const quat& b);\n    quat operator*(const quat& a, float b);\n    quat operator-(const quat& q);\n    bool operator==(const quat& left, const quat& right);\n    bool operator!=(const quat& a, const quat& b);\n    bool sameOrientation(const quat& left, const quat& right);\n    float dot(const quat& a, const quat& b);\n    float lenSq(const quat& q);\n    float len(const quat& q);\n    void normalize(quat& q);\n    quat normalized(const quat& q);\n    quat conjugate(const quat& q);\n    quat inverse(const quat& q);\n    quat operator*(const quat& Q1, const quat& Q2);\n    vec3 operator*(const quat& q, const vec3& v);\n    quat mix(const quat& from, const quat& to, float t);\n    quat nlerp(const quat& from, const quat& to, float t);\n    quat operator^(const quat& q, float f);\n    quat operator^(const quat& q, float f);\n    quat slerp(const quat& start, const quat& end, float t);\n    quat lookRotation(const vec3& direcion, const vec3& up);\n    mat4 quatToMat4(const quat& q);\n    quat mat4ToQuat(const mat4& m);\n\n    float Sqrtf(const float& n) {\n        if (n == 0.0f) {\n            return 0.0f;\n        }\n\n        int i = 0x2035AD0C + (*(int*)&n >> 1);\n        return n / *(float*)&i + *(float*)&i * 0.25f;\n    }\n\n    float Fabsf(const float& f) {\n        if (f < 0.0f) {\n            return f * -1.0f;\n        }\n        return f;\n    }\n\n    double Sin(const double& x) {\n        int i = 1;\n        double cur = x;\n        double acc = 1;\n        double fact = 1;\n        double pow = x;\n        while (acc > .00000001 && i < 100) {\n            fact *= ((2 * i) * (2 * i + 1));\n            pow *= -1 * x * x;\n            acc = pow / fact;\n            if (acc < 0.0) { // fabs\n                acc *= -1.0;\n            }\n            cur += acc;\n            i++;\n        }\n        return cur;\n    }\n\n    #define PI         (3.1415926535f)\n    #define HALF_PI    (0.5f * PI)\n    #define TWO_PI     (2.0f * PI)\n    #define TWO_PI_INV (1.0f / TWO_PI)\n\n    inline float Hill(float x)\n    {\n        const float a0 = 1.0f;\n        const float a2 = 2.0f / PI - 12.0f / (PI * PI);\n        const float a3 = 16.0f / (PI * PI * PI) - 4.0f / (PI * PI);\n        const float xx = x * x;\n        const float xxx = xx * x;\n\n        return a0 + a2 * xx + a3 * xxx;\n    }\n\n    float FastSin(float x)\n    {\n        // wrap x within [0, TWO_PI)\n        const float a = x * TWO_PI_INV;\n        x -= static_cast<int>(a) * TWO_PI;\n        if (x < 0.0f)\n            x += TWO_PI;\n\n        // 4 pieces of hills\n        if (x < HALF_PI)\n            return Hill(HALF_PI - x);\n        else if (x < PI)\n            return Hill(x - HALF_PI);\n        else if (x < 3.0f * HALF_PI)\n            return -Hill(3.0f * HALF_PI - x);\n        else\n            return -Hill(x - 3.0f * HALF_PI);\n    }\n\n    float FastCos(float x)\n    {\n        return FastSin(x + HALF_PI);\n    }\n\n    float Tan(const float& d) {\n        return FastSin(d) / FastCos(d);\n    }\n\n\n    vec3 operator+(const vec3& l, const vec3& r) {\n        return vec3(l.x + r.x, l.y + r.y, l.z + r.z);\n    }\n\n    vec3 operator-(const vec3& l, const vec3& r) {\n        return vec3(l.x - r.x, l.y - r.y, l.z - r.z);\n    }\n\n    vec3 operator*(const vec3& v, float f) {\n        return vec3(v.x * f, v.y * f, v.z * f);\n    }\n\n    vec3 operator*(const vec3& l, const vec3& r) {\n        return vec3(l.x * r.x, l.y * r.y, l.z * r.z);\n    }\n\n    float dot(const vec3& l, const vec3& r) {\n        return l.x * r.x + l.y * r.y + l.z * r.z;\n    }\n\n    float lenSq(const vec3& v) {\n        return v.x * v.x + v.y * v.y + v.z * v.z;\n    }\n\n    float len(const vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return 0.0f;\n        }\n        return Sqrtf(lenSq);\n    }\n\n    void normalize(vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return;\n        }\n        float invLen = 1.0f / Sqrtf(lenSq);\n\n        v.x *= invLen;\n        v.y *= invLen;\n        v.z *= invLen;\n    }\n\n    vec3 normalized(const vec3& v) {\n        float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n        if (lenSq < VEC3_EPSILON) {\n            return v;\n        }\n        float invLen = 1.0f / Sqrtf(lenSq);\n\n        return vec3(\n            v.x * invLen,\n            v.y * invLen,\n            v.z * invLen\n        );\n    }\n\n    vec3 project(const vec3& a, const vec3& b) {\n        float magBSq = len(b);\n        if (magBSq < VEC3_EPSILON) {\n            return vec3();\n        }\n        float scale = dot(a, b) / magBSq;\n        return b * scale;\n    }\n\n    vec3 reject(const vec3& a, const vec3& b) {\n        vec3 projection = project(a, b);\n        return a - projection;\n    }\n\n    vec3 reflect(const vec3& a, const vec3& b) {\n        float magBSq = len(b);\n        if (magBSq < VEC3_EPSILON) {\n            return vec3();\n        }\n        float scale = dot(a, b) / magBSq;\n        vec3 proj2 = b * (scale * 2);\n        return a - proj2;\n    }\n\n    vec3 cross(const vec3& l, const vec3& r) {\n        return vec3(\n            l.y * r.z - l.z * r.y,\n            l.z * r.x - l.x * r.z,\n            l.x * r.y - l.y * r.x\n        );\n    }\n\n    vec3 lerp(const vec3& s, const vec3& e, float t) {\n        return vec3(\n            s.x + (e.x - s.x) * t,\n            s.y + (e.y - s.y) * t,\n            s.z + (e.z - s.z) * t\n        );\n    }\n\n    vec3 nlerp(const vec3& s, const vec3& e, float t) {\n        vec3 linear(\n            s.x + (e.x - s.x) * t,\n            s.y + (e.y - s.y) * t,\n            s.z + (e.z - s.z) * t\n        );\n        return normalized(linear);\n    }\n\n    bool operator==(const vec3& l, const vec3& r) {\n        vec3 diff(l - r);\n        return lenSq(diff) < VEC3_EPSILON;\n    }\n\n    bool operator!=(const vec3& l, const vec3& r) {\n        return !(l == r);\n    }\n\n    bool operator==(const mat4& a, const mat4& b) {\n        for (int i = 0; i < 16; ++i) {\n            if (Fabsf(a.v[i] - b.v[i]) > MAT4_EPSILON) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool operator!=(const mat4& a, const mat4& b) {\n        return !(a == b);\n    }\n\n    mat4 operator+(const mat4& a, const mat4& b) {\n        return mat4(\n            a.xx + b.xx, a.xy + b.xy, a.xz + b.xz, a.xw + b.xw,\n            a.yx + b.yx, a.yy + b.yy, a.yz + b.yz, a.yw + b.yw,\n            a.zx + b.zx, a.zy + b.zy, a.zz + b.zz, a.zw + b.zw,\n            a.tx + b.tx, a.ty + b.ty, a.tz + b.tz, a.tw + b.tw\n        );\n    }\n\n    mat4 operator*(const mat4& m, float f) {\n        return mat4(\n            m.xx * f, m.xy * f, m.xz * f, m.xw * f,\n            m.yx * f, m.yy * f, m.yz * f, m.yw * f,\n            m.zx * f, m.zy * f, m.zz * f, m.zw * f,\n            m.tx * f, m.ty * f, m.tz * f, m.tw * f\n        );\n    }\n\n    #define M4D(aRow, bCol) \\\n        a.v[0 * 4 + aRow] * b.v[bCol * 4 + 0] + \\\n        a.v[1 * 4 + aRow] * b.v[bCol * 4 + 1] + \\\n        a.v[2 * 4 + aRow] * b.v[bCol * 4 + 2] + \\\n        a.v[3 * 4 + aRow] * b.v[bCol * 4 + 3]\n\n    mat4 operator*(const mat4& a, const mat4& b) {\n        return mat4(\n            M4D(0, 0), M4D(1, 0), M4D(2, 0), M4D(3, 0), // Column 0\n            M4D(0, 1), M4D(1, 1), M4D(2, 1), M4D(3, 1), // Column 1\n            M4D(0, 2), M4D(1, 2), M4D(2, 2), M4D(3, 2), // Column 2\n            M4D(0, 3), M4D(1, 3), M4D(2, 3), M4D(3, 3)  // Column 3\n        );\n    }\n\n    #define M4V4D(mRow, x, y, z, w) \\\n        x * m.v[0 * 4 + mRow] + \\\n        y * m.v[1 * 4 + mRow] + \\\n        z * m.v[2 * 4 + mRow] + \\\n        w * m.v[3 * 4 + mRow]\n\n    vec4 operator*(const mat4& m, const vec4& v) {\n        return vec4(\n            M4V4D(0, v.x, v.y, v.z, v.w),\n            M4V4D(1, v.x, v.y, v.z, v.w),\n            M4V4D(2, v.x, v.y, v.z, v.w),\n            M4V4D(3, v.x, v.y, v.z, v.w)\n        );\n    }\n\n    vec3 transformVector(const mat4& m, const vec3& v) {\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, 0.0f),\n            M4V4D(1, v.x, v.y, v.z, 0.0f),\n            M4V4D(2, v.x, v.y, v.z, 0.0f)\n        );\n    }\n\n    vec3 transformPoint(const mat4& m, const vec3& v) {\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, 1.0f),\n            M4V4D(1, v.x, v.y, v.z, 1.0f),\n            M4V4D(2, v.x, v.y, v.z, 1.0f)\n        );\n    }\n\n    vec3 transformPoint(const mat4& m, const vec3& v, float& w) {\n        float _w = w;\n        w = M4V4D(3, v.x, v.y, v.z, _w);\n\n        return vec3(\n            M4V4D(0, v.x, v.y, v.z, _w),\n            M4V4D(1, v.x, v.y, v.z, _w),\n            M4V4D(2, v.x, v.y, v.z, _w)\n        );\n    }\n\n    #define M4SWAP(x, y) \\\n        {float t = x; x = y; y = t; }\n\n    void transpose(mat4& m) {\n        M4SWAP(m.yx, m.xy);\n        M4SWAP(m.zx, m.xz);\n        M4SWAP(m.tx, m.xw);\n        M4SWAP(m.zy, m.yz);\n        M4SWAP(m.ty, m.yw);\n        M4SWAP(m.tz, m.zw);\n    }\n\n    mat4 transposed(const mat4& m) {\n        return mat4(\n            m.xx, m.yx, m.zx, m.tx,\n            m.xy, m.yy, m.zy, m.ty,\n            m.xz, m.yz, m.zz, m.tz,\n            m.xw, m.yw, m.zw, m.tw\n        );\n    }\n\n    #define M4_3X3MINOR(c0, c1, c2, r0, r1, r2) \\\n        (m.v[c0 * 4 + r0] * (m.v[c1 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c1 * 4 + r2] * m.v[c2 * 4 + r1]) - \\\n        m.v[c1 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c2 * 4 + r1]) + \\\n        m.v[c2 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c1 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c1 * 4 + r1]))\n\n    float determinant(const mat4& m) {\n        return  m.v[0] * M4_3X3MINOR(1, 2, 3, 1, 2, 3)\n            - m.v[4] * M4_3X3MINOR(0, 2, 3, 1, 2, 3)\n            + m.v[8] * M4_3X3MINOR(0, 1, 3, 1, 2, 3)\n            - m.v[12] * M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n    }\n\n    mat4 adjugate(const mat4& m) {\n        // Cofactor(M[i, j]) = Minor(M[i, j]] * pow(-1, i + j)\n        mat4 cofactor;\n\n        cofactor.v[0] = M4_3X3MINOR(1, 2, 3, 1, 2, 3);\n        cofactor.v[1] = -M4_3X3MINOR(1, 2, 3, 0, 2, 3);\n        cofactor.v[2] = M4_3X3MINOR(1, 2, 3, 0, 1, 3);\n        cofactor.v[3] = -M4_3X3MINOR(1, 2, 3, 0, 1, 2);\n\n        cofactor.v[4] = -M4_3X3MINOR(0, 2, 3, 1, 2, 3);\n        cofactor.v[5] = M4_3X3MINOR(0, 2, 3, 0, 2, 3);\n        cofactor.v[6] = -M4_3X3MINOR(0, 2, 3, 0, 1, 3);\n        cofactor.v[7] = M4_3X3MINOR(0, 2, 3, 0, 1, 2);\n\n        cofactor.v[8] = M4_3X3MINOR(0, 1, 3, 1, 2, 3);\n        cofactor.v[9] = -M4_3X3MINOR(0, 1, 3, 0, 2, 3);\n        cofactor.v[10] = M4_3X3MINOR(0, 1, 3, 0, 1, 3);\n        cofactor.v[11] = -M4_3X3MINOR(0, 1, 3, 0, 1, 2);\n\n        cofactor.v[12] = -M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n        cofactor.v[13] = M4_3X3MINOR(0, 1, 2, 0, 2, 3);\n        cofactor.v[14] = -M4_3X3MINOR(0, 1, 2, 0, 1, 3);\n        cofactor.v[15] = M4_3X3MINOR(0, 1, 2, 0, 1, 2);\n\n        return transposed(cofactor);\n    }\n\n    mat4 inverse(const mat4& m) {\n        float det = determinant(m);\n\n        if (det == 0.0f) { // Epsilon check would need to be REALLY small\n            return mat4();\n        }\n        mat4 adj = adjugate(m);\n\n        return adj * (1.0f / det);\n    }\n\n    void invert(mat4& m) {\n        float det = determinant(m);\n\n        if (det == 0.0f) {\n            m = mat4();\n            return;\n        }\n\n        m = adjugate(m) * (1.0f / det);\n    }\n\n    mat4 frustum(float l, float r, float b, float t, float n, float f) {\n        if (l == r || t == b || n == f) {\n            return mat4(); // Error\n        }\n        return mat4(\n            (2.0f * n) / (r - l), 0, 0, 0,\n            0, (2.0f * n) / (t - b), 0, 0,\n            (r + l) / (r - l), (t + b) / (t - b), (-(f + n)) / (f - n), -1,\n            0, 0, (-2 * f * n) / (f - n), 0\n        );\n    }\n\n    mat4 perspective(float fov, float aspect, float znear, float zfar) {\n        float ymax = znear * (float)Tan(fov * 3.14159265359f / 360.0f);\n        float xmax = ymax * aspect;\n\n        return frustum(-xmax, xmax, -ymax, ymax, znear, zfar);\n    }\n\n    mat4 ortho(float l, float r, float b, float t, float n, float f) {\n        if (l == r || t == b || n == f) {\n            return mat4(); // Error\n        }\n        return mat4(\n            2.0f / (r - l), 0, 0, 0,\n            0, 2.0f / (t - b), 0, 0,\n            0, 0, -2.0f / (f - n), 0,\n            -((r + l) / (r - l)), -((t + b) / (t - b)), -((f + n) / (f - n)), 1\n        );\n    }\n\n    mat4 lookAt(const vec3& position, const vec3& target, const vec3& up) {\n        // Remember, forward is negative z\n        vec3 f = normalized(target - position) * -1.0f;\n        vec3 r = cross(up, f); // Right handed\n        if (r == vec3(0, 0, 0)) {\n            return mat4(); // Error\n        }\n        normalize(r);\n        vec3 u = normalized(cross(f, r)); // Right handed\n\n        vec3 t = vec3(\n            -dot(r, position),\n            -dot(u, position),\n            -dot(f, position)\n        );\n\n        return mat4(\n            // Transpose upper 3x3 matrix to invert it\n            r.x, u.x, f.x, 0,\n            r.y, u.y, f.y, 0,\n            r.z, u.z, f.z, 0,\n            t.x, t.y, t.z, 1\n        );\n    }\n\n    quat angleAxis(float angle, const vec3& axis) {\n        vec3 norm = normalized(axis);\n        float s = FastSin(angle * 0.5f);\n\n        return quat(\n            norm.x * s,\n            norm.y * s,\n            norm.z * s,\n            FastCos(angle * 0.5f)\n        );\n    }\n\n    quat fromTo(const vec3& from, const vec3& to) {\n        vec3 f = normalized(from);\n        vec3 t = normalized(to);\n\n        if (f == t) {\n            return quat();\n        }\n        else if (f == t * -1.0f) {\n            vec3 ortho = vec3(1, 0, 0);\n            if (Fabsf(f.y) < Fabsf(f.x)) {\n                ortho = vec3(0, 1, 0);\n            }\n            if (Fabsf(f.z) < Fabsf(f.y) && Fabsf(f.z) < Fabsf(f.x)) {\n                ortho = vec3(0, 0, 1);\n            }\n\n            vec3 axis = normalized(cross(f, ortho));\n            return quat(axis.x, axis.y, axis.z, 0);\n        }\n\n        vec3 half = normalized(f + t);\n        vec3 axis = cross(f, half);\n\n        return quat(\n            axis.x,\n            axis.y,\n            axis.z,\n            dot(f, half)\n        );\n    }\n\n    vec3 getAxis(const quat& quat) {\n        return normalized(vec3(quat.x, quat.y, quat.z));\n    }\n\n    float getAngle(const quat& quat) {\n        return 2.0f * (1.0f / FastCos(quat.w));\n    }\n\n    quat operator+(const quat& a, const quat& b) {\n        return quat(\n            a.x + b.x,\n            a.y + b.y,\n            a.z + b.z,\n            a.w + b.w\n        );\n    }\n\n    quat operator-(const quat& a, const quat& b) {\n        return quat(\n            a.x - b.x,\n            a.y - b.y,\n            a.z - b.z,\n            a.w - b.w\n        );\n    }\n\n    quat operator*(const quat& a, float b) {\n        return quat(\n            a.x * b,\n            a.y * b,\n            a.z * b,\n            a.w * b\n        );\n    }\n\n    quat operator-(const quat& q) {\n        return quat(\n            -q.x,\n            -q.y,\n            -q.z,\n            -q.w\n        );\n    }\n\n    bool operator==(const quat& left, const quat& right) {\n        return (Fabsf(left.x - right.x) <= QUAT_EPSILON &&\n            Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n            Fabsf(left.z - right.z) <= QUAT_EPSILON &&\n            Fabsf(left.w - left.w) <= QUAT_EPSILON);\n    }\n\n    bool operator!=(const quat& a, const quat& b) {\n        return !(a == b);\n    }\n\n    bool sameOrientation(const quat& left, const quat& right) {\n        return (Fabsf(left.x - right.x) <= QUAT_EPSILON && Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n            Fabsf(left.z - right.z) <= QUAT_EPSILON && Fabsf(left.w - left.w) <= QUAT_EPSILON)\n            || (Fabsf(left.x + right.x) <= QUAT_EPSILON && Fabsf(left.y + right.y) <= QUAT_EPSILON &&\n                Fabsf(left.z + right.z) <= QUAT_EPSILON && Fabsf(left.w + left.w) <= QUAT_EPSILON);\n    }\n\n    float dot(const quat& a, const quat& b) {\n        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n    }\n\n    float lenSq(const quat& q) {\n        return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n    }\n\n    float len(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return 0.0f;\n        }\n        return Sqrtf(lenSq);\n    }\n\n    void normalize(quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return;\n        }\n        float i_len = 1.0f / Sqrtf(lenSq);\n\n        q.x *= i_len;\n        q.y *= i_len;\n        q.z *= i_len;\n        q.w *= i_len;\n    }\n\n    quat normalized(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return quat();\n        }\n        float i_len = 1.0f / Sqrtf(lenSq);\n\n        return quat(\n            q.x * i_len,\n            q.y * i_len,\n            q.z * i_len,\n            q.w * i_len\n        );\n    }\n\n    quat conjugate(const quat& q) {\n        return quat(\n            -q.x,\n            -q.y,\n            -q.z,\n            q.w\n        );\n    }\n\n    quat inverse(const quat& q) {\n        float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n        if (lenSq < QUAT_EPSILON) {\n            return quat();\n        }\n        float recip = 1.0f / lenSq;\n\n        // conjugate / norm\n        return quat(\n            -q.x * recip,\n            -q.y * recip,\n            -q.z * recip,\n            q.w * recip\n        );\n    }\n\n    #if 1\n    quat operator*(const quat& Q1, const quat& Q2) {\n        return quat(\n            Q2.x * Q1.w + Q2.y * Q1.z - Q2.z * Q1.y + Q2.w * Q1.x,\n            -Q2.x * Q1.z + Q2.y * Q1.w + Q2.z * Q1.x + Q2.w * Q1.y,\n            Q2.x * Q1.y - Q2.y * Q1.x + Q2.z * Q1.w + Q2.w * Q1.z,\n            -Q2.x * Q1.x - Q2.y * Q1.y - Q2.z * Q1.z + Q2.w * Q1.w\n        );\n    }\n    #else\n    quat operator*(const quat& Q1, const quat& Q2) {\n        quat result;\n        result.scalar = Q2.scalar * Q1.scalar - dot(Q2.vector, Q1.vector);\n        result.vector = (Q1.vector * Q2.scalar) + (Q2.vector * Q1.scalar) + cross(Q2.vector, Q1.vector);\n        return result;\n    }\n    #endif\n\n    vec3 operator*(const quat& q, const vec3& v) {\n        return q.vector * 2.0f * dot(q.vector, v) +\n            v * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n            cross(q.vector, v) * 2.0f * q.scalar;\n    }\n\n    quat mix(const quat& from, const quat& to, float t) {\n        return from * (1.0f - t) + to * t;\n    }\n\n    quat nlerp(const quat& from, const quat& to, float t) {\n        return normalized(from + (to - from) * t);\n    }\n\n    quat operator^(const quat& q, float f) {\n        float angle = 2.0f * (1.0f / FastCos(q.scalar));\n        vec3 axis = normalized(q.vector);\n\n        float halfCos = FastCos(f * angle * 0.5f);\n        float halfSin = FastSin(f * angle * 0.5f);\n\n        return quat(\n            axis.x * halfSin,\n            axis.y * halfSin,\n            axis.z * halfSin,\n            halfCos\n        );\n    }\n\n    quat slerp(const quat& start, const quat& end, float t) {\n        if (Fabsf(dot(start, end)) > 1.0f - QUAT_EPSILON) {\n            return nlerp(start, end, t);\n        }\n\n        return normalized(((inverse(start) * end) ^ t) * start);\n    }\n\n    quat lookRotation(const vec3& direcion, const vec3& up) {\n        // Find orthonormal basis vectors\n        vec3 f = normalized(direcion);\n        vec3 u = normalized(up);\n        vec3 r = cross(u, f);\n        u = cross(f, r);\n\n        // From world forward to object forward\n        quat f2d = fromTo(vec3(0, 0, 1), f);\n\n        // what direction is the new object up?\n        vec3 objectUp = f2d * vec3(0, 1, 0);\n        // From object up to desired up\n        quat u2u = fromTo(objectUp, u);\n\n        // Rotate to forward direction first, then twist to correct up\n        quat result = f2d * u2u;\n        // Don\u00ef\u00bf\u00bdt forget to normalize the result\n        return normalized(result);\n    }\n\n    mat4 quatToMat4(const quat& q) {\n        vec3 r = q * vec3(1, 0, 0);\n        vec3 u = q * vec3(0, 1, 0);\n        vec3 f = q * vec3(0, 0, 1);\n\n        return mat4(\n            r.x, r.y, r.z, 0,\n            u.x, u.y, u.z, 0,\n            f.x, f.y, f.z, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    quat mat4ToQuat(const mat4& m) {\n        vec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n        vec3 forward = normalized(vec3(m.forward.x, m.forward.y, m.forward.z));\n        vec3 right = cross(up, forward);\n        up = cross(forward, right);\n\n        return lookRotation(forward, up);\n    }\n\n\n    void CalculateTangentArray(unsigned int vertexCount, float* _vertex, float* _normal,\n\t\tfloat* _texcoord, float* _outTangent) {\n\n        vec3* vertex = (vec3*)_vertex;\n        vec3* normal = (vec3*)_normal;\n        vec2* texcoord = (vec2*)_texcoord;\n        vec3* outTangent = (vec3*)_outTangent;\n\n\t\tvec3* tan1 = (vec3*)MemAlloc(vertexCount * 2 * sizeof(vec3));\n\t\tvec3* tan2 = tan1 + vertexCount;\n\n\t\tfor (long a = 0; a < vertexCount; a += 3)\n\t\t{\n\t\t\tvec3 v1 = vertex[a + 0];\n\t\t\tvec3 v2 = vertex[a + 1];\n\t\t\tvec3 v3 = vertex[a + 2];\n\n\t\t\tvec2 w1 = texcoord[a + 0];\n\t\t\tvec2 w2 = texcoord[a + 1];\n\t\t\tvec2 w3 = texcoord[a + 2];\n\n\t\t\tfloat x1 = v2.x - v1.x;\n\t\t\tfloat x2 = v3.x - v1.x;\n\t\t\tfloat y1 = v2.y - v1.y;\n\t\t\tfloat y2 = v3.y - v1.y;\n\t\t\tfloat z1 = v2.z - v1.z;\n\t\t\tfloat z2 = v3.z - v1.z;\n\n\t\t\tfloat s1 = w2.x - w1.x;\n\t\t\tfloat s2 = w3.x - w1.x;\n\t\t\tfloat t1 = w2.y - w1.y;\n\t\t\tfloat t2 = w3.y - w1.y;\n\n\t\t\tfloat r = 1.0f / (s1 * t2 - s2 * t1);\n\t\t\tvec3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,\n\t\t\t\t(t2 * z1 - t1 * z2) * r);\n\t\t\tvec3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,\n\t\t\t\t(s1 * z2 - s2 * z1) * r);\n\n\t\t\ttan1[a + 0] = tan1[a + 0] + sdir;\n\t\t\ttan1[a + 1] = tan1[a + 1] + sdir;\n\t\t\ttan1[a + 2] = tan1[a + 2] + sdir;\n\n\t\t\ttan2[a + 0] = tan2[a + 0] + tdir;\n\t\t\ttan2[a + 1] = tan2[a + 1] + tdir;\n\t\t\ttan2[a + 2] = tan2[a + 2] + tdir;\n\t\t}\n\n\t\tfor (long a = 0; a < vertexCount; a++) {\n\t\t\tvec3 n = normal[a];\n\t\t\tvec3 t = tan1[a];\n\t\t\t// Gram-Schmidt orthogonalize\n\t\t\toutTangent[a] = normalized(t - n * dot(n, t));\n\t\t\t// Calculate handedness\n\t\t\t//outTangent[a].w = (dot(cross(n, t), tan2[a]) < 0.0F) ? -1.0F : 1.0F;\n\t\t}\n\n\t\tMemRelease(tan1);\n\t}\n\n    void CalculateTangentArrayInline(unsigned int vertexCount, float* interleaved) {\n        vec3* tan1 = (vec3*)MemAlloc(vertexCount * 2 * sizeof(vec3));\n        vec3* tan2 = tan1 + vertexCount;\n\n        for (long a = 0; a < vertexCount; a += 3) { // 3 verts at a time\n            vec3 v1 = *(vec3*)&interleaved[(a + 0) * 11 + 0];\n            vec3 v2 = *(vec3*)&interleaved[(a + 1) * 11 + 0];\n            vec3 v3 = *(vec3*)&interleaved[(a + 2) * 11 + 0];\n\n            vec2 w1 = *(vec2*)&interleaved[(a + 0) * 11 + 6];\n            vec2 w2 = *(vec2*)&interleaved[(a + 1) * 11 + 6];\n            vec2 w3 = *(vec2*)&interleaved[(a + 2) * 11 + 6];\n\n            float x1 = v2.x - v1.x;\n            float x2 = v3.x - v1.x;\n            float y1 = v2.y - v1.y;\n            float y2 = v3.y - v1.y;\n            float z1 = v2.z - v1.z;\n            float z2 = v3.z - v1.z;\n\n            float s1 = w2.x - w1.x;\n            float s2 = w3.x - w1.x;\n            float t1 = w2.y - w1.y;\n            float t2 = w3.y - w1.y;\n\n            float r = 1.0f / (s1 * t2 - s2 * t1);\n            vec3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,\n                (t2 * z1 - t1 * z2) * r);\n            vec3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,\n                (s1 * z2 - s2 * z1) * r);\n\n            tan1[a + 0] = tan1[a + 0] + sdir;\n            tan1[a + 1] = tan1[a + 1] + sdir;\n            tan1[a + 2] = tan1[a + 2] + sdir;\n\n            tan2[a + 0] = tan2[a + 0] + tdir;\n            tan2[a + 1] = tan2[a + 1] + tdir;\n            tan2[a + 2] = tan2[a + 2] + tdir;\n        }\n\n        for (long a = 0; a < vertexCount; a++) {\n            vec3 n = *(vec3*)&interleaved[a  * 11 + 3];\n            vec3 t = tan1[a];\n            // Gram-Schmidt orthogonalize\n            long a_index = a * 11 + 8;\n\n            vec3 result = normalized(t - n * dot(n, t));\n\n            interleaved[a * 11 + 8 + 0] = result.x;\n            interleaved[a * 11 + 8 + 1] = result.y;\n            interleaved[a * 11 + 8 + 2] = result.z;\n        }\n\n        MemRelease(tan1);\n    }\n}","#include \"memory.h\"\n\n#if defined(MEM_PLATFORM_WINDOWS)\n    #include <windows.h>\n    mem_cfunc void PrintDebugString(const char* str) {\n        OutputDebugStringA(str);\n    }\n\n    #ifdef _DEBUG\n        #define MemInternal_Assert(cond) if (!(cond)) {*(u8*)0 = 0;}\n    #else\n        #define MemInternal_Assert(cond) \n    #endif\n#elif defined(MEM_PLATFORM_WASM)\n    extern unsigned char __heap_base;\n    extern unsigned char __data_end;\n\n    __attribute__ (( visibility( \"default\" ) )) extern \"C\" void MemWasmTriggerCallback(fpAllocationInfo callback, u32 index, void* mem, u32 firstPage, u32 numPages, void* tag, void* userData) {\n        if (callback != 0) {\n        callback(index, mem, firstPage, numPages, tag, userData);\n        }\n    }\n\n    #ifdef _DEBUG\n        #define MemInternal_Assert(cond) if (!(cond)) {PrintDebugString(\"NATIVE ASSERT!\"); __builtin_trap();}\n    #else\n        #define MemInternal_Assert(cond) \n    #endif\n#endif\n\n\n\n#define MEM_ENABLE_SUBALLOCATORS        1\n\n#define MEM_PAGE_SIZE                   4096 // Each page is 4 KiB\n#define MEM_ALLOCATOR_SIZE              40 // (u32, u32, u32, u32, u32, u32, u32, u32, u32, u32)\n#if MEM_ENABLE_ALLOCGUARD\n#define MEM_ALLOCATION_HEADER_SIZE      30 // (u32, u16, u16, u32, u32, u64, u32, u16)\n#else\n#define MEM_ALLOCATION_HEADER_SIZE      22 // (u16, u16, u32, u32, u64, u16)\n#endif\n\nvoid* gHeap = 0;\n\n\n#if MEM_ENABLE_ALLOCGUARD\n#define MEM_ALLOCATION_magicHead        0\n#define MEM_ALLOCATION_startPage        4\n#define MEM_ALLOCATION_pageCount        6\n#define MEM_ALLOCATION_allocPrev        8\n#define MEM_ALLOCATION_allocNext        12\n#define MEM_ALLOCATION_tag              16\n#define MEM_ALLOCATION_magicTail        24\n#define MEM_ALLOCATION_padding          28\n#else\n#define MEM_ALLOCATION_startPage        0\n#define MEM_ALLOCATION_pageCount        2\n#define MEM_ALLOCATION_allocPrev        4\n#define MEM_ALLOCATION_allocNext        8\n#define MEM_ALLOCATION_tag              12\n#define MEM_ALLOCATION_padding          20\n#endif\n\n#define MEM_ALLOCATOR_heapSizeBytes     0\n#define MEM_ALLOCATOR_overheadPages     4\n#define MEM_ALLOCATOR_firstPage         8\n#define MEM_ALLOCATOR_activeAllocs      12\n#define MEM_ALLOCATOR_subAllocFree1     16\n#define MEM_ALLOCATOR_subAllocSize1     20\n#define MEM_ALLOCATOR_subAllocFree2     24\n#define MEM_ALLOCATOR_subAllocSize2     28\n#define MEM_ALLOCATOR_subAllocFree3     32\n#define MEM_ALLOCATOR_subAllocSize3     36\n\n#define MEM_ALLOCACTION_MAGIC_MAIN       (((u32)'m' << 0) | ((u32)'e' << 8) | ((u32)'m' << 16) | ((u32)'_' << 24))    // 1601004909\n#define MEM_ALLOCACTION_MAGIC_SUB_ACTIVE (((u32)'s' << 0) | ((u32)'u' << 8) | ((u32)'b' << 16) | ((u32)'a' << 24))    // \n#define MEM_ALLOCACTION_MAGIC_SUB_FREE   (((u32)'s' << 0) | ((u32)'u' << 8) | ((u32)'b' << 16) | ((u32)'f' << 24))    // \n#define MEM_ALLOCACTION_MAGIC_RELEASED   (((u32)'f' << 0) | ((u32)'r' << 8) | ((u32)'e' << 16) | ((u32)'e' << 24))    // 1701147238\n\n\n#if 0\n#define MEM_READU16(ptr, offset)        (*(u16*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU16(ptr, offset, val)  (*(u16*)((u8*)(ptr) + (offset)) = (u16)(val))\n\n#define MEM_READU32(ptr, offset)        (*(u32*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU32(ptr, offset, val)  (*(u32*)((u8*)(ptr) + (offset)) = (u32)(val))\n\n#define MEM_READU64(ptr, offset)        (*(u64*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU64(ptr, offset, val)  (*(u64*)((u8*)(ptr) + (offset)) = (u64)(val))\n\n#define MEM_SUBALLOCSIZE(ptr, index)    (*(u32*)((u8*)(ptr) + 20 + ((index) * 8)))\n#define MEM_GETSUBALLOCOFFSET(ptr, idx) (*(u32*)((u8*)(ptr) + 16 + ((idx) * 8)))\n#define MEM_SETSUBALLOCOFFSET(ptr,i,v)  (*(u32*)((u8*)(ptr) + 16 + ((i) * 8)) = (u32)(v))\n#define MEM_PAGEMASKPTR(ptr)            ( (u32*)((u8*)(ptr) + 40))\n#define MEM_HEAPSIZE(ptr)               (*(u32*)((u8*)(ptr) + 0 ))\n#define MEM_ACTIVEALLOCSOFFSET(ptr)     (*(u32*)((u8*)(ptr) + 12))\n#define MEM_FIRSTPAGEOFFSET(ptr)        (*(u32*)((u8*)(ptr) + 8 ))\n#define MEM_FIRSTPAGEPTR(ptr)           (       ((u8*)(ptr) + MEM_FIRSTPAGEOFFSET(ptr)))\n#define MEM_GETPAGEPTR(ptr, page)       ((u8*)MEM_FIRSTPAGEPTR(ptr) + (MEM_PAGE_SIZE * (page)))\n#else\ninline u16 MEM_READU16(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u16 low =  u8_ptr[offset];\n    u16 high = u8_ptr[offset + 1];\n\n    return low | (high << 8);\n}\n\ninline void MEM_WRITEU16(void* ptr, u32 offset, u16 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u8 b1 = (val & (255));\n    u8 b2 = (val & (255 << 8)) >> 8;\n\n    u8_ptr[offset] = b1;\n    u8_ptr[offset + 1] = b2;\n}\n\ninline u32 MEM_READU32(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u32 b1 = u8_ptr[offset + 0];\n    u32 b2 = u8_ptr[offset + 1];\n    u32 b3 = u8_ptr[offset + 2];\n    u32 b4 = u8_ptr[offset + 3];\n\n    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);\n}\n\ninline void MEM_WRITEU32(void* ptr, u32 offset, u32 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u8 b1 = (val & (255));\n    u8 b2 = (val & (255 << 8)) >> 8;\n    u8 b3 = (val & (255 << 16)) >> 16;\n    u8 b4 = (val & (255 << 24)) >> 24;\n\n    u8_ptr[offset + 0] = b1;\n    u8_ptr[offset + 1] = b2;\n    u8_ptr[offset + 2] = b3;\n    u8_ptr[offset + 3] = b4;\n}\n\ninline u64 MEM_READU64(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u64 b1 = u8_ptr[offset + 0];\n    u64 b2 = u8_ptr[offset + 1];\n    u64 b3 = u8_ptr[offset + 2];\n    u64 b4 = u8_ptr[offset + 3];\n    u64 b5 = u8_ptr[offset + 4];\n    u64 b6 = u8_ptr[offset + 5];\n    u64 b7 = u8_ptr[offset + 6];\n    u64 b8 = u8_ptr[offset + 7];\n\n    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24) | (b5 << 32) | (b6 << 40) | (b7 << 48) || (b8 << 56);\n}\n\ninline void MEM_WRITEU64(void* ptr, u32 offset, u64 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u32 a = (val << 32) >> 32;\n    u32 b = val >> 32;\n\n    MEM_WRITEU32(ptr, offset, a);\n    MEM_WRITEU32(ptr, offset + sizeof(u32), b);\n}\n\ninline u32 MEM_SUBALLOCSIZE(void* ptr, u32 index) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_subAllocSize1 + index * 8);\n}\n\ninline u32 MEM_GETSUBALLOCOFFSET(void* ptr, u32 index) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_subAllocFree1 + index * 8);\n}\n\ninline void MEM_SETSUBALLOCOFFSET(void* ptr, u32 index, u32 value) {\n    MEM_WRITEU32(ptr, MEM_ALLOCATOR_subAllocFree1 + index * 8, value);\n}\n\ninline u32* MEM_PAGEMASKPTR(void* ptr) {\n    u8* target = (u8*)ptr + MEM_ALLOCATOR_SIZE;\n    return (u32*)target;\n}\n\ninline u32 MEM_HEAPSIZE(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_heapSizeBytes);\n}\n\ninline u32 MEM_ACTIVEALLOCSOFFSET(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_activeAllocs);\n}\n\ninline u32 MEM_FIRSTPAGEOFFSET(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_firstPage);\n}\n\ninline u8* MEM_FIRSTPAGEPTR(void* ptr) {\n    return (u8*)ptr + MEM_FIRSTPAGEOFFSET(ptr);\n}\n\ninline u8* MEM_GETPAGEPTR(void* ptr, u32 page) {\n    return MEM_FIRSTPAGEPTR(ptr) + (MEM_PAGE_SIZE * page);\n}\n#endif\n\nmem_cfunc i32 MemRelease(void* target) {\n    return MemReleaseFromHeap(gHeap, target);\n}\n\nmem_cfunc void* MemAllocate(u32 bytes, u32 alignment, void* tag) {\n    return MemAllocateOnHeap(gHeap, bytes, alignment, tag);\n}\n\nmem_cfunc void* MemReallocate(void* src, u32 newBytes, void* newTag) {\n    return MemReallocateOnHeap(gHeap, src, newBytes, newTag);\n}\n\nmem_cfunc u32 MemForEachAllocation(fpAllocationInfo callback, void* userData) {\n    return MemForEachAllocationOnHeap(gHeap, callback, userData);\n}\n\nmem_cfunc void* MemPlatformAllocate(u32 bytes) {\n#if defined(MEM_PLATFORM_WINDOWS)\n    return VirtualAlloc(0, bytes, MEM_COMMIT, PAGE_READWRITE);\n#elif defined(MEM_PLATFORM_WASM)\n    return &__heap_base;\n#endif\n}\n\nmem_cfunc void MemPlatformRelease(void* mem) {\n#if defined(MEM_PLATFORM_WINDOWS)\n    VirtualFree(mem, 0, MEM_RELEASE);\n#endif\n}\n\n// Can only manage up to 4 GiB of RAM. This is because internally pointers are keps as offsets\n// and each offset is stored as a u32\nmem_cfunc void* MemInitializeHeap(void* heap, u32 heapSize) {\n    MemInternal_Assert(heapSize > MEM_PAGE_SIZE * 3); // Arbitrary\n\n    // Align to be on a 4 byte boundary. This will cause all masks to be on a 4 byte boundary as well\n    // and will make sure that the page mask is 4 byte aligned (since the header is 40 bytes, and the mask starts right after)\n    u64 alignment = sizeof(u32); // 4\n    u8* align_heap = (u8*)heap;\n    if ((u64)align_heap % alignment != 0) {\n        u64 remainder = (u64)align_heap % alignment;\n        align_heap += (u32)alignment - (u32)remainder;\n        heapSize -= (u32)alignment - (u32)remainder;\n    }\n    gHeap = align_heap;\n\n    u32 numPages = heapSize / MEM_PAGE_SIZE;\n    u32 pageMaskCount = (numPages / 32) + (numPages % 32 != 0 ? 1 : 0);\n\n    MemInternal_Assert(numPages >= 0);\n\n    u32 overheadBytes = (MEM_ALLOCATOR_SIZE + pageMaskCount * sizeof(u32)) + sizeof(u32);\n\n    u32 overheadPageCount = (overheadBytes / MEM_PAGE_SIZE) + (overheadBytes % MEM_PAGE_SIZE != 0 ? 1 : 0);\n    u32 firstPageOffset = overheadPageCount * MEM_PAGE_SIZE; // 0 = 0, 1 = 4096, etc...\n\n    // As arguments, you pass in how big each sub-alloctors chunks should be. IE, i want this sub-allocator\n    // to allocate 72 byte chunks. Then there would be \"pageSize / (72 + sizeof(header))\" blocks in each page\n\n    // If you request an allocation that's MemAlloc(72, 4), it wouldn't fit into the allocator, because that\n    // allocation needs 72 + 4 bytes. So it would bucket over to the next allocator.\n\n    // In the above examples, 72 would be written to the allocator struct as a sub allocator size.\n    u32 subAlloc1Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 8)) / 8;\n    u32 subAlloc2Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 4)) / 4;\n    u32 subAlloc3Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 2)) / 2;\n\n    // struct Allocator (40 bytes)\n    /* u32 heapSizeBytes */ MEM_WRITEU32(align_heap, sizeof(u32) * 0, heapSize);             // 0\n    /* u32 overheadPages */ MEM_WRITEU32(align_heap, sizeof(u32) * 1, overheadPageCount);    // 4\n    /* u32 firstPage     */ MEM_WRITEU32(align_heap, sizeof(u32) * 2, firstPageOffset);      // 8\n    /* u32 activeAllocs  */ MEM_WRITEU32(align_heap, sizeof(u32) * 3, 0);                    // 12\n    /* u32 subAllocFree1 */ MEM_WRITEU32(align_heap, sizeof(u32) * 4, 0);                    // 16\n    /* u32 subAllocSize1 */ MEM_WRITEU32(align_heap, sizeof(u32) * 5, subAlloc1Size);        // 20\n    /* u32 subAllocFree2 */ MEM_WRITEU32(align_heap, sizeof(u32) * 6, 0);                    // 24\n    /* u32 subAllocSize2 */ MEM_WRITEU32(align_heap, sizeof(u32) * 7, subAlloc2Size);        // 28\n    /* u32 subAllocFree3 */ MEM_WRITEU32(align_heap, sizeof(u32) * 8, 0);                    // 32\n    /* u32 subAllocSize3 */ MEM_WRITEU32(align_heap, sizeof(u32) * 9, subAlloc3Size);        // 36\n\n    // Clear page mask (and set overhead pages)\n    for (u32 page = 0; page < pageMaskCount; ++page) {\n        MEM_WRITEU32(align_heap, MEM_ALLOCATOR_SIZE + page * sizeof(u32), (page < overheadPageCount));\n    }\n\n    return align_heap;\n}\n\n// Returns true if all memory has been released. \nmem_cfunc int MemShutdownHeap(void* heap) {\n#if _DEBUG\n    u32 allocationOffset = MEM_ACTIVEALLOCSOFFSET(heap);\n    u32 numUnreleasedAllocations = 0;\n    while (allocationOffset != 0) {\n        u8* header = (u8*)heap + allocationOffset;\n\n        u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n        u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n        u64 _label = MEM_READU64(header, MEM_ALLOCATION_tag);\n        const char* label = (const char*)_label;\n\n#if MEM_ENABLE_ALLOCGUARD\n        MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n        MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n        allocationOffset = MEM_READU32(header, MEM_ALLOCATION_allocNext); // Iterate to next element\n        numUnreleasedAllocations += 1;\n    }\n#endif\n\n    bool allAllocationsReleased = MEM_ACTIVEALLOCSOFFSET(heap) == 0;\n    bool subAllocPool0Empty = MEM_GETSUBALLOCOFFSET(heap, 0) == 0;\n    bool subAllocPool1Empty = MEM_GETSUBALLOCOFFSET(heap, 1) == 0;\n    bool subAllocPool2Empty = MEM_GETSUBALLOCOFFSET(heap, 2) == 0;\n\n    MemInternal_Assert(allAllocationsReleased && subAllocPool0Empty && subAllocPool1Empty && subAllocPool2Empty);\n    return allAllocationsReleased && subAllocPool0Empty && subAllocPool1Empty && subAllocPool2Empty;\n}\n\nmem_cfunc u32 MemGetPageSize() {\n    return MEM_PAGE_SIZE;\n}\n\nmem_cfunc u32* MemGetPageMask() {\n    return (u32*)((u8*)gHeap + MEM_ALLOCATOR_SIZE);\n}\n\nmem_cfunc u32 MemGetHeapSize() {\n    return MEM_READU32(gHeap, MEM_ALLOCATOR_heapSizeBytes);\n}\n\nmem_cfunc u32 MemGetNumOverheadPages() {\n    return MEM_READU32(gHeap, MEM_ALLOCATOR_overheadPages);\n}\n\nmem_cfunc u64 MemGetTag64(void* _mem) {\n    u8* mem = (u8*)_mem;\n    u16 padding = MEM_READU16((u8*)_mem - 2, 0);\n    u8* header = mem - padding - MEM_ALLOCATION_HEADER_SIZE;\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    MemInternal_Assert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    MemInternal_Assert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    return MEM_READU64(header, MEM_ALLOCATION_tag);\n}\n\nmem_cfunc void MemSetTag64(void* _mem, u64 tag) {\n    u8* mem = (u8*)_mem;\n    u16 padding = MEM_READU16((u8*)_mem - 2, 0);\n    u8* header = mem - padding - MEM_ALLOCATION_HEADER_SIZE;\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    MemInternal_Assert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    MemInternal_Assert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    MEM_WRITEU64(header, MEM_ALLOCATION_tag, tag);\n}\n\nmem_cfunc u32 MemGetTag32(void* _mem) {\n    return (u32)MemGetTag64(_mem);\n}\n\nmem_cfunc void MemSetTag32(void* _mem, u32 tag) {\n    MemSetTag64(_mem, tag);\n}\n\n// Returns 0 on error, or the index of the page where a range of numPages starts\nstatic u32 MemInternal_FindFreePages(void* heap, u32 numPages) {\n    MemInternal_Assert(heap != 0);\n    MemInternal_Assert(numPages >= 1);\n\n    // Find the required number of pages\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    u32 heapNumPages = MEM_HEAPSIZE(heap) / MEM_PAGE_SIZE;\n\n    // Find available pages\n    u32 startPage = 0; // Page 0 is invalid. First page must be reserved for overhead\n    u32 pageCount = 0;\n    for (u32 i = 1; i < heapNumPages; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n\n        if (pageMask[index] & (1 << bit)) { // Page is in use\n            startPage = 0;\n            pageCount = 0;\n        }\n        else { // Free page\n            if (startPage == 0) { // New range\n                startPage = i;\n                pageCount = 1;\n                if (numPages == 1) {\n                    break;\n                }\n            }\n            else { // Expand range\n                pageCount += 1;\n                if (pageCount == numPages) {\n                    break;\n                }\n            }\n        }\n    }\n\n    MemInternal_Assert(startPage != 0);\n    MemInternal_Assert(pageCount == numPages);\n\n    return startPage;\n}\n\nstatic bool MemInternal_ClaimPages(void* heap, u32 startPage, u32 pageCount) {\n    if (startPage == 0 || pageCount == 0) {\n        return false;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    for (u32 i = startPage, count = startPage + pageCount; i < count; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n        if ((pageMask[index] & (1 << bit))) {\n            MemInternal_Assert(false);\n            return false; // Error\n        }\n        pageMask[index] |= (1 << bit);\n    }\n\n    return true;\n}\n\nstatic bool MemInternal_ReleasePages(void* heap, u32 startPage, u32 pageCount) {\n    if (startPage == 0 || pageCount == 0) {\n        return false;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    for (u32 i = startPage, count = startPage + pageCount; i < count; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n        if (!(pageMask[index] & (1 << bit))) {\n            MemInternal_Assert(false);\n            return false; // Error\n        }\n        pageMask[index] &= ~(1 << bit);\n    }\n\n    return true;\n}\n\nstatic void MemInternal_WriteAllocationHeader(void* header, u32 startPage, u32 pageCount, u32 allocPrev, u32 allocNext, u64 tag) {\n    MemInternal_Assert(header != 0);\n\n    // struct Allocation\n#if MEM_ENABLE_ALLOCGUARD\n    /* u32 magic        */ MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, pageCount == 0 ? (MEM_ALLOCACTION_MAGIC_SUB_ACTIVE) : (MEM_ALLOCACTION_MAGIC_MAIN));\n#endif\n    /* u16 startPage    */ MEM_WRITEU16(header, MEM_ALLOCATION_startPage, startPage);   // 0\n    /* u16 pageCount    */ MEM_WRITEU16(header, MEM_ALLOCATION_pageCount, pageCount);   // 2\n    /* u32 allocPrev    */ MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, allocPrev);   // 4\n    /* u32 allocNext    */ MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, allocNext);   // 8\n    /* u64 tag          */ MEM_WRITEU64(header, MEM_ALLOCATION_tag, tag);               // 12\n#if MEM_ENABLE_ALLOCGUARD\n    /* u32 magic        */ MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, pageCount == 0 ? (MEM_ALLOCACTION_MAGIC_SUB_ACTIVE) : (MEM_ALLOCACTION_MAGIC_MAIN));\n#endif\n    /* u16 padding      */ MEM_WRITEU16(header, MEM_ALLOCATION_padding, 0);// Only sub-allocators use padding\n}\n\nstatic void MemInternal_AddAllocationToActiveListList(void* heap, void* header) {\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n    MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    MemInternal_Assert(heap != 0);\n    MemInternal_Assert(header != 0);\n    MemInternal_Assert(header > heap);\n\n    u32 offset = (u8*)header - (u8*)heap;\n\n    u32 headOffset = MEM_READU32(heap, MEM_ALLOCATOR_activeAllocs);\n    if (headOffset != 0) {\n        u8* headHeader = (u8*)heap + headOffset;\n        // Replace the prev \"pointer\" (really offset), which should be 0 (assert?) with our own\n        MEM_WRITEU32(headHeader, MEM_ALLOCATION_allocPrev, offset); // Set the prev pointer of the old head to the current allocation\n    }\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, headOffset); // Set the next ptr of current allocation to old head\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, 0);\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activeAllocs, offset); // Set the current allocation as the new head\n}\n\n#if MEM_ENABLE_ALLOCGUARD\nstatic void MemInternal_RemoveAllocationFromActiveList(void* heap, void* header, u32 magic) {\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    MemInternal_Assert(magicHead == magic);\n    MemInternal_Assert(magicTail == magic);\n#else\nstatic void MemInternal_RemoveAllocationFromActiveList(void* heap, void* header) {\n#endif\n\n    u32 offset = (u8*)header - (u8*)heap;\n    u32 prev = MEM_READU32(header, MEM_ALLOCATION_allocPrev);\n    u32 next = MEM_READU32(header, MEM_ALLOCATION_allocNext);\n\n    if (next != 0) { // Reling next\n        u8* nextPtr = (u8*)heap + next;\n        MEM_WRITEU32(nextPtr, MEM_ALLOCATION_allocPrev, prev);\n    }\n\n    if (prev != 0) { // Relink prev\n        u8* prevPtr = (u8*)heap + prev;\n        MEM_WRITEU32(prevPtr, MEM_ALLOCATION_allocNext, next);\n    }\n\n    u32 headOffset = MEM_READU32(heap, MEM_ALLOCATOR_activeAllocs);\n    if (headOffset == offset) { // Update list head\n        MEM_WRITEU32(heap, MEM_ALLOCATOR_activeAllocs, next); // Head was detached, next is new head\n    }\n\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, 0);\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, 0);\n\n    // Header magic is expected to be set to free by caller\n}\n\nstatic void MemInternal_RemoveSubAllocationsFromFreeList(void* heap, u8 * header) {\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    MemInternal_Assert(magicHead == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    MemInternal_Assert(magicTail == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n    u8* allocPtr = (u8*)(mask + 2);\n\n    u32 numAllocationsInBlock = (MEM_PAGE_SIZE - sizeof(u32)) / (u32)stride;\n    for (u32 i = 0; i < numAllocationsInBlock; ++i) {\n        u32 offset = (u8*)allocPtr - (u8*)heap;\n        u32 prev = MEM_READU32(allocPtr, MEM_ALLOCATION_allocPrev);\n        u32 next = MEM_READU32(allocPtr, MEM_ALLOCATION_allocNext);\n\n        if (next != 0) { // Relink next\n            u8* nextPtr = (u8*)heap + next;\n            MEM_WRITEU32(nextPtr, MEM_ALLOCATION_allocPrev, prev);\n        }\n\n        if (prev != 0) { // Relink prev\n            u8* prevPtr = (u8*)heap + prev;\n            MEM_WRITEU32(prevPtr, MEM_ALLOCATION_allocNext, next);\n        }\n\n        // Remove any list headers\n        if (offset == MEM_GETSUBALLOCOFFSET(heap, 0)) {\n            MEM_SETSUBALLOCOFFSET(heap, 0, next);\n        }\n        else if (offset == MEM_GETSUBALLOCOFFSET(heap, 1)) {\n            MEM_SETSUBALLOCOFFSET(heap, 1, next);\n        }\n        else if (offset == MEM_GETSUBALLOCOFFSET(heap, 2)) {\n            MEM_SETSUBALLOCOFFSET(heap, 2, next);\n        }\n\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_allocPrev, 0);\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_allocNext, 0);\n\n#if MEM_ENABLE_ALLOCGUARD\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_RELEASED);\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_RELEASED);\n\n        u8* write = allocPtr + MEM_ALLOCATION_magicTail + sizeof(u32);\n        *write = '\\0'; // Null out bit after magic\n        write = allocPtr + MEM_ALLOCATION_magicHead + sizeof(u32);\n        *write = '\\0'; // Null out bit after magic\n#endif\n\n        allocPtr = allocPtr + stride;\n    }\n}\n\nstatic void MemInternal_AddSubAllocationToFreeList(void* heap, u8 * header) {\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n\n    u32 subAllocatorIndex = 0;\n    u32 subAlloc1Stride = MEM_SUBALLOCSIZE(heap, 0) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 subAlloc2Stride = MEM_SUBALLOCSIZE(heap, 1) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 subAlloc3Stride = MEM_SUBALLOCSIZE(heap, 2) + MEM_ALLOCATION_HEADER_SIZE;\n    if (stride == (u16)subAlloc1Stride) {\n        subAllocatorIndex = 0;\n    }\n    else if (stride == (u16)subAlloc2Stride) {\n        subAllocatorIndex = 1;\n    }\n    else if (stride == (u16)subAlloc3Stride) {\n        subAllocatorIndex = 2;\n    }\n    else {\n        MemInternal_Assert(false);//  Stride should be one of the known sub-allocator strides\n    }\n\n    u32 prev = 0; // Adding as head, always 0\n    u32 next = MEM_GETSUBALLOCOFFSET(heap, subAllocatorIndex); // Current head\n\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, prev);\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, next);\n\n    u32 headerOffset = header - (u8*)heap;\n    if (next != 0) { // Set next prev to this\n        u8* nextHeader = (u8*)heap + next;\n        MEM_WRITEU32(nextHeader, MEM_ALLOCATION_allocPrev, headerOffset);\n    }\n\n    MEM_SETSUBALLOCOFFSET(heap, subAllocatorIndex, headerOffset); // Set list head to this\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n}\n\nstatic void* MemInternal_SubAllocate(void* heap, u32 subAlloctorIndex, u32 bytes, u32 alignment, u64 tag) {\n    MemInternal_Assert(subAlloctorIndex <= 2);\n    MemInternal_Assert(heap != 0);\n    MemInternal_Assert(bytes != 0);\n\n    u32 subAllocHeaderStride = MEM_SUBALLOCSIZE(heap, subAlloctorIndex) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 numAllocationsInBlock = (MEM_PAGE_SIZE - sizeof(u32)) / subAllocHeaderStride; // First 32 bits in sub-alloc page is a flags mask.\n    MemInternal_Assert(numAllocationsInBlock >= 2);\n    u32 freeListOffset = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex);\n\n    // If free blocks for this sub-allocator don't exist, create some.\n    if (freeListOffset == 0) {\n        u32 page = MemInternal_FindFreePages(heap, 1);\n        MemInternal_Assert(page > 0);\n        if (!MemInternal_ClaimPages(heap, page, 1)) {\n            MemInternal_Assert(false);\n            return 0;\n        }\n\n        u8* header = MEM_GETPAGEPTR(heap, page);\n        u16* subAllocationMask = (u16*)header;\n        *subAllocationMask = 0;\n        u16* subAllocationStride = subAllocationMask + 1;\n        *subAllocationStride = subAllocHeaderStride;\n\n        header += sizeof(u32);\n\n        for (u32 i = 0; i < numAllocationsInBlock; ++i) { // struct Allocation\n            u32 prev = 0; // Adding as head, always 0\n            u32 next = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex); // Current head\n\n            MemInternal_WriteAllocationHeader(header, page, 0, prev, next, (u64)\"uninitialized\"); // Sub allocation fence is active\n            //\n            MemInternal_AddSubAllocationToFreeList(heap, header); // Sub allocation fence is free\n\n            header += subAllocHeaderStride;\n        }\n    }\n\n    // Free block is guaranteed to exist. Grab one.\n    u32 head = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex); // Current head\n    u8* allocHeader = (u8*)heap + head;\n\n    // Align the allocation (if needed)\n    u8* allocation = allocHeader + MEM_ALLOCATION_HEADER_SIZE;\n    u64 address = (u64)allocation; // Align the allocation\n    u16 padding = 0;\n    if (alignment != 0 && address % alignment != 0) {\n        u64 remainder = address % alignment;\n        padding = (u16)(alignment - (u32)remainder);\n        allocation += padding;\n    }\n\n    // Update header data\n    MEM_WRITEU64(allocHeader, MEM_ALLOCATION_tag, tag); // Update tag\n    MEM_WRITEU16(allocHeader, MEM_ALLOCATION_padding, padding);\n    MEM_WRITEU16(allocation - 2, 0, padding);\n    \n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_Assert(MEM_READU32(allocHeader, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    MemInternal_Assert(MEM_READU32(allocHeader, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n\n    // Get the pointer to the current pages used bitmask, and find the right bit\n    u32 page = MEM_READU16(allocHeader, MEM_ALLOCATION_startPage);//head / MEM_PAGE_SIZE; // Also stored in allocHeader\n    u16* mask = (u16*)MEM_GETPAGEPTR(heap, page);\n    u8* firstAllocPtr = (u8*)mask + sizeof(u16) + sizeof(u16);\n\n    // Claim the allocation as used\n    u32 index = (allocHeader - firstAllocPtr) / subAllocHeaderStride;\n    u16 _mask = *mask;\n    MemInternal_Assert(!(_mask & (1 << index))); // Assume it was off before\n    _mask |= (1 << index);\n    *mask = _mask;\n\n    // If there is a next pointer, unhook this from it's prev, and set it as the new sub-alloc header\n    u32 next = MEM_READU32(allocHeader, MEM_ALLOCATION_allocNext);\n    if (next != 0) {\n        u8* nextHeader = (u8*)heap + next;\n        MEM_WRITEU32(nextHeader, MEM_ALLOCATION_allocPrev, 0); // Set next prev to 0 (unlink head)\n    }\n    MEM_SETSUBALLOCOFFSET(heap, subAlloctorIndex, next); // Set next to be the new head\n\n    MemInternal_AddAllocationToActiveListList(heap, allocHeader); // Will reset allocHeader prev and next pointers\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(allocHeader, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    MEM_WRITEU32(allocHeader, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    return allocation;\n}\n\nstatic i32 MemInternal_SubRelease(void* heap, void* target) {\n    MemInternal_Assert(target != 0);\n\n    u8* allocation = (u8*)target;\n    u16 padding = MEM_READU16(allocation - 2, 0);\n    u8* header = allocation - padding - MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    MemInternal_Assert(magicHead == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    MemInternal_Assert(magicTail == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n    u8* firstAllocPtr = (u8*)(mask + 2);\n    u32 index = (header - firstAllocPtr) / (u32)stride;\n\n    u64 _tag = MEM_READU64(header, MEM_ALLOCATION_tag);\n    const char* tag = (const char*)_tag;\n    MemInternal_Assert(MEM_READU16(header, MEM_ALLOCATION_pageCount) == 0);\n\n    // Release (sub allocation) mask\n    u16 _mask = *mask;\n    if (!(_mask & (1 << index))) {  // Assume it was on before\n        MemInternal_Assert(false);\n        return 0;\n    }\n    _mask &= ~(1 << index);\n    *mask = _mask;\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_RemoveAllocationFromActiveList(heap, header, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#else\n    MemInternal_RemoveAllocationFromActiveList(heap, header);\n#endif\n    MemInternal_AddSubAllocationToFreeList(heap, header);\n\n    if (_mask == 0) { // Page is empty, release it\n        MemInternal_RemoveSubAllocationsFromFreeList(heap, header);  // Sets header magic\n        MemInternal_ReleasePages(heap, page, 1);\n    }\n\n    return 1;\n}\n\nmem_cfunc void* MemAllocateOnHeap(void* heap, u32 bytes, u32 alignment, void* _tag) {\n    u64 tag = (u64)_tag;\n\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    if (bytes == 0) {\n        return 0;\n    }\n\n    // Early out for any sub-allocators\n#if MEM_ENABLE_SUBALLOCATORS\n    if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 0)) {\n        return MemInternal_SubAllocate(heap, 0, bytes, alignment, tag);\n    }\n    else if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 1)) {\n        return MemInternal_SubAllocate(heap, 1, bytes, alignment, tag);\n    }\n    else if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 2)) {\n        return MemInternal_SubAllocate(heap, 2, bytes, alignment, tag);\n    }\n#endif\n\n    u32 totalAllocationSize = bytes + alignment + MEM_ALLOCATION_HEADER_SIZE;\n    u32 pageCount = totalAllocationSize / MEM_PAGE_SIZE + (totalAllocationSize % MEM_PAGE_SIZE == 0 ? 0 : 1);\n\n    // Find and claim available pages\n    u32 startPage = MemInternal_FindFreePages(heap, pageCount);\n    MemInternal_Assert(startPage != 0);\n    if (!MemInternal_ClaimPages(heap, startPage, pageCount)) {\n        MemInternal_Assert(false);\n        return 0; // Error\n    }\n\n    // Create allocation header\n    u8* memory = MEM_GETPAGEPTR(heap, startPage);\n    u8* allocation = memory + MEM_ALLOCATION_HEADER_SIZE;\n    u64 address = (u64)allocation; // Align the allocation\n    if (alignment != 0 && address % alignment != 0) {\n        u64 remainder = address % alignment;\n        allocation += alignment - (u32)remainder;\n    }\n    u8* header = allocation - MEM_ALLOCATION_HEADER_SIZE;\n\n    MemInternal_WriteAllocationHeader(header, startPage, pageCount, 0, 0, tag);\n    MemInternal_AddAllocationToActiveListList(heap, header); // Will set header prev and next pointers\n\n    return allocation;\n}\n\n// Returns true if the memory was successfully released\n// Returns true if the memory being passed in is NULL\nmem_cfunc i32 MemReleaseFromHeap(void* heap, void* target) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    if (target == 0) { // Sage release\n        return true;\n    }\n\n    u16 padding = MEM_READU16((u8*)target - 2, 0);\n    u8* header = (u8*)target - padding - MEM_ALLOCATION_HEADER_SIZE;\n    u32 offset = header - (u8*)heap;\n\n    u16 startPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16 pageCount = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n\n    // Delegate to sub-allocator\n#if MEM_ENABLE_SUBALLOCATORS\n    if (pageCount == 0) { // No page count means it's a sub-allocator\n        return MemInternal_SubRelease(heap, target);\n    }\n#endif\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_MAIN);\n    MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_MAIN);\n#endif\n\n    // Clear the pages that where in use\n    MemInternal_ReleasePages(heap, startPage, pageCount);\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_RemoveAllocationFromActiveList(heap, header, MEM_ALLOCACTION_MAGIC_MAIN);\n#else\n    MemInternal_RemoveAllocationFromActiveList(heap, header);\n#endif\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_RELEASED);\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_RELEASED);\n\n    u8* write = header + MEM_ALLOCATION_magicHead + sizeof(u32);\n    *write = '\\0';\n    write = header + MEM_ALLOCATION_magicTail + sizeof(u32);\n    *write = '\\0';\n#endif\n\n    return 1;\n}\n\nmem_cfunc u32 MemForEachAllocationOnHeap(void* heap, fpAllocationInfo callback, void* userData) {\n    u32 numAllocations = 0;\n\n    u32 allocationOffset = MEM_ACTIVEALLOCSOFFSET(heap);\n    while (allocationOffset != 0) {\n        u8* header = (u8*)heap + allocationOffset;\n        u8* mem = header + MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n        MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n        MemInternal_Assert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n        u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n        u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n        allocationOffset = MEM_READU32(header, MEM_ALLOCATION_allocNext); // Iterate to next element\n        u64 _label = MEM_READU64(header, MEM_ALLOCATION_tag);\n        const char* loc = (const char*)_label;\n\n        if (callback != 0) {\n            callback(numAllocations, mem, firstPage, numPages, (void*)_label, userData);\n        }\n        numAllocations += 1;\n    }\n\n    return numAllocations;\n}\n\nmem_cfunc void* MemClear(void* dst, u32 bytes) {\n    return MemSet(dst, 0, bytes);\n}\n\nmem_cfunc void* MemReallocateOnHeap(void* heap, void* src, u32 newBytes, void* newTag) {\n    if (src == 0) {\n        return MemAllocateOnHeap(heap, newBytes, 4, newTag);\n    }\n    u16 padding = MEM_READU16((u8*)src - 2, 0);\n    u8* header = (u8*)src - padding - MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    MemInternal_Assert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    MemInternal_Assert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n    if (numPages == 0) {\n        numPages = 1;\n    }\n\n    u8* lastByte = MEM_GETPAGEPTR(heap, firstPage);\n    lastByte += numPages * MEM_PAGE_SIZE;\n    u32 maxAllocBytes = lastByte - (u8*)src;\n\n    u32 bytesToCopy = newBytes;\n    if (maxAllocBytes < bytesToCopy) {\n        bytesToCopy = maxAllocBytes;\n    }\n\n    void* newMem = MemAllocateOnHeap(heap, newBytes, 4, newTag); // Realloc is always 4 byte aligned. Consider storing alignment in each allocation as well?\n    MemCopy(newMem, src, bytesToCopy);\n    MemRelease(src);\n\n    return newMem;\n}\n\nmem_cfunc void* MemCopy(void* _dst, const void* _src, u32 bytes) {\n    u8* dst = (u8*)_dst;\n    const u8* src = (const u8*)_src;\n\n    u32 delta = 0; // Check for overlap\n    if ((u32)dst < (u32)src) {\n        delta = (u32)src - (u32)dst;\n    }\n    else {\n        delta = (u32)dst - (u32)src;\n    }\n    MemInternal_Assert(delta >= bytes);\n\n    for (unsigned int b = 0; b < bytes; ++b) {\n        dst[b] = src[b];\n    }\n\n    return dst;\n}\n\nmem_cfunc void* MemSet(void* _dst, u8 val, u32 bytes) {\n    u8* dst = (u8*)_dst;\n\n    for (unsigned int b = 0; b < bytes; ++b) {\n        dst[b] = val;\n    }\n\n    return dst;\n}\n\nmem_cfunc i32 MemCompare(const void* _a, const void* _b, u32 bytes) {\n    const u8* a = (const u8*)_a;\n    const u8* b = (const u8*)_b;\n    for (u32 i = 0; i < bytes; ++i) {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        else if (b[i] < a[i]) {\n            return 1;\n        }\n    }\n\n    return 0;\n}","#include \"sort.h\"\n#include \"../debt/qsort.h\"\n\nstatic void SortInternal_Swap(void* a, void* b, unsigned int bytes) {\n\tunsigned char* x = (unsigned char*)a;\n\tunsigned char* y = (unsigned char*)b;\n\tunsigned char z = 0;\n\tfor (unsigned int b = 0; b < bytes; ++b) {\n\t\tz = x[b];\n\t\tx[b] = y[b];\n\t\ty[b] = z;\n\t}\n}\n\nvoid QSort(void* base, unsigned int nitems, unsigned int size, int (*compare)(const void*, const void*)) {\n\tunsigned char* m = (unsigned char*)base;\n\n#define QSRT_LESS(x, y) (compare(m + (x) * size, m + (y) * size) < 0)\n#define QSRT_SWAP(i, j) SortInternal_Swap(m + (i) * size, m + (j) * size, size)\n\tQSORT(nitems, QSRT_LESS, QSRT_SWAP);\n#undef QSRT_LESS\n#undef QSRT_SWAP\n}","#include \"draw2d.h\"\n\n#include \"../platform/memory.h\"\n#include \"../platform/math.h\"\n#include \"../framework/mat4.h\"\n#include \"../platform/graphics.h\"\n#include \"../debt/stb_image.h\"\n#include \"vector.h\"\n\n#define DRAW2D_MAXVERTS 10000\n#define DRAW2D_MAXINDICES 5000\n#define DRAW2D_MAX_IMAGES 5\n\nnamespace Draw2D {\n    namespace Internal {\n        struct Font {\n            char* path;\n        };\n\n        struct Image {\n            u32 id; // Graphics System Texture ID\n            u32 width;\n            u32 height;\n        };\n\n        struct Vertex { // 36\n            vec2 position;\n            vec2 uv;\n            vec4 color;\n            u16 texture;\n            u16 padding;\n        };\n\n        struct Buffer {\n            u32 vboId;\n            u32 iboId;\n            u32 imgVao;\n            u32 clrVao;\n\n            Buffer* next;\n        };\n\n        struct State {\n            Vector<vec4> clipStack;\n            vec4 activeClip;\n\n            Vector<Font> loadedFonts;\n            Vector<Image> loadedImages;\n\n            u32 screenWidth;\n            u32 screenHeight;\n\n            // Flushable\n            Vertex* vertices;\n            u32   numVertices;\n\n            u16*  indices;\n            u32   numIndices;\n            \n            u32 boundImages[DRAW2D_MAX_IMAGES];\n            u32 imgUniformSlots[DRAW2D_MAX_IMAGES];\n            u32 numBoundImages;\n\n            Buffer* freeBuffers;\n            Buffer* usedBuffers;\n\n            u32 imageShader;\n            u32 imageShaderScreenSizeUniform;\n            u32 shaderToDraw;\n        };\n\n        State* gState;\n\n        inline vec2 MakeVertex(const vec2& position, const vec2& rotationPivot, float cosTheta, float sinTheta, const vec2& scale) {\n            vec2 vertex = (position - rotationPivot) * scale;\n\n            float x = (vertex.x) * cosTheta  - (vertex.y) * sinTheta;\n            float y = (vertex.x) * sinTheta  + (vertex.y) * cosTheta;\n\n            return (vec2(x, y)) ;\n        }\n\n        inline vec4 UpdateClipStack() {\n            u32 globalClipLeft = 0;\n            u32 globalClipRight = 0;\n            u32 globalClipTop = 0;\n            u32 globalClipBottom = 0;\n\n            if (gState->clipStack.Count() >= 1) {\n                vec4 clipRect = gState->clipStack[0];\n\n                globalClipLeft = clipRect.x;\n                globalClipTop = clipRect.y;\n                globalClipRight = globalClipLeft + clipRect.z;\n                globalClipBottom = globalClipTop + clipRect.w;\n            }\n\n            for (u32 i = 1, size = gState->clipStack.Count(); i < size; ++i) {\n                vec4 clipRect = gState->clipStack[i];\n\n                u32 clipLeft = clipRect.x;\n                u32 clipTop = clipRect.y;\n                u32 clipRight = globalClipLeft + clipRect.z;\n                u32 clipBottom = globalClipTop + clipRect.w;\n\n                if (clipLeft > globalClipLeft) {\n                    globalClipLeft = clipLeft;\n                }\n                if (clipTop > globalClipTop) {\n                    globalClipTop = clipTop;\n                }\n                if (clipRight < globalClipRight) {\n                    globalClipRight = clipRight;\n                }\n                if (clipBottom < globalClipBottom) {\n                    globalClipBottom = clipBottom;\n                }\n            }\n            \n            vec4 clip(globalClipLeft, globalClipTop, globalClipRight - globalClipLeft, globalClipBottom - globalClipTop);\n            gState->activeClip = clip;\n            return clip;\n        }\n\n        void FlushAllDrawCommands() {\n            // Early out if there is nothing to flush\n            if (gState->numIndices == 0) {\n                return;\n            }\n            PlatformAssert(gState->numVertices != 0, __LOCATION__);\n            if (gState->shaderToDraw == 0) {\n                // No shader is bound, we shouldn't really get here....\n                // Try to recover gracefully, but break in debug\n                gState->numIndices = 0;\n                gState->numVertices = 0;\n                PlatformAssert(false, __LOCATION__);\n                return;\n            }\n\n            // Grab an iter from the free list\n            Buffer* iter = gState->freeBuffers;\n            // If free list was empty, make a few.\n            if (iter == 0) {\n                u32 numBuffers = 8;\n                Buffer* buffers = (Buffer*)MemAlloc(numBuffers * sizeof(Buffer));\n                MemSet(buffers, 0, sizeof(Buffer) * numBuffers);\n\n                iter = buffers;\n                for (u32 i = 0; i < numBuffers; ++i) {\n                    iter->vboId = GfxCreateBuffer();\n                    iter->iboId = GfxCreateBuffer();\n                    iter->imgVao = GfxCreateVertexLayout(gState->imageShader);\n                    // TODO: create color VAO\n\n                    iter->next = gState->freeBuffers;\n                    gState->freeBuffers = iter;\n                    iter += 1;\n                }\n\n                // Make sure iter is valid\n                iter = gState->freeBuffers;\n            }\n            // Now that the iter is valid, advance the free list\n            gState->freeBuffers = gState->freeBuffers->next;\n\n            // Register iter as having been used this run\n            iter->next = gState->usedBuffers;\n            gState->usedBuffers = iter;\n\n            // Update Vertex and index data\n            GfxFillArrayBuffer(iter->vboId, gState->vertices, sizeof(Vertex) * gState->numVertices, false);\n            GfxFillIndexBuffer(iter->iboId, gState->indices, gState->numIndices * sizeof(u16), GfxIndexTypeShort, false);\n\n            float screenSize[2] = { (float)gState->screenWidth, (float)gState->screenHeight };\n            PlatformAssert(gState->numBoundImages < 10, __LOCATION__); // Can only do single digits\n\n            // Fill out array objects for buffer, depending on what is being drawn\n            if (gState->shaderToDraw == gState->imageShader) {\n                // TODO: Not by name plz, use pending api by id\n                GfxAddBufferToLayout(iter->imgVao, \"position\", iter->vboId, 2, sizeof(Vertex), GfxBufferTypeFloat32, 0);\n                GfxAddBufferToLayout(iter->imgVao, \"texCoord\", iter->vboId, 2, sizeof(Vertex), GfxBufferTypeFloat32, sizeof(float) * 2);\n                GfxAddBufferToLayout(iter->imgVao, \"blendColor\", iter->vboId, 4, sizeof(Vertex), GfxBufferTypeFloat32, sizeof(float) * (2 + 2));\n                GfxAddBufferToLayout(iter->imgVao, \"texIndex\", iter->vboId, 1, sizeof(Vertex), GfxBufferTypeInt16, sizeof(float) * (2 + 2 + 4));\n                GfxAddIndexBufferToLayout(iter->imgVao, iter->iboId);\n\n                GfxSetUniform(gState->shaderToDraw, gState->imageShaderScreenSizeUniform, screenSize, GfxUniformTypeFloat2, 1);\n                for (u32 i = 0; i < gState->numBoundImages; ++i) {\n                    GfxSetUniformTexture(gState->shaderToDraw, gState->imgUniformSlots[i], gState->boundImages[i]);\n                }\n            }\n            // TODO: Create color vao\n            else {\n                PlatformAssert(false, __LOCATION__);\n            }\n\n            // Bind textures\n            \n            //textures\n\n            // Submit the finalized draw call\n            GfxDraw(0, 0, iter->imgVao, GfxDrawModeTriangles, 0, gState->numIndices, 1);\n\n            // Reset the CPU side buffers now that the data lives on the GPU\n            gState->numVertices = 0;\n            gState->numIndices = 0;\n        }\n    }\n\n    void Initialize() {\n        Internal::gState = (Internal::State*)MemAlloc(sizeof(Internal::State));\n        MemSet(Internal::gState, 0, sizeof(Internal::State));\n\n        Internal::gState->vertices = (Internal::Vertex*)MemAlloc(sizeof(Internal::Vertex) * DRAW2D_MAXVERTS);\n        Internal::gState->indices = (u16*)MemAlloc(sizeof(u16) * DRAW2D_MAXINDICES);\n        Internal::gState->numVertices = 0;\n        Internal::gState->numIndices = 0;\n\n        new (&Internal::gState->clipStack) Vector<vec4>(); // Just allocated, do what the constructor does\n        new (&Internal::gState->loadedFonts) Vector<Internal::Font>(); // Just allocated, do what the constructor does\n        new (&Internal::gState->loadedImages) Vector<Internal::Image>(); // Just allocated, do what the constructor does\n\n        const char* vShader =\n            \"#version 300 es\\n\"\n            \"precision highp float;\\n\"\n            \"precision highp int;\\n\"\n            \"in vec2 position;\\n\"\n            \"in vec2 texCoord;\\n\"\n            \"in vec4 blendColor;\\n\"\n            \"in int texIndex;\\n\"\n            \"uniform vec2 screenSize;\\n\"\n            \"out vec2 vTexCoord;\\n\"\n            \"out vec4 vBlendColor;\\n\"\n            \"flat out int vTexIndex;\\n\"\n            \"void main() {\\n\"\n            \"    vec2 invertedPosition = position;\\n\"\n            \"    invertedPosition.y = screenSize.y - invertedPosition.y;\\n\"\n            \"    vec2 ndc = invertedPosition / screenSize;\\n\"\n            \"    ndc = ndc * 2.0 - 1.0;\\n\"\n            \"    gl_Position = vec4(ndc, 0.0, 1.0);\\n\"\n            \"    vTexCoord = texCoord;\\n\"\n            \"    vBlendColor = blendColor;\\n\"\n            \"    vTexIndex = texIndex;\\n\"\n            \"}\\n\";\n\n        const char* fShader =\n            \"#version 300 es\\n\"\n            \"precision highp float;\\n\"\n            \"precision highp int;\\n\"\n            \"flat in int vTexIndex;\\n\"\n            \"in vec2 vTexCoord;\\n\"\n            \"in vec4 vBlendColor;\\n\"\n            \"uniform sampler2D tex0;\\n\"\n            \"uniform sampler2D tex1;\\n\"\n            \"uniform sampler2D tex2;\\n\"\n            \"uniform sampler2D tex3;\\n\"\n            \"uniform sampler2D tex4;\\n\"\n            \"uniform sampler2D tex5;\\n\"\n            \"uniform sampler2D tex6;\\n\"\n            \"uniform sampler2D tex7;\\n\"\n            \"out vec4 outputColor;\\n\"\n            \"void main() {\\n\"\n            \"   vec4 texColor = vec4(0, 0, 0, 1);\\n\"\n            \"   if (vTexIndex == 0) {texColor = texture(tex0, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 1) {texColor = texture(tex1, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 2) {texColor = texture(tex2, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 3) {texColor = texture(tex3, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 4) {texColor = texture(tex4, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 5) {texColor = texture(tex5, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 6) {texColor = texture(tex6, vTexCoord);}\\n\"\n            \"   if (vTexIndex == 7) {texColor = texture(tex7, vTexCoord);}\\n\"\n            \"   outputColor = texColor * vBlendColor;\\n\"\n            \"}\\n\";\n\n#if MEM_PLATFORM_WASM\n        // TODO: Modify shader for web if needed. Keep 3.3 core if not.\n#endif\n        Internal::gState->imageShader = GfxCreateShader(vShader, fShader);\n        Internal::gState->imageShaderScreenSizeUniform = GfxGetUniformSlot(Internal::gState->imageShader, \"screenSize\");\n\n        PlatformAssert(DRAW2D_MAX_IMAGES < 10, __LOCATION__);\n        char uniformName[] = { 't', 'e', 'x', '0', '\\0'};\n        for (u32 i = 0; i < DRAW2D_MAX_IMAGES; ++i) {\n            uniformName[3] = '0' + i;\n            Internal::gState->imgUniformSlots[i] = GfxGetUniformSlot(Internal::gState->imageShader, uniformName);\n        }\n    }\n\n    void Shutdown() {\n        GfxDestroyShader(Internal::gState->imageShader);\n\n        // TODO: Cleanup fonts\n\n        // Cleanup textures\n        for (u32 i = 0, size = Internal::gState->loadedImages.Count(); i < size; ++i) {\n            PlatformAssert(Internal::gState->loadedImages[i].id == 0, __LOCATION__);\n            if (Internal::gState->loadedImages[i].id != 0) {\n                GfxDestroyTexture(Internal::gState->loadedImages[i].id);\n            }\n        }\n        Internal::gState->loadedImages.~Vector();\n        Internal::gState->clipStack.~Vector();\n        Internal::gState->loadedFonts.~Vector();\n\n        MemRelease(Internal::gState->vertices);\n        MemRelease(Internal::gState->indices);\n        MemRelease(Internal::gState);\n    }\n\n    u32 LoadImage(void* memory, u32 bytes, Interpolation interp) {\n        i32 width = 0;\n        i32 height = 0;\n        i32 components = 0;\n\n        unsigned char* img_data = stbi_load_from_memory((unsigned char*)memory, bytes, &width, &height, &components, 0);\n        unsigned int format = (components == 4)? GfxTextureFormatRGBA8  : GfxTextureFormatRGB8;\n        u32 imageId = GfxCreateTexture(img_data, width, height, format, format, true);\n        MemRelease(img_data);\n\n        Vector<Draw2D::Internal::Image>& loadedImages = Internal::gState->loadedImages;\n        for (u32 i = 0, size = loadedImages.Count(); i < size; ++i) {\n            if (loadedImages[i].id == 0) {\n                loadedImages[i].id = imageId;\n                loadedImages[i].width = width;\n                loadedImages[i].height = height;\n\n                return i;\n            }\n        }\n\n        Internal::Image result = {imageId, (u32)width, (u32)height};\n        Internal::gState->loadedImages.PushBack(result);\n        return Internal::gState->loadedImages.Count() - 1;\n    }\n\n    void DestroyImage(u32 imageId) {\n        u32 textureId = Internal::gState->loadedImages[imageId].id;\n        GfxDestroyTexture(textureId);\n        Internal::gState->loadedImages[imageId].id = 0;\n    }\n\n    void DrawImage(u32 image, f32 screenX, f32 screenY, f32 scaleX, f32 scaleY, f32 sourceX, f32 sourceY, f32 width, f32 height, f32 pivotX, f32 pivotY, f32 rotationRadians, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        if (scaleX * scaleY == 0.0f) {\n            return;\n        }\n        // Flush if no more images can be bound\n        u32 textureId = Internal::gState->loadedImages[image].id;\n        PlatformAssert(textureId != 0, __LOCATION__);\n        float textureWidth = (float)Internal::gState->loadedImages[image].width;\n        float textureHeight = (float)Internal::gState->loadedImages[image].height;\n\n        bool found = false;\n        u32 imageIndex = 0;\n        for (u32 i = 0, size = Internal::gState->numBoundImages; i < size; ++i) {\n            if (Internal::gState->boundImages[i] == textureId) {\n                imageIndex = i;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (Internal::gState->numBoundImages >= DRAW2D_MAX_IMAGES) {\n                Internal::FlushAllDrawCommands(); // Will reset numBoundImages to 0\n            }\n            imageIndex = Internal::gState->numBoundImages++;\n        }\n        Internal::gState->boundImages[imageIndex] = textureId;\n\n        // Flush if at vertex limit\n        if (Internal::gState->numVertices + 4 >= DRAW2D_MAXVERTS) {\n            Internal::FlushAllDrawCommands(); // Will reset numRenderCommands to 0\n        }\n\n        // Flush if at index limit\n        if (Internal::gState->numIndices + 6 >= DRAW2D_MAXINDICES) {\n            Internal::FlushAllDrawCommands(); // Will reset numRenderCommands to 0\n        }\n\n        // Flush if the image shader isn't bound\n        if (Internal::gState->shaderToDraw != Internal::gState->imageShader) {\n            if (Internal::gState->shaderToDraw != 0) {\n                Internal::FlushAllDrawCommands();\n            }\n        }\n        // Next flush will happen with the image shader\n        Internal::gState->shaderToDraw = Internal::gState->imageShader;\n\n        // TODO: Apply clipping\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 4;\n\n        vec2 pivot(pivotX, pivotY);\n        float cosTheta = MathCos(rotationRadians);\n        float sinTheta = MathSin(rotationRadians);\n        vec2 screenPos(screenX, screenY);\n        vec2 scale((scaleX), (scaleY));\n\n        verts[0].position = Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos;\n        verts[0].uv = vec2(sourceX / textureWidth, sourceY / textureHeight);\n        verts[0].texture = imageIndex;\n        verts[0].color = vec4(blendR, blendG, blendB, blendA);\n\n        verts[1].position = Internal::MakeVertex(vec2(width, 0), pivot, cosTheta, sinTheta, scale) + screenPos;\n        verts[1].uv = vec2((sourceX + width) / textureWidth, sourceY / textureHeight);\n        verts[1].texture = imageIndex;\n        verts[1].color = vec4(blendR, blendG, blendB, blendA);\n\n        verts[2].position = Internal::MakeVertex(vec2(width, height), pivot , cosTheta, sinTheta, scale) + screenPos;\n        verts[2].uv = vec2((sourceX + width) / textureWidth, (sourceY + height) / textureHeight);\n        verts[2].texture = imageIndex;\n        verts[2].color = vec4(blendR, blendG, blendB, blendA);\n\n        verts[3].position = Internal::MakeVertex(vec2(0, height), pivot , cosTheta, sinTheta, scale)  + screenPos;\n        verts[3].uv = vec2(sourceX / textureWidth, (sourceY + height) / textureHeight);\n        verts[3].texture = imageIndex;\n        verts[3].color = vec4(blendR, blendG, blendB, blendA);\n\n        \n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 6;\n        bool ccw = true;\n        if ((scaleX < 0 && scaleY > 0) || (scaleY < 0 && scaleX > 0)) {\n            ccw = false;\n        }\n\n        if (ccw) {\n            indices[0] = firstVertex + 1;\n            indices[1] = firstVertex + 3;\n            indices[2] = firstVertex + 2;\n\n            indices[3] = firstVertex + 1;\n            indices[4] = firstVertex + 0;\n            indices[5] = firstVertex + 3;\n        }\n        else { \n            indices[0] = firstVertex + 1;\n            indices[1] = firstVertex + 2;\n            indices[2] = firstVertex + 3;\n\n            indices[3] = firstVertex + 1;\n            indices[4] = firstVertex + 3;\n            indices[5] = firstVertex + 0;\n        }\n    }\n\n    void Begin(u32 w, u32 h) {\n        GfxDisableDepthTest();\n        Internal::gState->screenWidth = w;\n        Internal::gState->screenHeight = h;\n        // TODO\n    }\n\n    void End() {\n        PlatformAssert(Internal::gState->clipStack.Count() == 0, __LOCATION__);\n        while (Internal::gState->clipStack.Count() != 0) {\n            PopClip();\n        }\n        Internal::FlushAllDrawCommands();\n        // TODO\n    }\n\n    void EnableAlphaBlending() {\n        Internal::FlushAllDrawCommands();\n        u32 src = GfxBlendFuncSrcAlpha;\n        u32 dst = GfxBlendFuncOneMinusSrcAlpha;\n        u32 blend = GfxBlendEquationAdd;\n        GfxSetBlendState(true, 0, dst, dst, blend, blend, src, src);\n    }\n\n    void DisableAlphaBlending() {\n        Internal::FlushAllDrawCommands();\n        u32 src = GfxBlendFuncSrcAlpha;\n        u32 dst = GfxBlendFuncOneMinusSrcAlpha;\n        u32 blend = GfxBlendEquationAdd;\n        GfxSetBlendState(false, 0, dst, dst, blend, blend, src, src);\n    }\n\n    void PushClip(f32 x, f32 y, f32 w, f32 h) {\n        Internal::FlushAllDrawCommands();\n\n        Internal::gState->clipStack.PushBack(vec4(x, y, w, h));\n        vec4 clip = Internal::UpdateClipStack();\n        // Modify clip to be in window space\n        clip.y = Internal::gState->screenHeight - clip.y;\n        clip.y -= clip.w; // And be bottom left coordinates\n\n        GfxSetClipState(true, clip.x, clip.y, clip.z, clip.w);\n    }\n\n    void PopClip() {\n        Internal::FlushAllDrawCommands();\n\n        Internal::gState->clipStack.PopBack();\n        Internal::UpdateClipStack();\n        if (Internal::gState->clipStack.Count() == 0) {\n            GfxSetClipState(false, 0, 0, 128, 128);\n        }\n    }\n\n    u32 LoadFont(void* memory, u32 bytes);\n    void DestroyFont(u32 font);\n}","#ifndef _H_PLATFORMASSERT_\n#define _H_PLATFORMASSERT_\n\n#include \"memory.h\"\n\n#if _DEBUG\ninline int PlatformAssert(bool cond, const char* msg) { // Always returns 0\n#if MEM_PLATFORM_WASM\n\tif (!cond) {\n\t\t\tPrintDebugString(msg);\n            __builtin_trap();\n\t\t}\n#else\n\tif (!cond) {\n\t\tunsigned char* ptr = (unsigned char*)0;\n\t\t*ptr = 0;\n\t}\n#endif\n\treturn 0;\n}\n\n#else\n#define PlatformAssert(x, m)\n#endif\n\n#endif // !_H_ASSERT_\n","#ifndef _H_GRAPHICS_\n#define _H_GRAPHICS_\n\ntypedef unsigned int u32;\ntypedef float f32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(f32) == 4, \"f32 should be a 4 byte type\");\nstatic_assert (sizeof(void*) >= 4, \"pointer should be >= 4 byte type\");\n\n#define GfxBufferTypeFloat32            0\n#define GfxBufferTypeInt16              3\n#define GfxBufferTypeInt32              5\n\n#define GfxIndexTypeByte                1\n#define GfxIndexTypeShort               2\n#define GfxIndexTypeInt                 4\n\n#define GfxTextureFormatRGB8            0\n#define GfxTextureFormatRGBA8           1\n#define GfxTextureFormatR32F            2\n#define GfxTextureFormatRGB32F          3\n#define GfxTextureFormatDepth           4\n// GfxTextureFormatDepth is only a target format, not a source format\n\n#define GfxFilterNearest                0\n#define GfxFilterLinear                 1\n#define GfxFilterNone                   2\n\n#define GfxWrapRepeat                   0\n#define GfxWrapClamp                    1\n\n#define GfxUniformTypeInt1              0\n#define GfxUniformTypeInt2              1\n#define GfxUniformTypeInt3              2\n#define GfxUniformTypeInt4              3\n#define GfxUniformTypeFloat1            4\n#define GfxUniformTypeFloat2            5\n#define GfxUniformTypeFloat3            6\n#define GfxUniformTypeFloat4            7\n#define GfxUniformTypeFloat9            8\n#define GfxUniformTypeFloat16           9\n#define GfxUniformTypeTexture           10\n\n#define GfxDepthFuncAlways              0\n#define GfxDepthFuncNever               1\n#define GfxDepthFuncEqual               2\n#define GfxDepthFuncLEqual              3\n#define GfxDepthFuncGreater             4\n#define GfxDepthFuncGEqual              5\n#define GfxDepthFuncNotEqual            6\n#define GfxDepthFuncLess                7\n\n#define GfxCullFaceOff                  0\n#define GfxCullFaceBack                 1\n#define GfxCullFaceFront                2\n#define GfxCullFaceFrontAndBack         3\n\n#define GfxFaceWindCounterClockwise     0\n#define GfxFaceWindClockwise            1\n\n#define GfxBlendFuncZero                1\n#define GfxBlendFuncOne                 2\n#define GfxBlendFuncSrcColor            3\n#define GfxBlendFuncOneMinusSrcColor    4\n#define GfxBlendFuncDstColor            5\n#define GfxBlendFuncOneMinusDstColor    6\n#define GfxBlendFuncSrcAlpha            7\n#define GfxBlendFuncOneMinusSrcAlpha    8\n#define GfxBlendFuncDstAlpha            9\n#define GfxBlendFuncOneMinusDstAlpha    10\n#define GfxBlendFuncConstColor          11\n#define GfxBlendFuncOneMinusConstColor  12\n#define GfxBlendFuncConstAlpha          13\n#define GfxBlendFuncOneMinusconstAlpha  14\n#define GfxBlendFuncSrcAlphaSaturate    15\n\n#define GfxBlendEquationAdd             0\n#define GfxBlendEquationSubtract        1\n#define GfxBlendEquationReverseSubtract 2\n#define GfxBlendEquationMin             3\n#define GfxBlendEquationMax             4\n\n#define GfxDrawModePoints               0\n#define GfxDrawModeLines                1\n#define GfxDrawModeLineStrip            2\n#define GfxDrawModeTriangles            3\n#define GfxDrawModeTriangleStrip        4\n#define GfxDrawModeTriangleFan          5\n\nextern \"C\" u32 GfxCreateBuffer();\nextern \"C\" void GfxDestroyBuffer(u32 bufferId);\n\nextern \"C\" void GfxFillArrayBuffer(u32 bufferId, void* input, u32 bytes, bool _static);\nextern \"C\" void GfxFillIndexBuffer(u32 bufferId, void* input, u32 bytes, u32 indexType, bool _static);\n\ninline u32 GfxCreateArrayBuffer(void* input, u32 bytes, bool _static) {\n    u32 buffer = GfxCreateBuffer();\n    GfxFillArrayBuffer(buffer, input, bytes, _static);\n    return buffer;\n}\n\ninline u32 GfxCreateIndexBuffer(void* input, u32 bytes, u32 indexType, bool _static = true) {\n    u32 buffer = GfxCreateBuffer();\n    GfxFillIndexBuffer(buffer, input, bytes, indexType, _static);\n    return buffer;\n}\n\nextern \"C\" u32 GfxCreateShader(const char* vsource, const char* fsource);\nextern \"C\" u32 GfxGetUniformSlot(u32 shaderId, const char* name);\nextern \"C\" void GfxDestroyShader(u32 shaderId);\n\nextern \"C\" u32 GfxCreateShaderVertexLayout(u32 shaderId);\n#define GfxCreateVertexLayout GfxCreateShaderVertexLayout\nextern \"C\" void GfxAddBufferToLayout(u32 layoutId, const char* name, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\n\n\n\n// TODO: Refactor GfxAddBufferToLayout to take a u32 for buffer name. It should take an attribute slot\n// TODO: Create GfxGetAttributeSlot\n// TODO: Create GfxAddBufferToLayoutNamed, which maintains the current GfxAddBufferToLayout signature (and can be inlined)\nextern \"C\" void GfxDestroyShaderVertexLayout(u32 layoutId);\n\ninline void GfxAddIndexBufferToLayout(u32 layoutId, u32 bufferId) {\n    GfxAddBufferToLayout(layoutId, 0, bufferId, 1, 0, GfxBufferTypeInt16, 0);\n}\n\nextern \"C\" u32 GfxCreateTexture(void* data, u32 width, u32 height, u32 sourceFormat, u32 targetFormat, bool genMips);\ninline u32 GfxCreateDepthTexture(u32 width, u32 height) {\n    return GfxCreateTexture(0, width, height, GfxTextureFormatDepth, GfxTextureFormatDepth, false);\n}\nextern \"C\" void GfxSetTextureSampler(u32 textureId, u32 wrapS, u32 wrapT, u32 minFilter, u32 mipFilter, u32 magFilter);\nextern \"C\" void GfxDestroyTexture(u32 textureId);\n\nextern \"C\" void GfxSetUniform(u32 shaderId, u32 uniformSlot, void* data, u32 uniformType, u32 count); \ninline void GfxSetUniformTexture(u32 shaderId, u32 uniformSlot, u32 textureId) {\n    GfxSetUniform(shaderId, uniformSlot, (void*)textureId, 10, 1);\n}\n\nextern \"C\" void GfxClearAll(u32 colorTargetId, u32 depthTargetId, float r, float g, float b, float d);\nextern \"C\" void GfxClearColor(u32 colorTargetTextureId, u32 depthTargetTextureId, float r, float g, float b);\nextern \"C\" void GfxClearDepth(u32 colorTargetTextureId, u32 depthTargetTextureId, float depth);\nextern \"C\" void GfxDraw(u32 colorTargetTextureId, u32 depthTargetTextureId, u32 vertexLayoutId, u32 drawMode, u32 startIndex, u32 indexCount, u32 instanceCount);\n\nextern \"C\" void GfxSetBlendState(bool blend, f32* optBlendColor, u32 blendDstRgb, u32 blendDstAlpha, u32 blendEquationRgb, u32 blendEquationAlpha, u32 blendSrcRgb, u32 blendSrcAlpha);\nextern \"C\" void GfxSetCullState(u32 cullFace, u32 faceWind);\nextern \"C\" void GfxSetDepthState(bool enable, u32 depthFunc, f32* depthRange);\ninline void GfxEnableDepthTest() {\n    GfxSetDepthState(true, GfxDepthFuncLess, 0);\n}\ninline void GfxDisableDepthTest() {\n    GfxSetDepthState(false, GfxDepthFuncLess, 0);\n}\n\n// OpenGL style, bottom left / width and height\nextern \"C\" void GfxSetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\n#define GfxSetClipState GfxSetScissorState\nextern \"C\" void GfxSetWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void GfxSetViewport(u32 x, u32 y, u32 w, u32 h);\n\n// Initialize and shutdown functions exist, but you don't call them\n// the platform does. The void* that's being passed in is platform\n// specific, it contains whatever we need for OpenGL rendering \nextern \"C\" int GfxInitialize(void* in, void* out);\nextern \"C\" void GfxShutdown(void* userData);\nextern \"C\" void GfxFinish(); // This just calls glFinish, used to wait for vsynch on windows\n\n#endif","#ifndef _H_VECTOR_\n#define _H_VECTOR_\n\n#include \"../platform/memory.h\"\n#include \"../platform/assert.h\"\n\ntemplate<typename T>\nclass Vector {\n    T* mData;\n    u32 mCount;\n    u32 mCapacity;\npublic:\n    inline Vector() {\n        mData = 0;\n        mCount = 0;\n        mCapacity = 0;\n    }\n\n    inline Vector(u32 capacity) {\n        mData = (T*)MemAlloc(sizeof(T) * capacity);\n        mCount = 0;\n        mCapacity = capacity;\n    }\n\n    void* operator new(platform_t bytes, void* p) { // TODO: wasm might need some other arguments...\n        Vector* v = (Vector*)p;\n        PlatformAssert(v->mData == 0, __LOCATION__);\n        v->mData = 0;\n        v->mCount = 0;\n        v->mCapacity = 0;\n\n        return p;\n    }\n\n    inline Vector(T* array, u32 count) {\n        mData = (T*)MemAlloc(sizeof(T) * count);\n        MemCopy(mData, array, count * sizeof(T));\n        mCount = count;\n        mCapacity = count;\n    }\n\n    inline Vector(const Vector<T>& other) {\n        mCapacity = other.mCapacity;\n        mCount = other.mCount;\n        mData = (T*)MemAlloc(sizeof(T) * mCapacity);\n        MemCopy(mData, other.mData, mCapacity * sizeof(T));\n    }\n\n    inline Vector<T>& operator=(const Vector<T>& other) {\n        PlatformAssert(this != &other, __LOCATION__);\n        if (this != &other) {\n            if (mData != 0) {\n                MemRelease(mData);\n            }\n            mCapacity = other.mCapacity;\n            mCount = other.mCount;\n            mData = (T*)MemAlloc(sizeof(T) * mCapacity);\n            MemCopy(mData, other.mData, mCapacity * sizeof(T));\n        }\n\n        return *this;\n    }\n\n    inline ~Vector() {\n        if (mData != 0) {\n            MemRelease(mData);\n        }\n        mData = 0;\n        mCount = 0;\n        mCapacity = 0;\n    }\npublic:\n    T& operator[](u32 i) { \n        PlatformAssert(i < mCount, __LOCATION__);\n        PlatformAssert(mData != 0, __LOCATION__);\n        return mData[i]; \n    }\n\n    const T& operator[](u32 i) const { \n        PlatformAssert(i < mCount, __LOCATION__);\n        PlatformAssert(mData != 0, __LOCATION__);\n        return mData[i];\n    }\n\n    inline void Reserve(u32 count) {\n        if (count < 1) {\n            count = 1;\n        }\n\n        if (count > mCapacity) {\n            T* newData = (T*)MemAlloc(sizeof(T) * count);\n            if (mCapacity > 0) {\n                MemCopy(newData, mData, mCapacity * sizeof(T));\n            }\n            mCapacity = count;\n            if (mData != 0) {\n                MemRelease(mData);\n            }\n            mData = newData;\n        }\n    }\n\n    inline void Resize(u32 count) {\n        Reserve(count);\n        mCount = count;\n    }\n    \n    inline void PushBack(const T& val) {\n        if (mCapacity == 0) {\n            Reserve(2);\n        }\n        \n        if (mCapacity - mCount == 0) {\n            Reserve(mCapacity * 2);\n        }\n\n        MemCopy(&mData[mCount++], &val, sizeof(T));\n    }\n\n    inline void PopBack() {\n        if (mCount > 0) {\n            mCount -= 1;\n        }\n    }\n\n    inline void Append(const T* array, u32 size) {\n        Reserve(mCount + size);\n        MemCopy(&mData[mCount], array, sizeof(T) * size);\n        mCount += size;\n    }\n\n    inline const T* PeekHead() {\n        if (mCount != 0) {\n            return &mData[0];\n        }\n        return 0;\n    }\n\n    inline const T* PeekTail() {\n        if (mCount != 0) {\n            return &mData[mCount - 1];\n        }\n        return 0;\n    }\n\n    inline u32 Count() {\n        return mCount;\n    }\n\n    inline u32 Capacity() {\n        return mCapacity;\n    }\n};\n\n#endif","/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb\n                                  no warranty implied; use at your own risk\n\n   Do this:\n      #define STB_IMAGE_IMPLEMENTATION\n   before you include this file in *one* C or C++ file to create the implementation.\n\n   // i.e. it should look like this:\n   #include ...\n   #include ...\n   #include ...\n   #define STB_IMAGE_IMPLEMENTATION\n   #include \"stb_image.h\"\n\n   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.\n   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free\n\n\n   QUICK NOTES:\n      Primarily of interest to game developers and other people who can\n          avoid problematic images and only need the trivial interface\n\n      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)\n      PNG 1/2/4/8/16-bit-per-channel\n\n      TGA (not sure what subset, if a subset)\n      BMP non-1bpp, non-RLE\n      PSD (composited view only, no extra channels, 8/16 bit-per-channel)\n\n      GIF (*comp always reports as 4-channel)\n      HDR (radiance rgbE format)\n      PIC (Softimage PIC)\n      PNM (PPM and PGM binary only)\n\n      Animated GIF still needs a proper API, but here's one way to do it:\n          http://gist.github.com/urraka/685d9a6340b26b830d49\n\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\n      - decode from arbitrary I/O callbacks\n      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)\n\n   Full documentation under \"DOCUMENTATION\" below.\n\n\nLICENSE\n\n  See end of file for license information.\n\nRECENT REVISION HISTORY:\n\n      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes\n      2.26  (2020-07-13) many minor fixes\n      2.25  (2020-02-02) fix warnings\n      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically\n      2.23  (2019-08-11) fix clang static analysis warning\n      2.22  (2019-03-04) gif fixes, fix warnings\n      2.21  (2019-02-25) fix typo in comment\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\n      2.19  (2018-02-11) fix warning\n      2.18  (2018-01-30) fix warnings\n      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings\n      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes\n      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\n      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\n      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64\n                         RGB-format JPEG; remove white matting in PSD;\n                         allocate large structures on the stack;\n                         correct channel count for PNG & BMP\n      2.10  (2016-01-22) avoid warning introduced in 2.09\n      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED\n\n   See end of file for full revision history.\n\n\n ============================    Contributors    =========================\n\n Image formats                          Extensions, features\n    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)\n    Nicolas Schulz (hdr, psd)              Martin \"SpartanJ\" Golini (stbi_info)\n    Jonathan Dummer (tga)                  James \"moose2000\" Brown (iPhone PNG)\n    Jean-Marc Lienher (gif)                Ben \"Disch\" Wenger (io callbacks)\n    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)\n    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)\n    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)\n    github:urraka (animated gif)           Junggon Kim (PNM comments)\n    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)\n                                           socks-the-fox (16-bit PNG)\n                                           Jeremy Sawicki (handle all ImageNet JPGs)\n Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)\n    Fabian \"ryg\" Giesen                    Anael Seghezzi (is-16-bit query)\n    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)\n    John-Mark Allen\n    Carmelo J Fdez-Aguera\n\n Bug & warning fixes\n    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko\n    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski\n    Phil Jordan                                Dave Moore           Roy Eltham\n    Hayaki Saito            Nathan Reed        Won Chun\n    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community\n    Thomas Ruf              Ronny Chevalier                         github:rlyeh\n    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou\n    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk\n    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar\n    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex\n    Cass Everitt            Ryamond Barbiero                        github:grim210\n    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw\n    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus\n    Josh Tobin                                 Matthew Gregan       github:poppolopoppo\n    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji\n    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007\n                            Brad Weinberger    Matvey Cherevko      github:mosra\n    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]\n    Ryan C. Gordon          [reserved]                              [reserved]\n                     DO NOT ADD YOUR NAME HERE\n\n                     Jacko Dirks\n\n  To add your name to the credits, pick a random blank space in the middle and fill it.\n  80% of merge conflicts on stb PRs are due to people adding their name at the end\n  of the credits.\n*/\n\n#ifndef STBI_INCLUDE_STB_IMAGE_H\n#define STBI_INCLUDE_STB_IMAGE_H\n\n// DOCUMENTATION\n//\n// Limitations:\n//    - no 12-bit-per-channel JPEG\n//    - no JPEGs with arithmetic coding\n//    - GIF always returns *comp=4\n//\n// Basic usage (see HDR discussion below for HDR usage):\n//    int x,y,n;\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\n//    // ... process data if not NULL ...\n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\n//    // ... but 'n' will always be the number that it would have been if you said 0\n//    stbi_image_free(data)\n//\n// Standard parameters:\n//    int *x                 -- outputs image width in pixels\n//    int *y                 -- outputs image height in pixels\n//    int *channels_in_file  -- outputs # of image components in image file\n//    int desired_channels   -- if non-zero, # of image components requested in result\n//\n// The return value from an image loader is an 'unsigned char *' which points\n// to the pixel data, or NULL on an allocation failure or if the image is\n// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,\n// with each pixel consisting of N interleaved 8-bit components; the first\n// pixel pointed to is top-left-most in the image. There is no padding between\n// image scanlines or between pixels, regardless of format. The number of\n// components N is 'desired_channels' if desired_channels is non-zero, or\n// *channels_in_file otherwise. If desired_channels is non-zero,\n// *channels_in_file has the number of components that _would_ have been\n// output otherwise. E.g. if you set desired_channels to 4, you will always\n// get RGBA output, but you can check *channels_in_file to see if it's trivially\n// opaque because e.g. there were only 3 channels in the source image.\n//\n// An output image with N components has the following components interleaved\n// in this order in each pixel:\n//\n//     N=#comp     components\n//       1           grey\n//       2           grey, alpha\n//       3           red, green, blue\n//       4           red, green, blue, alpha\n//\n// If image loading fails for any reason, the return value will be NULL,\n// and *x, *y, *channels_in_file will be unchanged. The function\n// stbi_failure_reason() can be queried for an extremely brief, end-user\n// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS\n// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\n// more user-friendly ones.\n//\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\n//\n// To query the width, height and component count of an image without having to\n// decode the full file, you can use the stbi_info family of functions:\n//\n//   int x,y,n,ok;\n//   ok = stbi_info(filename, &x, &y, &n);\n//   // returns ok=1 and sets x, y, n if image is a supported format,\n//   // 0 otherwise.\n//\n// Note that stb_image pervasively uses ints in its public API for sizes,\n// including sizes of memory buffers. This is now part of the API and thus\n// hard to change without causing breakage. As a result, the various image\n// loaders all have certain limits on image size; these differ somewhat\n// by format but generally boil down to either just under 2GB or just under\n// 1GB. When the decoded image would be larger than this, stb_image decoding\n// will fail.\n//\n// Additionally, stb_image will reject image files that have any of their\n// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,\n// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,\n// the only way to have an image with such dimensions load correctly\n// is for it to have a rather extreme aspect ratio. Either way, the\n// assumption here is that such larger images are likely to be malformed\n// or malicious. If you do need to load an image with individual dimensions\n// larger than that, and it still fits in the overall size limit, you can\n// #define STBI_MAX_DIMENSIONS on your own to be something larger.\n//\n// ===========================================================================\n//\n// UNICODE:\n//\n//   If compiling for Windows and you wish to use Unicode filenames, compile\n//   with\n//       #define STBI_WINDOWS_UTF8\n//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert\n//   Windows wchar_t filenames to utf8.\n//\n// ===========================================================================\n//\n// Philosophy\n//\n// stb libraries are designed with the following priorities:\n//\n//    1. easy to use\n//    2. easy to maintain\n//    3. good performance\n//\n// Sometimes I let \"good performance\" creep up in priority over \"easy to maintain\",\n// and for best performance I may provide less-easy-to-use APIs that give higher\n// performance, in addition to the easy-to-use ones. Nevertheless, it's important\n// to keep in mind that from the standpoint of you, a client of this library,\n// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.\n//\n// Some secondary priorities arise directly from the first two, some of which\n// provide more explicit reasons why performance can't be emphasized.\n//\n//    - Portable (\"ease of use\")\n//    - Small source code footprint (\"easy to maintain\")\n//    - No dependencies (\"ease of use\")\n//\n// ===========================================================================\n//\n// I/O callbacks\n//\n// I/O callbacks allow you to read from arbitrary sources, like packaged\n// files or some other source. Data read from callbacks are processed\n// through a small internal buffer (currently 128 bytes) to try to reduce\n// overhead.\n//\n// The three functions you must define are \"read\" (reads some bytes of data),\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\n//\n// ===========================================================================\n//\n// SIMD support\n//\n// The JPEG decoder will try to automatically use SIMD kernels on x86 when\n// supported by the compiler. For ARM Neon support, you must explicitly\n// request it.\n//\n// (The old do-it-yourself SIMD API is no longer supported in the current\n// code.)\n//\n// On x86, SSE2 will automatically be used when available based on a run-time\n// test; if not, the generic C versions are used as a fall-back. On ARM targets,\n// the typical path is to have separate builds for NEON and non-NEON devices\n// (at least this is true for iOS and Android). Therefore, the NEON support is\n// toggled by a build flag: define STBI_NEON to get NEON loops.\n//\n// If for some reason you do not want to use any of SIMD code, or if\n// you have issues compiling it, you can disable it entirely by\n// defining STBI_NO_SIMD.\n//\n// ===========================================================================\n//\n// HDR image support   (disable by defining STBI_NO_HDR)\n//\n// stb_image supports loading HDR images in general, and currently the Radiance\n// .HDR file format specifically. You can still load any file through the existing\n// interface; if you attempt to load an HDR file, it will be automatically remapped\n// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\n// both of these constants can be reconfigured through this interface:\n//\n//     stbi_hdr_to_ldr_gamma(2.2f);\n//     stbi_hdr_to_ldr_scale(1.0f);\n//\n// (note, do not use _inverse_ constants; stbi_image will invert them\n// appropriately).\n//\n// Additionally, there is a new, parallel interface for loading files as\n// (linear) floats to preserve the full dynamic range:\n//\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\n//\n// If you load LDR images through this interface, those images will\n// be promoted to floating point values, run through the inverse of\n// constants corresponding to the above:\n//\n//     stbi_ldr_to_hdr_scale(1.0f);\n//     stbi_ldr_to_hdr_gamma(2.2f);\n//\n// Finally, given a filename (or an open file or memory block--see header\n// file for details) containing image data, you can query for the \"most\n// appropriate\" interface to use (that is, whether the image is HDR or\n// not), using:\n//\n//     stbi_is_hdr(char *filename);\n//\n// ===========================================================================\n//\n// iPhone PNG support:\n//\n// We optionally support converting iPhone-formatted PNGs (which store\n// premultiplied BGRA) back to RGB, even though they're internally encoded\n// differently. To enable this conversion, call\n// stbi_convert_iphone_png_to_rgb(1).\n//\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\n// says there's premultiplied data (currently only happens in iPhone images,\n// and only if iPhone convert-to-rgb processing is on).\n//\n// ===========================================================================\n//\n// ADDITIONAL CONFIGURATION\n//\n//  - You can suppress implementation of any of the decoders to reduce\n//    your code footprint by #defining one or more of the following\n//    symbols before creating the implementation.\n//\n//        STBI_NO_JPEG\n//        STBI_NO_PNG\n//        STBI_NO_BMP\n//        STBI_NO_PSD\n//        STBI_NO_TGA\n//        STBI_NO_GIF\n//        STBI_NO_HDR\n//        STBI_NO_PIC\n//        STBI_NO_PNM   (.ppm and .pgm)\n//\n//  - You can request *only* certain decoders and suppress all other ones\n//    (this will be more forward-compatible, as addition of new decoders\n//    doesn't require you to disable them explicitly):\n//\n//        STBI_ONLY_JPEG\n//        STBI_ONLY_PNG\n//        STBI_ONLY_BMP\n//        STBI_ONLY_PSD\n//        STBI_ONLY_TGA\n//        STBI_ONLY_GIF\n//        STBI_ONLY_HDR\n//        STBI_ONLY_PIC\n//        STBI_ONLY_PNM   (.ppm and .pgm)\n//\n//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still\n//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB\n//\n//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater\n//    than that size (in either width or height) without further processing.\n//    This is to let programs in the wild set an upper bound to prevent\n//    denial-of-service attacks on untrusted data, as one could generate a\n//    valid image of gigantic dimensions and force stb_image to allocate a\n//    huge block of memory and spend disproportionate time decoding it. By\n//    default this is set to (1 << 24), which is 16777216, but that's still\n//    very big.\n\n#define STBI_NO_STDIO\n#define STBI_NO_PSD\n#define STBI_NO_GIF\n#define STBI_NO_HDR\n#define STBI_NO_PIC\n#define STBI_NO_PNM\n\n#ifndef STBI_NO_STDIO\n#include <stdio.h>\n#endif // STBI_NO_STDIO\n\n#define STBI_VERSION 1\n\nenum\n{\n   STBI_default = 0, // only used for desired_channels\n\n   STBI_grey       = 1,\n   STBI_grey_alpha = 2,\n   STBI_rgb        = 3,\n   STBI_rgb_alpha  = 4\n};\n\n//#include <stdlib.h>\ntypedef unsigned char stbi_uc;\ntypedef unsigned short stbi_us;\n\n#ifndef STBIDEF\n#ifdef STB_IMAGE_STATIC\n#define STBIDEF static\n#else\n#define STBIDEF extern\n#endif\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PRIMARY API - works on images of any type\n//\n\n//\n// load image by filename, open file, or memory buffer\n//\n\ntypedef struct\n{\n   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read\n   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\n   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data\n} stbi_io_callbacks;\n\n////////////////////////////////////\n//\n// 8-bits-per-channel interface\n//\n\nSTBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n// for stbi_load_from_file, file pointer is left pointing immediately after image\n#endif\n\n#ifndef STBI_NO_GIF\nSTBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);\n#endif\n\n#ifdef STBI_WINDOWS_UTF8\nSTBIDEF int stbi_convert_wchar_to_utf8(char *buffer, unsigned int bufferlen, const wchar_t* input);\n#endif\n\n////////////////////////////////////\n//\n// 16-bits-per-channel interface\n//\n\nSTBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n#endif\n\n////////////////////////////////////\n//\n// float-per-channel interface\n//\n#ifndef STBI_NO_LINEAR\n   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\n   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);\n\n   #ifndef STBI_NO_STDIO\n   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\n   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n   #endif\n#endif\n\n#ifndef STBI_NO_HDR\n   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\n   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\n#endif // STBI_NO_HDR\n\n#ifndef STBI_NO_LINEAR\n   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\n   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\n#endif // STBI_NO_LINEAR\n\n// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR\nSTBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);\nSTBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename);\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f);\n#endif // STBI_NO_STDIO\n\n\n// get a VERY brief reason for failure\n// on most compilers (and ALL modern mainstream compilers) this is threadsafe\nSTBIDEF const char *stbi_failure_reason  (void);\n\n// free the loaded image -- this is just free()\nSTBIDEF void     stbi_image_free      (void *retval_from_stbi_load);\n\n// get image dimensions & components without fully decoding\nSTBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);\nSTBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);\nSTBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);\nSTBIDEF int      stbi_is_16_bit          (char const *filename);\nSTBIDEF int      stbi_is_16_bit_from_file(FILE *f);\n#endif\n\n\n\n// for image formats that explicitly notate that they have premultiplied alpha,\n// we just return the colors as stored in the file. set this flag to force\n// unpremultiplication. results are undefined if the unpremultiply overflow.\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\n\n// indicate whether we should process iphone images back to canonical format,\n// or just pass them through \"as-is\"\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\n\n// flip the image vertically, so the first pixel in the output array is the bottom left\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);\n\n// as above, but only applies to images loaded on the thread that calls the function\n// this function is only available if your compiler supports thread-local variables;\n// calling it will fail to link if your compiler doesn't\nSTBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);\n\n// ZLIB client - used by PNG, available for other purposes\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);\nSTBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\n\n//\n//\n////   end header file   /////////////////////////////////////////////////////\n#endif // STBI_INCLUDE_STB_IMAGE_H\n\n#ifdef STB_IMAGE_IMPLEMENTATION\n\n#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \\\n  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \\\n  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \\\n  || defined(STBI_ONLY_ZLIB)\n   #ifndef STBI_ONLY_JPEG\n   #define STBI_NO_JPEG\n   #endif\n   #ifndef STBI_ONLY_PNG\n   #define STBI_NO_PNG\n   #endif\n   #ifndef STBI_ONLY_BMP\n   #define STBI_NO_BMP\n   #endif\n   #ifndef STBI_ONLY_PSD\n   #define STBI_NO_PSD\n   #endif\n   #ifndef STBI_ONLY_TGA\n   #define STBI_NO_TGA\n   #endif\n   #ifndef STBI_ONLY_GIF\n   #define STBI_NO_GIF\n   #endif\n   #ifndef STBI_ONLY_HDR\n   #define STBI_NO_HDR\n   #endif\n   #ifndef STBI_ONLY_PIC\n   #define STBI_NO_PIC\n   #endif\n   #ifndef STBI_ONLY_PNM\n   #define STBI_NO_PNM\n   #endif\n#endif\n\n#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)\n#define STBI_NO_ZLIB\n#endif\n\n\n//#include <stdarg.h>\n//#include <stddef.h> // ptrdiff_t on osx\n//#include <stdlib.h>\n//#include <string.h>\n//#include <limits.h>\n\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)\n//#include <math.h>  // ldexp, MathPow\n#endif\n\n#ifndef STBI_NO_STDIO\n//#include <stdio.h>\n#endif\n\n#ifndef STBI_ASSERT\n//#include <assert.h>\n#define STBI_ASSERT(x) assert(x)\n#endif\n\n#define STBI_EXTERN\n\n\n#ifndef _MSC_VER\n   #ifdef __cplusplus\n   #define stbi_inline inline\n   #else\n   #define stbi_inline\n   #endif\n#else\n   #define stbi_inline __forceinline\n#endif\n\n#ifndef STBI_NO_THREAD_LOCALS\n   #if defined(__cplusplus) &&  __cplusplus >= 201103L\n      #define STBI_THREAD_LOCAL       thread_local\n   #elif defined(__GNUC__) && __GNUC__ < 5\n      #define STBI_THREAD_LOCAL       __thread\n   #elif defined(_MSC_VER)\n      #define STBI_THREAD_LOCAL       __declspec(thread)\n   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\n      #define STBI_THREAD_LOCAL       _Thread_local\n   #endif\n\n   #ifndef STBI_THREAD_LOCAL\n      #if defined(__GNUC__)\n        #define STBI_THREAD_LOCAL       __thread\n      #endif\n   #endif\n#endif\n\n\ntypedef u16 stbi__uint16;\ntypedef i16  stbi__int16;\ntypedef u32 stbi__uint32;\ntypedef i32  stbi__int32;\n\n// should produce compiler error if size is wrong\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];\n\n#ifdef _MSC_VER\n#define STBI_NOTUSED(v)  (void)(v)\n#else\n#define STBI_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifdef _MSC_VER\n#define STBI_HAS_LROTL\n#endif\n\n#ifdef STBI_HAS_LROTL\n   #define stbi_lrot(x,y)  _lrotl(x,y)\n#else\n   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))\n#endif\n\n#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))\n// ok\n#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)\n// ok\n#else\n#error \"Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED).\"\n#endif\n\n#ifndef STBI_MALLOC\n#define STBI_MALLOC(sz)           malloc(sz)\n#define STBI_REALLOC(p,newsz)     realloc(p,newsz)\n#define STBI_FREE(p)              free(p)\n#endif\n\n#ifndef STBI_REALLOC_SIZED\n#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)\n#endif\n\n// x86/x64 detection\n#if defined(__x86_64__) || defined(_M_X64)\n#define STBI__X64_TARGET\n#elif defined(__i386) || defined(_M_IX86)\n#define STBI__X86_TARGET\n#endif\n\n#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)\n// gcc doesn't support sse2 intrinsics unless you compile with -msse2,\n// which in turn means it gets to use SSE2 everywhere. This is unfortunate,\n// but previous attempts to provide the SSE2 functions with runtime\n// detection caused numerous issues. The way architecture extensions are\n// exposed in GCC/Clang is, sadly, not really suited for one-file libs.\n// New behavior: if compiled with -msse2, we use SSE2 without any\n// detection; if not, we don't use it at all.\n#define STBI_NO_SIMD\n#endif\n\n#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)\n// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET\n//\n// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the\n// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.\n// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not\n// simultaneously enabling \"-mstackrealign\".\n//\n// See https://github.com/nothings/stb/issues/81 for more information.\n//\n// So default to no SSE2 on 32-bit MinGW. If you've read this far and added\n// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.\n#define STBI_NO_SIMD\n#endif\n\n#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))\n#define STBI_SSE2\n#include <emmintrin.h>\n\n#ifdef _MSC_VER\n\n#if _MSC_VER >= 1400  // not VC6\n#include <intrin.h> // __cpuid\nstatic int stbi__cpuid3(void)\n{\n   int info[4];\n   __cpuid(info,1);\n   return info[3];\n}\n#else\nstatic int stbi__cpuid3(void)\n{\n   int res;\n   __asm {\n      mov  eax,1\n      cpuid\n      mov  res,edx\n   }\n   return res;\n}\n#endif\n\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\n\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\nstatic int stbi__sse2_available(void)\n{\n   int info3 = stbi__cpuid3();\n   return ((info3 >> 26) & 1) != 0;\n}\n#endif\n\n#else // assume GCC-style if not VC++\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\n\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\nstatic int stbi__sse2_available(void)\n{\n   // If we're even attempting to compile this on GCC/Clang, that means\n   // -msse2 is on, which means the compiler is allowed to use SSE2\n   // instructions at will, and so are we.\n   return 1;\n}\n#endif\n\n#endif\n#endif\n\n// ARM NEON\n#if defined(STBI_NO_SIMD) && defined(STBI_NEON)\n#undef STBI_NEON\n#endif\n\n#ifdef STBI_NEON\n#include <arm_neon.h>\n#ifdef _MSC_VER\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\n#else\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\n#endif\n#endif\n\n#ifndef STBI_SIMD_ALIGN\n#define STBI_SIMD_ALIGN(type, name) type name\n#endif\n\n#ifndef STBI_MAX_DIMENSIONS\n#define STBI_MAX_DIMENSIONS (1 << 24)\n#endif\n\n///////////////////////////////////////////////\n//\n//  stbi__context struct and start_xxx functions\n\n// stbi__context structure is our basic context used by all images, so it\n// contains all the IO context, plus some basic image information\ntypedef struct\n{\n   stbi__uint32 img_x, img_y;\n   int img_n, img_out_n;\n\n   stbi_io_callbacks io;\n   void *io_user_data;\n\n   int read_from_callbacks;\n   int buflen;\n   stbi_uc buffer_start[128];\n   int callback_already_read;\n\n   stbi_uc *img_buffer, *img_buffer_end;\n   stbi_uc *img_buffer_original, *img_buffer_original_end;\n} stbi__context;\n\n\nstatic void stbi__refill_buffer(stbi__context *s);\n\n// initialize a memory-decode context\nstatic void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)\n{\n   s->io.read = NULL;\n   s->read_from_callbacks = 0;\n   s->callback_already_read = 0;\n   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;\n   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;\n}\n\n// initialize a callback-based context\nstatic void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)\n{\n   s->io = *c;\n   s->io_user_data = user;\n   s->buflen = sizeof(s->buffer_start);\n   s->read_from_callbacks = 1;\n   s->callback_already_read = 0;\n   s->img_buffer = s->img_buffer_original = s->buffer_start;\n   stbi__refill_buffer(s);\n   s->img_buffer_original_end = s->img_buffer_end;\n}\n\n#ifndef STBI_NO_STDIO\n\nstatic int stbi__stdio_read(void *user, char *data, int size)\n{\n   return (int) fread(data,1,size,(FILE*) user);\n}\n\nstatic void stbi__stdio_skip(void *user, int n)\n{\n   int ch;\n   fseek((FILE*) user, n, SEEK_CUR);\n   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */\n   if (ch != EOF) {\n      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */\n   }\n}\n\nstatic int stbi__stdio_eof(void *user)\n{\n   return feof((FILE*) user) || ferror((FILE *) user);\n}\n\nstatic stbi_io_callbacks stbi__stdio_callbacks =\n{\n   stbi__stdio_read,\n   stbi__stdio_skip,\n   stbi__stdio_eof,\n};\n\nstatic void stbi__start_file(stbi__context *s, FILE *f)\n{\n   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);\n}\n\n//static void stop_file(stbi__context *s) { }\n\n#endif // !STBI_NO_STDIO\n\nstatic void stbi__rewind(stbi__context *s)\n{\n   // conceptually rewind SHOULD rewind to the beginning of the stream,\n   // but we just rewind to the beginning of the initial buffer, because\n   // we only use it after doing 'test', which only ever looks at at most 92 bytes\n   s->img_buffer = s->img_buffer_original;\n   s->img_buffer_end = s->img_buffer_original_end;\n}\n\nenum\n{\n   STBI_ORDER_RGB,\n   STBI_ORDER_BGR\n};\n\ntypedef struct\n{\n   int bits_per_channel;\n   int num_channels;\n   int channel_order;\n} stbi__result_info;\n\n#ifndef STBI_NO_JPEG\nstatic int      stbi__jpeg_test(stbi__context *s);\nstatic void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PNG\nstatic int      stbi__png_test(stbi__context *s);\nstatic void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__png_is16(stbi__context *s);\n#endif\n\n#ifndef STBI_NO_BMP\nstatic int      stbi__bmp_test(stbi__context *s);\nstatic void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_TGA\nstatic int      stbi__tga_test(stbi__context *s);\nstatic void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PSD\nstatic int      stbi__psd_test(stbi__context *s);\nstatic void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);\nstatic int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__psd_is16(stbi__context *s);\n#endif\n\n#ifndef STBI_NO_HDR\nstatic int      stbi__hdr_test(stbi__context *s);\nstatic float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PIC\nstatic int      stbi__pic_test(stbi__context *s);\nstatic void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_GIF\nstatic int      stbi__gif_test(stbi__context *s);\nstatic void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);\nstatic int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PNM\nstatic int      stbi__pnm_test(stbi__context *s);\nstatic void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__pnm_is16(stbi__context *s);\n#endif\n\nstatic\n#ifdef STBI_THREAD_LOCAL\nSTBI_THREAD_LOCAL\n#endif\nconst char *stbi__g_failure_reason;\n\nSTBIDEF const char *stbi_failure_reason(void)\n{\n   return stbi__g_failure_reason;\n}\n\n#ifndef STBI_NO_FAILURE_STRINGS\nstatic int stbi__err(const char *str)\n{\n   stbi__g_failure_reason = str;\n   return 0;\n}\n#endif\n\nstatic void *stbi__malloc(unsigned int size)\n{\n    return STBI_MALLOC(size);\n}\n\n// stb_image uses ints pervasively, including for offset calculations.\n// therefore the largest decoded image size we can support with the\n// current code, even on 64-bit targets, is INT_MAX. this is not a\n// significant limitation for the intended use case.\n//\n// we do, however, need to make sure our size calculations don't\n// overflow. hence a few helper functions for size calculations that\n// multiply integers together, making sure that they're non-negative\n// and no overflow occurs.\n\n// return 1 if the sum is valid, 0 on overflow.\n// negative terms are considered invalid.\nstatic int stbi__addsizes_valid(int a, int b)\n{\n   if (b < 0) return 0;\n   // now 0 <= b <= INT_MAX, hence also\n   // 0 <= INT_MAX - b <= INTMAX.\n   // And \"a + b <= INT_MAX\" (which might overflow) is the\n   // same as a <= INT_MAX - b (no overflow)\n   return a <= STBI_INT_MAX - b;\n}\n\n// returns 1 if the product is valid, 0 on overflow.\n// negative factors are considered invalid.\nstatic int stbi__mul2sizes_valid(int a, int b)\n{\n   if (a < 0 || b < 0) return 0;\n   if (b == 0) return 1; // mul-by-0 is always safe\n   // portable way to check for no overflows in a*b\n   return a <= STBI_INT_MAX/b;\n}\n\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\n// returns 1 if \"a*b + add\" has no negative terms/factors and doesn't overflow\nstatic int stbi__mad2sizes_valid(int a, int b, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);\n}\n#endif\n\n// returns 1 if \"a*b*c + add\" has no negative terms/factors and doesn't overflow\nstatic int stbi__mad3sizes_valid(int a, int b, int c, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\n      stbi__addsizes_valid(a*b*c, add);\n}\n\n// returns 1 if \"a*b*c*d + add\" has no negative terms/factors and doesn't overflow\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\nstatic int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\n      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);\n}\n#endif\n\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\n// mallocs with size overflow checking\nstatic void *stbi__malloc_mad2(int a, int b, int add)\n{\n   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;\n   return stbi__malloc(a*b + add);\n}\n#endif\n\nstatic void *stbi__malloc_mad3(int a, int b, int c, int add)\n{\n   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\n   return stbi__malloc(a*b*c + add);\n}\n\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\nstatic void *stbi__malloc_mad4(int a, int b, int c, int d, int add)\n{\n   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;\n   return stbi__malloc(a*b*c*d + add);\n}\n#endif\n\n// stbi__err - error\n// stbi__errpf - error returning pointer to float\n// stbi__errpuc - error returning pointer to unsigned char\n\n#ifdef STBI_NO_FAILURE_STRINGS\n   #define stbi__err(x,y)  0\n#elif defined(STBI_FAILURE_USERMSG)\n   #define stbi__err(x,y)  stbi__err(y)\n#else\n   #define stbi__err(x,y)  stbi__err(x)\n#endif\n\n#define stbi__errpf(x,y)   ((float *)(unsigned int) (stbi__err(x,y)?NULL:NULL))\n#define stbi__errpuc(x,y)  ((unsigned char *)(unsigned int) (stbi__err(x,y)?NULL:NULL))\n\nSTBIDEF void stbi_image_free(void *retval_from_stbi_load)\n{\n   STBI_FREE(retval_from_stbi_load);\n}\n\n#ifndef STBI_NO_LINEAR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);\n#endif\n\n#ifndef STBI_NO_HDR\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);\n#endif\n\nstatic int stbi__vertically_flip_on_load_global = 0;\n\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)\n{\n   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;\n}\n\n#ifndef STBI_THREAD_LOCAL\n#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global\n#else\nstatic STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;\n\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)\n{\n   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;\n   stbi__vertically_flip_on_load_set = 1;\n}\n\n#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \\\n                                         ? stbi__vertically_flip_on_load_local  \\\n                                         : stbi__vertically_flip_on_load_global)\n#endif // STBI_THREAD_LOCAL\n\nstatic void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\n{\n   MemSet(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields\n   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed\n   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order\n   ri->num_channels = 0;\n\n   // test the formats with a very explicit header first (at least a FOURCC\n   // or distinctive magic number first)\n   #ifndef STBI_NO_PNG\n   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_BMP\n   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_GIF\n   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);\n   #else\n   STBI_NOTUSED(bpc);\n   #endif\n   #ifndef STBI_NO_PIC\n   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   // then the formats that can end up attempting to load with just 1 or 2\n   // bytes matching expectations; these are prone to false positives, so\n   // try them later\n   #ifndef STBI_NO_JPEG\n   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);\n      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\n   }\n   #endif\n\n   #ifndef STBI_NO_TGA\n   // test tga last because it's a crappy test!\n   if (stbi__tga_test(s))\n      return stbi__tga_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nstatic stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)\n{\n   int i;\n   int img_len = w * h * channels;\n   stbi_uc *reduced;\n\n   reduced = (stbi_uc *) stbi__malloc(img_len);\n   if (reduced == NULL) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   for (i = 0; i < img_len; ++i)\n      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling\n\n   STBI_FREE(orig);\n   return reduced;\n}\n\nstatic stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)\n{\n   int i;\n   int img_len = w * h * channels;\n   stbi__uint16 *enlarged;\n\n   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);\n   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   for (i = 0; i < img_len; ++i)\n      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff\n\n   STBI_FREE(orig);\n   return enlarged;\n}\n\nstatic void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)\n{\n   int row;\n   unsigned int bytes_per_row = (unsigned int)w * bytes_per_pixel;\n   stbi_uc temp[2048];\n   stbi_uc *bytes = (stbi_uc *)image;\n\n   for (row = 0; row < (h>>1); row++) {\n      stbi_uc *row0 = bytes + row*bytes_per_row;\n      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;\n      // swap row0 with row1\n      unsigned int bytes_left = bytes_per_row;\n      while (bytes_left) {\n         unsigned int bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);\n         MemCopy(temp, row0, bytes_copy);\n         MemCopy(row0, row1, bytes_copy);\n         MemCopy(row1, temp, bytes_copy);\n         row0 += bytes_copy;\n         row1 += bytes_copy;\n         bytes_left -= bytes_copy;\n      }\n   }\n}\n\n#ifndef STBI_NO_GIF\nstatic void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)\n{\n   int slice;\n   int slice_size = w * h * bytes_per_pixel;\n\n   stbi_uc *bytes = (stbi_uc *)image;\n   for (slice = 0; slice < z; ++slice) {\n      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);\n      bytes += slice_size;\n   }\n}\n#endif\n\nstatic unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__result_info ri;\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);\n\n   if (result == NULL)\n      return NULL;\n\n   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\n   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\n\n   if (ri.bits_per_channel != 8) {\n      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\n      ri.bits_per_channel = 8;\n   }\n\n   // @TODO: move stbi__convert_format to here\n\n   if (stbi__vertically_flip_on_load) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));\n   }\n\n   return (unsigned char *) result;\n}\n\nstatic stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__result_info ri;\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);\n\n   if (result == NULL)\n      return NULL;\n\n   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\n   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\n\n   if (ri.bits_per_channel != 16) {\n      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\n      ri.bits_per_channel = 16;\n   }\n\n   // @TODO: move stbi__convert_format16 to here\n   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision\n\n   if (stbi__vertically_flip_on_load) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));\n   }\n\n   return (stbi__uint16 *) result;\n}\n\n#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)\nstatic void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)\n{\n   if (stbi__vertically_flip_on_load && result != NULL) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));\n   }\n}\n#endif\n\n#ifndef STBI_NO_STDIO\n\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\nSTBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);\nSTBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);\n#endif\n\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\nSTBIDEF int stbi_convert_wchar_to_utf8(char *buffer, unsigned int bufferlen, const wchar_t* input)\n{\n\treturn WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);\n}\n#endif\n\nstatic FILE *stbi__fopen(char const *filename, char const *mode)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\n   wchar_t wMode[64];\n   wchar_t wFilename[1024];\n\tif (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))\n      return 0;\n\n\tif (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))\n      return 0;\n\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n\tif (0 != _wfopen_s(&f, wFilename, wMode))\n\t\tf = 0;\n#else\n   f = _wfopen(wFilename, wMode);\n#endif\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n   if (0 != fopen_s(&f, filename, mode))\n      f=0;\n#else\n   f = fopen(filename, mode);\n#endif\n   return f;\n}\n\n\nSTBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   unsigned char *result;\n   if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n\nSTBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__uint16 *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n\nSTBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   stbi__uint16 *result;\n   if (!f) return (stbi_us *) stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file_16(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\n\n#endif //!STBI_NO_STDIO\n\nSTBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\n}\n\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\n}\n\nSTBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n}\n\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_GIF\nSTBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n\n   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);\n   if (stbi__vertically_flip_on_load) {\n      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );\n   }\n\n   return result;\n}\n#endif\n\n#ifndef STBI_NO_LINEAR\nstatic float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *data;\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      stbi__result_info ri;\n      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);\n      if (hdr_data)\n         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);\n      return hdr_data;\n   }\n   #endif\n   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);\n   if (data)\n      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\n   return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nSTBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n\nSTBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   float *result;\n   FILE *f = stbi__fopen(filename, \"rb\");\n   if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\n   result = stbi_loadf_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_file(&s,f);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n#endif // !STBI_NO_STDIO\n\n#endif // !STBI_NO_LINEAR\n\n// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is\n// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always\n// reports false!\n\nSTBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(buffer);\n   STBI_NOTUSED(len);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   int result=0;\n   if (f) {\n      result = stbi_is_hdr_from_file(f);\n      fclose(f);\n   }\n   return result;\n}\n\nSTBIDEF int stbi_is_hdr_from_file(FILE *f)\n{\n   #ifndef STBI_NO_HDR\n   long pos = ftell(f);\n   int res;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   res = stbi__hdr_test(&s);\n   fseek(f, pos, SEEK_SET);\n   return res;\n   #else\n   STBI_NOTUSED(f);\n   return 0;\n   #endif\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(clbk);\n   STBI_NOTUSED(user);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_LINEAR\nstatic float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;\n\nSTBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\nSTBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\n#endif\n\nstatic float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;\n\nSTBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }\nSTBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Common code used by all image loaders\n//\n\nenum\n{\n   STBI__SCAN_load=0,\n   STBI__SCAN_type,\n   STBI__SCAN_header\n};\n\nstatic void stbi__refill_buffer(stbi__context *s)\n{\n   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);\n   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);\n   if (n == 0) {\n      // at end of file, treat same as if from memory, but need to handle case\n      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\n      s->read_from_callbacks = 0;\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start+1;\n      *s->img_buffer = 0;\n   } else {\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start + n;\n   }\n}\n\nstbi_inline static stbi_uc stbi__get8(stbi__context *s)\n{\n   if (s->img_buffer < s->img_buffer_end)\n      return *s->img_buffer++;\n   if (s->read_from_callbacks) {\n      stbi__refill_buffer(s);\n      return *s->img_buffer++;\n   }\n   return 0;\n}\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\nstbi_inline static int stbi__at_eof(stbi__context *s)\n{\n   if (s->io.read) {\n      if (!(s->io.eof)(s->io_user_data)) return 0;\n      // if feof() is true, check if buffer = end\n      // special case: we've only got the special 0 character at the end\n      if (s->read_from_callbacks == 0) return 1;\n   }\n\n   return s->img_buffer >= s->img_buffer_end;\n}\n#endif\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic void stbi__skip(stbi__context *s, int n)\n{\n   if (n == 0) return;  // already there!\n   if (n < 0) {\n      s->img_buffer = s->img_buffer_end;\n      return;\n   }\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         s->img_buffer = s->img_buffer_end;\n         (s->io.skip)(s->io_user_data, n - blen);\n         return;\n      }\n   }\n   s->img_buffer += n;\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)\n// nothing\n#else\nstatic int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\n{\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         int res, count;\n\n         MemCopy(buffer, s->img_buffer, blen);\n\n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\n         res = (count == (n-blen));\n         s->img_buffer = s->img_buffer_end;\n         return res;\n      }\n   }\n\n   if (s->img_buffer+n <= s->img_buffer_end) {\n      MemCopy(buffer, s->img_buffer, n);\n      s->img_buffer += n;\n      return 1;\n   } else\n      return 0;\n}\n#endif\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic int stbi__get16be(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return (z << 8) + stbi__get8(s);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic stbi__uint32 stbi__get32be(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16be(s);\n   return (z << 16) + stbi__get16be(s);\n}\n#endif\n\n#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)\n// nothing\n#else\nstatic int stbi__get16le(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return z + (stbi__get8(s) << 8);\n}\n#endif\n\n#ifndef STBI_NO_BMP\nstatic stbi__uint32 stbi__get32le(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16le(s);\n   z += (stbi__uint32)stbi__get16le(s) << 16;\n   return z;\n}\n#endif\n\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\n//////////////////////////////////////////////////////////////////////////////\n//\n//  generic converter from built-in img_n to req_comp\n//    individual types do this automatically as much as possible (e.g. jpeg\n//    does all cases internally since it needs to colorspace convert anyway,\n//    and it never has alpha, so very few cases ). png can automatically\n//    interleave an alpha=255 channel, but falls back to this for other cases\n//\n//  assume data buffer is malloced, so malloc a new one and free that one\n//  only failure mode is malloc failing\n\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\n{\n   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\nstatic unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   unsigned char *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);\n   if (good == NULL) {\n      STBI_FREE(data);\n      return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      unsigned char *src  = data + j * x * img_n   ;\n      unsigned char *dest = good + j * x * req_comp;\n\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (STBI__COMBO(img_n, req_comp)) {\n         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;\n         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;\n         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;\n         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;\n         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\n      }\n      #undef STBI__CASE\n   }\n\n   STBI_FREE(data);\n   return good;\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\n// nothing\n#else\nstatic stbi__uint16 stbi__compute_y_16(int r, int g, int b)\n{\n   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\n// nothing\n#else\nstatic stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   stbi__uint16 *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);\n   if (good == NULL) {\n      STBI_FREE(data);\n      return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      stbi__uint16 *src  = data + j * x * img_n   ;\n      stbi__uint16 *dest = good + j * x * req_comp;\n\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (STBI__COMBO(img_n, req_comp)) {\n         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;\n         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;\n         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;\n         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;\n         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\n      }\n      #undef STBI__CASE\n   }\n\n   STBI_FREE(data);\n   return good;\n}\n#endif\n\n#ifndef STBI_NO_LINEAR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)\n{\n   int i,k,n;\n   float *output;\n   if (!data) return NULL;\n   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);\n   if (output == NULL) { STBI_FREE(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         output[i*comp + k] = (float) (MathPow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\n      }\n   }\n   if (n < comp) {\n      for (i=0; i < x*y; ++i) {\n         output[i*comp + n] = data[i*comp + n]/255.0f;\n      }\n   }\n   STBI_FREE(data);\n   return output;\n}\n#endif\n\n#ifndef STBI_NO_HDR\n#define stbi__float2int(x)   ((int) (x))\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)\n{\n   int i,k,n;\n   stbi_uc *output;\n   if (!data) return NULL;\n   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);\n   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         float z = (float) MathPow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n      if (k < comp) {\n         float z = data[i*comp+k] * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n   }\n   STBI_FREE(data);\n   return output;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  \"baseline\" JPEG/JFIF decoder\n//\n//    simple implementation\n//      - doesn't support delayed output of y-dimension\n//      - simple interface (only one output format: 8-bit interleaved RGB)\n//      - doesn't try to recover corrupt jpegs\n//      - doesn't allow partial loading, loading multiple at once\n//      - still fast on x86 (copying globals into locals doesn't help x86)\n//      - allocates lots of intermediate memory (full size of all components)\n//        - non-interleaved case requires this anyway\n//        - allows good upsampling (see next)\n//    high-quality\n//      - upsampled channels are bilinearly interpolated, even across blocks\n//      - quality integer IDCT derived from IJG's 'slow'\n//    performance\n//      - fast huffman; reasonable integer IDCT\n//      - some SIMD kernels for common paths on targets with SSE2/NEON\n//      - uses a lot of intermediate memory, could cache poorly\n\n#ifndef STBI_NO_JPEG\n\n// huffman decoding acceleration\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\n\ntypedef struct\n{\n   stbi_uc  fast[1 << FAST_BITS];\n   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\n   stbi__uint16 code[256];\n   stbi_uc  values[256];\n   stbi_uc  size[257];\n   unsigned int maxcode[18];\n   int    delta[17];   // old 'firstsymbol' - old 'firstcode'\n} stbi__huffman;\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi__huffman huff_dc[4];\n   stbi__huffman huff_ac[4];\n   stbi__uint16 dequant[4][64];\n   stbi__int16 fast_ac[4][1 << FAST_BITS];\n\n// sizes for components, interleaved MCUs\n   int img_h_max, img_v_max;\n   int img_mcu_x, img_mcu_y;\n   int img_mcu_w, img_mcu_h;\n\n// definition of jpeg image component\n   struct\n   {\n      int id;\n      int h,v;\n      int tq;\n      int hd,ha;\n      int dc_pred;\n\n      int x,y,w2,h2;\n      stbi_uc *data;\n      void *raw_data, *raw_coeff;\n      stbi_uc *linebuf;\n      short   *coeff;   // progressive only\n      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks\n   } img_comp[4];\n\n   stbi__uint32   code_buffer; // jpeg entropy-coded buffer\n   int            code_bits;   // number of valid bits\n   unsigned char  marker;      // marker seen while filling entropy buffer\n   int            nomore;      // flag if we saw a marker so must stop\n\n   int            progressive;\n   int            spec_start;\n   int            spec_end;\n   int            succ_high;\n   int            succ_low;\n   int            eob_run;\n   int            jfif;\n   int            app14_color_transform; // Adobe APP14 tag\n   int            rgb;\n\n   int scan_n, order[4];\n   int restart_interval, todo;\n\n// kernels\n   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);\n   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);\n   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);\n} stbi__jpeg;\n\nstatic int stbi__build_huffman(stbi__huffman *h, int *count)\n{\n   int i,j,k=0;\n   unsigned int code;\n   // build size list for each symbol (from JPEG spec)\n   for (i=0; i < 16; ++i)\n      for (j=0; j < count[i]; ++j)\n         h->size[k++] = (stbi_uc) (i+1);\n   h->size[k] = 0;\n\n   // compute actual symbols (from jpeg spec)\n   code = 0;\n   k = 0;\n   for(j=1; j <= 16; ++j) {\n      // compute delta to add to code to compute symbol id\n      h->delta[j] = k - code;\n      if (h->size[k] == j) {\n         while (h->size[k] == j)\n            h->code[k++] = (stbi__uint16) (code++);\n         if (code-1 >= (1u << j)) return stbi__err(\"bad code lengths\",\"Corrupt JPEG\");\n      }\n      // compute largest code + 1 for this size, preshifted as needed later\n      h->maxcode[j] = code << (16-j);\n      code <<= 1;\n   }\n   h->maxcode[j] = 0xffffffff;\n\n   // build non-spec acceleration table; 255 is flag for not-accelerated\n   MemSet(h->fast, 255, 1 << FAST_BITS);\n   for (i=0; i < k; ++i) {\n      int s = h->size[i];\n      if (s <= FAST_BITS) {\n         int c = h->code[i] << (FAST_BITS-s);\n         int m = 1 << (FAST_BITS-s);\n         for (j=0; j < m; ++j) {\n            h->fast[c+j] = (stbi_uc) i;\n         }\n      }\n   }\n   return 1;\n}\n\n// build a table that decodes both magnitude and value of small ACs in\n// one go.\nstatic void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)\n{\n   int i;\n   for (i=0; i < (1 << FAST_BITS); ++i) {\n      stbi_uc fast = h->fast[i];\n      fast_ac[i] = 0;\n      if (fast < 255) {\n         int rs = h->values[fast];\n         int run = (rs >> 4) & 15;\n         int magbits = rs & 15;\n         int len = h->size[fast];\n\n         if (magbits && len + magbits <= FAST_BITS) {\n            // magnitude code followed by receive_extend code\n            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);\n            int m = 1 << (magbits - 1);\n            if (k < m) k += (~0U << magbits) + 1;\n            // if the result is small enough, we can fit it in fast_ac table\n            if (k >= -128 && k <= 127)\n               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));\n         }\n      }\n   }\n}\n\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg *j)\n{\n   do {\n      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);\n      if (b == 0xff) {\n         int c = stbi__get8(j->s);\n         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes\n         if (c != 0) {\n            j->marker = (unsigned char) c;\n            j->nomore = 1;\n            return;\n         }\n      }\n      j->code_buffer |= b << (24 - j->code_bits);\n      j->code_bits += 8;\n   } while (j->code_bits <= 24);\n}\n\n// (1 << n) - 1\nstatic const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};\n\n// decode a jpeg huffman value from the bitstream\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)\n{\n   unsigned int temp;\n   int c,k;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   // look at the top FAST_BITS and determine what symbol ID it is,\n   // if the code is <= FAST_BITS\n   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n   k = h->fast[c];\n   if (k < 255) {\n      int s = h->size[k];\n      if (s > j->code_bits)\n         return -1;\n      j->code_buffer <<= s;\n      j->code_bits -= s;\n      return h->values[k];\n   }\n\n   // naive test is to shift the code_buffer down so k bits are\n   // valid, then test against maxcode. To speed this up, we've\n   // preshifted maxcode left so that it has (16-k) 0s at the\n   // end; in other words, regardless of the number of bits, it\n   // wants to be compared against something shifted to have 16;\n   // that way we don't need to shift inside the loop.\n   temp = j->code_buffer >> 16;\n   for (k=FAST_BITS+1 ; ; ++k)\n      if (temp < h->maxcode[k])\n         break;\n   if (k == 17) {\n      // error! code not found\n      j->code_bits -= 16;\n      return -1;\n   }\n\n   if (k > j->code_bits)\n      return -1;\n\n   // convert the huffman code to the symbol id\n   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\n   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\n\n   // convert the id to a symbol\n   j->code_bits -= k;\n   j->code_buffer <<= k;\n   return h->values[c];\n}\n\n// bias[n] = (-1<<n) + 1\nstatic const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};\n\n// combined JPEG 'receive' and JPEG 'extend', since baseline\n// always extends everything it receives.\nstbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   int sgn;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n\n   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k + (stbi__jbias[n] & (sgn - 1));\n}\n\n// get some unsigned bits\nstbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k;\n}\n\nstbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)\n{\n   unsigned int k;\n   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);\n   k = j->code_buffer;\n   j->code_buffer <<= 1;\n   --j->code_bits;\n   return k & 0x80000000;\n}\n\n// given a value that's at position X in the zigzag stream,\n// where does it appear in the 8x8 matrix coded as row-major?\nstatic const stbi_uc stbi__jpeg_dezigzag[64+15] =\n{\n    0,  1,  8, 16,  9,  2,  3, 10,\n   17, 24, 32, 25, 18, 11,  4,  5,\n   12, 19, 26, 33, 40, 48, 41, 34,\n   27, 20, 13,  6,  7, 14, 21, 28,\n   35, 42, 49, 56, 57, 50, 43, 36,\n   29, 22, 15, 23, 30, 37, 44, 51,\n   58, 59, 52, 45, 38, 31, 39, 46,\n   53, 60, 61, 54, 47, 55, 62, 63,\n   // let corrupt input sample past end\n   63, 63, 63, 63, 63, 63, 63, 63,\n   63, 63, 63, 63, 63, 63, 63\n};\n\n// decode one 64-entry block--\nstatic int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)\n{\n   int diff,dc,k;\n   int t;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n   t = stbi__jpeg_huff_decode(j, hdc);\n   if (t < 0 || t > 15) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   MemSet(data,0,64*sizeof(data[0]));\n\n   diff = t ? stbi__extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) (dc * dequant[0]);\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      unsigned int zig;\n      int c,r,s;\n      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n      r = fac[c];\n      if (r) { // fast-AC path\n         k += (r >> 4) & 15; // run\n         s = r & 15; // combined length\n         j->code_buffer <<= s;\n         j->code_bits -= s;\n         // decode into unzigzag'd location\n         zig = stbi__jpeg_dezigzag[k++];\n         data[zig] = (short) ((r >> 8) * dequant[zig]);\n      } else {\n         int rs = stbi__jpeg_huff_decode(j, hac);\n         if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n         s = rs & 15;\n         r = rs >> 4;\n         if (s == 0) {\n            if (rs != 0xf0) break; // end block\n            k += 16;\n         } else {\n            k += r;\n            // decode into unzigzag'd location\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);\n         }\n      }\n   } while (k < 64);\n   return 1;\n}\n\nstatic int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)\n{\n   int diff,dc;\n   int t;\n   if (j->spec_end != 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   if (j->succ_high == 0) {\n      // first scan for DC coefficient, must be first\n      MemSet(data,0,64*sizeof(data[0])); // 0 all the ac values now\n      t = stbi__jpeg_huff_decode(j, hdc);\n      if (t < 0 || t > 15) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n      diff = t ? stbi__extend_receive(j, t) : 0;\n\n      dc = j->img_comp[b].dc_pred + diff;\n      j->img_comp[b].dc_pred = dc;\n      data[0] = (short) (dc * (1 << j->succ_low));\n   } else {\n      // refinement scan for DC coefficient\n      if (stbi__jpeg_get_bit(j))\n         data[0] += (short) (1 << j->succ_low);\n   }\n   return 1;\n}\n\n// @OPTIMIZE: store non-zigzagged during the decode passes,\n// and only de-zigzag when dequantizing\nstatic int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)\n{\n   int k;\n   if (j->spec_start == 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n\n   if (j->succ_high == 0) {\n      int shift = j->succ_low;\n\n      if (j->eob_run) {\n         --j->eob_run;\n         return 1;\n      }\n\n      k = j->spec_start;\n      do {\n         unsigned int zig;\n         int c,r,s;\n         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n         r = fac[c];\n         if (r) { // fast-AC path\n            k += (r >> 4) & 15; // run\n            s = r & 15; // combined length\n            j->code_buffer <<= s;\n            j->code_bits -= s;\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) ((r >> 8) * (1 << shift));\n         } else {\n            int rs = stbi__jpeg_huff_decode(j, hac);\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n            s = rs & 15;\n            r = rs >> 4;\n            if (s == 0) {\n               if (r < 15) {\n                  j->eob_run = (1 << r);\n                  if (r)\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\n                  --j->eob_run;\n                  break;\n               }\n               k += 16;\n            } else {\n               k += r;\n               zig = stbi__jpeg_dezigzag[k++];\n               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));\n            }\n         }\n      } while (k <= j->spec_end);\n   } else {\n      // refinement scan for these AC coefficients\n\n      short bit = (short) (1 << j->succ_low);\n\n      if (j->eob_run) {\n         --j->eob_run;\n         for (k = j->spec_start; k <= j->spec_end; ++k) {\n            short *p = &data[stbi__jpeg_dezigzag[k]];\n            if (*p != 0)\n               if (stbi__jpeg_get_bit(j))\n                  if ((*p & bit)==0) {\n                     if (*p > 0)\n                        *p += bit;\n                     else\n                        *p -= bit;\n                  }\n         }\n      } else {\n         k = j->spec_start;\n         do {\n            int r,s;\n            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n            s = rs & 15;\n            r = rs >> 4;\n            if (s == 0) {\n               if (r < 15) {\n                  j->eob_run = (1 << r) - 1;\n                  if (r)\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\n                  r = 64; // force end of block\n               } else {\n                  // r=15 s=0 should write 16 0s, so we just do\n                  // a run of 15 0s and then write s (which is 0),\n                  // so we don't have to do anything special here\n               }\n            } else {\n               if (s != 1) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\n               // sign bit\n               if (stbi__jpeg_get_bit(j))\n                  s = bit;\n               else\n                  s = -bit;\n            }\n\n            // advance by r\n            while (k <= j->spec_end) {\n               short *p = &data[stbi__jpeg_dezigzag[k++]];\n               if (*p != 0) {\n                  if (stbi__jpeg_get_bit(j))\n                     if ((*p & bit)==0) {\n                        if (*p > 0)\n                           *p += bit;\n                        else\n                           *p -= bit;\n                     }\n               } else {\n                  if (r == 0) {\n                     *p = (short) s;\n                     break;\n                  }\n                  --r;\n               }\n            }\n         } while (k <= j->spec_end);\n      }\n   }\n   return 1;\n}\n\n// take a -128..127 value and stbi__clamp it and convert to 0..255\nstbi_inline static stbi_uc stbi__clamp(int x)\n{\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (stbi_uc) x;\n}\n\n#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))\n#define stbi__fsh(x)  ((x) * 4096)\n\n// derived from jidctint -- DCT_ISLOW\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \\\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\n   p2 = s2;                                    \\\n   p3 = s6;                                    \\\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \\\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \\\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \\\n   p2 = s0;                                    \\\n   p3 = s4;                                    \\\n   t0 = stbi__fsh(p2+p3);                      \\\n   t1 = stbi__fsh(p2-p3);                      \\\n   x0 = t0+t3;                                 \\\n   x3 = t0-t3;                                 \\\n   x1 = t1+t2;                                 \\\n   x2 = t1-t2;                                 \\\n   t0 = s7;                                    \\\n   t1 = s5;                                    \\\n   t2 = s3;                                    \\\n   t3 = s1;                                    \\\n   p3 = t0+t2;                                 \\\n   p4 = t1+t3;                                 \\\n   p1 = t0+t3;                                 \\\n   p2 = t1+t2;                                 \\\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \\\n   t0 = t0*stbi__f2f( 0.298631336f);           \\\n   t1 = t1*stbi__f2f( 2.053119869f);           \\\n   t2 = t2*stbi__f2f( 3.072711026f);           \\\n   t3 = t3*stbi__f2f( 1.501321110f);           \\\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \\\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \\\n   p3 = p3*stbi__f2f(-1.961570560f);           \\\n   p4 = p4*stbi__f2f(-0.390180644f);           \\\n   t3 += p1+p4;                                \\\n   t2 += p2+p3;                                \\\n   t1 += p2+p4;                                \\\n   t0 += p1+p3;\n\nstatic void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])\n{\n   int i,val[64],*v=val;\n   stbi_uc *o;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0]*4;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      // so we want to round that, which means adding 0.5 * 1<<17,\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\n      x0 += 65536 + (128<<17);\n      x1 += 65536 + (128<<17);\n      x2 += 65536 + (128<<17);\n      x3 += 65536 + (128<<17);\n      // tried computing the shifts into temps, or'ing the temps to see\n      // if any were out of range, but that was slower\n      o[0] = stbi__clamp((x0+t3) >> 17);\n      o[7] = stbi__clamp((x0-t3) >> 17);\n      o[1] = stbi__clamp((x1+t2) >> 17);\n      o[6] = stbi__clamp((x1-t2) >> 17);\n      o[2] = stbi__clamp((x2+t1) >> 17);\n      o[5] = stbi__clamp((x2-t1) >> 17);\n      o[3] = stbi__clamp((x3+t0) >> 17);\n      o[4] = stbi__clamp((x3-t0) >> 17);\n   }\n}\n\n#ifdef STBI_SSE2\n// sse2 integer IDCT. not the fastest possible implementation but it\n// produces bit-identical results to the generic C version so it's\n// fully \"transparent\".\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\n{\n   // This is constructed to match our regular (generic) integer IDCT exactly.\n   __m128i row0, row1, row2, row3, row4, row5, row6, row7;\n   __m128i tmp;\n\n   // dot product constant: even elems=x, odd elems=y\n   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))\n\n   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)\n   // out(1) = c1[even]*x + c1[odd]*y\n   #define dct_rot(out0,out1, x,y,c0,c1) \\\n      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \\\n      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \\\n      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \\\n      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \\\n      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \\\n      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)\n\n   // out = in << 12  (in 16-bit, out 32-bit)\n   #define dct_widen(out, in) \\\n      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \\\n      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)\n\n   // wide add\n   #define dct_wadd(out, a, b) \\\n      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \\\n      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)\n\n   // wide sub\n   #define dct_wsub(out, a, b) \\\n      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \\\n      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)\n\n   // butterfly a/b, add bias, then shift by \"s\" and pack\n   #define dct_bfly32o(out0, out1, a,b,bias,s) \\\n      { \\\n         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \\\n         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \\\n         dct_wadd(sum, abiased, b); \\\n         dct_wsub(dif, abiased, b); \\\n         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \\\n         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \\\n      }\n\n   // 8-bit interleave step (for transposes)\n   #define dct_interleave8(a, b) \\\n      tmp = a; \\\n      a = _mm_unpacklo_epi8(a, b); \\\n      b = _mm_unpackhi_epi8(tmp, b)\n\n   // 16-bit interleave step (for transposes)\n   #define dct_interleave16(a, b) \\\n      tmp = a; \\\n      a = _mm_unpacklo_epi16(a, b); \\\n      b = _mm_unpackhi_epi16(tmp, b)\n\n   #define dct_pass(bias,shift) \\\n      { \\\n         /* even part */ \\\n         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \\\n         __m128i sum04 = _mm_add_epi16(row0, row4); \\\n         __m128i dif04 = _mm_sub_epi16(row0, row4); \\\n         dct_widen(t0e, sum04); \\\n         dct_widen(t1e, dif04); \\\n         dct_wadd(x0, t0e, t3e); \\\n         dct_wsub(x3, t0e, t3e); \\\n         dct_wadd(x1, t1e, t2e); \\\n         dct_wsub(x2, t1e, t2e); \\\n         /* odd part */ \\\n         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \\\n         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \\\n         __m128i sum17 = _mm_add_epi16(row1, row7); \\\n         __m128i sum35 = _mm_add_epi16(row3, row5); \\\n         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \\\n         dct_wadd(x4, y0o, y4o); \\\n         dct_wadd(x5, y1o, y5o); \\\n         dct_wadd(x6, y2o, y5o); \\\n         dct_wadd(x7, y3o, y4o); \\\n         dct_bfly32o(row0,row7, x0,x7,bias,shift); \\\n         dct_bfly32o(row1,row6, x1,x6,bias,shift); \\\n         dct_bfly32o(row2,row5, x2,x5,bias,shift); \\\n         dct_bfly32o(row3,row4, x3,x4,bias,shift); \\\n      }\n\n   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));\n   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));\n   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));\n   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));\n   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));\n   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));\n   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));\n   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));\n\n   // rounding biases in column/row passes, see stbi__idct_block for explanation.\n   __m128i bias_0 = _mm_set1_epi32(512);\n   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));\n\n   // load\n   row0 = _mm_load_si128((const __m128i *) (data + 0*8));\n   row1 = _mm_load_si128((const __m128i *) (data + 1*8));\n   row2 = _mm_load_si128((const __m128i *) (data + 2*8));\n   row3 = _mm_load_si128((const __m128i *) (data + 3*8));\n   row4 = _mm_load_si128((const __m128i *) (data + 4*8));\n   row5 = _mm_load_si128((const __m128i *) (data + 5*8));\n   row6 = _mm_load_si128((const __m128i *) (data + 6*8));\n   row7 = _mm_load_si128((const __m128i *) (data + 7*8));\n\n   // column pass\n   dct_pass(bias_0, 10);\n\n   {\n      // 16bit 8x8 transpose pass 1\n      dct_interleave16(row0, row4);\n      dct_interleave16(row1, row5);\n      dct_interleave16(row2, row6);\n      dct_interleave16(row3, row7);\n\n      // transpose pass 2\n      dct_interleave16(row0, row2);\n      dct_interleave16(row1, row3);\n      dct_interleave16(row4, row6);\n      dct_interleave16(row5, row7);\n\n      // transpose pass 3\n      dct_interleave16(row0, row1);\n      dct_interleave16(row2, row3);\n      dct_interleave16(row4, row5);\n      dct_interleave16(row6, row7);\n   }\n\n   // row pass\n   dct_pass(bias_1, 17);\n\n   {\n      // pack\n      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7\n      __m128i p1 = _mm_packus_epi16(row2, row3);\n      __m128i p2 = _mm_packus_epi16(row4, row5);\n      __m128i p3 = _mm_packus_epi16(row6, row7);\n\n      // 8bit 8x8 transpose pass 1\n      dct_interleave8(p0, p2); // a0e0a1e1...\n      dct_interleave8(p1, p3); // c0g0c1g1...\n\n      // transpose pass 2\n      dct_interleave8(p0, p1); // a0c0e0g0...\n      dct_interleave8(p2, p3); // b0d0f0h0...\n\n      // transpose pass 3\n      dct_interleave8(p0, p2); // a0b0c0d0...\n      dct_interleave8(p1, p3); // a4b4c4d4...\n\n      // store\n      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));\n   }\n\n#undef dct_const\n#undef dct_rot\n#undef dct_widen\n#undef dct_wadd\n#undef dct_wsub\n#undef dct_bfly32o\n#undef dct_interleave8\n#undef dct_interleave16\n#undef dct_pass\n}\n\n#endif // STBI_SSE2\n\n#ifdef STBI_NEON\n\n// NEON integer IDCT. should produce bit-identical\n// results to the generic C version.\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\n{\n   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;\n\n   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));\n   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));\n   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));\n   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));\n   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));\n   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));\n   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));\n   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));\n   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));\n   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));\n   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));\n   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));\n\n#define dct_long_mul(out, inq, coeff) \\\n   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \\\n   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)\n\n#define dct_long_mac(out, acc, inq, coeff) \\\n   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \\\n   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)\n\n#define dct_widen(out, inq) \\\n   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \\\n   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)\n\n// wide add\n#define dct_wadd(out, a, b) \\\n   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \\\n   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)\n\n// wide sub\n#define dct_wsub(out, a, b) \\\n   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \\\n   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)\n\n// butterfly a/b, then shift using \"shiftop\" by \"s\" and pack\n#define dct_bfly32o(out0,out1, a,b,shiftop,s) \\\n   { \\\n      dct_wadd(sum, a, b); \\\n      dct_wsub(dif, a, b); \\\n      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \\\n      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \\\n   }\n\n#define dct_pass(shiftop, shift) \\\n   { \\\n      /* even part */ \\\n      int16x8_t sum26 = vaddq_s16(row2, row6); \\\n      dct_long_mul(p1e, sum26, rot0_0); \\\n      dct_long_mac(t2e, p1e, row6, rot0_1); \\\n      dct_long_mac(t3e, p1e, row2, rot0_2); \\\n      int16x8_t sum04 = vaddq_s16(row0, row4); \\\n      int16x8_t dif04 = vsubq_s16(row0, row4); \\\n      dct_widen(t0e, sum04); \\\n      dct_widen(t1e, dif04); \\\n      dct_wadd(x0, t0e, t3e); \\\n      dct_wsub(x3, t0e, t3e); \\\n      dct_wadd(x1, t1e, t2e); \\\n      dct_wsub(x2, t1e, t2e); \\\n      /* odd part */ \\\n      int16x8_t sum15 = vaddq_s16(row1, row5); \\\n      int16x8_t sum17 = vaddq_s16(row1, row7); \\\n      int16x8_t sum35 = vaddq_s16(row3, row5); \\\n      int16x8_t sum37 = vaddq_s16(row3, row7); \\\n      int16x8_t sumodd = vaddq_s16(sum17, sum35); \\\n      dct_long_mul(p5o, sumodd, rot1_0); \\\n      dct_long_mac(p1o, p5o, sum17, rot1_1); \\\n      dct_long_mac(p2o, p5o, sum35, rot1_2); \\\n      dct_long_mul(p3o, sum37, rot2_0); \\\n      dct_long_mul(p4o, sum15, rot2_1); \\\n      dct_wadd(sump13o, p1o, p3o); \\\n      dct_wadd(sump24o, p2o, p4o); \\\n      dct_wadd(sump23o, p2o, p3o); \\\n      dct_wadd(sump14o, p1o, p4o); \\\n      dct_long_mac(x4, sump13o, row7, rot3_0); \\\n      dct_long_mac(x5, sump24o, row5, rot3_1); \\\n      dct_long_mac(x6, sump23o, row3, rot3_2); \\\n      dct_long_mac(x7, sump14o, row1, rot3_3); \\\n      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \\\n      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \\\n      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \\\n      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \\\n   }\n\n   // load\n   row0 = vld1q_s16(data + 0*8);\n   row1 = vld1q_s16(data + 1*8);\n   row2 = vld1q_s16(data + 2*8);\n   row3 = vld1q_s16(data + 3*8);\n   row4 = vld1q_s16(data + 4*8);\n   row5 = vld1q_s16(data + 5*8);\n   row6 = vld1q_s16(data + 6*8);\n   row7 = vld1q_s16(data + 7*8);\n\n   // add DC bias\n   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));\n\n   // column pass\n   dct_pass(vrshrn_n_s32, 10);\n\n   // 16bit 8x8 transpose\n   {\n// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.\n// whether compilers actually get this is another story, sadly.\n#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }\n#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }\n#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }\n\n      // pass 1\n      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6\n      dct_trn16(row2, row3);\n      dct_trn16(row4, row5);\n      dct_trn16(row6, row7);\n\n      // pass 2\n      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4\n      dct_trn32(row1, row3);\n      dct_trn32(row4, row6);\n      dct_trn32(row5, row7);\n\n      // pass 3\n      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0\n      dct_trn64(row1, row5);\n      dct_trn64(row2, row6);\n      dct_trn64(row3, row7);\n\n#undef dct_trn16\n#undef dct_trn32\n#undef dct_trn64\n   }\n\n   // row pass\n   // vrshrn_n_s32 only supports shifts up to 16, we need\n   // 17. so do a non-rounding shift of 16 first then follow\n   // up with a rounding shift by 1.\n   dct_pass(vshrn_n_s32, 16);\n\n   {\n      // pack and round\n      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);\n      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);\n      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);\n      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);\n      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);\n      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);\n      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);\n      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);\n\n      // again, these can translate into one instruction, but often don't.\n#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }\n#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }\n#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }\n\n      // sadly can't use interleaved stores here since we only write\n      // 8 bytes to each scan line!\n\n      // 8x8 8-bit transpose pass 1\n      dct_trn8_8(p0, p1);\n      dct_trn8_8(p2, p3);\n      dct_trn8_8(p4, p5);\n      dct_trn8_8(p6, p7);\n\n      // pass 2\n      dct_trn8_16(p0, p2);\n      dct_trn8_16(p1, p3);\n      dct_trn8_16(p4, p6);\n      dct_trn8_16(p5, p7);\n\n      // pass 3\n      dct_trn8_32(p0, p4);\n      dct_trn8_32(p1, p5);\n      dct_trn8_32(p2, p6);\n      dct_trn8_32(p3, p7);\n\n      // store\n      vst1_u8(out, p0); out += out_stride;\n      vst1_u8(out, p1); out += out_stride;\n      vst1_u8(out, p2); out += out_stride;\n      vst1_u8(out, p3); out += out_stride;\n      vst1_u8(out, p4); out += out_stride;\n      vst1_u8(out, p5); out += out_stride;\n      vst1_u8(out, p6); out += out_stride;\n      vst1_u8(out, p7);\n\n#undef dct_trn8_8\n#undef dct_trn8_16\n#undef dct_trn8_32\n   }\n\n#undef dct_long_mul\n#undef dct_long_mac\n#undef dct_widen\n#undef dct_wadd\n#undef dct_wsub\n#undef dct_bfly32o\n#undef dct_pass\n}\n\n#endif // STBI_NEON\n\n#define STBI__MARKER_none  0xff\n// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\nstatic stbi_uc stbi__get_marker(stbi__jpeg *j)\n{\n   stbi_uc x;\n   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\n   x = stbi__get8(j->s);\n   if (x != 0xff) return STBI__MARKER_none;\n   while (x == 0xff)\n      x = stbi__get8(j->s); // consume repeated 0xff fill bytes\n   return x;\n}\n\n// in each scan, we'll have scan_n components, and the order\n// of the components is specified by order[]\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\n\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\n// the dc prediction\nstatic void stbi__jpeg_reset(stbi__jpeg *j)\n{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;\n   j->marker = STBI__MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   j->eob_run = 0;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}\n\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg *z)\n{\n   stbi__jpeg_reset(z);\n   if (!z->progressive) {\n      if (z->scan_n == 1) {\n         int i,j;\n         STBI_SIMD_ALIGN(short, data[64]);\n         int n = z->order[0];\n         // non-interleaved data, we just need to process one block at a time,\n         // in trivial scanline order\n         // number of blocks to do just depends on how many actual \"pixels\" this\n         // component has, independent of interleaved MCU blocking and such\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               int ha = z->img_comp[n].ha;\n               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\n               // every data block is an MCU, so countdown the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  // if it's NOT a restart, then just bail, so we get corrupt data\n                  // rather than no data\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      } else { // interleaved\n         int i,j,k,x,y;\n         STBI_SIMD_ALIGN(short, data[64]);\n         for (j=0; j < z->img_mcu_y; ++j) {\n            for (i=0; i < z->img_mcu_x; ++i) {\n               // scan an interleaved mcu... process scan_n components in order\n               for (k=0; k < z->scan_n; ++k) {\n                  int n = z->order[k];\n                  // scan out an mcu's worth of this component; that's just determined\n                  // by the basic H and V specified for the component\n                  for (y=0; y < z->img_comp[n].v; ++y) {\n                     for (x=0; x < z->img_comp[n].h; ++x) {\n                        int x2 = (i*z->img_comp[n].h + x)*8;\n                        int y2 = (j*z->img_comp[n].v + y)*8;\n                        int ha = z->img_comp[n].ha;\n                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\n                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);\n                     }\n                  }\n               }\n               // after all interleaved components, that's an interleaved MCU,\n               // so now count down the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      }\n   } else {\n      if (z->scan_n == 1) {\n         int i,j;\n         int n = z->order[0];\n         // non-interleaved data, we just need to process one block at a time,\n         // in trivial scanline order\n         // number of blocks to do just depends on how many actual \"pixels\" this\n         // component has, independent of interleaved MCU blocking and such\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\n               if (z->spec_start == 0) {\n                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\n                     return 0;\n               } else {\n                  int ha = z->img_comp[n].ha;\n                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))\n                     return 0;\n               }\n               // every data block is an MCU, so countdown the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      } else { // interleaved\n         int i,j,k,x,y;\n         for (j=0; j < z->img_mcu_y; ++j) {\n            for (i=0; i < z->img_mcu_x; ++i) {\n               // scan an interleaved mcu... process scan_n components in order\n               for (k=0; k < z->scan_n; ++k) {\n                  int n = z->order[k];\n                  // scan out an mcu's worth of this component; that's just determined\n                  // by the basic H and V specified for the component\n                  for (y=0; y < z->img_comp[n].v; ++y) {\n                     for (x=0; x < z->img_comp[n].h; ++x) {\n                        int x2 = (i*z->img_comp[n].h + x);\n                        int y2 = (j*z->img_comp[n].v + y);\n                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);\n                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\n                           return 0;\n                     }\n                  }\n               }\n               // after all interleaved components, that's an interleaved MCU,\n               // so now count down the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      }\n   }\n}\n\nstatic void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)\n{\n   int i;\n   for (i=0; i < 64; ++i)\n      data[i] *= dequant[i];\n}\n\nstatic void stbi__jpeg_finish(stbi__jpeg *z)\n{\n   if (z->progressive) {\n      // dequantize and idct the data\n      int i,j,n;\n      for (n=0; n < z->s->img_n; ++n) {\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\n               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\n            }\n         }\n      }\n   }\n}\n\nstatic int stbi__process_marker(stbi__jpeg *z, int m)\n{\n   int IdkSomeL = 0;\n   switch (m) {\n      case STBI__MARKER_none: // no marker found\n         return stbi__err(\"expected marker\",\"Corrupt JPEG\");\n\n      case 0xDD: // DRI - specify restart interval\n         if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\",\"Corrupt JPEG\");\n         z->restart_interval = stbi__get16be(z->s);\n         return 1;\n\n      case 0xDB: // DQT - define quantization table\n         IdkSomeL = stbi__get16be(z->s)-2;\n         while (IdkSomeL > 0) {\n            int q = stbi__get8(z->s);\n            int p = q >> 4, sixteen = (p != 0);\n            int t = q & 15,i;\n            if (p != 0 && p != 1) return stbi__err(\"bad DQT type\",\"Corrupt JPEG\");\n            if (t > 3) return stbi__err(\"bad DQT table\",\"Corrupt JPEG\");\n\n            for (i=0; i < 64; ++i)\n               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));\n            IdkSomeL -= (sixteen ? 129 : 65);\n         }\n         return IdkSomeL==0;\n\n      case 0xC4: // DHT - define huffman table\n         IdkSomeL = stbi__get16be(z->s)-2;\n         while (IdkSomeL > 0) {\n            stbi_uc *v;\n            int sizes[16],i,n=0;\n            int q = stbi__get8(z->s);\n            int tc = q >> 4;\n            int th = q & 15;\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\");\n            for (i=0; i < 16; ++i) {\n               sizes[i] = stbi__get8(z->s);\n               n += sizes[i];\n            }\n            IdkSomeL -= 17;\n            if (tc == 0) {\n               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;\n               v = z->huff_dc[th].values;\n            } else {\n               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;\n               v = z->huff_ac[th].values;\n            }\n            for (i=0; i < n; ++i)\n               v[i] = stbi__get8(z->s);\n            if (tc != 0)\n               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);\n            IdkSomeL -= n;\n         }\n         return IdkSomeL==0;\n   }\n\n   // check for comment block or APP blocks\n   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\n      IdkSomeL = stbi__get16be(z->s);\n      if (IdkSomeL < 2) {\n         if (m == 0xFE)\n            return stbi__err(\"bad COM len\",\"Corrupt JPEG\");\n         else\n            return stbi__err(\"bad APP len\",\"Corrupt JPEG\");\n      }\n      IdkSomeL -= 2;\n\n      if (m == 0xE0 && IdkSomeL >= 5) { // JFIF APP0 segment\n         static const unsigned char tag[5] = {'J','F','I','F','\\0'};\n         int ok = 1;\n         int i;\n         for (i=0; i < 5; ++i)\n            if (stbi__get8(z->s) != tag[i])\n               ok = 0;\n         IdkSomeL -= 5;\n         if (ok)\n            z->jfif = 1;\n      } else if (m == 0xEE && IdkSomeL >= 12) { // Adobe APP14 segment\n         static const unsigned char tag[6] = {'A','d','o','b','e','\\0'};\n         int ok = 1;\n         int i;\n         for (i=0; i < 6; ++i)\n            if (stbi__get8(z->s) != tag[i])\n               ok = 0;\n         IdkSomeL -= 6;\n         if (ok) {\n            stbi__get8(z->s); // version\n            stbi__get16be(z->s); // flags0\n            stbi__get16be(z->s); // flags1\n            z->app14_color_transform = stbi__get8(z->s); // color transform\n            IdkSomeL -= 6;\n         }\n      }\n\n      stbi__skip(z->s, IdkSomeL);\n      return 1;\n   }\n\n   return stbi__err(\"unknown marker\",\"Corrupt JPEG\");\n}\n\n// after we see SOS\nstatic int stbi__process_scan_header(stbi__jpeg *z)\n{\n   int i;\n   int Ls = stbi__get16be(z->s);\n   z->scan_n = stbi__get8(z->s);\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(\"bad SOS component count\",\"Corrupt JPEG\");\n   if (Ls != 6+2*z->scan_n) return stbi__err(\"bad SOS len\",\"Corrupt JPEG\");\n   for (i=0; i < z->scan_n; ++i) {\n      int id = stbi__get8(z->s), which;\n      int q = stbi__get8(z->s);\n      for (which = 0; which < z->s->img_n; ++which)\n         if (z->img_comp[which].id == id)\n            break;\n      if (which == z->s->img_n) return 0; // no match\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\",\"Corrupt JPEG\");\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\",\"Corrupt JPEG\");\n      z->order[i] = which;\n   }\n\n   {\n      int aa;\n      z->spec_start = stbi__get8(z->s);\n      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0\n      aa = stbi__get8(z->s);\n      z->succ_high = (aa >> 4);\n      z->succ_low  = (aa & 15);\n      if (z->progressive) {\n         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)\n            return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\n      } else {\n         if (z->spec_start != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\n         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\n         z->spec_end = 63;\n      }\n   }\n\n   return 1;\n}\n\nstatic int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)\n{\n   int i;\n   for (i=0; i < ncomp; ++i) {\n      if (z->img_comp[i].raw_data) {\n         STBI_FREE(z->img_comp[i].raw_data);\n         z->img_comp[i].raw_data = NULL;\n         z->img_comp[i].data = NULL;\n      }\n      if (z->img_comp[i].raw_coeff) {\n         STBI_FREE(z->img_comp[i].raw_coeff);\n         z->img_comp[i].raw_coeff = 0;\n         z->img_comp[i].coeff = 0;\n      }\n      if (z->img_comp[i].linebuf) {\n         STBI_FREE(z->img_comp[i].linebuf);\n         z->img_comp[i].linebuf = NULL;\n      }\n   }\n   return why;\n}\n\nstatic int stbi__process_frame_header(stbi__jpeg *z, int scan)\n{\n   stbi__context *s = z->s;\n   int Lf,p,i,q, h_max=1,v_max=1,c;\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\"); // JPEG\n   p  = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   c = stbi__get8(s);\n   if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\",\"Corrupt JPEG\");\n   s->img_n = c;\n   for (i=0; i < c; ++i) {\n      z->img_comp[i].data = NULL;\n      z->img_comp[i].linebuf = NULL;\n   }\n\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\");\n\n   z->rgb = 0;\n   for (i=0; i < s->img_n; ++i) {\n      static const unsigned char rgb[3] = { 'R', 'G', 'B' };\n      z->img_comp[i].id = stbi__get8(s);\n      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\n         ++z->rgb;\n      q = stbi__get8(s);\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\n   }\n\n   if (scan != STBI__SCAN_load) return 1;\n\n   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\n\n   for (i=0; i < s->img_n; ++i) {\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\n   }\n\n   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios\n   // and I've never seen a non-corrupted JPEG file actually use them\n   for (i=0; i < s->img_n; ++i) {\n      if (h_max % z->img_comp[i].h != 0) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      if (v_max % z->img_comp[i].v != 0) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n   }\n\n   // compute interleaved mcu info\n   z->img_h_max = h_max;\n   z->img_v_max = v_max;\n   z->img_mcu_w = h_max * 8;\n   z->img_mcu_h = v_max * 8;\n   // these sizes can't be more than 17 bits\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\n\n   for (i=0; i < s->img_n; ++i) {\n      // number of effective pixels (e.g. for non-interleaved MCU)\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\n      // to simplify generation, we'll allocate enough memory to decode\n      // the bogus oversized data from using interleaved MCUs and their\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\n      // discard the extra data until colorspace conversion\n      //\n      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\n      // so these muls can't overflow with 32-bit ints (which we require)\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\n      z->img_comp[i].coeff = 0;\n      z->img_comp[i].raw_coeff = 0;\n      z->img_comp[i].linebuf = NULL;\n      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\n      if (z->img_comp[i].raw_data == NULL)\n         return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n      // align blocks for idct using mmx/sse\n      z->img_comp[i].data = (stbi_uc*) (((unsigned int) z->img_comp[i].raw_data + 15) & ~15);\n      if (z->progressive) {\n         // w2, h2 are multiples of 8 (see above)\n         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\n         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\n         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\n         if (z->img_comp[i].raw_coeff == NULL)\n            return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n         z->img_comp[i].coeff = (short*) (((unsigned int) z->img_comp[i].raw_coeff + 15) & ~15);\n      }\n   }\n\n   return 1;\n}\n\n// use comparisons since in some cases we handle more than one case (e.g. SOF)\n#define stbi__DNL(x)         ((x) == 0xdc)\n#define stbi__SOI(x)         ((x) == 0xd8)\n#define stbi__EOI(x)         ((x) == 0xd9)\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)\n#define stbi__SOS(x)         ((x) == 0xda)\n\n#define stbi__SOF_progressive(x)   ((x) == 0xc2)\n\nstatic int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)\n{\n   int m;\n   z->jfif = 0;\n   z->app14_color_transform = -1; // valid values are 0,1,2\n   z->marker = STBI__MARKER_none; // initialize cached marker to empty\n   m = stbi__get_marker(z);\n   if (!stbi__SOI(m)) return stbi__err(\"no SOI\",\"Corrupt JPEG\");\n   if (scan == STBI__SCAN_type) return 1;\n   m = stbi__get_marker(z);\n   while (!stbi__SOF(m)) {\n      if (!stbi__process_marker(z,m)) return 0;\n      m = stbi__get_marker(z);\n      while (m == STBI__MARKER_none) {\n         // some files have extra padding after their blocks, so ok, we'll scan\n         if (stbi__at_eof(z->s)) return stbi__err(\"no SOF\", \"Corrupt JPEG\");\n         m = stbi__get_marker(z);\n      }\n   }\n   z->progressive = stbi__SOF_progressive(m);\n   if (!stbi__process_frame_header(z, scan)) return 0;\n   return 1;\n}\n\n// decode image to YCbCr format\nstatic int stbi__decode_jpeg_image(stbi__jpeg *j)\n{\n   int m;\n   for (m = 0; m < 4; m++) {\n      j->img_comp[m].raw_data = NULL;\n      j->img_comp[m].raw_coeff = NULL;\n   }\n   j->restart_interval = 0;\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;\n   m = stbi__get_marker(j);\n   while (!stbi__EOI(m)) {\n      if (stbi__SOS(m)) {\n         if (!stbi__process_scan_header(j)) return 0;\n         if (!stbi__parse_entropy_coded_data(j)) return 0;\n         if (j->marker == STBI__MARKER_none ) {\n            // handle 0s at the end of image data from IP Kamera 9060\n            while (!stbi__at_eof(j->s)) {\n               int x = stbi__get8(j->s);\n               if (x == 255) {\n                  j->marker = stbi__get8(j->s);\n                  break;\n               }\n            }\n            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\n         }\n      } else if (stbi__DNL(m)) {\n         int Ld = stbi__get16be(j->s);\n         stbi__uint32 NL = stbi__get16be(j->s);\n         if (Ld != 4) return stbi__err(\"bad DNL len\", \"Corrupt JPEG\");\n         if (NL != j->s->img_y) return stbi__err(\"bad DNL height\", \"Corrupt JPEG\");\n      } else {\n         if (!stbi__process_marker(j, m)) return 0;\n      }\n      m = stbi__get_marker(j);\n   }\n   if (j->progressive)\n      stbi__jpeg_finish(j);\n   return 1;\n}\n\n// static jfif-centered resampling (across block boundaries)\n\ntypedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\n                                    int w, int hs);\n\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\n\nstatic stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   STBI_NOTUSED(out);\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(w);\n   STBI_NOTUSED(hs);\n   return in_near;\n}\n\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples vertically for every one in input\n   int i;\n   STBI_NOTUSED(hs);\n   for (i=0; i < w; ++i)\n      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);\n   return out;\n}\n\nstatic stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples horizontally for every one in input\n   int i;\n   stbi_uc *input = in_near;\n\n   if (w == 1) {\n      // if only one sample, can't do any interpolation\n      out[0] = out[1] = input[0];\n      return out;\n   }\n\n   out[0] = input[0];\n   out[1] = stbi__div4(input[0]*3 + input[1] + 2);\n   for (i=1; i < w-1; ++i) {\n      int n = 3*input[i]+2;\n      out[i*2+0] = stbi__div4(n+input[i-1]);\n      out[i*2+1] = stbi__div4(n+input[i+1]);\n   }\n   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);\n   out[i*2+1] = input[w-1];\n\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\n\nstatic stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i,t0,t1;\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   out[0] = stbi__div4(t1+2);\n   for (i=1; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#if defined(STBI_SSE2) || defined(STBI_NEON)\nstatic stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i=0,t0,t1;\n\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   // process groups of 8 pixels for as long as we can.\n   // note we can't handle the last pixel in a row in this loop\n   // because we need to handle the filter boundary conditions.\n   for (; i < ((w-1) & ~7); i += 8) {\n#if defined(STBI_SSE2)\n      // load and perform the vertical filtering pass\n      // this uses 3*x + y = 4*x + (y - x)\n      __m128i zero  = _mm_setzero_si128();\n      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));\n      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));\n      __m128i farw  = _mm_unpacklo_epi8(farb, zero);\n      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);\n      __m128i diff  = _mm_sub_epi16(farw, nearw);\n      __m128i nears = _mm_slli_epi16(nearw, 2);\n      __m128i curr  = _mm_add_epi16(nears, diff); // current row\n\n      // horizontal filter works the same based on shifted vers of current\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\n      // insert the previous pixel value (from t1).\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\n      // of next block of 8 pixels added in.\n      __m128i prv0 = _mm_slli_si128(curr, 2);\n      __m128i nxt0 = _mm_srli_si128(curr, 2);\n      __m128i prev = _mm_insert_epi16(prv0, t1, 0);\n      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);\n\n      // horizontal filter, polyphase implementation since it's convenient:\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\n      // note the shared term.\n      __m128i bias  = _mm_set1_epi16(8);\n      __m128i curs = _mm_slli_epi16(curr, 2);\n      __m128i prvd = _mm_sub_epi16(prev, curr);\n      __m128i nxtd = _mm_sub_epi16(next, curr);\n      __m128i curb = _mm_add_epi16(curs, bias);\n      __m128i even = _mm_add_epi16(prvd, curb);\n      __m128i odd  = _mm_add_epi16(nxtd, curb);\n\n      // interleave even and odd pixels, then undo scaling.\n      __m128i int0 = _mm_unpacklo_epi16(even, odd);\n      __m128i int1 = _mm_unpackhi_epi16(even, odd);\n      __m128i de0  = _mm_srli_epi16(int0, 4);\n      __m128i de1  = _mm_srli_epi16(int1, 4);\n\n      // pack and write output\n      __m128i outv = _mm_packus_epi16(de0, de1);\n      _mm_storeu_si128((__m128i *) (out + i*2), outv);\n#elif defined(STBI_NEON)\n      // load and perform the vertical filtering pass\n      // this uses 3*x + y = 4*x + (y - x)\n      uint8x8_t farb  = vld1_u8(in_far + i);\n      uint8x8_t nearb = vld1_u8(in_near + i);\n      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));\n      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));\n      int16x8_t curr  = vaddq_s16(nears, diff); // current row\n\n      // horizontal filter works the same based on shifted vers of current\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\n      // insert the previous pixel value (from t1).\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\n      // of next block of 8 pixels added in.\n      int16x8_t prv0 = vextq_s16(curr, curr, 7);\n      int16x8_t nxt0 = vextq_s16(curr, curr, 1);\n      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);\n      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);\n\n      // horizontal filter, polyphase implementation since it's convenient:\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\n      // note the shared term.\n      int16x8_t curs = vshlq_n_s16(curr, 2);\n      int16x8_t prvd = vsubq_s16(prev, curr);\n      int16x8_t nxtd = vsubq_s16(next, curr);\n      int16x8_t even = vaddq_s16(curs, prvd);\n      int16x8_t odd  = vaddq_s16(curs, nxtd);\n\n      // undo scaling and round, then store with even/odd phases interleaved\n      uint8x8x2_t o;\n      o.val[0] = vqrshrun_n_s16(even, 4);\n      o.val[1] = vqrshrun_n_s16(odd,  4);\n      vst2_u8(out + i*2, o);\n#endif\n\n      // \"previous\" value for next iter\n      t1 = 3*in_near[i+7] + in_far[i+7];\n   }\n\n   t0 = t1;\n   t1 = 3*in_near[i] + in_far[i];\n   out[i*2] = stbi__div16(3*t1 + t0 + 8);\n\n   for (++i; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n#endif\n\nstatic stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // resample with nearest-neighbor\n   int i,j;\n   STBI_NOTUSED(in_far);\n   for (i=0; i < w; ++i)\n      for (j=0; j < hs; ++j)\n         out[i*hs+j] = in_near[i];\n   return out;\n}\n\n// this is a reduced-precision calculation of YCbCr-to-RGB introduced\n// to make sure the code produces the same results in both SIMD and scalar\n#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)\n{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed +  cr* stbi__float2fixed(1.40200f);\n      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\n      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);\n      r >>= 20;\n      g >>= 20;\n      b >>= 20;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n\n#if defined(STBI_SSE2) || defined(STBI_NEON)\nstatic void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)\n{\n   int i = 0;\n\n#ifdef STBI_SSE2\n   // step == 3 is pretty ugly on the final interleave, and i'm not convinced\n   // it's useful in practice (you wouldn't use it for textures, for example).\n   // so just accelerate step == 4 case.\n   if (step == 4) {\n      // this is a fairly straightforward implementation and not super-optimized.\n      __m128i signflip  = _mm_set1_epi8(-0x80);\n      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));\n      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));\n      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));\n      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));\n      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);\n      __m128i xw = _mm_set1_epi16(255); // alpha channel\n\n      for (; i+7 < count; i += 8) {\n         // load\n         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));\n         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));\n         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));\n         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128\n         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128\n\n         // unpack to short (and left-shift cr, cb by 8)\n         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);\n         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);\n         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);\n\n         // color transform\n         __m128i yws = _mm_srli_epi16(yw, 4);\n         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);\n         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);\n         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);\n         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);\n         __m128i rws = _mm_add_epi16(cr0, yws);\n         __m128i gwt = _mm_add_epi16(cb0, yws);\n         __m128i bws = _mm_add_epi16(yws, cb1);\n         __m128i gws = _mm_add_epi16(gwt, cr1);\n\n         // descale\n         __m128i rw = _mm_srai_epi16(rws, 4);\n         __m128i bw = _mm_srai_epi16(bws, 4);\n         __m128i gw = _mm_srai_epi16(gws, 4);\n\n         // back to byte, set up for transpose\n         __m128i brb = _mm_packus_epi16(rw, bw);\n         __m128i gxb = _mm_packus_epi16(gw, xw);\n\n         // transpose to interleave channels\n         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);\n         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);\n         __m128i o0 = _mm_unpacklo_epi16(t0, t1);\n         __m128i o1 = _mm_unpackhi_epi16(t0, t1);\n\n         // store\n         _mm_storeu_si128((__m128i *) (out + 0), o0);\n         _mm_storeu_si128((__m128i *) (out + 16), o1);\n         out += 32;\n      }\n   }\n#endif\n\n#ifdef STBI_NEON\n   // in this version, step=3 support would be easy to add. but is there demand?\n   if (step == 4) {\n      // this is a fairly straightforward implementation and not super-optimized.\n      uint8x8_t signflip = vdup_n_u8(0x80);\n      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));\n      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));\n      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));\n      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));\n\n      for (; i+7 < count; i += 8) {\n         // load\n         uint8x8_t y_bytes  = vld1_u8(y + i);\n         uint8x8_t cr_bytes = vld1_u8(pcr + i);\n         uint8x8_t cb_bytes = vld1_u8(pcb + i);\n         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));\n         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));\n\n         // expand to s16\n         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));\n         int16x8_t crw = vshll_n_s8(cr_biased, 7);\n         int16x8_t cbw = vshll_n_s8(cb_biased, 7);\n\n         // color transform\n         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);\n         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);\n         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);\n         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);\n         int16x8_t rws = vaddq_s16(yws, cr0);\n         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);\n         int16x8_t bws = vaddq_s16(yws, cb1);\n\n         // undo scaling, round, convert to byte\n         uint8x8x4_t o;\n         o.val[0] = vqrshrun_n_s16(rws, 4);\n         o.val[1] = vqrshrun_n_s16(gws, 4);\n         o.val[2] = vqrshrun_n_s16(bws, 4);\n         o.val[3] = vdup_n_u8(255);\n\n         // store, interleaving r/g/b/a\n         vst4_u8(out, o);\n         out += 8*4;\n      }\n   }\n#endif\n\n   for (; i < count; ++i) {\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr* stbi__float2fixed(1.40200f);\n      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\n      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);\n      r >>= 20;\n      g >>= 20;\n      b >>= 20;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n#endif\n\n// set up the kernels\nstatic void stbi__setup_jpeg(stbi__jpeg *j)\n{\n   j->idct_block_kernel = stbi__idct_block;\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;\n\n#ifdef STBI_SSE2\n   if (stbi__sse2_available()) {\n      j->idct_block_kernel = stbi__idct_simd;\n      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\n      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\n   }\n#endif\n\n#ifdef STBI_NEON\n   j->idct_block_kernel = stbi__idct_simd;\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\n#endif\n}\n\n// clean up the temporary component buffers\nstatic void stbi__cleanup_jpeg(stbi__jpeg *j)\n{\n   stbi__free_jpeg_components(j, j->s->img_n, 0);\n}\n\ntypedef struct\n{\n   resample_row_func resample;\n   stbi_uc *line0,*line1;\n   int hs,vs;   // expansion factor in each axis\n   int w_lores; // horizontal pixels pre-expansion\n   int ystep;   // how far through vertical expansion we are\n   int ypos;    // which pre-expansion row we're on\n} stbi__resample;\n\n// fast 0..255 * 0..255 => 0..255 rounded multiplication\nstatic stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)\n{\n   unsigned int t = x*y + 128;\n   return (stbi_uc) ((t + (t >>8)) >> 8);\n}\n\nstatic stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)\n{\n   int n, decode_n, is_rgb;\n   z->s->img_n = 0; // make stbi__cleanup_jpeg safe\n\n   // validate req_comp\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n\n   // load a jpeg image from whichever source, but leave in YCbCr format\n   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // determine actual number of components to generate\n   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;\n\n   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));\n\n   if (z->s->img_n == 3 && n < 3 && !is_rgb)\n      decode_n = 1;\n   else\n      decode_n = z->s->img_n;\n\n   // nothing to do if no components requested; check this now to avoid\n   // accessing uninitialized coutput[0] later\n   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // resample and color-convert\n   {\n      int k;\n      unsigned int i,j;\n      stbi_uc *output;\n      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };\n\n      stbi__resample res_comp[4];\n\n      for (k=0; k < decode_n; ++k) {\n         stbi__resample *r = &res_comp[k];\n\n         // allocate line buffer big enough for upsampling off the edges\n         // with upsample factor of 4\n         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);\n         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n         r->hs      = z->img_h_max / z->img_comp[k].h;\n         r->vs      = z->img_v_max / z->img_comp[k].v;\n         r->ystep   = r->vs >> 1;\n         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;\n         r->ypos    = 0;\n         r->line0   = r->line1 = z->img_comp[k].data;\n\n         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\n         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\n         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\n         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;\n         else                               r->resample = stbi__resample_row_generic;\n      }\n\n      // can't error after this so, this is safe\n      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);\n      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n      // now go ahead and resample\n      for (j=0; j < z->s->img_y; ++j) {\n         stbi_uc *out = output + n * z->s->img_x * j;\n         for (k=0; k < decode_n; ++k) {\n            stbi__resample *r = &res_comp[k];\n            int y_bot = r->ystep >= (r->vs >> 1);\n            coutput[k] = r->resample(z->img_comp[k].linebuf,\n                                     y_bot ? r->line1 : r->line0,\n                                     y_bot ? r->line0 : r->line1,\n                                     r->w_lores, r->hs);\n            if (++r->ystep >= r->vs) {\n               r->ystep = 0;\n               r->line0 = r->line1;\n               if (++r->ypos < z->img_comp[k].y)\n                  r->line1 += z->img_comp[k].w2;\n            }\n         }\n         if (n >= 3) {\n            stbi_uc *y = coutput[0];\n            if (z->s->img_n == 3) {\n               if (is_rgb) {\n                  for (i=0; i < z->s->img_x; ++i) {\n                     out[0] = y[i];\n                     out[1] = coutput[1][i];\n                     out[2] = coutput[2][i];\n                     out[3] = 255;\n                     out += n;\n                  }\n               } else {\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               }\n            } else if (z->s->img_n == 4) {\n               if (z->app14_color_transform == 0) { // CMYK\n                  for (i=0; i < z->s->img_x; ++i) {\n                     stbi_uc m = coutput[3][i];\n                     out[0] = stbi__blinn_8x8(coutput[0][i], m);\n                     out[1] = stbi__blinn_8x8(coutput[1][i], m);\n                     out[2] = stbi__blinn_8x8(coutput[2][i], m);\n                     out[3] = 255;\n                     out += n;\n                  }\n               } else if (z->app14_color_transform == 2) { // YCCK\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n                  for (i=0; i < z->s->img_x; ++i) {\n                     stbi_uc m = coutput[3][i];\n                     out[0] = stbi__blinn_8x8(255 - out[0], m);\n                     out[1] = stbi__blinn_8x8(255 - out[1], m);\n                     out[2] = stbi__blinn_8x8(255 - out[2], m);\n                     out += n;\n                  }\n               } else { // YCbCr + alpha?  Ignore the fourth channel for now\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               }\n            } else\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = out[1] = out[2] = y[i];\n                  out[3] = 255; // not used if n==3\n                  out += n;\n               }\n         } else {\n            if (is_rgb) {\n               if (n == 1)\n                  for (i=0; i < z->s->img_x; ++i)\n                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\n               else {\n                  for (i=0; i < z->s->img_x; ++i, out += 2) {\n                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\n                     out[1] = 255;\n                  }\n               }\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {\n               for (i=0; i < z->s->img_x; ++i) {\n                  stbi_uc m = coutput[3][i];\n                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);\n                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);\n                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);\n                  out[0] = stbi__compute_y(r, g, b);\n                  out[1] = 255;\n                  out += n;\n               }\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);\n                  out[1] = 255;\n                  out += n;\n               }\n            } else {\n               stbi_uc *y = coutput[0];\n               if (n == 1)\n                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];\n               else\n                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }\n            }\n         }\n      }\n      stbi__cleanup_jpeg(z);\n      *out_x = z->s->img_x;\n      *out_y = z->s->img_y;\n      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output\n      return output;\n   }\n}\n\nstatic void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   unsigned char* result;\n   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));\n   if (!j) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   STBI_NOTUSED(ri);\n   j->s = s;\n   stbi__setup_jpeg(j);\n   result = load_jpeg_image(j, x,y,comp,req_comp);\n   STBI_FREE(j);\n   return result;\n}\n\nstatic int stbi__jpeg_test(stbi__context *s)\n{\n   int r;\n   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\n   if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\n   j->s = s;\n   stbi__setup_jpeg(j);\n   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);\n   stbi__rewind(s);\n   STBI_FREE(j);\n   return r;\n}\n\nstatic int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)\n{\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {\n      stbi__rewind( j->s );\n      return 0;\n   }\n   if (x) *x = j->s->img_x;\n   if (y) *y = j->s->img_y;\n   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;\n   return 1;\n}\n\nstatic int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int result;\n   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));\n   if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\n   j->s = s;\n   result = stbi__jpeg_info_raw(j, x, y, comp);\n   STBI_FREE(j);\n   return result;\n}\n#endif\n\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\n//    simple implementation\n//      - all input must be provided in an upfront buffer\n//      - all output is written to a single output buffer (can malloc/realloc)\n//    performance\n//      - fast huffman\n\n#ifndef STBI_NO_ZLIB\n\n// fast-way is faster to check than jpeg huffman, but slow way is slower\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\n#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet\n\n// zlib-style huffman encoding\n// (jpegs packs from left, zlib from right, so can't share code)\ntypedef struct\n{\n   stbi__uint16 fast[1 << STBI__ZFAST_BITS];\n   stbi__uint16 firstcode[16];\n   int maxcode[17];\n   stbi__uint16 firstsymbol[16];\n   stbi_uc  size[STBI__ZNSYMS];\n   stbi__uint16 value[STBI__ZNSYMS];\n} stbi__zhuffman;\n\nstbi_inline static int stbi__bitreverse16(int n)\n{\n  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);\n  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);\n  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);\n  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);\n  return n;\n}\n\nstbi_inline static int stbi__bit_reverse(int v, int bits)\n{\n   STBI_ASSERT(bits <= 16);\n   // to bit reverse n bits, reverse 16 and shift\n   // e.g. 11 bits, bit reverse and shift away 5\n   return stbi__bitreverse16(v) >> (16-bits);\n}\n\nstatic int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)\n{\n   int i,k=0;\n   int code, next_code[16], sizes[17];\n\n   // DEFLATE spec for generating codes\n   MemSet(sizes, 0, sizeof(sizes));\n   MemSet(z->fast, 0, sizeof(z->fast));\n   for (i=0; i < num; ++i)\n      ++sizes[sizelist[i]];\n   sizes[0] = 0;\n   for (i=1; i < 16; ++i)\n      if (sizes[i] > (1 << i))\n         return stbi__err(\"bad sizes\", \"Corrupt PNG\");\n   code = 0;\n   for (i=1; i < 16; ++i) {\n      next_code[i] = code;\n      z->firstcode[i] = (stbi__uint16) code;\n      z->firstsymbol[i] = (stbi__uint16) k;\n      code = (code + sizes[i]);\n      if (sizes[i])\n         if (code-1 >= (1 << i)) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n      z->maxcode[i] = code << (16-i); // preshift for inner loop\n      code <<= 1;\n      k += sizes[i];\n   }\n   z->maxcode[16] = 0x10000; // sentinel\n   for (i=0; i < num; ++i) {\n      int s = sizelist[i];\n      if (s) {\n         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\n         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);\n         z->size [c] = (stbi_uc     ) s;\n         z->value[c] = (stbi__uint16) i;\n         if (s <= STBI__ZFAST_BITS) {\n            int j = stbi__bit_reverse(next_code[s],s);\n            while (j < (1 << STBI__ZFAST_BITS)) {\n               z->fast[j] = fastv;\n               j += (1 << s);\n            }\n         }\n         ++next_code[s];\n      }\n   }\n   return 1;\n}\n\n// zlib-from-memory implementation for PNG reading\n//    because PNG allows splitting the zlib stream arbitrarily,\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\n//    we require PNG read all the IDATs and combine them into a single\n//    memory buffer\n\ntypedef struct\n{\n   stbi_uc *zbuffer, *zbuffer_end;\n   int num_bits;\n   stbi__uint32 code_buffer;\n\n   char *zout;\n   char *zout_start;\n   char *zout_end;\n   int   z_expandable;\n\n   stbi__zhuffman z_length, z_distance;\n} stbi__zbuf;\n\nstbi_inline static int stbi__zeof(stbi__zbuf *z)\n{\n   return (z->zbuffer >= z->zbuffer_end);\n}\n\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)\n{\n   return stbi__zeof(z) ? 0 : *z->zbuffer++;\n}\n\nstatic void stbi__fill_bits(stbi__zbuf *z)\n{\n   do {\n      if (z->code_buffer >= (1U << z->num_bits)) {\n        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */\n        return;\n      }\n      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;\n      z->num_bits += 8;\n   } while (z->num_bits <= 24);\n}\n\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)\n{\n   unsigned int k;\n   if (z->num_bits < n) stbi__fill_bits(z);\n   k = z->code_buffer & ((1 << n) - 1);\n   z->code_buffer >>= n;\n   z->num_bits -= n;\n   return k;\n}\n\nstatic int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s,k;\n   // not resolved by fast table, so compute it the slow way\n   // use jpeg approach, which requires MSbits at top\n   k = stbi__bit_reverse(a->code_buffer, 16);\n   for (s=STBI__ZFAST_BITS+1; ; ++s)\n      if (k < z->maxcode[s])\n         break;\n   if (s >= 16) return -1; // invalid code!\n   // code size is s, so:\n   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];\n   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!\n   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.\n   a->code_buffer >>= s;\n   a->num_bits -= s;\n   return z->value[b];\n}\n\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s;\n   if (a->num_bits < 16) {\n      if (stbi__zeof(a)) {\n         return -1;   /* report error for unexpected end of data. */\n      }\n      stbi__fill_bits(a);\n   }\n   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\n   if (b) {\n      s = b >> 9;\n      a->code_buffer >>= s;\n      a->num_bits -= s;\n      return b & 511;\n   }\n   return stbi__zhuffman_decode_slowpath(a, z);\n}\n\nstatic int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes\n{\n   char *q;\n   unsigned int cur, limit, old_limit;\n   z->zout = zout;\n   if (!z->z_expandable) return stbi__err(\"output buffer limit\",\"Corrupt PNG\");\n   cur   = (unsigned int) (z->zout - z->zout_start);\n   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);\n   if (STBI_UINT_MAX - cur < (unsigned) n) return stbi__err(\"outofmem\", \"Out of memory\");\n   while (cur + n > limit) {\n      if(limit > STBI_UINT_MAX / 2) return stbi__err(\"outofmem\", \"Out of memory\");\n      limit *= 2;\n   }\n   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);\n   STBI_NOTUSED(old_limit);\n   if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n   z->zout_start = q;\n   z->zout       = q + cur;\n   z->zout_end   = q + limit;\n   return 1;\n}\n\nstatic const int stbi__zlength_base[31] = {\n   3,4,5,6,7,8,9,10,11,13,\n   15,17,19,23,27,31,35,43,51,59,\n   67,83,99,115,131,163,195,227,258,0,0 };\n\nstatic const int stbi__zlength_extra[31]=\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\n\nstatic const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\n\nstatic const int stbi__zdist_extra[32] =\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nstatic int stbi__parse_huffman_block(stbi__zbuf *a)\n{\n   char *zout = a->zout;\n   for(;;) {\n      int z = stbi__zhuffman_decode(a, &a->z_length);\n      if (z < 256) {\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // error in huffman codes\n         if (zout >= a->zout_end) {\n            if (!stbi__zexpand(a, zout, 1)) return 0;\n            zout = a->zout;\n         }\n         *zout++ = (char) z;\n      } else {\n         stbi_uc *p;\n         int len,dist;\n         if (z == 256) {\n            a->zout = zout;\n            return 1;\n         }\n         z -= 257;\n         len = stbi__zlength_base[z];\n         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\n         z = stbi__zhuffman_decode(a, &a->z_distance);\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\");\n         dist = stbi__zdist_base[z];\n         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\n         if (zout - a->zout_start < dist) return stbi__err(\"bad dist\",\"Corrupt PNG\");\n         if (zout + len > a->zout_end) {\n            if (!stbi__zexpand(a, zout, len)) return 0;\n            zout = a->zout;\n         }\n         p = (stbi_uc *) (zout - dist);\n         if (dist == 1) { // run of one byte; common in images.\n            stbi_uc v = *p;\n            if (len) { do *zout++ = v; while (--len); }\n         } else {\n            if (len) { do *zout++ = *p++; while (--len); }\n         }\n      }\n   }\n}\n\nstatic int stbi__compute_huffman_codes(stbi__zbuf *a)\n{\n   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\n   stbi__zhuffman z_codelength;\n   stbi_uc lencodes[286+32+137];//padding for maximum single op\n   stbi_uc codelength_sizes[19];\n   int i,n;\n\n   int hlit  = stbi__zreceive(a,5) + 257;\n   int hdist = stbi__zreceive(a,5) + 1;\n   int hclen = stbi__zreceive(a,4) + 4;\n   int ntot  = hlit + hdist;\n\n   MemSet(codelength_sizes, 0, sizeof(codelength_sizes));\n   for (i=0; i < hclen; ++i) {\n      int s = stbi__zreceive(a,3);\n      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;\n   }\n   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\n\n   n = 0;\n   while (n < ntot) {\n      int c = stbi__zhuffman_decode(a, &z_codelength);\n      if (c < 0 || c >= 19) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n      if (c < 16)\n         lencodes[n++] = (stbi_uc) c;\n      else {\n         stbi_uc fill = 0;\n         if (c == 16) {\n            c = stbi__zreceive(a,2)+3;\n            if (n == 0) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n            fill = lencodes[n-1];\n         } else if (c == 17) {\n            c = stbi__zreceive(a,3)+3;\n         } else if (c == 18) {\n            c = stbi__zreceive(a,7)+11;\n         } else {\n            return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n         }\n         if (ntot - n < c) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n         MemSet(lencodes+n, fill, c);\n         n += c;\n      }\n   }\n   if (n != ntot) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\n   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;\n   return 1;\n}\n\nstatic int stbi__parse_uncompressed_block(stbi__zbuf *a)\n{\n   stbi_uc header[4];\n   int len,nlen,k;\n   if (a->num_bits & 7)\n      stbi__zreceive(a, a->num_bits & 7); // discard\n   // drain the bit-packed data into header\n   k = 0;\n   while (a->num_bits > 0) {\n      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check\n      a->code_buffer >>= 8;\n      a->num_bits -= 8;\n   }\n   if (a->num_bits < 0) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   // now fill header the normal way\n   while (k < 4)\n      header[k++] = stbi__zget8(a);\n   len  = header[1] * 256 + header[0];\n   nlen = header[3] * 256 + header[2];\n   if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\",\"Corrupt PNG\");\n   if (a->zout + len > a->zout_end)\n      if (!stbi__zexpand(a, a->zout, len)) return 0;\n   MemCopy(a->zout, a->zbuffer, len);\n   a->zbuffer += len;\n   a->zout += len;\n   return 1;\n}\n\nstatic int stbi__parse_zlib_header(stbi__zbuf *a)\n{\n   int cmf   = stbi__zget8(a);\n   int cm    = cmf & 15;\n   /* int cinfo = cmf >> 4; */\n   int flg   = stbi__zget8(a);\n   if (stbi__zeof(a)) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if ((cmf*256+flg) % 31 != 0) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if (flg & 32) return stbi__err(\"no preset dict\",\"Corrupt PNG\"); // preset dictionary not allowed in png\n   if (cm != 8) return stbi__err(\"bad compression\",\"Corrupt PNG\"); // DEFLATE required for png\n   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\n   return 1;\n}\n\nstatic const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =\n{\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8\n};\nstatic const stbi_uc stbi__zdefault_distance[32] =\n{\n   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\n};\n/*\nInit algorithm:\n{\n   int i;   // use <= to match clearly with spec\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\n\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\n}\n*/\n\nstatic int stbi__parse_zlib(stbi__zbuf *a, int parse_header)\n{\n   int final, type;\n   if (parse_header)\n      if (!stbi__parse_zlib_header(a)) return 0;\n   a->num_bits = 0;\n   a->code_buffer = 0;\n   do {\n      final = stbi__zreceive(a,1);\n      type = stbi__zreceive(a,2);\n      if (type == 0) {\n         if (!stbi__parse_uncompressed_block(a)) return 0;\n      } else if (type == 3) {\n         return 0;\n      } else {\n         if (type == 1) {\n            // use fixed code lengths\n            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;\n            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;\n         } else {\n            if (!stbi__compute_huffman_codes(a)) return 0;\n         }\n         if (!stbi__parse_huffman_block(a)) return 0;\n      }\n   } while (!final);\n   return 1;\n}\n\nstatic int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)\n{\n   a->zout_start = obuf;\n   a->zout       = obuf;\n   a->zout_end   = obuf + olen;\n   a->z_expandable = exp;\n\n   return stbi__parse_zlib(a, parse_header);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)\n{\n   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(16384);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer+len;\n   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n#endif\n\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\n//    simple implementation\n//      - only 8-bit samples\n//      - no CRC checking\n//      - allocates lots of intermediate memory\n//        - avoids problem of streaming data between subsystems\n//        - avoids explicit window management\n//    performance\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\n\n#ifndef STBI_NO_PNG\ntypedef struct\n{\n   stbi__uint32 length;\n   stbi__uint32 type;\n} stbi__pngchunk;\n\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context *s)\n{\n   stbi__pngchunk c;\n   c.length = stbi__get32be(s);\n   c.type   = stbi__get32be(s);\n   return c;\n}\n\nstatic int stbi__check_png_header(stbi__context *s)\n{\n   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\n   int i;\n   for (i=0; i < 8; ++i)\n      if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\",\"Not a PNG\");\n   return 1;\n}\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi_uc *idata, *expanded, *out;\n   int depth;\n} stbi__png;\n\n\nenum {\n   STBI__F_none=0,\n   STBI__F_sub=1,\n   STBI__F_up=2,\n   STBI__F_avg=3,\n   STBI__F_paeth=4,\n   // synthetic filters used for first scanline to avoid needing a dummy row of 0s\n   STBI__F_avg_first,\n   STBI__F_paeth_first\n};\n\nstatic stbi_uc first_row_filter[5] =\n{\n   STBI__F_none,\n   STBI__F_sub,\n   STBI__F_none,\n   STBI__F_avg_first,\n   STBI__F_paeth_first\n};\n\nstatic int stbi__paeth(int a, int b, int c)\n{\n   int p = a + b - c;\n   int pa = MathAbsI(p-a);\n   int pb = MathAbsI(p-b);\n   int pc = MathAbsI(p-c);\n   if (pa <= pb && pa <= pc) return a;\n   if (pb <= pc) return b;\n   return c;\n}\n\nstatic const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };\n\n// create the png data from post-deflated data\nstatic int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)\n{\n   int bytes = (depth == 16? 2 : 1);\n   stbi__context *s = a->s;\n   stbi__uint32 i,j,stride = x*out_n*bytes;\n   stbi__uint32 img_len, img_width_bytes;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n\n   int output_bytes = out_n*bytes;\n   int filter_bytes = img_n*bytes;\n   int width = x;\n\n   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);\n   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into\n   if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(\"too large\", \"Corrupt PNG\");\n   img_width_bytes = (((img_n * x * depth) + 7) >> 3);\n   img_len = (img_width_bytes + 1) * y;\n\n   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,\n   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),\n   // so just check for raw_len < img_len always.\n   if (raw_len < img_len) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\n\n   for (j=0; j < y; ++j) {\n      stbi_uc *cur = a->out + stride*j;\n      stbi_uc *prior;\n      int filter = *raw++;\n\n      if (filter > 4)\n         return stbi__err(\"invalid filter\",\"Corrupt PNG\");\n\n      if (depth < 8) {\n         if (img_width_bytes > x) return stbi__err(\"invalid width\",\"Corrupt PNG\");\n         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place\n         filter_bytes = 1;\n         width = img_width_bytes;\n      }\n      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above\n\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n\n      // handle first byte explicitly\n      for (k=0; k < filter_bytes; ++k) {\n         switch (filter) {\n            case STBI__F_none       : cur[k] = raw[k]; break;\n            case STBI__F_sub        : cur[k] = raw[k]; break;\n            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\n            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;\n            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;\n            case STBI__F_avg_first  : cur[k] = raw[k]; break;\n            case STBI__F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n\n      if (depth == 8) {\n         if (img_n != out_n)\n            cur[img_n] = 255; // first pixel\n         raw += img_n;\n         cur += out_n;\n         prior += out_n;\n      } else if (depth == 16) {\n         if (img_n != out_n) {\n            cur[filter_bytes]   = 255; // first pixel top byte\n            cur[filter_bytes+1] = 255; // first pixel bottom byte\n         }\n         raw += filter_bytes;\n         cur += output_bytes;\n         prior += output_bytes;\n      } else {\n         raw += 1;\n         cur += 1;\n         prior += 1;\n      }\n\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (depth < 8 || img_n == out_n) {\n         int nk = (width - 1)*filter_bytes;\n         #define STBI__CASE(f) \\\n             case f:     \\\n                for (k=0; k < nk; ++k)\n         switch (filter) {\n            // \"none\" filter turns into a MemCopy here; make that explicit.\n            case STBI__F_none:         MemCopy(cur, raw, nk); break;\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;\n         }\n         #undef STBI__CASE\n         raw += nk;\n      } else {\n         STBI_ASSERT(img_n+1 == out_n);\n         #define STBI__CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \\\n                   for (k=0; k < filter_bytes; ++k)\n         switch (filter) {\n            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;\n         }\n         #undef STBI__CASE\n\n         // the loop above sets the high byte of the pixels' alpha, but for\n         // 16 bit png files we also need the low byte set. we'll do that here.\n         if (depth == 16) {\n            cur = a->out + stride*j; // start at the beginning of the row again\n            for (i=0; i < x; ++i,cur+=output_bytes) {\n               cur[filter_bytes+1] = 255;\n            }\n         }\n      }\n   }\n\n   // we make a separate pass to expand bits to pixels; for performance,\n   // this could run two scanlines behind the above code, so it won't\n   // intefere with filtering but will still be in the cache.\n   if (depth < 8) {\n      for (j=0; j < y; ++j) {\n         stbi_uc *cur = a->out + stride*j;\n         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;\n         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit\n         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop\n         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range\n\n         // note that the final byte might overshoot and write more data than desired.\n         // we can allocate enough data that this never writes out of memory, but it\n         // could also overwrite the next scanline. can it overwrite non-empty data\n         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.\n         // so we need to explicitly clamp the final ones\n\n         if (depth == 4) {\n            for (k=x*img_n; k >= 2; k-=2, ++in) {\n               *cur++ = scale * ((*in >> 4)       );\n               *cur++ = scale * ((*in     ) & 0x0f);\n            }\n            if (k > 0) *cur++ = scale * ((*in >> 4)       );\n         } else if (depth == 2) {\n            for (k=x*img_n; k >= 4; k-=4, ++in) {\n               *cur++ = scale * ((*in >> 6)       );\n               *cur++ = scale * ((*in >> 4) & 0x03);\n               *cur++ = scale * ((*in >> 2) & 0x03);\n               *cur++ = scale * ((*in     ) & 0x03);\n            }\n            if (k > 0) *cur++ = scale * ((*in >> 6)       );\n            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);\n            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);\n         } else if (depth == 1) {\n            for (k=x*img_n; k >= 8; k-=8, ++in) {\n               *cur++ = scale * ((*in >> 7)       );\n               *cur++ = scale * ((*in >> 6) & 0x01);\n               *cur++ = scale * ((*in >> 5) & 0x01);\n               *cur++ = scale * ((*in >> 4) & 0x01);\n               *cur++ = scale * ((*in >> 3) & 0x01);\n               *cur++ = scale * ((*in >> 2) & 0x01);\n               *cur++ = scale * ((*in >> 1) & 0x01);\n               *cur++ = scale * ((*in     ) & 0x01);\n            }\n            if (k > 0) *cur++ = scale * ((*in >> 7)       );\n            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);\n            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);\n            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);\n            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);\n            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);\n            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);\n         }\n         if (img_n != out_n) {\n            int q;\n            // insert alpha = 255\n            cur = a->out + stride*j;\n            if (img_n == 1) {\n               for (q=x-1; q >= 0; --q) {\n                  cur[q*2+1] = 255;\n                  cur[q*2+0] = cur[q];\n               }\n            } else {\n               STBI_ASSERT(img_n == 3);\n               for (q=x-1; q >= 0; --q) {\n                  cur[q*4+3] = 255;\n                  cur[q*4+2] = cur[q*3+2];\n                  cur[q*4+1] = cur[q*3+1];\n                  cur[q*4+0] = cur[q*3+0];\n               }\n            }\n         }\n      }\n   } else if (depth == 16) {\n      // force the image data from big-endian to platform-native.\n      // this is done in a separate pass due to the decoding relying\n      // on the data being untouched, but could probably be done\n      // per-line during decode if care is taken.\n      stbi_uc *cur = a->out;\n      stbi__uint16 *cur16 = (stbi__uint16*)cur;\n\n      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {\n         *cur16 = (cur[0] << 8) | cur[1];\n      }\n   }\n\n   return 1;\n}\n\nstatic int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)\n{\n   int bytes = (depth == 16 ? 2 : 1);\n   int out_bytes = out_n * bytes;\n   stbi_uc *final;\n   int p;\n   if (!interlaced)\n      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);\n\n   // de-interlacing\n   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);\n   if (!final) return stbi__err(\"outofmem\", \"Out of memory\");\n   for (p=0; p < 7; ++p) {\n      int xorig[] = { 0,4,0,2,0,1,0 };\n      int yorig[] = { 0,0,4,0,2,0,1 };\n      int xspc[]  = { 8,8,4,4,2,2,1 };\n      int yspc[]  = { 8,8,8,4,4,2,2 };\n      int i,j,x,y;\n      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\n      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];\n      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];\n      if (x && y) {\n         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;\n         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {\n            STBI_FREE(final);\n            return 0;\n         }\n         for (j=0; j < y; ++j) {\n            for (i=0; i < x; ++i) {\n               int out_y = j*yspc[p]+yorig[p];\n               int out_x = i*xspc[p]+xorig[p];\n               MemCopy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,\n                      a->out + (j*x+i)*out_bytes, out_bytes);\n            }\n         }\n         STBI_FREE(a->out);\n         image_data += img_len;\n         image_data_len -= img_len;\n      }\n   }\n   a->out = final;\n\n   return 1;\n}\n\nstatic int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 255 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i=0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 255);\n         p += 2;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi__uint16 *p = (stbi__uint16*) z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 65535 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i = 0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 65535);\n         p += 2;\n      }\n   } else {\n      for (i = 0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)\n{\n   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\n   stbi_uc *p, *temp_out, *orig = a->out;\n\n   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);\n   if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   // between here and free(out) below, exitting would leak\n   temp_out = p;\n\n   if (pal_img_n == 3) {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p += 3;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p[3] = palette[n+3];\n         p += 4;\n      }\n   }\n   STBI_FREE(a->out);\n   a->out = temp_out;\n\n   STBI_NOTUSED(len);\n\n   return 1;\n}\n\nstatic int stbi__unpremultiply_on_load_global = 0;\nstatic int stbi__de_iphone_flag_global = 0;\n\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag_global = flag_true_if_should_convert;\n}\n\n#ifndef STBI_THREAD_LOCAL\n#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global\n#define stbi__de_iphone_flag  stbi__de_iphone_flag_global\n#else\nstatic STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;\nstatic STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;\n\nSTBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;\n   stbi__unpremultiply_on_load_set = 1;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag_local = flag_true_if_should_convert;\n   stbi__de_iphone_flag_set = 1;\n}\n\n#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \\\n                                       ? stbi__unpremultiply_on_load_local      \\\n                                       : stbi__unpremultiply_on_load_global)\n#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \\\n                                ? stbi__de_iphone_flag_local                    \\\n                                : stbi__de_iphone_flag_global)\n#endif // STBI_THREAD_LOCAL\n\nstatic void stbi__de_iphone(stbi__png *z)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   if (s->img_out_n == 3) {  // convert bgr to rgb\n      for (i=0; i < pixel_count; ++i) {\n         stbi_uc t = p[0];\n         p[0] = p[2];\n         p[2] = t;\n         p += 3;\n      }\n   } else {\n      STBI_ASSERT(s->img_out_n == 4);\n      if (stbi__unpremultiply_on_load) {\n         // convert bgr to rgb and unpremultiply\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc a = p[3];\n            stbi_uc t = p[0];\n            if (a) {\n               stbi_uc half = a / 2;\n               p[0] = (p[2] * 255 + half) / a;\n               p[1] = (p[1] * 255 + half) / a;\n               p[2] = ( t   * 255 + half) / a;\n            } else {\n               p[0] = p[2];\n               p[2] = t;\n            }\n            p += 4;\n         }\n      } else {\n         // convert bgr to rgb\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc t = p[0];\n            p[0] = p[2];\n            p[2] = t;\n            p += 4;\n         }\n      }\n   }\n}\n\n#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))\n\nstatic int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)\n{\n   stbi_uc palette[1024], pal_img_n=0;\n   stbi_uc has_trans=0, tc[3]={0};\n   stbi__uint16 tc16[3];\n   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;\n   int first=1,k,interlace=0, color=0, is_iphone=0;\n   stbi__context *s = z->s;\n\n   z->expanded = NULL;\n   z->idata = NULL;\n   z->out = NULL;\n\n   if (!stbi__check_png_header(s)) return 0;\n\n   if (scan == STBI__SCAN_type) return 1;\n\n   for (;;) {\n      stbi__pngchunk c = stbi__get_chunk_header(s);\n      switch (c.type) {\n         case STBI__PNG_TYPE('C','g','B','I'):\n            is_iphone = 1;\n            stbi__skip(s, c.length);\n            break;\n         case STBI__PNG_TYPE('I','H','D','R'): {\n            int comp,filter;\n            if (!first) return stbi__err(\"multiple IHDR\",\"Corrupt PNG\");\n            first = 0;\n            if (c.length != 13) return stbi__err(\"bad IHDR len\",\"Corrupt PNG\");\n            s->img_x = stbi__get32be(s);\n            s->img_y = stbi__get32be(s);\n            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(\"1/2/4/8/16-bit only\",\"PNG not supported: 1/2/4/8/16-bit only\");\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3 && z->depth == 16)                  return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            comp  = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\",\"Corrupt PNG\");\n            filter= stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\",\"Corrupt PNG\");\n            interlace = stbi__get8(s); if (interlace>1) return stbi__err(\"bad interlace method\",\"Corrupt PNG\");\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\",\"Corrupt PNG\");\n            if (!pal_img_n) {\n               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\n               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\n               if (scan == STBI__SCAN_header) return 1;\n            } else {\n               // if paletted, then pal_n is our final components, and\n               // img_n is # components to decompress/filter.\n               s->img_n = 1;\n               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\",\"Corrupt PNG\");\n               // if SCAN_header, have to scan to see if we have a tRNS\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('P','L','T','E'):  {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (c.length > 256*3) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            pal_len = c.length / 3;\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            for (i=0; i < pal_len; ++i) {\n               palette[i*4+0] = stbi__get8(s);\n               palette[i*4+1] = stbi__get8(s);\n               palette[i*4+2] = stbi__get8(s);\n               palette[i*4+3] = 255;\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('t','R','N','S'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (z->idata) return stbi__err(\"tRNS after IDAT\",\"Corrupt PNG\");\n            if (pal_img_n) {\n               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }\n               if (pal_len == 0) return stbi__err(\"tRNS before PLTE\",\"Corrupt PNG\");\n               if (c.length > pal_len) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               pal_img_n = 4;\n               for (i=0; i < c.length; ++i)\n                  palette[i*4+3] = stbi__get8(s);\n            } else {\n               if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\",\"Corrupt PNG\");\n               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               has_trans = 1;\n               if (z->depth == 16) {\n                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is\n               } else {\n                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger\n               }\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('I','D','A','T'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\",\"Corrupt PNG\");\n            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }\n            if ((int)(ioff + c.length) < (int)ioff) return 0;\n            if (ioff + c.length > idata_limit) {\n               stbi__uint32 idata_limit_old = idata_limit;\n               stbi_uc *p;\n               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\n               while (ioff + c.length > idata_limit)\n                  idata_limit *= 2;\n               STBI_NOTUSED(idata_limit_old);\n               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n               z->idata = p;\n            }\n            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(\"outofdata\",\"Corrupt PNG\");\n            ioff += c.length;\n            break;\n         }\n\n         case STBI__PNG_TYPE('I','E','N','D'): {\n            stbi__uint32 raw_len, bpl;\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (scan != STBI__SCAN_load) return 1;\n            if (z->idata == NULL) return stbi__err(\"no IDAT\",\"Corrupt PNG\");\n            // initial guess for decoded data size to avoid unnecessary reallocs\n            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component\n            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;\n            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);\n            if (z->expanded == NULL) return 0; // zlib should set error\n            STBI_FREE(z->idata); z->idata = NULL;\n            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)\n               s->img_out_n = s->img_n+1;\n            else\n               s->img_out_n = s->img_n;\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;\n            if (has_trans) {\n               if (z->depth == 16) {\n                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;\n               } else {\n                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\n               }\n            }\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\n               stbi__de_iphone(z);\n            if (pal_img_n) {\n               // pal_img_n == 3 or 4\n               s->img_n = pal_img_n; // record the actual colors we had\n               s->img_out_n = pal_img_n;\n               if (req_comp >= 3) s->img_out_n = req_comp;\n               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\n                  return 0;\n            } else if (has_trans) {\n               // non-paletted image with tRNS -> source image has (constant) alpha\n               ++s->img_n;\n            }\n            STBI_FREE(z->expanded); z->expanded = NULL;\n            // end of PNG chunk, read and skip CRC\n            stbi__get32be(s);\n            return 1;\n         }\n\n         default:\n            // if critical, fail\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if ((c.type & (1 << 29)) == 0) {\n               #ifndef STBI_NO_FAILURE_STRINGS\n               // not threadsafe\n               static char invalid_chunk[] = \"XXXX PNG chunk not known\";\n               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\n               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\n               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);\n               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);\n               #endif\n               return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\n            }\n            stbi__skip(s, c.length);\n            break;\n      }\n      // end of PNG chunk, read and skip CRC\n      stbi__get32be(s);\n   }\n}\n\nstatic void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)\n{\n   void *result=NULL;\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {\n      if (p->depth <= 8)\n         ri->bits_per_channel = 8;\n      else if (p->depth == 16)\n         ri->bits_per_channel = 16;\n      else\n         return stbi__errpuc(\"bad bits_per_channel\", \"PNG not supported: unsupported color depth\");\n      result = p->out;\n      p->out = NULL;\n      if (req_comp && req_comp != p->s->img_out_n) {\n         if (ri->bits_per_channel == 8)\n            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         else\n            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         p->s->img_out_n = req_comp;\n         if (result == NULL) return result;\n      }\n      *x = p->s->img_x;\n      *y = p->s->img_y;\n      if (n) *n = p->s->img_n;\n   }\n   STBI_FREE(p->out);      p->out      = NULL;\n   STBI_FREE(p->expanded); p->expanded = NULL;\n   STBI_FREE(p->idata);    p->idata    = NULL;\n\n   return result;\n}\n\nstatic void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__do_png(&p, x,y,comp,req_comp, ri);\n}\n\nstatic int stbi__png_test(stbi__context *s)\n{\n   int r;\n   r = stbi__check_png_header(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)\n{\n   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {\n      stbi__rewind( p->s );\n      return 0;\n   }\n   if (x) *x = p->s->img_x;\n   if (y) *y = p->s->img_y;\n   if (comp) *comp = p->s->img_n;\n   return 1;\n}\n\nstatic int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__png_info_raw(&p, x, y, comp);\n}\n\nstatic int stbi__png_is16(stbi__context *s)\n{\n   stbi__png p;\n   p.s = s;\n   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))\n\t   return 0;\n   if (p.depth != 16) {\n      stbi__rewind(p.s);\n      return 0;\n   }\n   return 1;\n}\n#endif\n\n// Microsoft/Windows BMP image\n\n#ifndef STBI_NO_BMP\nstatic int stbi__bmp_test_raw(stbi__context *s)\n{\n   int r;\n   int sz;\n   if (stbi__get8(s) != 'B') return 0;\n   if (stbi__get8(s) != 'M') return 0;\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   stbi__get32le(s); // discard data offset\n   sz = stbi__get32le(s);\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\n   return r;\n}\n\nstatic int stbi__bmp_test(stbi__context *s)\n{\n   int r = stbi__bmp_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\n\n// returns 0..31 for the highest set bit\nstatic int stbi__high_bit(unsigned int z)\n{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) { n += 16; z >>= 16; }\n   if (z >= 0x00100) { n +=  8; z >>=  8; }\n   if (z >= 0x00010) { n +=  4; z >>=  4; }\n   if (z >= 0x00004) { n +=  2; z >>=  2; }\n   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }\n   return n;\n}\n\nstatic int stbi__bitcount(unsigned int a)\n{\n   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2\n   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4\n   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\n   a = (a + (a >> 8)); // max 16 per 8 bits\n   a = (a + (a >> 16)); // max 32 per 8 bits\n   return a & 0xff;\n}\n\n// extract an arbitrarily-aligned N-bit value (N=bits)\n// from v, and then make it 8-bits long and fractionally\n// extend it to full full range.\nstatic int stbi__shiftsigned(unsigned int v, int shift, int bits)\n{\n   static unsigned int mul_table[9] = {\n      0,\n      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,\n      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,\n   };\n   static unsigned int shift_table[9] = {\n      0, 0,0,1,0,2,4,6,0,\n   };\n   if (shift < 0)\n      v <<= -shift;\n   else\n      v >>= shift;\n   STBI_ASSERT(v < 256);\n   v >>= (8-bits);\n   STBI_ASSERT(bits >= 0 && bits <= 8);\n   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];\n}\n\ntypedef struct\n{\n   int bpp, offset, hsz;\n   unsigned int mr,mg,mb,ma, all_a;\n   int extra_read;\n} stbi__bmp_data;\n\nstatic int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)\n{\n   // BI_BITFIELDS specifies masks explicitly, don't override\n   if (compress == 3)\n      return 1;\n\n   if (compress == 0) {\n      if (info->bpp == 16) {\n         info->mr = 31u << 10;\n         info->mg = 31u <<  5;\n         info->mb = 31u <<  0;\n      } else if (info->bpp == 32) {\n         info->mr = 0xffu << 16;\n         info->mg = 0xffu <<  8;\n         info->mb = 0xffu <<  0;\n         info->ma = 0xffu << 24;\n         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0\n      } else {\n         // otherwise, use defaults, which is all-0\n         info->mr = info->mg = info->mb = info->ma = 0;\n      }\n      return 1;\n   }\n   return 0; // error\n}\n\nstatic void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)\n{\n   int hsz;\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   info->offset = stbi__get32le(s);\n   info->hsz = hsz = stbi__get32le(s);\n   info->mr = info->mg = info->mb = info->ma = 0;\n   info->extra_read = 14;\n\n   if (info->offset < 0) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\n   if (hsz == 12) {\n      s->img_x = stbi__get16le(s);\n      s->img_y = stbi__get16le(s);\n   } else {\n      s->img_x = stbi__get32le(s);\n      s->img_y = stbi__get32le(s);\n   }\n   if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n   info->bpp = stbi__get16le(s);\n   if (hsz != 12) {\n      int compress = stbi__get32le(s);\n      if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\n      if (compress >= 4) return stbi__errpuc(\"BMP JPEG/PNG\", \"BMP type not supported: unsupported compression\"); // this includes PNG/JPEG modes\n      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(\"bad BMP\", \"bad BMP\"); // bitfields requires 16 or 32 bits/pixel\n      stbi__get32le(s); // discard sizeof\n      stbi__get32le(s); // discard hres\n      stbi__get32le(s); // discard vres\n      stbi__get32le(s); // discard colorsused\n      stbi__get32le(s); // discard max important\n      if (hsz == 40 || hsz == 56) {\n         if (hsz == 56) {\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n         }\n         if (info->bpp == 16 || info->bpp == 32) {\n            if (compress == 0) {\n               stbi__bmp_set_mask_defaults(info, compress);\n            } else if (compress == 3) {\n               info->mr = stbi__get32le(s);\n               info->mg = stbi__get32le(s);\n               info->mb = stbi__get32le(s);\n               info->extra_read += 12;\n               // not documented, but generated by photoshop and handled by mspaint\n               if (info->mr == info->mg && info->mg == info->mb) {\n                  // ?!?!?\n                  return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n               }\n            } else\n               return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         }\n      } else {\n         // V4/V5 header\n         int i;\n         if (hsz != 108 && hsz != 124)\n            return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         info->mr = stbi__get32le(s);\n         info->mg = stbi__get32le(s);\n         info->mb = stbi__get32le(s);\n         info->ma = stbi__get32le(s);\n         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs\n            stbi__bmp_set_mask_defaults(info, compress);\n         stbi__get32le(s); // discard color space\n         for (i=0; i < 12; ++i)\n            stbi__get32le(s); // discard color space parameters\n         if (hsz == 124) {\n            stbi__get32le(s); // discard rendering intent\n            stbi__get32le(s); // discard offset of profile data\n            stbi__get32le(s); // discard size of profile data\n            stbi__get32le(s); // discard reserved\n         }\n      }\n   }\n   return (void *) 1;\n}\n\n\nstatic void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;\n   stbi_uc pal[256][4];\n   int psize=0,i,j,width;\n   int flip_vertically, pad, target;\n   stbi__bmp_data info;\n   STBI_NOTUSED(ri);\n\n   info.all_a = 255;\n   if (stbi__bmp_parse_header(s, &info) == NULL)\n      return NULL; // error code already set\n\n   flip_vertically = ((int) s->img_y) > 0;\n   s->img_y = MathAbsI((int) s->img_y);\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   mr = info.mr;\n   mg = info.mg;\n   mb = info.mb;\n   ma = info.ma;\n   all_a = info.all_a;\n\n   if (info.hsz == 12) {\n      if (info.bpp < 24)\n         psize = (info.offset - info.extra_read - 24) / 3;\n   } else {\n      if (info.bpp < 16)\n         psize = (info.offset - info.extra_read - info.hsz) >> 2;\n   }\n   if (psize == 0) {\n      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {\n        return stbi__errpuc(\"bad offset\", \"Corrupt BMP\");\n      }\n   }\n\n   if (info.bpp == 24 && ma == 0xff000000)\n      s->img_n = 3;\n   else\n      s->img_n = ma ? 4 : 3;\n   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\n      target = req_comp;\n   else\n      target = s->img_n; // if they want monochrome, we'll post-convert\n\n   // sanity-check size\n   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt BMP\");\n\n   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (info.bpp < 16) {\n      int z=0;\n      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\n      for (i=0; i < psize; ++i) {\n         pal[i][2] = stbi__get8(s);\n         pal[i][1] = stbi__get8(s);\n         pal[i][0] = stbi__get8(s);\n         if (info.hsz != 12) stbi__get8(s);\n         pal[i][3] = 255;\n      }\n      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));\n      if (info.bpp == 1) width = (s->img_x + 7) >> 3;\n      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;\n      else if (info.bpp == 8) width = s->img_x;\n      else { STBI_FREE(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\n      pad = (-width)&3;\n      if (info.bpp == 1) {\n         for (j=0; j < (int) s->img_y; ++j) {\n            int bit_offset = 7, v = stbi__get8(s);\n            for (i=0; i < (int) s->img_x; ++i) {\n               int color = (v>>bit_offset)&0x1;\n               out[z++] = pal[color][0];\n               out[z++] = pal[color][1];\n               out[z++] = pal[color][2];\n               if (target == 4) out[z++] = 255;\n               if (i+1 == (int) s->img_x) break;\n               if((--bit_offset) < 0) {\n                  bit_offset = 7;\n                  v = stbi__get8(s);\n               }\n            }\n            stbi__skip(s, pad);\n         }\n      } else {\n         for (j=0; j < (int) s->img_y; ++j) {\n            for (i=0; i < (int) s->img_x; i += 2) {\n               int v=stbi__get8(s),v2=0;\n               if (info.bpp == 4) {\n                  v2 = v & 15;\n                  v >>= 4;\n               }\n               out[z++] = pal[v][0];\n               out[z++] = pal[v][1];\n               out[z++] = pal[v][2];\n               if (target == 4) out[z++] = 255;\n               if (i+1 == (int) s->img_x) break;\n               v = (info.bpp == 8) ? stbi__get8(s) : v2;\n               out[z++] = pal[v][0];\n               out[z++] = pal[v][1];\n               out[z++] = pal[v][2];\n               if (target == 4) out[z++] = 255;\n            }\n            stbi__skip(s, pad);\n         }\n      }\n   } else {\n      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;\n      int z = 0;\n      int easy=0;\n      stbi__skip(s, info.offset - info.extra_read - info.hsz);\n      if (info.bpp == 24) width = 3 * s->img_x;\n      else if (info.bpp == 16) width = 2*s->img_x;\n      else /* bpp = 32 and pad = 0 */ width=0;\n      pad = (-width) & 3;\n      if (info.bpp == 24) {\n         easy = 1;\n      } else if (info.bpp == 32) {\n         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\n            easy = 2;\n      }\n      if (!easy) {\n         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n         // right shift amt to put high bit in position #7\n         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);\n         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);\n         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);\n         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);\n         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n      }\n      for (j=0; j < (int) s->img_y; ++j) {\n         if (easy) {\n            for (i=0; i < (int) s->img_x; ++i) {\n               unsigned char a;\n               out[z+2] = stbi__get8(s);\n               out[z+1] = stbi__get8(s);\n               out[z+0] = stbi__get8(s);\n               z += 3;\n               a = (easy == 2 ? stbi__get8(s) : 255);\n               all_a |= a;\n               if (target == 4) out[z++] = a;\n            }\n         } else {\n            int bpp = info.bpp;\n            for (i=0; i < (int) s->img_x; ++i) {\n               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));\n               unsigned int a;\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\n               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\n               all_a |= a;\n               if (target == 4) out[z++] = STBI__BYTECAST(a);\n            }\n         }\n         stbi__skip(s, pad);\n      }\n   }\n\n   // if alpha channel is all 0s, replace with all 255s\n   if (target == 4 && all_a == 0)\n      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)\n         out[i] = 255;\n\n   if (flip_vertically) {\n      stbi_uc t;\n      for (j=0; j < (int) s->img_y>>1; ++j) {\n         stbi_uc *p1 = out +      j     *s->img_x*target;\n         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;\n         for (i=0; i < (int) s->img_x*target; ++i) {\n            t = p1[i]; p1[i] = p2[i]; p2[i] = t;\n         }\n      }\n   }\n\n   if (req_comp && req_comp != target) {\n      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n   return out;\n}\n#endif\n\n// Targa Truevision - TGA\n// by Jonathan Dummer\n#ifndef STBI_NO_TGA\n// returns STBI_rgb or whatever, 0 on error\nstatic int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)\n{\n   // only RGB or RGBA (incl. 16bit) or grey allowed\n   if (is_rgb16) *is_rgb16 = 0;\n   switch(bits_per_pixel) {\n      case 8:  return STBI_grey;\n      case 16: if(is_grey) return STBI_grey_alpha;\n               // fallthrough\n      case 15: if(is_rgb16) *is_rgb16 = 1;\n               return STBI_rgb;\n      case 24: // fallthrough\n      case 32: return bits_per_pixel/8;\n      default: return 0;\n   }\n}\n\nstatic int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)\n{\n    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;\n    int sz, tga_colormap_type;\n    stbi__get8(s);                   // discard Offset\n    tga_colormap_type = stbi__get8(s); // colormap type\n    if( tga_colormap_type > 1 ) {\n        stbi__rewind(s);\n        return 0;      // only RGB or indexed allowed\n    }\n    tga_image_type = stbi__get8(s); // image type\n    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image\n        if (tga_image_type != 1 && tga_image_type != 9) {\n            stbi__rewind(s);\n            return 0;\n        }\n        stbi__skip(s,4);       // skip index of first colormap entry and number of entries\n        sz = stbi__get8(s);    //   check bits per palette color entry\n        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {\n            stbi__rewind(s);\n            return 0;\n        }\n        stbi__skip(s,4);       // skip image x and y origin\n        tga_colormap_bpp = sz;\n    } else { // \"normal\" image w/o colormap - only RGB or grey allowed, +/- RLE\n        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {\n            stbi__rewind(s);\n            return 0; // only RGB or grey allowed, +/- RLE\n        }\n        stbi__skip(s,9); // skip colormap specification and image x/y origin\n        tga_colormap_bpp = 0;\n    }\n    tga_w = stbi__get16le(s);\n    if( tga_w < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test width\n    }\n    tga_h = stbi__get16le(s);\n    if( tga_h < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test height\n    }\n    tga_bits_per_pixel = stbi__get8(s); // bits per pixel\n    stbi__get8(s); // ignore alpha bits\n    if (tga_colormap_bpp != 0) {\n        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {\n            // when using a colormap, tga_bits_per_pixel is the size of the indexes\n            // I don't think anything but 8 or 16bit indexes makes sense\n            stbi__rewind(s);\n            return 0;\n        }\n        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);\n    } else {\n        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);\n    }\n    if(!tga_comp) {\n      stbi__rewind(s);\n      return 0;\n    }\n    if (x) *x = tga_w;\n    if (y) *y = tga_h;\n    if (comp) *comp = tga_comp;\n    return 1;                   // seems to have passed everything\n}\n\nstatic int stbi__tga_test(stbi__context *s)\n{\n   int res = 0;\n   int sz, tga_color_type;\n   stbi__get8(s);      //   discard Offset\n   tga_color_type = stbi__get8(s);   //   color type\n   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed\n   sz = stbi__get8(s);   //   image type\n   if ( tga_color_type == 1 ) { // colormapped (paletted) image\n      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9\n      stbi__skip(s,4);       // skip index of first colormap entry and number of entries\n      sz = stbi__get8(s);    //   check bits per palette color entry\n      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\n      stbi__skip(s,4);       // skip image x and y origin\n   } else { // \"normal\" image w/o colormap\n      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE\n      stbi__skip(s,9); // skip colormap specification and image x/y origin\n   }\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height\n   sz = stbi__get8(s);   //   bits per pixel\n   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index\n   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\n\n   res = 1; // if we got this far, everything's good and we can return 1 instead of 0\n\nerrorEnd:\n   stbi__rewind(s);\n   return res;\n}\n\n// read 16bit value and convert to 24bit RGB\nstatic void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)\n{\n   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);\n   stbi__uint16 fiveBitMask = 31;\n   // we have 3 channels with 5bits each\n   int r = (px >> 10) & fiveBitMask;\n   int g = (px >> 5) & fiveBitMask;\n   int b = px & fiveBitMask;\n   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later\n   out[0] = (stbi_uc)((r * 255)/31);\n   out[1] = (stbi_uc)((g * 255)/31);\n   out[2] = (stbi_uc)((b * 255)/31);\n\n   // some people claim that the most significant bit might be used for alpha\n   // (possibly if an alpha-bit is set in the \"image descriptor byte\")\n   // but that only made 16bit test images completely translucent..\n   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.\n}\n\nstatic void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   //   read in the TGA header stuff\n   int tga_offset = stbi__get8(s);\n   int tga_indexed = stbi__get8(s);\n   int tga_image_type = stbi__get8(s);\n   int tga_is_RLE = 0;\n   int tga_palette_start = stbi__get16le(s);\n   int tga_palette_len = stbi__get16le(s);\n   int tga_palette_bits = stbi__get8(s);\n   int tga_x_origin = stbi__get16le(s);\n   int tga_y_origin = stbi__get16le(s);\n   int tga_width = stbi__get16le(s);\n   int tga_height = stbi__get16le(s);\n   int tga_bits_per_pixel = stbi__get8(s);\n   int tga_comp, tga_rgb16=0;\n   int tga_inverted = stbi__get8(s);\n   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)\n   //   image data\n   unsigned char *tga_data;\n   unsigned char *tga_palette = NULL;\n   int i, j;\n   unsigned char raw_data[4] = {0};\n   int RLE_count = 0;\n   int RLE_repeating = 0;\n   int read_next_pixel = 1;\n   STBI_NOTUSED(ri);\n   STBI_NOTUSED(tga_x_origin); // @TODO\n   STBI_NOTUSED(tga_y_origin); // @TODO\n\n   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   //   do a tiny bit of precessing\n   if ( tga_image_type >= 8 )\n   {\n      tga_image_type -= 8;\n      tga_is_RLE = 1;\n   }\n   tga_inverted = 1 - ((tga_inverted >> 5) & 1);\n\n   //   If I'm paletted, then I'll use the number of bits from the palette\n   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);\n   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);\n\n   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency\n      return stbi__errpuc(\"bad format\", \"Can't find out TGA pixelformat\");\n\n   //   tga info\n   *x = tga_width;\n   *y = tga_height;\n   if (comp) *comp = tga_comp;\n\n   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt TGA\");\n\n   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);\n   if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   // skip to the data's starting position (offset usually = 0)\n   stbi__skip(s, tga_offset );\n\n   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {\n      for (i=0; i < tga_height; ++i) {\n         int row = tga_inverted ? tga_height -i - 1 : i;\n         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;\n         stbi__getn(s, tga_row, tga_width * tga_comp);\n      }\n   } else  {\n      //   do I need to load a palette?\n      if ( tga_indexed)\n      {\n         if (tga_palette_len == 0) {  /* you have to have at least one entry! */\n            STBI_FREE(tga_data);\n            return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n\n         //   any data to skip? (offset usually = 0)\n         stbi__skip(s, tga_palette_start );\n         //   load the palette\n         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);\n         if (!tga_palette) {\n            STBI_FREE(tga_data);\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\n         }\n         if (tga_rgb16) {\n            stbi_uc *pal_entry = tga_palette;\n            STBI_ASSERT(tga_comp == STBI_rgb);\n            for (i=0; i < tga_palette_len; ++i) {\n               stbi__tga_read_rgb16(s, pal_entry);\n               pal_entry += tga_comp;\n            }\n         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {\n               STBI_FREE(tga_data);\n               STBI_FREE(tga_palette);\n               return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n      }\n      //   load the data\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\n         if ( tga_is_RLE )\n         {\n            if ( RLE_count == 0 )\n            {\n               //   yep, get the next byte as a RLE command\n               int RLE_cmd = stbi__get8(s);\n               RLE_count = 1 + (RLE_cmd & 127);\n               RLE_repeating = RLE_cmd >> 7;\n               read_next_pixel = 1;\n            } else if ( !RLE_repeating )\n            {\n               read_next_pixel = 1;\n            }\n         } else\n         {\n            read_next_pixel = 1;\n         }\n         //   OK, if I need to read a pixel, do it now\n         if ( read_next_pixel )\n         {\n            //   load however much data we did have\n            if ( tga_indexed )\n            {\n               // read in index, then perform the lookup\n               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);\n               if ( pal_idx >= tga_palette_len ) {\n                  // invalid index\n                  pal_idx = 0;\n               }\n               pal_idx *= tga_comp;\n               for (j = 0; j < tga_comp; ++j) {\n                  raw_data[j] = tga_palette[pal_idx+j];\n               }\n            } else if(tga_rgb16) {\n               STBI_ASSERT(tga_comp == STBI_rgb);\n               stbi__tga_read_rgb16(s, raw_data);\n            } else {\n               //   read in the data raw\n               for (j = 0; j < tga_comp; ++j) {\n                  raw_data[j] = stbi__get8(s);\n               }\n            }\n            //   clear the reading flag for the next pixel\n            read_next_pixel = 0;\n         } // end of reading a pixel\n\n         // copy data\n         for (j = 0; j < tga_comp; ++j)\n           tga_data[i*tga_comp+j] = raw_data[j];\n\n         //   in case we're in RLE mode, keep counting down\n         --RLE_count;\n      }\n      //   do I need to invert the image?\n      if ( tga_inverted )\n      {\n         for (j = 0; j*2 < tga_height; ++j)\n         {\n            int index1 = j * tga_width * tga_comp;\n            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\n            for (i = tga_width * tga_comp; i > 0; --i)\n            {\n               unsigned char temp = tga_data[index1];\n               tga_data[index1] = tga_data[index2];\n               tga_data[index2] = temp;\n               ++index1;\n               ++index2;\n            }\n         }\n      }\n      //   clear my palette, if I had one\n      if ( tga_palette != NULL )\n      {\n         STBI_FREE( tga_palette );\n      }\n   }\n\n   // swap RGB - if the source data was RGB16, it already is in the right order\n   if (tga_comp >= 3 && !tga_rgb16)\n   {\n      unsigned char* tga_pixel = tga_data;\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         unsigned char temp = tga_pixel[0];\n         tga_pixel[0] = tga_pixel[2];\n         tga_pixel[2] = temp;\n         tga_pixel += tga_comp;\n      }\n   }\n\n   // convert to target component count\n   if (req_comp && req_comp != tga_comp)\n      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\n\n   //   the things I do to get rid of an error message, and yet keep\n   //   Microsoft's C compilers happy... [8^(\n   tga_palette_start = tga_palette_len = tga_palette_bits =\n         tga_x_origin = tga_y_origin = 0;\n   STBI_NOTUSED(tga_palette_start);\n   //   OK, done\n   return tga_data;\n}\n#endif\n\n// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\n\n#ifndef STBI_NO_PSD\nstatic int stbi__psd_test(stbi__context *s)\n{\n   int r = (stbi__get32be(s) == 0x38425053);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)\n{\n   int count, nleft, len;\n\n   count = 0;\n   while ((nleft = pixelCount - count) > 0) {\n      len = stbi__get8(s);\n      if (len == 128) {\n         // No-op.\n      } else if (len < 128) {\n         // Copy next len+1 bytes literally.\n         len++;\n         if (len > nleft) return 0; // corrupt data\n         count += len;\n         while (len) {\n            *p = stbi__get8(s);\n            p += 4;\n            len--;\n         }\n      } else if (len > 128) {\n         stbi_uc   val;\n         // Next -len+1 bytes in the dest are replicated from next source byte.\n         // (Interpret len as a negative 8-bit int.)\n         len = 257 - len;\n         if (len > nleft) return 0; // corrupt data\n         val = stbi__get8(s);\n         count += len;\n         while (len) {\n            *p = val;\n            p += 4;\n            len--;\n         }\n      }\n   }\n\n   return 1;\n}\n\nstatic void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\n{\n   int pixelCount;\n   int channelCount, compression;\n   int channel, i;\n   int bitdepth;\n   int w,h;\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\n      return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\n\n   // Check file type version.\n   if (stbi__get16be(s) != 1)\n      return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\n\n   // Skip 6 reserved bytes.\n   stbi__skip(s, 6 );\n\n   // Read the number of channels (R, G, B, A, etc).\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16)\n      return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\n\n   // Read the rows and columns of the image.\n   h = stbi__get32be(s);\n   w = stbi__get32be(s);\n\n   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   // Make sure the depth is 8 bits.\n   bitdepth = stbi__get16be(s);\n   if (bitdepth != 8 && bitdepth != 16)\n      return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 or 16 bit\");\n\n   // Make sure the color mode is RGB.\n   // Valid options are:\n   //   0: Bitmap\n   //   1: Grayscale\n   //   2: Indexed color\n   //   3: RGB color\n   //   4: CMYK color\n   //   7: Multichannel\n   //   8: Duotone\n   //   9: Lab color\n   if (stbi__get16be(s) != 3)\n      return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\n\n   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\n   stbi__skip(s,stbi__get32be(s) );\n\n   // Skip the image resources.  (resolution, pen tool paths, etc)\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Skip the reserved data.\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Find out if the data is compressed.\n   // Known values:\n   //   0: no compression\n   //   1: RLE compressed\n   compression = stbi__get16be(s);\n   if (compression > 1)\n      return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\n\n   // Check size\n   if (!stbi__mad3sizes_valid(4, w, h, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt PSD\");\n\n   // Create the destination image.\n\n   if (!compression && bitdepth == 16 && bpc == 16) {\n      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);\n      ri->bits_per_channel = 16;\n   } else\n      out = (stbi_uc *) stbi__malloc(4 * w*h);\n\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   pixelCount = w*h;\n\n   // Initialize the data to zero.\n   //MemSet( out, 0, pixelCount * 4 );\n\n   // Finally, the image data.\n   if (compression) {\n      // RLE as used by .PSD and .TIFF\n      // Loop until you get the number of unpacked bytes you are expecting:\n      //     Read the next source byte into n.\n      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\n      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\n      //     Else if n is 128, noop.\n      // Endloop\n\n      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,\n      // which we're going to just skip.\n      stbi__skip(s, h * channelCount * 2 );\n\n      // Read the RLE data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         stbi_uc *p;\n\n         p = out+channel;\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            for (i = 0; i < pixelCount; i++, p += 4)\n               *p = (channel == 3 ? 255 : 0);\n         } else {\n            // Read the RLE data.\n            if (!stbi__psd_decode_rle(s, p, pixelCount)) {\n               STBI_FREE(out);\n               return stbi__errpuc(\"corrupt\", \"bad RLE data\");\n            }\n         }\n      }\n\n   } else {\n      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\n      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.\n\n      // Read the data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            if (bitdepth == 16 && bpc == 16) {\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\n               stbi__uint16 val = channel == 3 ? 65535 : 0;\n               for (i = 0; i < pixelCount; i++, q += 4)\n                  *q = val;\n            } else {\n               stbi_uc *p = out+channel;\n               stbi_uc val = channel == 3 ? 255 : 0;\n               for (i = 0; i < pixelCount; i++, p += 4)\n                  *p = val;\n            }\n         } else {\n            if (ri->bits_per_channel == 16) {    // output bpc\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\n               for (i = 0; i < pixelCount; i++, q += 4)\n                  *q = (stbi__uint16) stbi__get16be(s);\n            } else {\n               stbi_uc *p = out+channel;\n               if (bitdepth == 16) {  // input bpc\n                  for (i = 0; i < pixelCount; i++, p += 4)\n                     *p = (stbi_uc) (stbi__get16be(s) >> 8);\n               } else {\n                  for (i = 0; i < pixelCount; i++, p += 4)\n                     *p = stbi__get8(s);\n               }\n            }\n         }\n      }\n   }\n\n   // remove weird white matte from PSD\n   if (channelCount >= 4) {\n      if (ri->bits_per_channel == 16) {\n         for (i=0; i < w*h; ++i) {\n            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;\n            if (pixel[3] != 0 && pixel[3] != 65535) {\n               float a = pixel[3] / 65535.0f;\n               float ra = 1.0f / a;\n               float inv_a = 65535.0f * (1 - ra);\n               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);\n               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);\n               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);\n            }\n         }\n      } else {\n         for (i=0; i < w*h; ++i) {\n            unsigned char *pixel = out + 4*i;\n            if (pixel[3] != 0 && pixel[3] != 255) {\n               float a = pixel[3] / 255.0f;\n               float ra = 1.0f / a;\n               float inv_a = 255.0f * (1 - ra);\n               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);\n               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);\n               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);\n            }\n         }\n      }\n   }\n\n   // convert to desired output format\n   if (req_comp && req_comp != 4) {\n      if (ri->bits_per_channel == 16)\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);\n      else\n         out = stbi__convert_format(out, 4, req_comp, w, h);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   if (comp) *comp = 4;\n   *y = h;\n   *x = w;\n\n   return out;\n}\n#endif\n\n// *************************************************************************************************\n// Softimage PIC loader\n// by Tom Seddon\n//\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\n\n#ifndef STBI_NO_PIC\nstatic int stbi__pic_is4(stbi__context *s,const char *str)\n{\n   int i;\n   for (i=0; i<4; ++i)\n      if (stbi__get8(s) != (stbi_uc)str[i])\n         return 0;\n\n   return 1;\n}\n\nstatic int stbi__pic_test_core(stbi__context *s)\n{\n   int i;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\"))\n      return 0;\n\n   for(i=0;i<84;++i)\n      stbi__get8(s);\n\n   if (!stbi__pic_is4(s,\"PICT\"))\n      return 0;\n\n   return 1;\n}\n\ntypedef struct\n{\n   stbi_uc size,type,channel;\n} stbi__pic_packet;\n\nstatic stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)\n{\n   int mask=0x80, i;\n\n   for (i=0; i<4; ++i, mask>>=1) {\n      if (channel & mask) {\n         if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\",\"PIC file too short\");\n         dest[i]=stbi__get8(s);\n      }\n   }\n\n   return dest;\n}\n\nstatic void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)\n{\n   int mask=0x80,i;\n\n   for (i=0;i<4; ++i, mask>>=1)\n      if (channel&mask)\n         dest[i]=src[i];\n}\n\nstatic stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)\n{\n   int act_comp=0,num_packets=0,y,chained;\n   stbi__pic_packet packets[10];\n\n   // this will (should...) cater for even some bizarre stuff like having data\n    // for the same channel in multiple packets.\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return stbi__errpuc(\"bad format\",\"too many packets\");\n\n      packet = &packets[num_packets++];\n\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\",\"file too short (reading packets)\");\n      if (packet->size != 8)  return stbi__errpuc(\"bad format\",\"packet isn't 8bpp\");\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\n\n   for(y=0; y<height; ++y) {\n      int packet_idx;\n\n      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {\n         stbi__pic_packet *packet = &packets[packet_idx];\n         stbi_uc *dest = result+y*width*4;\n\n         switch (packet->type) {\n            default:\n               return stbi__errpuc(\"bad format\",\"packet has bad compression type\");\n\n            case 0: {//uncompressed\n               int x;\n\n               for(x=0;x<width;++x, dest+=4)\n                  if (!stbi__readval(s,packet->channel,dest))\n                     return 0;\n               break;\n            }\n\n            case 1://Pure RLE\n               {\n                  int left=width, i;\n\n                  while (left>0) {\n                     stbi_uc count,value[4];\n\n                     count=stbi__get8(s);\n                     if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\",\"file too short (pure read count)\");\n\n                     if (count > left)\n                        count = (stbi_uc) left;\n\n                     if (!stbi__readval(s,packet->channel,value))  return 0;\n\n                     for(i=0; i<count; ++i,dest+=4)\n                        stbi__copyval(packet->channel,dest,value);\n                     left -= count;\n                  }\n               }\n               break;\n\n            case 2: {//Mixed RLE\n               int left=width;\n               while (left>0) {\n                  int count = stbi__get8(s), i;\n                  if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (mixed read count)\");\n\n                  if (count >= 128) { // Repeated\n                     stbi_uc value[4];\n\n                     if (count==128)\n                        count = stbi__get16be(s);\n                     else\n                        count -= 127;\n                     if (count > left)\n                        return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     if (!stbi__readval(s,packet->channel,value))\n                        return 0;\n\n                     for(i=0;i<count;++i, dest += 4)\n                        stbi__copyval(packet->channel,dest,value);\n                  } else { // Raw\n                     ++count;\n                     if (count>left) return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     for(i=0;i<count;++i, dest+=4)\n                        if (!stbi__readval(s,packet->channel,dest))\n                           return 0;\n                  }\n                  left-=count;\n               }\n               break;\n            }\n         }\n      }\n   }\n\n   return result;\n}\n\nstatic void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (pic header)\");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\"too large\", \"PIC image too large to decode\");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   MemSet(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      result=0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}\n\nstatic int stbi__pic_test(stbi__context *s)\n{\n   int r = stbi__pic_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n#endif\n\n// *************************************************************************************************\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\n\n#ifndef STBI_NO_GIF\ntypedef struct\n{\n   stbi__int16 prefix;\n   stbi_uc first;\n   stbi_uc suffix;\n} stbi__gif_lzw;\n\ntypedef struct\n{\n   int w,h;\n   stbi_uc *out;                 // output buffer (always 4 components)\n   stbi_uc *background;          // The current \"background\" as far as a gif is concerned\n   stbi_uc *history;\n   int flags, bgindex, ratio, transparent, eflags;\n   stbi_uc  pal[256][4];\n   stbi_uc lpal[256][4];\n   stbi__gif_lzw codes[8192];\n   stbi_uc *color_table;\n   int parse, step;\n   int lflags;\n   int start_x, start_y;\n   int max_x, max_y;\n   int cur_x, cur_y;\n   int line_size;\n   int delay;\n} stbi__gif;\n\nstatic int stbi__gif_test_raw(stbi__context *s)\n{\n   int sz;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\n   sz = stbi__get8(s);\n   if (sz != '9' && sz != '7') return 0;\n   if (stbi__get8(s) != 'a') return 0;\n   return 1;\n}\n\nstatic int stbi__gif_test(stbi__context *s)\n{\n   int r = stbi__gif_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)\n{\n   int i;\n   for (i=0; i < num_entries; ++i) {\n      pal[i][2] = stbi__get8(s);\n      pal[i][1] = stbi__get8(s);\n      pal[i][0] = stbi__get8(s);\n      pal[i][3] = transp == i ? 0 : 255;\n   }\n}\n\nstatic int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)\n{\n   stbi_uc version;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\n      return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   version = stbi__get8(s);\n   if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\n   if (stbi__get8(s) != 'a')                return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   stbi__g_failure_reason = \"\";\n   g->w = stbi__get16le(s);\n   g->h = stbi__get16le(s);\n   g->flags = stbi__get8(s);\n   g->bgindex = stbi__get8(s);\n   g->ratio = stbi__get8(s);\n   g->transparent = -1;\n\n   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n\n   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\n\n   if (is_info) return 1;\n\n   if (g->flags & 0x80)\n      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);\n\n   return 1;\n}\n\nstatic int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\n   if (!g) return stbi__err(\"outofmem\", \"Out of memory\");\n   if (!stbi__gif_header(s, g, comp, 1)) {\n      STBI_FREE(g);\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = g->w;\n   if (y) *y = g->h;\n   STBI_FREE(g);\n   return 1;\n}\n\nstatic void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)\n{\n   stbi_uc *p, *c;\n   int idx;\n\n   // recurse to decode the prefixes, since the linked-list is backwards,\n   // and working backwards through an interleaved image would be nasty\n   if (g->codes[code].prefix >= 0)\n      stbi__out_gif_code(g, g->codes[code].prefix);\n\n   if (g->cur_y >= g->max_y) return;\n\n   idx = g->cur_x + g->cur_y;\n   p = &g->out[idx];\n   g->history[idx / 4] = 1;\n\n   c = &g->color_table[g->codes[code].suffix * 4];\n   if (c[3] > 128) { // don't render transparent pixels;\n      p[0] = c[2];\n      p[1] = c[1];\n      p[2] = c[0];\n      p[3] = c[3];\n   }\n   g->cur_x += 4;\n\n   if (g->cur_x >= g->max_x) {\n      g->cur_x = g->start_x;\n      g->cur_y += g->step;\n\n      while (g->cur_y >= g->max_y && g->parse > 0) {\n         g->step = (1 << g->parse) * g->line_size;\n         g->cur_y = g->start_y + (g->step >> 1);\n         --g->parse;\n      }\n   }\n}\n\nstatic stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)\n{\n   stbi_uc lzw_cs;\n   stbi__int32 len, init_code;\n   stbi__uint32 first;\n   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n   stbi__gif_lzw *p;\n\n   lzw_cs = stbi__get8(s);\n   if (lzw_cs > 12) return NULL;\n   clear = 1 << lzw_cs;\n   first = 1;\n   codesize = lzw_cs + 1;\n   codemask = (1 << codesize) - 1;\n   bits = 0;\n   valid_bits = 0;\n   for (init_code = 0; init_code < clear; init_code++) {\n      g->codes[init_code].prefix = -1;\n      g->codes[init_code].first = (stbi_uc) init_code;\n      g->codes[init_code].suffix = (stbi_uc) init_code;\n   }\n\n   // support no starting clear code\n   avail = clear+2;\n   oldcode = -1;\n\n   len = 0;\n   for(;;) {\n      if (valid_bits < codesize) {\n         if (len == 0) {\n            len = stbi__get8(s); // start new block\n            if (len == 0)\n               return g->out;\n         }\n         --len;\n         bits |= (stbi__int32) stbi__get8(s) << valid_bits;\n         valid_bits += 8;\n      } else {\n         stbi__int32 code = bits & codemask;\n         bits >>= codesize;\n         valid_bits -= codesize;\n         // @OPTIMIZE: is there some way we can accelerate the non-clear path?\n         if (code == clear) {  // clear code\n            codesize = lzw_cs + 1;\n            codemask = (1 << codesize) - 1;\n            avail = clear + 2;\n            oldcode = -1;\n            first = 0;\n         } else if (code == clear + 1) { // end of stream code\n            stbi__skip(s, len);\n            while ((len = stbi__get8(s)) > 0)\n               stbi__skip(s,len);\n            return g->out;\n         } else if (code <= avail) {\n            if (first) {\n               return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\n            }\n\n            if (oldcode >= 0) {\n               p = &g->codes[avail++];\n               if (avail > 8192) {\n                  return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\n               }\n\n               p->prefix = (stbi__int16) oldcode;\n               p->first = g->codes[oldcode].first;\n               p->suffix = (code == avail) ? p->first : g->codes[code].first;\n            } else if (code == avail)\n               return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n\n            stbi__out_gif_code(g, (stbi__uint16) code);\n\n            if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n               codesize++;\n               codemask = (1 << codesize) - 1;\n            }\n\n            oldcode = code;\n         } else {\n            return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n         }\n      }\n   }\n}\n\n// this function is designed to support animated gifs, although stb_image doesn't support it\n// two back is the image from two frames ago, used for a very specific disposal format\nstatic stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)\n{\n   int dispose;\n   int first_frame;\n   int pi;\n   int pcount;\n   STBI_NOTUSED(req_comp);\n\n   // on first frame, any non-written pixels get the background colour (non-transparent)\n   first_frame = 0;\n   if (g->out == 0) {\n      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header\n      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))\n         return stbi__errpuc(\"too large\", \"GIF image is too large\");\n      pcount = g->w * g->h;\n      g->out = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->background = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->history = (stbi_uc *) stbi__malloc(pcount);\n      if (!g->out || !g->background || !g->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background;\n      // background colour is only used for pixels that are not rendered first frame, after that \"background\"\n      // color refers to the color that was there the previous frame.\n      MemSet(g->out, 0x00, 4 * pcount);\n      MemSet(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)\n      MemSet(g->history, 0x00, pcount);        // pixels that were affected previous frame\n      first_frame = 1;\n   } else {\n      // second frame - how do we dispose of the previous one?\n      dispose = (g->eflags & 0x1C) >> 2;\n      pcount = g->w * g->h;\n\n      if ((dispose == 3) && (two_back == 0)) {\n         dispose = 2; // if I don't have an image to revert back to, default to the old background\n      }\n\n      if (dispose == 3) { // use previous graphic\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               MemCopy( &g->out[pi * 4], &two_back[pi * 4], 4 );\n            }\n         }\n      } else if (dispose == 2) {\n         // restore what was changed last frame to background before that frame;\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               MemCopy( &g->out[pi * 4], &g->background[pi * 4], 4 );\n            }\n         }\n      } else {\n         // This is a non-disposal case eithe way, so just\n         // leave the pixels as is, and they will become the new background\n         // 1: do not dispose\n         // 0:  not specified.\n      }\n\n      // background is what out is after the undoing of the previou frame;\n      MemCopy( g->background, g->out, 4 * g->w * g->h );\n   }\n\n   // clear my history;\n   MemSet( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n\n   for (;;) {\n      int tag = stbi__get8(s);\n      switch (tag) {\n         case 0x2C: /* Image Descriptor */\n         {\n            stbi__int32 x, y, w, h;\n            stbi_uc *o;\n\n            x = stbi__get16le(s);\n            y = stbi__get16le(s);\n            w = stbi__get16le(s);\n            h = stbi__get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            // if the width of the specified rectangle is 0, that means\n            // we may not see *any* pixels or the image is malformed;\n            // to make sure this is caught, move the current y down to\n            // max_y (which is what out_gif_code checks).\n            if (w == 0)\n               g->cur_y = g->max_y;\n\n            g->lflags = stbi__get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (stbi_uc *) g->lpal;\n            } else if (g->flags & 0x80) {\n               g->color_table = (stbi_uc *) g->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\n\n            o = stbi__process_gif_raster(s, g);\n            if (!o) return NULL;\n\n            // if this was the first frame,\n            pcount = g->w * g->h;\n            if (first_frame && (g->bgindex > 0)) {\n               // if first frame, any pixel not drawn to gets the background color\n               for (pi = 0; pi < pcount; ++pi) {\n                  if (g->history[pi] == 0) {\n                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;\n                     MemCopy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );\n                  }\n               }\n            }\n\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            int ext = stbi__get8(s);\n            if (ext == 0xF9) { // Graphic Control Extension.\n               len = stbi__get8(s);\n               if (len == 4) {\n                  g->eflags = stbi__get8(s);\n                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.\n\n                  // unset old transparent\n                  if (g->transparent >= 0) {\n                     g->pal[g->transparent][3] = 255;\n                  }\n                  if (g->eflags & 0x01) {\n                     g->transparent = stbi__get8(s);\n                     if (g->transparent >= 0) {\n                        g->pal[g->transparent][3] = 0;\n                     }\n                  } else {\n                     // don't need transparent\n                     stbi__skip(s, 1);\n                     g->transparent = -1;\n                  }\n               } else {\n                  stbi__skip(s, len);\n                  break;\n               }\n            }\n            while ((len = stbi__get8(s)) != 0) {\n               stbi__skip(s, len);\n            }\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}\n\nstatic void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)\n{\n   STBI_FREE(g->out);\n   STBI_FREE(g->history);\n   STBI_FREE(g->background);\n\n   if (out) STBI_FREE(out);\n   if (delays && *delays) STBI_FREE(*delays);\n   return stbi__errpuc(\"outofmem\", \"Out of memory\");\n}\n\nstatic void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)\n{\n   if (stbi__gif_test(s)) {\n      int layers = 0;\n      stbi_uc *u = 0;\n      stbi_uc *out = 0;\n      stbi_uc *two_back = 0;\n      stbi__gif g;\n      int stride;\n      int out_size = 0;\n      int delays_size = 0;\n\n      STBI_NOTUSED(out_size);\n      STBI_NOTUSED(delays_size);\n\n      MemSet(&g, 0, sizeof(g));\n      if (delays) {\n         *delays = 0;\n      }\n\n      do {\n         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);\n         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n\n         if (u) {\n            *x = g.w;\n            *y = g.h;\n            ++layers;\n            stride = g.w * g.h * 4;\n\n            if (out) {\n               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );\n               if (!tmp)\n                  return stbi__load_gif_main_outofmem(&g, out, delays);\n               else {\n                   out = (stbi_uc*) tmp;\n                   out_size = layers * stride;\n               }\n\n               if (delays) {\n                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );\n                  if (!new_delays)\n                     return stbi__load_gif_main_outofmem(&g, out, delays);\n                  *delays = new_delays;\n                  delays_size = layers * sizeof(int);\n               }\n            } else {\n               out = (stbi_uc*)stbi__malloc( layers * stride );\n               if (!out)\n                  return stbi__load_gif_main_outofmem(&g, out, delays);\n               out_size = layers * stride;\n               if (delays) {\n                  *delays = (int*) stbi__malloc( layers * sizeof(int) );\n                  if (!*delays)\n                     return stbi__load_gif_main_outofmem(&g, out, delays);\n                  delays_size = layers * sizeof(int);\n               }\n            }\n            MemCopy( out + ((layers - 1) * stride), u, stride );\n            if (layers >= 2) {\n               two_back = out - 2 * stride;\n            }\n\n            if (delays) {\n               (*delays)[layers - 1U] = g.delay;\n            }\n         }\n      } while (u != 0);\n\n      // free temp buffer;\n      STBI_FREE(g.out);\n      STBI_FREE(g.history);\n      STBI_FREE(g.background);\n\n      // do the final conversion after loading everything;\n      if (req_comp && req_comp != 4)\n         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);\n\n      *z = layers;\n      return out;\n   } else {\n      return stbi__errpuc(\"not GIF\", \"Image was not as a gif type.\");\n   }\n}\n\nstatic void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *u = 0;\n   stbi__gif g;\n   MemSet(&g, 0, sizeof(g));\n   STBI_NOTUSED(ri);\n\n   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n   if (u) {\n      *x = g.w;\n      *y = g.h;\n\n      // moved conversion to after successful load so that the same\n      // can be done for multiple frames.\n      if (req_comp && req_comp != 4)\n         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\n   } else if (g.out) {\n      // if there was an error and we allocated an image buffer, free it!\n      STBI_FREE(g.out);\n   }\n\n   // free buffers needed for multiple frame loading;\n   STBI_FREE(g.history);\n   STBI_FREE(g.background);\n\n   return u;\n}\n\nstatic int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   return stbi__gif_info_raw(s,x,y,comp);\n}\n#endif\n\n// *************************************************************************************************\n// Radiance RGBE HDR loader\n// originally by Nicolas Schulz\n#ifndef STBI_NO_HDR\nstatic int stbi__hdr_test_core(stbi__context *s, const char *signature)\n{\n   int i;\n   for (i=0; signature[i]; ++i)\n      if (stbi__get8(s) != signature[i])\n          return 0;\n   stbi__rewind(s);\n   return 1;\n}\n\nstatic int stbi__hdr_test(stbi__context* s)\n{\n   int r = stbi__hdr_test_core(s, \"#?RADIANCE\\n\");\n   stbi__rewind(s);\n   if(!r) {\n       r = stbi__hdr_test_core(s, \"#?RGBE\\n\");\n       stbi__rewind(s);\n   }\n   return r;\n}\n\n#define STBI__HDR_BUFLEN  1024\nstatic char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\n{\n   int len=0;\n   char c = '\\0';\n\n   c = (char) stbi__get8(z);\n\n   while (!stbi__at_eof(z) && c != '\\n') {\n      buffer[len++] = c;\n      if (len == STBI__HDR_BUFLEN-1) {\n         // flush to end of line\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\n            ;\n         break;\n      }\n      c = (char) stbi__get8(z);\n   }\n\n   buffer[len] = 0;\n   return buffer;\n}\n\nstatic void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)\n{\n   if ( input[3] != 0 ) {\n      float f1;\n      // Exponent\n      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));\n      if (req_comp <= 2)\n         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\n      else {\n         output[0] = input[0] * f1;\n         output[1] = input[1] * f1;\n         output[2] = input[2] * f1;\n      }\n      if (req_comp == 2) output[1] = 1;\n      if (req_comp == 4) output[3] = 1;\n   } else {\n      switch (req_comp) {\n         case 4: output[3] = 1; /* fallthrough */\n         case 3: output[0] = output[1] = output[2] = 0;\n                 break;\n         case 2: output[1] = 1; /* fallthrough */\n         case 1: output[0] = 0;\n                 break;\n      }\n   }\n}\n\nstatic float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}\n\nstatic int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int dummy;\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   if (stbi__hdr_test(s) == 0) {\n       stbi__rewind( s );\n       return 0;\n   }\n\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *y = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *x = (int) strtol(token, NULL, 10);\n   *comp = 3;\n   return 1;\n}\n#endif // STBI_NO_HDR\n\n#ifndef STBI_NO_BMP\nstatic int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   void *p;\n   stbi__bmp_data info;\n\n   info.all_a = 255;\n   p = stbi__bmp_parse_header(s, &info);\n   if (p == NULL) {\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = s->img_x;\n   if (y) *y = s->img_y;\n   if (comp) {\n      if (info.bpp == 24 && info.ma == 0xff000000)\n         *comp = 3;\n      else\n         *comp = info.ma ? 4 : 3;\n   }\n   return 1;\n}\n#endif\n\n#ifndef STBI_NO_PSD\nstatic int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int channelCount, dummy, depth;\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *y = stbi__get32be(s);\n   *x = stbi__get32be(s);\n   depth = stbi__get16be(s);\n   if (depth != 8 && depth != 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 3) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *comp = 4;\n   return 1;\n}\n\nstatic int stbi__psd_is16(stbi__context *s)\n{\n   int channelCount, depth;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   STBI_NOTUSED(stbi__get32be(s));\n   STBI_NOTUSED(stbi__get32be(s));\n   depth = stbi__get16be(s);\n   if (depth != 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   return 1;\n}\n#endif\n\n#ifndef STBI_NO_PIC\nstatic int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int act_comp=0,num_packets=0,chained,dummy;\n   stbi__pic_packet packets[10];\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\")) {\n      stbi__rewind(s);\n      return 0;\n   }\n\n   stbi__skip(s, 88);\n\n   *x = stbi__get16be(s);\n   *y = stbi__get16be(s);\n   if (stbi__at_eof(s)) {\n      stbi__rewind( s);\n      return 0;\n   }\n   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {\n      stbi__rewind( s );\n      return 0;\n   }\n\n   stbi__skip(s, 8);\n\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return 0;\n\n      packet = &packets[num_packets++];\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s)) {\n          stbi__rewind( s );\n          return 0;\n      }\n      if (packet->size != 8) {\n          stbi__rewind( s );\n          return 0;\n      }\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3);\n\n   return 1;\n}\n#endif\n\n// *************************************************************************************************\n// Portable Gray Map and Portable Pixel Map loader\n// by Ken Miller\n//\n// PGM: http://netpbm.sourceforge.net/doc/pgm.html\n// PPM: http://netpbm.sourceforge.net/doc/ppm.html\n//\n// Known limitations:\n//    Does not support comments in the header section\n//    Does not support ASCII image data (formats P2 and P3)\n\n#ifndef STBI_NO_PNM\n\nstatic int      stbi__pnm_test(stbi__context *s)\n{\n   char p, t;\n   p = (char) stbi__get8(s);\n   t = (char) stbi__get8(s);\n   if (p != 'P' || (t != '5' && t != '6')) {\n       stbi__rewind( s );\n       return 0;\n   }\n   return 1;\n}\n\nstatic void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n\n   if (req_comp && req_comp != s->img_n) {\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}\n\nstatic int      stbi__pnm_isspace(char c)\n{\n   return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\n}\n\nstatic void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)\n{\n   for (;;) {\n      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))\n         *c = (char) stbi__get8(s);\n\n      if (stbi__at_eof(s) || *c != '#')\n         break;\n\n      while (!stbi__at_eof(s) && *c != '\\n' && *c != '\\r' )\n         *c = (char) stbi__get8(s);\n   }\n}\n\nstatic int      stbi__pnm_isdigit(char c)\n{\n   return c >= '0' && c <= '9';\n}\n\nstatic int      stbi__pnm_getinteger(stbi__context *s, char *c)\n{\n   int value = 0;\n\n   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {\n      value = value*10 + (*c - '0');\n      *c = (char) stbi__get8(s);\n   }\n\n   return value;\n}\n\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int maxv, dummy;\n   char c, p, t;\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   stbi__rewind(s);\n\n   // Get identifier\n   p = (char) stbi__get8(s);\n   t = (char) stbi__get8(s);\n   if (p != 'P' || (t != '5' && t != '6')) {\n       stbi__rewind(s);\n       return 0;\n   }\n\n   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm\n\n   c = (char) stbi__get8(s);\n   stbi__pnm_skip_whitespace(s, &c);\n\n   *x = stbi__pnm_getinteger(s, &c); // read width\n   stbi__pnm_skip_whitespace(s, &c);\n\n   *y = stbi__pnm_getinteger(s, &c); // read height\n   stbi__pnm_skip_whitespace(s, &c);\n\n   maxv = stbi__pnm_getinteger(s, &c);  // read max value\n   if (maxv > 65535)\n      return stbi__err(\"max value > 65535\", \"PPM image supports only 8-bit and 16-bit images\");\n   else if (maxv > 255)\n      return 16;\n   else\n      return 8;\n}\n\nstatic int stbi__pnm_is16(stbi__context *s)\n{\n   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)\n\t   return 1;\n   return 0;\n}\n#endif\n\nstatic int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)\n{\n   #ifndef STBI_NO_JPEG\n   if (stbi__jpeg_info(s, x, y, comp)) return 1;\n   #endif\n\n   #ifndef STBI_NO_PNG\n   if (stbi__png_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_GIF\n   if (stbi__gif_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_BMP\n   if (stbi__bmp_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PIC\n   if (stbi__pic_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_info(s, x, y, comp))  return 1;\n   #endif\n\n   // test tga last because it's a crappy test!\n   #ifndef STBI_NO_TGA\n   if (stbi__tga_info(s, x, y, comp))\n       return 1;\n   #endif\n   return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nstatic int stbi__is_16_main(stbi__context *s)\n{\n   #ifndef STBI_NO_PNG\n   if (stbi__png_is16(s))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_is16(s))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_is16(s))  return 1;\n   #endif\n   return 0;\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_info_from_file(f, x, y, comp);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__info_main(&s,x,y,comp);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n\nSTBIDEF int stbi_is_16_bit(char const *filename)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_is_16_bit_from_file(f);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_is_16_bit_from_file(FILE *f)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__is_16_main(&s);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__is_16_main(&s);\n}\n\nSTBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__is_16_main(&s);\n}\n\n#endif // STB_IMAGE_IMPLEMENTATION\n\n/*\n   revision history:\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\n      2.19  (2018-02-11) fix warning\n      2.18  (2018-01-30) fix warnings\n      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug\n                         1-bit BMP\n                         *_is_16_bit api\n                         avoid warnings\n      2.16  (2017-07-23) all functions have 16-bit variants;\n                         STBI_NO_STDIO works again;\n                         compilation fixes;\n                         fix rounding in unpremultiply;\n                         optimize vertical flip;\n                         disable raw_len validation;\n                         documentation fixes\n      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;\n                         warning fixes; disable run-time SSE detection on gcc;\n                         uniform handling of optional \"return\" values;\n                         thread-safe initialization of zlib tables\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\n      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\n      2.11  (2016-04-02) allocate large structures on the stack\n                         remove white matting for transparent PSD\n                         fix reported channel count for PNG & BMP\n                         re-enable SSE2 in non-gcc 64-bit\n                         support RGB-formatted JPEG\n                         read 16-bit PNGs (only as 8-bit)\n      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED\n      2.09  (2016-01-16) allow comments in PNM files\n                         16-bit-per-pixel TGA (not bit-per-component)\n                         info() for TGA could break due to .hdr handling\n                         info() for BMP to shares code instead of sloppy parse\n                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc\n                         code cleanup\n      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA\n      2.07  (2015-09-13) fix compiler warnings\n                         partial animated GIF support\n                         limited 16-bpc PSD support\n                         #ifdef unused functions\n                         bug with < 92 byte PIC,PNM,HDR,TGA\n      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value\n      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning\n      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit\n      2.03  (2015-04-12) extra corruption checking (mmozeiko)\n                         stbi_set_flip_vertically_on_load (nguillemot)\n                         fix NEON support; fix mingw support\n      2.02  (2015-01-19) fix incorrect assert, fix warning\n      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2\n      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG\n      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)\n                         progressive JPEG (stb)\n                         PGM/PPM support (Ken Miller)\n                         STBI_MALLOC,STBI_REALLOC,STBI_FREE\n                         GIF bugfix -- seemingly never worked\n                         STBI_NO_*, STBI_ONLY_*\n      1.48  (2014-12-14) fix incorrectly-named assert()\n      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)\n                         optimize PNG (ryg)\n                         fix bug in interlaced PNG with user-specified channel count (stb)\n      1.46  (2014-08-26)\n              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\n      1.45  (2014-08-16)\n              fix MSVC-ARM internal compiler error by wrapping malloc\n      1.44  (2014-08-07)\n              various warning fixes from Ronny Chevalier\n      1.43  (2014-07-15)\n              fix MSVC-only compiler problem in code changed in 1.42\n      1.42  (2014-07-09)\n              don't define _CRT_SECURE_NO_WARNINGS (affects user code)\n              fixes to stbi__cleanup_jpeg path\n              added STBI_ASSERT to avoid requiring assert.h\n      1.41  (2014-06-25)\n              fix search&replace from 1.36 that messed up comments/error messages\n      1.40  (2014-06-22)\n              fix gcc struct-initialization warning\n      1.39  (2014-06-15)\n              fix to TGA optimization when req_comp != number of components in TGA;\n              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\n              add support for BMP version 5 (more ignored fields)\n      1.38  (2014-06-06)\n              suppress MSVC warnings on integer casts truncating values\n              fix accidental rename of 'skip' field of I/O\n      1.37  (2014-06-04)\n              remove duplicate typedef\n      1.36  (2014-06-03)\n              convert to header file single-file library\n              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\n      1.35  (2014-05-27)\n              various warnings\n              fix broken STBI_SIMD path\n              fix bug where stbi_load_from_file no longer left file pointer in correct place\n              fix broken non-easy path for 32-bit BMP (possibly never used)\n              TGA optimization by Arseny Kapoulkine\n      1.34  (unknown)\n              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\n      1.33  (2011-07-14)\n              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\n      1.32  (2011-07-13)\n              support for \"info\" function for all supported filetypes (SpartanJ)\n      1.31  (2011-06-20)\n              a few more leak fixes, bug in PNG handling (SpartanJ)\n      1.30  (2011-06-11)\n              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\n              removed deprecated format-specific test/load functions\n              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\n              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\n              fix inefficiency in decoding 32-bit BMP (David Woo)\n      1.29  (2010-08-16)\n              various warning fixes from Aurelien Pocheville\n      1.28  (2010-08-01)\n              fix bug in GIF palette transparency (SpartanJ)\n      1.27  (2010-08-01)\n              cast-to-stbi_uc to fix warnings\n      1.26  (2010-07-24)\n              fix bug in file buffering for PNG reported by SpartanJ\n      1.25  (2010-07-17)\n              refix trans_data warning (Won Chun)\n      1.24  (2010-07-12)\n              perf improvements reading from files on platforms with lock-heavy fgetc()\n              minor perf improvements for jpeg\n              deprecated type-specific functions so we'll get feedback if they're needed\n              attempt to fix trans_data warning (Won Chun)\n      1.23    fixed bug in iPhone support\n      1.22  (2010-07-10)\n              removed image *writing* support\n              stbi_info support from Jetro Lauha\n              GIF support from Jean-Marc Lienher\n              iPhone PNG-extensions from James Brown\n              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\n      1.21    fix use of 'stbi_uc' in header (reported by jon blow)\n      1.20    added support for Softimage PIC, by Tom Seddon\n      1.19    bug in interlaced PNG corruption check (found by ryg)\n      1.18  (2008-08-02)\n              fix a threading bug (local mutable static)\n      1.17    support interlaced PNG\n      1.16    major bugfix - stbi__convert_format converted one too many pixels\n      1.15    initialize some fields for thread safety\n      1.14    fix threadsafe conversion bug\n              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\n      1.13    threadsafe\n      1.12    const qualifiers in the API\n      1.11    Support installable IDCT, colorspace conversion routines\n      1.10    Fixes for 64-bit (don't use \"unsigned long\")\n              optimized upsampling by Fabian \"ryg\" Giesen\n      1.09    Fix format-conversion for PSD code (bad global variables!)\n      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz\n      1.07    attempt to fix C++ warning/errors again\n      1.06    attempt to fix C++ warning/errors again\n      1.05    fix TGA loading to return correct *comp and use good luminance calc\n      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free\n      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR\n      1.02    support for (subset of) HDR files, float interface for preferred access to them\n      1.01    fix bug: possible bug in handling right-side up bmps... not sure\n              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\n      1.00    interface to zlib that skips zlib header\n      0.99    correct handling of alpha in palette\n      0.98    TGA loader by lonesock; dynamically add loaders (untested)\n      0.97    jpeg errors on too large a file; also catch another malloc failure\n      0.96    fix detection of invalid v value - particleman@mollyrocket forum\n      0.95    during header scan, seek to markers in case of padding\n      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same\n      0.93    handle jpegtran output; verbose errors\n      0.92    read 4,8,16,24,32-bit BMP files of several formats\n      0.91    output 24-bit Windows 3.0 BMP files\n      0.90    fix a few more warnings; bump version number to approach 1.0\n      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd\n      0.60    fix compiling as c++\n      0.59    fix warnings: merge Dave Moore's -Wall fixes\n      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian\n      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\n      0.56    fix bug: zlib uncompressed mode len vs. nlen\n      0.55    fix bug: restart_interval not initialized to 0\n      0.54    allow NULL for 'int *comp'\n      0.53    fix bug in png 3->4; speedup png decoding\n      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments\n      0.51    obey req_comp requests, 1-component jpegs return as 1-component,\n              on 'test' only check type, not whether we support this variant\n      0.50  (2006-11-19)\n              first released version\n*/\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#ifndef _H_VEC2_\n#define _H_VEC2_\n\ntemplate<typename T>\nstruct TVec2 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t};\n\t\tT v[2];\n\t};\n\tinline TVec2() : x(T(0)), y(T(0)) { }\n\tinline TVec2(T _x, T _y) :\n\t\tx(_x), y(_y) { }\n\tinline TVec2(T* fv) :\n\t\tx(fv[0]), y(fv[1]) { }\n};\n\ntypedef TVec2<float> vec2;\ntypedef TVec2<int> ivec2;\ntypedef TVec2<unsigned int> uivec2;\n\nvec2 operator-(const vec2& l, const vec2& r);\nvec2 operator+(const vec2& l, const vec2& r);\nvec2 operator*(const vec2& l, const vec2& r);\nvec2 operator*(const vec2& l, float f);\n\n\n#endif","#include \"vec2.h\"\n#include \"../platform/math.h\"\n\nvec2 operator-(const vec2& l, const vec2& r) {\n\treturn vec2(l.x - r.x, l.y - r.y);\n}\n\nvec2 operator+(const vec2& l, const vec2& r) {\n\treturn vec2(l.x + r.x, l.y + r.y);\n}\n\nvec2 operator*(const vec2& l, const vec2& r) {\n\treturn vec2(l.x * r.x, l.y * r.y);\n}\n\nvec2 operator*(const vec2& l, float f) {\n\treturn vec2(l.x * f, l.y * f);\n}","#ifndef _H_VEC4_\n#define _H_VEC4_\n\ntemplate<typename T>\nstruct TVec4 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t\tT z;\n\t\t\tT w;\n\t\t};\n\t\tT v[4];\n\t};\n\tinline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n\tinline TVec4(T _x, T _y, T _z, T _w) :\n\t\tx(_x), y(_y), z(_z), w(_w) { }\n\tinline TVec4(T* fv) :\n\t\tx(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n};\n\ntypedef TVec4<float> vec4;\ntypedef TVec4<int> ivec4;\ntypedef TVec4<unsigned int> uivec4;\n\n#endif","#define STB_VORBIS_NO_CRT\n#define STB_VORBIS_NO_STDIO\n#define STB_VORBIS_NO_PUSHDATA_API\n\n#include \"../platform/memory.h\"\n#include \"../platform/math.h\"\n#include \"../platform/assert.h\"\n#include \"../framework/sort.h\"\n\n#define VORBIS_UINT_MAX 4294967295 \n#define VORBIS_ASSERT(cond) PlatformAssert(cond, __LOCATION__)\n\n// Ogg Vorbis audio decoder - v1.22 - public domain\n// http://nothings.org/stb_vorbis/\n//\n// Original version written by Sean Barrett in 2007.\n//\n// Originally sponsored by RAD Game Tools. Seeking implementation\n// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,\n// Elias Software, Aras Pranckevicius, and Sean Barrett.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// Limitations:\n//\n//   - floor 0 not supported (used in old ogg vorbis files pre-2004)\n//   - lossless sample-truncation at beginning ignored\n//   - cannot concatenate multiple vorbis streams\n//   - sample positions are 32-bit, limiting seekable 192Khz\n//       files to around 6 hours (Ogg supports 64-bit)\n//\n// Feature contributors:\n//    Dougall Johnson (sample-exact seeking)\n//\n// Bugfix/warning contributors:\n//    Terje Mathisen     Niklas Frykholm     Andy Hill\n//    Casey Muratori     John Bolton         Gargaj\n//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier\n//    Bernhard Wodo      Evan Balster        github:alxprd\n//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot\n//    Phillip Bennefall  Rohit               Thiago Goulart\n//    github:manxorist   Saga Musix          github:infatum\n//    Timur Gagiev       Maxwell Koo         Peter Waller\n//    github:audinowho   Dougall Johnson     David Reid\n//    github:Clownacy    Pedro J. Estebanez  Remi Verschelde\n//    AnthoFoxo          github:morlat       Gabriel Ravier\n//\n// Partial history:\n//    1.22    - 2021-07-11 - various small fixes\n//    1.21    - 2021-07-02 - fix bug for files with no comments\n//    1.20    - 2020-07-11 - several small fixes\n//    1.19    - 2020-02-05 - warnings\n//    1.18    - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.\n//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)\n//    1.16    - 2019-03-04 - fix warnings\n//    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n//    1.14    - 2018-02-11 - delete bogus dealloca usage\n//    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n//    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n//    1.11    - 2017-07-23 - fix MinGW compilation\n//    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n//    1.09    - 2016-04-04 - back out 'truncation of last frame' fix from previous version\n//    1.08    - 2016-04-02 - warnings; setup memory leaks; truncation of last frame\n//    1.07    - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const\n//    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n//                           some crash fixes when out of memory or with corrupt files\n//                           fix some inappropriately signed shifts\n//    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n//    1.04    - 2014-08-27 - fix missing const-correct case in API\n//    1.03    - 2014-08-07 - warning fixes\n//    1.02    - 2014-07-09 - declare qsort comparison as explicitly _cdecl in Windows\n//    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float (interleaved was correct)\n//    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;\n//                           (API change) report sample rate for decode-full-file funcs\n//\n// See end of file for full version history.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  HEADER BEGINS HERE\n//\n\n#ifndef STB_VORBIS_INCLUDE_STB_VORBIS_H\n#define STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n#define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_STDIO\n#endif\n\n    ///////////   THREAD SAFETY\n\n    // Individual stb_vorbis* handles are not thread-safe; you cannot decode from\n    // them from multiple threads at the same time. However, you can have multiple\n    // stb_vorbis* handles and decode from them independently in multiple thrads.\n\n\n    ///////////   MEMORY ALLOCATION\n\n    // normally stb_vorbis uses malloc() to allocate memory at startup,\n    // and alloca() to allocate temporary memory during a frame on the\n    // stack. (Memory consumption will depend on the amount of setup\n    // data in the file and how you set the compile flags for speed\n    // vs. size. In my test files the maximal-size usage is ~150KB.)\n    //\n    // You can modify the wrapper functions in the source (setup_malloc,\n    // setup_temp_malloc, temp_malloc) to change this behavior, or you\n    // can use a simpler allocation model: you pass in a buffer from\n    // which stb_vorbis will allocate _all_ its memory (including the\n    // temp memory). \"open\" may fail with a VORBIS_outofmem if you\n    // do not pass in enough data; there is no way to determine how\n    // much you do need except to succeed (at which point you can\n    // query get_info to find the exact amount required. yes I know\n    // this is lame).\n    //\n    // If you pass in a non-NULL buffer of the type below, allocation\n    // will occur from it as described above. Otherwise just pass NULL\n    // to use malloc()/alloca()\n\n    typedef struct\n    {\n        char* alloc_buffer;\n        int   alloc_buffer_length_in_bytes;\n    } stb_vorbis_alloc;\n\n\n    ///////////   FUNCTIONS USEABLE WITH ALL INPUT MODES\n\n    typedef struct stb_vorbis stb_vorbis;\n\n    typedef struct\n    {\n        unsigned int sample_rate;\n        int channels;\n\n        unsigned int setup_memory_required;\n        unsigned int setup_temp_memory_required;\n        unsigned int temp_memory_required;\n\n        int max_frame_size;\n    } stb_vorbis_info;\n\n    typedef struct\n    {\n        char* vendor;\n\n        int comment_list_length;\n        char** comment_list;\n    } stb_vorbis_comment;\n\n    // get general information about the file\n    stb_vorbis_info stb_vorbis_get_info(stb_vorbis* f);\n\n    // get ogg comments\n    stb_vorbis_comment stb_vorbis_get_comment(stb_vorbis* f);\n\n    // get the last error detected (clears it, too)\n    int stb_vorbis_get_error(stb_vorbis* f);\n\n    // close an ogg vorbis file and free all memory in use\n    void stb_vorbis_close(stb_vorbis* f);\n\n    // this function returns the offset (in samples) from the beginning of the\n    // file that will be returned by the next decode, if it is known, or -1\n    // otherwise. after a flush_pushdata() call, this may take a while before\n    // it becomes valid again.\n    // NOT WORKING YET after a seek with PULLDATA API\n    int stb_vorbis_get_sample_offset(stb_vorbis* f);\n\n    // returns the current seek point within the file, or offset from the beginning\n    // of the memory buffer. In pushdata mode it returns 0.\n    unsigned int stb_vorbis_get_file_offset(stb_vorbis* f);\n\n    ///////////   PUSHDATA API\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\n// this API allows you to get blocks of data from any source and hand\n// them to stb_vorbis. you have to buffer them; stb_vorbis will tell\n// you how much it used, and you have to give it the rest next time;\n// and stb_vorbis may not have enough data to work with and you will\n// need to give it the same data again PLUS more. Note that the Vorbis\n// specification does not bound the size of an individual frame.\n\n    stb_vorbis* stb_vorbis_open_pushdata(\n        const unsigned char* datablock, int datablock_length_in_bytes,\n        int* datablock_memory_consumed_in_bytes,\n        int* error,\n        const stb_vorbis_alloc* alloc_buffer);\n    // create a vorbis decoder by passing in the initial data block containing\n    //    the ogg&vorbis headers (you don't need to do parse them, just provide\n    //    the first N bytes of the file--you're told if it's not enough, see below)\n    // on success, returns an stb_vorbis *, does not set error, returns the amount of\n    //    data parsed/consumed on this call in *datablock_memory_consumed_in_bytes;\n    // on failure, returns NULL on error and sets *error, does not change *datablock_memory_consumed\n    // if returns NULL and *error is VORBIS_need_more_data, then the input block was\n    //       incomplete and you need to pass in a larger block from the start of the file\n\n    int stb_vorbis_decode_frame_pushdata(\n        stb_vorbis* f,\n        const unsigned char* datablock, int datablock_length_in_bytes,\n        int* channels,             // place to write number of float * buffers\n        float*** output,           // place to write float ** array of float * buffers\n        int* samples               // place to write number of output samples\n    );\n    // decode a frame of audio sample data if possible from the passed-in data block\n    //\n    // return value: number of bytes we used from datablock\n    //\n    // possible cases:\n    //     0 bytes used, 0 samples output (need more data)\n    //     N bytes used, 0 samples output (resynching the stream, keep going)\n    //     N bytes used, M samples output (one frame of data)\n    // note that after opening a file, you will ALWAYS get one N-bytes,0-sample\n    // frame, because Vorbis always \"discards\" the first frame.\n    //\n    // Note that on resynch, stb_vorbis will rarely consume all of the buffer,\n    // instead only datablock_length_in_bytes-3 or less. This is because it wants\n    // to avoid missing parts of a page header if they cross a datablock boundary,\n    // without writing state-machiney code to record a partial detection.\n    //\n    // The number of channels returned are stored in *channels (which can be\n    // NULL--it is always the same as the number of channels reported by\n    // get_info). *output will contain an array of float* buffers, one per\n    // channel. In other words, (*output)[0][0] contains the first sample from\n    // the first channel, and (*output)[1][0] contains the first sample from\n    // the second channel.\n    //\n    // *output points into stb_vorbis's internal output buffer storage; these\n    // buffers are owned by stb_vorbis and application code should not free\n    // them or modify their contents. They are transient and will be overwritten\n    // once you ask for more data to get decoded, so be sure to grab any data\n    // you need before then.\n\n    void stb_vorbis_flush_pushdata(stb_vorbis* f);\n    // inform stb_vorbis that your next datablock will not be contiguous with\n    // previous ones (e.g. you've seeked in the data); future attempts to decode\n    // frames will cause stb_vorbis to resynchronize (as noted above), and\n    // once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it\n    // will begin decoding the _next_ frame.\n    //\n    // if you want to seek using pushdata, you need to seek in your file, then\n    // call stb_vorbis_flush_pushdata(), then start calling decoding, then once\n    // decoding is returning you data, call stb_vorbis_get_sample_offset, and\n    // if you don't like the result, seek your file again and repeat.\n#endif\n\n\n//////////   PULLING INPUT API\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n// This API assumes stb_vorbis is allowed to pull data from a source--\n// either a block of memory containing the _entire_ vorbis stream, or a\n// FILE * that you or it create, or possibly some other reading mechanism\n// if you go modify the source to replace the FILE * case with some kind\n// of callback to your code. (But if you don't support seeking, you may\n// just want to go ahead and use pushdata.)\n\n#if !defined(STB_VORBIS_NO_STDIO) && !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\n    int stb_vorbis_decode_filename(const char* filename, int* channels, int* sample_rate, short** output);\n#endif\n#if !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\n    int stb_vorbis_decode_memory(const unsigned char* mem, int len, int* channels, int* sample_rate, short** output);\n#endif\n    // decode an entire file and output the data interleaved into a malloc()ed\n    // buffer stored in *output. The return value is the number of samples\n    // decoded, or -1 if the file could not be opened or was not an ogg vorbis file.\n    // When you're done with it, just free() the pointer returned in *output.\n\n    stb_vorbis* stb_vorbis_open_memory(const unsigned char* data, int len,\n        int* error, const stb_vorbis_alloc* alloc_buffer);\n    // create an ogg vorbis decoder from an ogg vorbis stream in memory (note\n    // this must be the entire stream!). on failure, returns NULL and sets *error\n\n#ifndef STB_VORBIS_NO_STDIO\n    stb_vorbis* stb_vorbis_open_filename(const char* filename,\n        int* error, const stb_vorbis_alloc* alloc_buffer);\n    // create an ogg vorbis decoder from a filename via fopen(). on failure,\n    // returns NULL and sets *error (possibly to VORBIS_file_open_failure).\n\n    stb_vorbis* stb_vorbis_open_file(FILE* f, int close_handle_on_close,\n        int* error, const stb_vorbis_alloc* alloc_buffer);\n    // create an ogg vorbis decoder from an open FILE *, looking for a stream at\n    // the _current_ seek point (ftell). on failure, returns NULL and sets *error.\n    // note that stb_vorbis must \"own\" this stream; if you seek it in between\n    // calls to stb_vorbis, it will become confused. Moreover, if you attempt to\n    // perform stb_vorbis_seek_*() operations on this file, it will assume it\n    // owns the _entire_ rest of the file after the start point. Use the next\n    // function, stb_vorbis_open_file_section(), to limit it.\n\n    stb_vorbis* stb_vorbis_open_file_section(FILE* f, int close_handle_on_close,\n        int* error, const stb_vorbis_alloc* alloc_buffer, unsigned int len);\n    // create an ogg vorbis decoder from an open FILE *, looking for a stream at\n    // the _current_ seek point (ftell); the stream will be of length 'len' bytes.\n    // on failure, returns NULL and sets *error. note that stb_vorbis must \"own\"\n    // this stream; if you seek it in between calls to stb_vorbis, it will become\n    // confused.\n#endif\n\n    int stb_vorbis_seek_frame(stb_vorbis* f, unsigned int sample_number);\n    int stb_vorbis_seek(stb_vorbis* f, unsigned int sample_number);\n    // these functions seek in the Vorbis file to (approximately) 'sample_number'.\n    // after calling seek_frame(), the next call to get_frame_*() will include\n    // the specified sample. after calling stb_vorbis_seek(), the next call to\n    // stb_vorbis_get_samples_* will start with the specified sample. If you\n    // do not need to seek to EXACTLY the target sample when using get_samples_*,\n    // you can also use seek_frame().\n\n    int stb_vorbis_seek_start(stb_vorbis* f);\n    // this function is equivalent to stb_vorbis_seek(f,0)\n\n    unsigned int stb_vorbis_stream_length_in_samples(stb_vorbis* f);\n    float        stb_vorbis_stream_length_in_seconds(stb_vorbis* f);\n    // these functions return the total length of the vorbis stream\n\n    int stb_vorbis_get_frame_float(stb_vorbis* f, int* channels, float*** output);\n    // decode the next frame and return the number of samples. the number of\n    // channels returned are stored in *channels (which can be NULL--it is always\n    // the same as the number of channels reported by get_info). *output will\n    // contain an array of float* buffers, one per channel. These outputs will\n    // be overwritten on the next call to stb_vorbis_get_frame_*.\n    //\n    // You generally should not intermix calls to stb_vorbis_get_frame_*()\n    // and stb_vorbis_get_samples_*(), since the latter calls the former.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n    int stb_vorbis_get_frame_short_interleaved(stb_vorbis* f, int num_c, short* buffer, int num_shorts);\n    int stb_vorbis_get_frame_short(stb_vorbis* f, int num_c, short** buffer, int num_samples);\n#endif\n    // decode the next frame and return the number of *samples* per channel.\n    // Note that for interleaved data, you pass in the number of shorts (the\n    // size of your array), but the return value is the number of samples per\n    // channel, not the total number of samples.\n    //\n    // The data is coerced to the number of channels you request according to the\n    // channel coercion rules (see below). You must pass in the size of your\n    // buffer(s) so that stb_vorbis will not overwrite the end of the buffer.\n    // The maximum buffer size needed can be gotten from get_info(); however,\n    // the Vorbis I specification implies an absolute maximum of 4096 samples\n    // per channel.\n\n    // Channel coercion rules:\n    //    Let M be the number of channels requested, and N the number of channels present,\n    //    and Cn be the nth channel; let stereo L be the sum of all L and center channels,\n    //    and stereo R be the sum of all R and center channels (channel assignment from the\n    //    vorbis spec).\n    //        M    N       output\n    //        1    k      sum(Ck) for all k\n    //        2    *      stereo L, stereo R\n    //        k    l      k > l, the first l channels, then 0s\n    //        k    l      k <= l, the first k channels\n    //    Note that this is not _good_ surround etc. mixing at all! It's just so\n    //    you get something useful.\n\n    int stb_vorbis_get_samples_float_interleaved(stb_vorbis* f, int channels, float* buffer, int num_floats);\n    int stb_vorbis_get_samples_float(stb_vorbis* f, int channels, float** buffer, int num_samples);\n    // gets num_samples samples, not necessarily on a frame boundary--this requires\n    // buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.\n    // Returns the number of samples stored per channel; it may be less than requested\n    // at the end of the file. If there are no more samples in the file, returns 0.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n    int stb_vorbis_get_samples_short_interleaved(stb_vorbis* f, int channels, short* buffer, int num_shorts);\n    int stb_vorbis_get_samples_short(stb_vorbis* f, int channels, short** buffer, int num_samples);\n#endif\n    // gets num_samples samples, not necessarily on a frame boundary--this requires\n    // buffering so you have to supply the buffers. Applies the coercion rules above\n    // to produce 'channels' channels. Returns the number of samples stored per channel;\n    // it may be less than requested at the end of the file. If there are no more\n    // samples in the file, returns 0.\n\n#endif\n\n////////   ERROR CODES\n\n    enum STBVorbisError\n    {\n        VORBIS__no_error,\n\n        VORBIS_need_more_data = 1,             // not a real error\n\n        VORBIS_invalid_api_mixing,           // can't mix API modes\n        VORBIS_outofmem,                     // not enough memory\n        VORBIS_feature_not_supported,        // uses floor 0\n        VORBIS_too_many_channels,            // STB_VORBIS_MAX_CHANNELS is too small\n        VORBIS_file_open_failure,            // fopen() failed\n        VORBIS_seek_without_length,          // can't seek in unknown-length file\n\n        VORBIS_unexpected_eof = 10,            // file is truncated?\n        VORBIS_seek_invalid,                 // seek past EOF\n\n        // decoding errors (corrupt/invalid stream) -- you probably\n        // don't care about the exact details of these\n\n        // vorbis errors:\n        VORBIS_invalid_setup = 20,\n        VORBIS_invalid_stream,\n\n        // ogg errors:\n        VORBIS_missing_capture_pattern = 30,\n        VORBIS_invalid_stream_structure_version,\n        VORBIS_continued_packet_flag_invalid,\n        VORBIS_incorrect_stream_serial_number,\n        VORBIS_invalid_first_page,\n        VORBIS_bad_packet_type,\n        VORBIS_cant_find_last_page,\n        VORBIS_seek_failed,\n        VORBIS_ogg_skeleton_not_supported\n    };\n\n\n#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H\n//\n//  HEADER ENDS HERE\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef STB_VORBIS_HEADER_ONLY\n\n// global configuration settings (e.g. set these in the project/makefile),\n// or just set them in this file at the top (although ideally the first few\n// should be visible when the header file is compiled too, although it's not\n// crucial)\n\n// STB_VORBIS_NO_PUSHDATA_API\n//     does not compile the code for the various stb_vorbis_*_pushdata()\n//     functions\n// #define STB_VORBIS_NO_PUSHDATA_API\n\n// STB_VORBIS_NO_PULLDATA_API\n//     does not compile the code for the non-pushdata APIs\n// #define STB_VORBIS_NO_PULLDATA_API\n\n// STB_VORBIS_NO_STDIO\n//     does not compile the code for the APIs that use FILE *s internally\n//     or externally (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_STDIO\n\n// STB_VORBIS_NO_INTEGER_CONVERSION\n//     does not compile the code for converting audio sample data from\n//     float to integer (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_INTEGER_CONVERSION\n\n// STB_VORBIS_NO_FAST_SCALED_FLOAT\n//      does not use a fast float-to-int trick to accelerate float-to-int on\n//      most platforms which requires endianness be defined correctly.\n//#define STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n\n// STB_VORBIS_MAX_CHANNELS [number]\n//     globally define this to the maximum number of channels you need.\n//     The spec does not put a restriction on channels except that\n//     the count is stored in a byte, so 255 is the hard limit.\n//     Reducing this saves about 16 bytes per value, so using 16 saves\n//     (255-16)*16 or around 4KB. Plus anything other memory usage\n//     I forgot to account for. Can probably go as low as 8 (7.1 audio),\n//     6 (5.1 audio), or 2 (stereo only).\n#ifndef STB_VORBIS_MAX_CHANNELS\n#define STB_VORBIS_MAX_CHANNELS    16  // enough for anyone?\n#endif\n\n// STB_VORBIS_PUSHDATA_CRC_COUNT [number]\n//     after a flush_pushdata(), stb_vorbis begins scanning for the\n//     next valid page, without backtracking. when it finds something\n//     that looks like a page, it streams through it and verifies its\n//     CRC32. Should that validation fail, it keeps scanning. But it's\n//     possible that _while_ streaming through to check the CRC32 of\n//     one candidate page, it sees another candidate page. This #define\n//     determines how many \"overlapping\" candidate pages it can search\n//     at once. Note that \"real\" pages are typically ~4KB to ~8KB, whereas\n//     garbage pages could be as big as 64KB, but probably average ~16KB.\n//     So don't hose ourselves by scanning an apparent 64KB page and\n//     missing a ton of real ones in the interim; so minimum of 2\n#ifndef STB_VORBIS_PUSHDATA_CRC_COUNT\n#define STB_VORBIS_PUSHDATA_CRC_COUNT  4\n#endif\n\n// STB_VORBIS_FAST_HUFFMAN_LENGTH [number]\n//     sets the log size of the huffman-acceleration table.  Maximum\n//     supported value is 24. with larger numbers, more decodings are O(1),\n//     but the table size is larger so worse cache missing, so you'll have\n//     to probe (and try multiple ogg vorbis files) to find the sweet spot.\n#ifndef STB_VORBIS_FAST_HUFFMAN_LENGTH\n#define STB_VORBIS_FAST_HUFFMAN_LENGTH   10\n#endif\n\n// STB_VORBIS_FAST_BINARY_LENGTH [number]\n//     sets the log size of the binary-search acceleration table. this\n//     is used in similar fashion to the fast-huffman size to set initial\n//     parameters for the binary search\n\n// STB_VORBIS_FAST_HUFFMAN_INT\n//     The fast huffman tables are much more efficient if they can be\n//     stored as 16-bit results instead of 32-bit results. This restricts\n//     the codebooks to having only 65535 possible outcomes, though.\n//     (At least, accelerated by the huffman table.)\n#ifndef STB_VORBIS_FAST_HUFFMAN_INT\n#define STB_VORBIS_FAST_HUFFMAN_SHORT\n#endif\n\n// STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n//     If the 'fast huffman' search doesn't succeed, then stb_vorbis falls\n//     back on binary searching for the correct one. This requires storing\n//     extra tables with the huffman codes in sorted order. Defining this\n//     symbol trades off space for speed by forcing a linear search in the\n//     non-fast case, except for \"sparse\" codebooks.\n// #define STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n\n// STB_VORBIS_DIVIDES_IN_RESIDUE\n//     stb_vorbis precomputes the result of the scalar residue decoding\n//     that would otherwise require a divide per chunk. you can trade off\n//     space for time by defining this symbol.\n// #define STB_VORBIS_DIVIDES_IN_RESIDUE\n\n// STB_VORBIS_DIVIDES_IN_CODEBOOK\n//     vorbis VQ codebooks can be encoded two ways: with every case explicitly\n//     stored, or with all elements being chosen from a small range of values,\n//     and all values possible in all elements. By default, stb_vorbis expands\n//     this latter kind out to look like the former kind for ease of decoding,\n//     because otherwise an integer divide-per-vector-element is required to\n//     unpack the index. If you define STB_VORBIS_DIVIDES_IN_CODEBOOK, you can\n//     trade off storage for speed.\n//#define STB_VORBIS_DIVIDES_IN_CODEBOOK\n\n#ifdef STB_VORBIS_CODEBOOK_SHORTS\n#error \"STB_VORBIS_CODEBOOK_SHORTS is no longer supported as it produced incorrect results for some input formats\"\n#endif\n\n// STB_VORBIS_DIVIDE_TABLE\n//     this replaces small integer divides in the floor decode loop with\n//     table lookups. made less than 1% difference, so disabled by default.\n\n// STB_VORBIS_NO_INLINE_DECODE\n//     disables the inlining of the scalar codebook fast-huffman decode.\n//     might save a little codespace; useful for debugging\n// #define STB_VORBIS_NO_INLINE_DECODE\n\n// STB_VORBIS_NO_DEFER_FLOOR\n//     Normally we only decode the floor without synthesizing the actual\n//     full curve. We can instead synthesize the curve immediately. This\n//     requires more memory and is very likely slower, so I don't think\n//     you'd ever want to do it except for debugging.\n// #define STB_VORBIS_NO_DEFER_FLOOR\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef STB_VORBIS_NO_PULLDATA_API\n#define STB_VORBIS_NO_INTEGER_CONVERSION\n#define STB_VORBIS_NO_STDIO\n#endif\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n#define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n   // only need endianness for fast-float-to-int, which we don't\n   // use for pushdata\n\n#ifndef STB_VORBIS_BIG_ENDIAN\n#define STB_VORBIS_ENDIAN  0\n#else\n#define STB_VORBIS_ENDIAN  1\n#endif\n\n#endif\n#endif\n\n\n#ifndef STB_VORBIS_NO_STDIO\n#endif\n\n#ifndef STB_VORBIS_NO_CRT\n\n// find definition of alloca if it's not in stdlib.h:\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#endif\n#if defined(__linux__) || defined(__linux) || defined(__sun__) || defined(__EMSCRIPTEN__) || defined(__NEWLIB__)\n#endif\n#else // STB_VORBIS_NO_CRT\n#define NULL 0\n#endif // STB_VORBIS_NO_CRT\n\n\n#ifdef __MINGW32__\n   // eff you mingw:\n   //     \"fixed\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32882927/\n   //     \"no that broke the build, reverted, who cares about C\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32890381/\n#ifdef __forceinline\n#undef __forceinline\n#endif\n#define __forceinline\n#ifndef alloca\n#define alloca __builtin_alloca\n#endif\n#elif !defined(_MSC_VER)\n#if __GNUC__\n#define __forceinline inline\n#else\n#define __forceinline\n#endif\n#endif\n\n#if STB_VORBIS_MAX_CHANNELS > 256\n#error \"Value of STB_VORBIS_MAX_CHANNELS outside of allowed range\"\n#endif\n\n#if STB_VORBIS_FAST_HUFFMAN_LENGTH > 24\n#error \"Value of STB_VORBIS_FAST_HUFFMAN_LENGTH outside of allowed range\"\n#endif\n\n\n#if 0\n#define CHECK(f)   _CrtIsValidHeapPointer(f->channel_buffers[1])\n#else\n#define CHECK(f)   ((void) 0)\n#endif\n\n#define MAX_BLOCKSIZE_LOG  13   // from specification\n#define MAX_BLOCKSIZE      (1 << MAX_BLOCKSIZE_LOG)\n\n\ntypedef unsigned char  uint8;\ntypedef   signed char   int8;\ntypedef unsigned short uint16;\ntypedef   signed short  int16;\ntypedef unsigned int   uint32;\ntypedef   signed int    int32;\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n\ntypedef float codetype;\n\n#ifdef _MSC_VER\n#define STBV_NOTUSED(v)  (void)(v)\n#else\n#define STBV_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n// @NOTE\n//\n// Some arrays below are tagged \"//varies\", which means it's actually\n// a variable-sized piece of data, but rather than malloc I assume it's\n// small enough it's better to just allocate it all together with the\n// main thing\n//\n// Most of the variables are specified with the smallest size I could pack\n// them into. It might give better performance to make them all full-sized\n// integers. It should be safe to freely rearrange the structures or change\n// the sizes larger--nothing relies on silently truncating etc., nor the\n// order of variables.\n\n#define FAST_HUFFMAN_TABLE_SIZE   (1 << STB_VORBIS_FAST_HUFFMAN_LENGTH)\n#define FAST_HUFFMAN_TABLE_MASK   (FAST_HUFFMAN_TABLE_SIZE - 1)\n\ntypedef struct\n{\n    int dimensions, entries;\n    uint8* codeword_lengths;\n    float  minimum_value;\n    float  delta_value;\n    uint8  value_bits;\n    uint8  lookup_type;\n    uint8  sequence_p;\n    uint8  sparse;\n    uint32 lookup_values;\n    codetype* multiplicands;\n    uint32* codewords;\n#ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n    int16  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n#else\n    int32  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n#endif\n    uint32* sorted_codewords;\n    int* sorted_values;\n    int     sorted_entries;\n} Codebook;\n\ntypedef struct\n{\n    uint8 order;\n    uint16 rate;\n    uint16 bark_map_size;\n    uint8 amplitude_bits;\n    uint8 amplitude_offset;\n    uint8 number_of_books;\n    uint8 book_list[16]; // varies\n} Floor0;\n\ntypedef struct\n{\n    uint8 partitions;\n    uint8 partition_class_list[32]; // varies\n    uint8 class_dimensions[16]; // varies\n    uint8 class_subclasses[16]; // varies\n    uint8 class_masterbooks[16]; // varies\n    int16 subclass_books[16][8]; // varies\n    uint16 Xlist[31 * 8 + 2]; // varies\n    uint8 sorted_order[31 * 8 + 2];\n    uint8 neighbors[31 * 8 + 2][2];\n    uint8 floor1_multiplier;\n    uint8 rangebits;\n    int values;\n} Floor1;\n\ntypedef union\n{\n    Floor0 floor0;\n    Floor1 floor1;\n} Floor;\n\ntypedef struct\n{\n    uint32 begin, end;\n    uint32 part_size;\n    uint8 classifications;\n    uint8 classbook;\n    uint8** classdata;\n    int16(*residue_books)[8];\n} Residue;\n\ntypedef struct\n{\n    uint8 magnitude;\n    uint8 angle;\n    uint8 mux;\n} MappingChannel;\n\ntypedef struct\n{\n    uint16 coupling_steps;\n    MappingChannel* chan;\n    uint8  submaps;\n    uint8  submap_floor[15]; // varies\n    uint8  submap_residue[15]; // varies\n} Mapping;\n\ntypedef struct\n{\n    uint8 blockflag;\n    uint8 mapping;\n    uint16 windowtype;\n    uint16 transformtype;\n} Mode;\n\ntypedef struct\n{\n    uint32  goal_crc;    // expected crc if match\n    int     bytes_left;  // bytes left in packet\n    uint32  crc_so_far;  // running crc\n    int     bytes_done;  // bytes processed in _current_ chunk\n    uint32  sample_loc;  // granule pos encoded in page\n} CRCscan;\n\ntypedef struct\n{\n    uint32 page_start, page_end;\n    uint32 last_decoded_sample;\n} ProbedPage;\n\nstruct stb_vorbis\n{\n    // user-accessible info\n    unsigned int sample_rate;\n    int channels;\n\n    unsigned int setup_memory_required;\n    unsigned int temp_memory_required;\n    unsigned int setup_temp_memory_required;\n\n    char* vendor;\n    int comment_list_length;\n    char** comment_list;\n\n    // input config\n#ifndef STB_VORBIS_NO_STDIO\n    FILE* f;\n    uint32 f_start;\n    int close_on_free;\n#endif\n\n    uint8* stream;\n    uint8* stream_start;\n    uint8* stream_end;\n\n    uint32 stream_len;\n\n    uint8  push_mode;\n\n    // the page to seek to when seeking to start, may be zero\n    uint32 first_audio_page_offset;\n\n    // p_first is the page on which the first audio packet ends\n    // (but not necessarily the page on which it starts)\n    ProbedPage p_first, p_last;\n\n    // memory management\n    stb_vorbis_alloc alloc;\n    int setup_offset;\n    int temp_offset;\n\n    // run-time results\n    int eof;\n    enum STBVorbisError error;\n\n    // user-useful data\n\n    // header info\n    int blocksize[2];\n    int blocksize_0, blocksize_1;\n    int codebook_count;\n    Codebook* codebooks;\n    int floor_count;\n    uint16 floor_types[64]; // varies\n    Floor* floor_config;\n    int residue_count;\n    uint16 residue_types[64]; // varies\n    Residue* residue_config;\n    int mapping_count;\n    Mapping* mapping;\n    int mode_count;\n    Mode mode_config[64];  // varies\n\n    uint32 total_samples;\n\n    // decode buffer\n    float* channel_buffers[STB_VORBIS_MAX_CHANNELS];\n    float* outputs[STB_VORBIS_MAX_CHANNELS];\n\n    float* previous_window[STB_VORBIS_MAX_CHANNELS];\n    int previous_length;\n\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n    int16* finalY[STB_VORBIS_MAX_CHANNELS];\n#else\n    float* floor_buffers[STB_VORBIS_MAX_CHANNELS];\n#endif\n\n    uint32 current_loc; // sample location of next frame to decode\n    int    current_loc_valid;\n\n    // per-blocksize precomputed data\n\n     // twiddle factors\n    float* A[2], * B[2], * C[2];\n    float* window[2];\n    uint16* bit_reverse[2];\n\n    // current page/packet/segment streaming info\n    uint32 serial; // stream serial number for verification\n    int last_page;\n    int segment_count;\n    uint8 segments[255];\n    uint8 page_flag;\n    uint8 bytes_in_seg;\n    uint8 first_decode;\n    int next_seg;\n    int last_seg;  // flag that we're on the last segment\n    int last_seg_which; // what was the segment number of the last seg?\n    uint32 acc;\n    int valid_bits;\n    int packet_bytes;\n    int end_seg_with_known_loc;\n    uint32 known_loc_for_packet;\n    int discard_samples_deferred;\n    uint32 samples_output;\n\n    // push mode scanning\n    int page_crc_tests; // only in push_mode: number of tests active; -1 if not searching\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n    CRCscan scan[STB_VORBIS_PUSHDATA_CRC_COUNT];\n#endif\n\n    // sample-access\n    int channel_buffer_start;\n    int channel_buffer_end;\n};\n\n#if defined(STB_VORBIS_NO_PUSHDATA_API)\n#define IS_PUSH_MODE(f)   FALSE\n#elif defined(STB_VORBIS_NO_PULLDATA_API)\n#define IS_PUSH_MODE(f)   TRUE\n#else\n#define IS_PUSH_MODE(f)   ((f)->push_mode)\n#endif\n\ntypedef struct stb_vorbis vorb;\n\nstatic int error(vorb* f, enum STBVorbisError e)\n{\n    f->error = e;\n    if (!f->eof && e != VORBIS_need_more_data) {\n        f->error = e; // breakpoint for debugging\n    }\n    return 0;\n}\n\n\n// these functions are used for allocating temporary memory\n// while decoding. if you can afford the stack space, use\n// alloca(); otherwise, provide a temp buffer and it will\n// allocate out of those.\n\n#define array_size_required(count,size)  (count*(sizeof(void *)+(size)))\n\n#if 0\n#define temp_alloc(f,size)              (f->alloc.alloc_buffer ? setup_temp_malloc(f,size) : alloca(size))\n#define temp_free(f,p)                  (void)0\n#define temp_alloc_save(f)              ((f)->temp_offset)\n#define temp_alloc_restore(f,p)         ((f)->temp_offset = (p))\n#else\n#define temp_alloc(f,size)              (f->alloc.alloc_buffer ? setup_temp_malloc(f,size) : MemAlloc(size))\n//#define temp_free(f,p)                  (void)0\n#define temp_free(f,p)                  (f->alloc.alloc_buffer ? 0 : MemRelease(p))\n#define temp_alloc_save(f)              ((f)->temp_offset)\n#define temp_alloc_restore(f,p)         ((f)->temp_offset = (p))\n#endif\n\n#define temp_block_array(f,count,size)  make_block_array(temp_alloc(f,array_size_required(count,size)), count, size)\n\n// given a sufficiently large block of memory, make an array of pointers to subblocks of it\nstatic void* make_block_array(void* mem, int count, int size)\n{\n    int i;\n    void** p = (void**)mem;\n    char* q = (char*)(p + count);\n    for (i = 0; i < count; ++i) {\n        p[i] = q;\n        q += size;\n    }\n    return p;\n}\n\nstatic void* setup_malloc(vorb* f, int sz)\n{\n    sz = (sz + 7) & ~7; // round up to nearest 8 for alignment of future allocs.\n    f->setup_memory_required += sz;\n    if (f->alloc.alloc_buffer) {\n        void* p = (char*)f->alloc.alloc_buffer + f->setup_offset;\n        if (f->setup_offset + sz > f->temp_offset) return NULL;\n        f->setup_offset += sz;\n        return p;\n    }\n    return sz ? MemAlloc(sz) : (void*)NULL;\n}\n\nstatic void setup_free(vorb* f, void* p)\n{\n    if (f->alloc.alloc_buffer) return; // do nothing; setup mem is a stack\n    MemRelease(p);\n}\n\nstatic void* setup_temp_malloc(vorb* f, int sz)\n{\n    sz = (sz + 7) & ~7; // round up to nearest 8 for alignment of future allocs.\n    if (f->alloc.alloc_buffer) {\n        if (f->temp_offset - sz < f->setup_offset) return NULL;\n        f->temp_offset -= sz;\n        return (char*)f->alloc.alloc_buffer + f->temp_offset;\n    }\n    return MemAlloc(sz);\n}\n\nstatic void setup_temp_free(vorb* f, void* p, int sz)\n{\n    if (f->alloc.alloc_buffer) {\n        f->temp_offset += (sz + 7) & ~7;\n        return;\n    }\n    MemRelease(p);\n}\n\n#define CRC32_POLY    0x04c11db7   // from spec\n\nstatic uint32 crc_table[256];\nstatic void crc32_init(void)\n{\n    int i, j;\n    uint32 s;\n    for (i = 0; i < 256; i++) {\n        for (s = (uint32)i << 24, j = 0; j < 8; ++j)\n            s = (s << 1) ^ (s >= (1U << 31) ? CRC32_POLY : 0);\n        crc_table[i] = s;\n    }\n}\n\nstatic __forceinline uint32 crc32_update(uint32 crc, uint8 byte)\n{\n    return (crc << 8) ^ crc_table[byte ^ (crc >> 24)];\n}\n\n\n// used in setup, and for huffman that doesn't go fast path\nstatic unsigned int bit_reverse(unsigned int n)\n{\n    n = ((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1);\n    n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2);\n    n = ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4);\n    n = ((n & 0xFF00FF00) >> 8) | ((n & 0x00FF00FF) << 8);\n    return (n >> 16) | (n << 16);\n}\n\nstatic float square(float x)\n{\n    return x * x;\n}\n\n// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3\n// as required by the specification. fast(?) implementation from stb.h\n// @OPTIMIZE: called multiple times per-packet with \"constants\"; move to setup\nstatic int ilog(int32 n)\n{\n    static signed char log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };\n\n    if (n < 0) return 0; // signed n returns 0\n\n    // 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)\n    if (n < (1 << 14))\n        if (n < (1 << 4))            return  0 + log2_4[n];\n        else if (n < (1 << 9))       return  5 + log2_4[n >> 5];\n        else                     return 10 + log2_4[n >> 10];\n    else if (n < (1 << 24))\n        if (n < (1 << 19))       return 15 + log2_4[n >> 15];\n        else                     return 20 + log2_4[n >> 20];\n    else if (n < (1 << 29))       return 25 + log2_4[n >> 25];\n    else                     return 30 + log2_4[n >> 30];\n}\n\n#ifndef M_PI\n#define M_PI  3.14159265358979323846264f  // from CRC\n#endif\n\n// code length assigned to a value with no huffman encoding\n#define NO_CODE   255\n\n/////////////////////// LEAF SETUP FUNCTIONS //////////////////////////\n//\n// these functions are only called at setup, and only a few times\n// per file\n\nstatic float float32_unpack(uint32 x)\n{\n    // from the specification\n    uint32 mantissa = x & 0x1fffff;\n    uint32 sign = x & 0x80000000;\n    uint32 exp = (x & 0x7fe00000) >> 21;\n    double res = sign ? -(double)mantissa : (double)mantissa;\n    return (float)MathLdexp((float)res, (int)exp - 788);\n}\n\n\n// zlib & jpeg huffman tables assume that the output symbols\n// can either be arbitrarily arranged, or have monotonically\n// increasing frequencies--they rely on the lengths being sorted;\n// this makes for a very simple generation algorithm.\n// vorbis allows a huffman table with non-sorted lengths. This\n// requires a more sophisticated construction, since symbols in\n// order do not map to huffman codes \"in order\".\nstatic void add_entry(Codebook* c, uint32 huff_code, int symbol, int count, int len, uint32* values)\n{\n    if (!c->sparse) {\n        c->codewords[symbol] = huff_code;\n    }\n    else {\n        c->codewords[count] = huff_code;\n        c->codeword_lengths[count] = len;\n        values[count] = symbol;\n    }\n}\n\nstatic int compute_codewords(Codebook* c, uint8* len, int n, uint32* values)\n{\n    int i, k, m = 0;\n    uint32 available[32];\n\n    MemSet(available, 0, sizeof(available));\n    // find the first entry\n    for (k = 0; k < n; ++k) if (len[k] < NO_CODE) break;\n    if (k == n) { VORBIS_ASSERT(c->sorted_entries == 0); return TRUE; }\n    VORBIS_ASSERT(len[k] < 32); // no error return required, code reading lens checks this\n    // add to the list\n    add_entry(c, 0, k, m++, len[k], values);\n    // add all available leaves\n    for (i = 1; i <= len[k]; ++i)\n        available[i] = 1U << (32 - i);\n    // note that the above code treats the first case specially,\n    // but it's really the same as the following code, so they\n    // could probably be combined (except the initial code is 0,\n    // and I use 0 in available[] to mean 'empty')\n    for (i = k + 1; i < n; ++i) {\n        uint32 res;\n        int z = len[i], y;\n        if (z == NO_CODE) continue;\n        VORBIS_ASSERT(z < 32); // no error return required, code reading lens checks this\n        // find lowest available leaf (should always be earliest,\n        // which is what the specification calls for)\n        // note that this property, and the fact we can never have\n        // more than one free leaf at a given level, isn't totally\n        // trivial to prove, but it seems true and the VORBIS_ASSERT never\n        // fires, so!\n        while (z > 0 && !available[z]) --z;\n        if (z == 0) { return FALSE; }\n        res = available[z];\n        available[z] = 0;\n        add_entry(c, bit_reverse(res), i, m++, len[i], values);\n        // propagate availability up the tree\n        if (z != len[i]) {\n            for (y = len[i]; y > z; --y) {\n                VORBIS_ASSERT(available[y] == 0);\n                available[y] = res + (1 << (32 - y));\n            }\n        }\n    }\n    return TRUE;\n}\n\n// accelerated huffman table allows fast O(1) match of all symbols\n// of length <= STB_VORBIS_FAST_HUFFMAN_LENGTH\nstatic void compute_accelerated_huffman(Codebook* c)\n{\n    int i, len;\n    for (i = 0; i < FAST_HUFFMAN_TABLE_SIZE; ++i)\n        c->fast_huffman[i] = -1;\n\n    len = c->sparse ? c->sorted_entries : c->entries;\n#ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n    if (len > 32767) len = 32767; // largest possible value we can encode!\n#endif\n    for (i = 0; i < len; ++i) {\n        if (c->codeword_lengths[i] <= STB_VORBIS_FAST_HUFFMAN_LENGTH) {\n            uint32 z = c->sparse ? bit_reverse(c->sorted_codewords[i]) : c->codewords[i];\n            // set table entries for all bit combinations in the higher bits\n            while (z < FAST_HUFFMAN_TABLE_SIZE) {\n                c->fast_huffman[z] = i;\n                z += 1 << c->codeword_lengths[i];\n            }\n        }\n    }\n}\n\n#ifdef _MSC_VER\n#define STBV_CDECL __cdecl\n#else\n#define STBV_CDECL\n#endif\n\nstatic int STBV_CDECL uint32_compare(const void* p, const void* q)\n{\n    uint32 x = *(uint32*)p;\n    uint32 y = *(uint32*)q;\n    return x < y ? -1 : x > y;\n}\n\nstatic int include_in_sort(Codebook* c, uint8 len)\n{\n    if (c->sparse) { VORBIS_ASSERT(len != NO_CODE); return TRUE; }\n    if (len == NO_CODE) return FALSE;\n    if (len > STB_VORBIS_FAST_HUFFMAN_LENGTH) return TRUE;\n    return FALSE;\n}\n\n// if the fast table above doesn't work, we want to binary\n// search them... need to reverse the bits\nstatic void compute_sorted_huffman(Codebook* c, uint8* lengths, uint32* values)\n{\n    int i, len;\n    // build a list of all the entries\n    // OPTIMIZATION: don't include the short ones, since they'll be caught by FAST_HUFFMAN.\n    // this is kind of a frivolous optimization--I don't see any performance improvement,\n    // but it's like 4 extra lines of code, so.\n    if (!c->sparse) {\n        int k = 0;\n        for (i = 0; i < c->entries; ++i)\n            if (include_in_sort(c, lengths[i]))\n                c->sorted_codewords[k++] = bit_reverse(c->codewords[i]);\n        VORBIS_ASSERT(k == c->sorted_entries);\n    }\n    else {\n        for (i = 0; i < c->sorted_entries; ++i)\n            c->sorted_codewords[i] = bit_reverse(c->codewords[i]);\n    }\n\n    QSort(c->sorted_codewords, c->sorted_entries, sizeof(c->sorted_codewords[0]), uint32_compare);\n    c->sorted_codewords[c->sorted_entries] = 0xffffffff;\n\n    len = c->sparse ? c->sorted_entries : c->entries;\n    // now we need to indicate how they correspond; we could either\n    //   #1: sort a different data structure that says who they correspond to\n    //   #2: for each sorted entry, search the original list to find who corresponds\n    //   #3: for each original entry, find the sorted entry\n    // #1 requires extra storage, #2 is slow, #3 can use binary search!\n    for (i = 0; i < len; ++i) {\n        int huff_len = c->sparse ? lengths[values[i]] : lengths[i];\n        if (include_in_sort(c, huff_len)) {\n            uint32 code = bit_reverse(c->codewords[i]);\n            int x = 0, n = c->sorted_entries;\n            while (n > 1) {\n                // invariant: sc[x] <= code < sc[x+n]\n                int m = x + (n >> 1);\n                if (c->sorted_codewords[m] <= code) {\n                    x = m;\n                    n -= (n >> 1);\n                }\n                else {\n                    n >>= 1;\n                }\n            }\n            VORBIS_ASSERT(c->sorted_codewords[x] == code);\n            if (c->sparse) {\n                c->sorted_values[x] = values[i];\n                c->codeword_lengths[x] = huff_len;\n            }\n            else {\n                c->sorted_values[x] = i;\n            }\n        }\n    }\n}\n\n// only run while parsing the header (3 times)\nstatic int vorbis_validate(uint8* data)\n{\n    static uint8 vorbis[6] = { 'v', 'o', 'r', 'b', 'i', 's' };\n    return MemCompare(data, vorbis, 6) == 0;\n}\n\n// called from setup only, once per code book\n// (formula implied by specification)\nstatic int lookup1_values(int entries, int dim)\n{\n    int r = (int)MathFloor(MathExp((float)MathLog((float)entries) / dim));\n    if ((int)MathFloor(MathPow((float)r + 1, dim)) <= entries)   // (int) cast for MinGW warning;\n        ++r;                                              // floor() to avoid _ftol() when non-CRT\n    if (MathPow((float)r + 1, dim) <= entries)\n        return -1;\n    if ((int)MathFloor(MathPow((float)r, dim)) > entries)\n        return -1;\n    return r;\n}\n\n// called twice per file\nstatic void compute_twiddle_factors(int n, float* A, float* B, float* C)\n{\n    int n4 = n >> 2, n8 = n >> 3;\n    int k, k2;\n\n    for (k = k2 = 0; k < n4; ++k, k2 += 2) {\n        A[k2] = (float)MathCos(4 * k * M_PI / n);\n        A[k2 + 1] = (float)-MathSin(4 * k * M_PI / n);\n        B[k2] = (float)MathCos((k2 + 1) * M_PI / n / 2) * 0.5f;\n        B[k2 + 1] = (float)MathSin((k2 + 1) * M_PI / n / 2) * 0.5f;\n    }\n    for (k = k2 = 0; k < n8; ++k, k2 += 2) {\n        C[k2] = (float)MathCos(2 * (k2 + 1) * M_PI / n);\n        C[k2 + 1] = (float)-MathSin(2 * (k2 + 1) * M_PI / n);\n    }\n}\n\nstatic void compute_window(int n, float* window)\n{\n    int n2 = n >> 1, i;\n    for (i = 0; i < n2; ++i)\n        window[i] = (float)MathSin(0.5 * M_PI * square((float)MathSin((i - 0 + 0.5) / n2 * 0.5 * M_PI)));\n}\n\nstatic void compute_bitreverse(int n, uint16* rev)\n{\n    int ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n    int i, n8 = n >> 3;\n    for (i = 0; i < n8; ++i)\n        rev[i] = (bit_reverse(i) >> (32 - ld + 3)) << 2;\n}\n\nstatic int init_blocksize(vorb* f, int b, int n)\n{\n    int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3;\n    f->A[b] = (float*)setup_malloc(f, sizeof(float) * n2);\n    f->B[b] = (float*)setup_malloc(f, sizeof(float) * n2);\n    f->C[b] = (float*)setup_malloc(f, sizeof(float) * n4);\n    if (!f->A[b] || !f->B[b] || !f->C[b]) return error(f, VORBIS_outofmem);\n    compute_twiddle_factors(n, f->A[b], f->B[b], f->C[b]);\n    f->window[b] = (float*)setup_malloc(f, sizeof(float) * n2);\n    if (!f->window[b]) return error(f, VORBIS_outofmem);\n    compute_window(n, f->window[b]);\n    f->bit_reverse[b] = (uint16*)setup_malloc(f, sizeof(uint16) * n8);\n    if (!f->bit_reverse[b]) return error(f, VORBIS_outofmem);\n    compute_bitreverse(n, f->bit_reverse[b]);\n    return TRUE;\n}\n\nstatic void neighbors(uint16* x, int n, int* plow, int* phigh)\n{\n    int low = -1;\n    int high = 65536;\n    int i;\n    for (i = 0; i < n; ++i) {\n        if (x[i] > low && x[i] < x[n]) { *plow = i; low = x[i]; }\n        if (x[i] < high && x[i] > x[n]) { *phigh = i; high = x[i]; }\n    }\n}\n\n// this has been repurposed so y is now the original index instead of y\ntypedef struct\n{\n    uint16 x, id;\n} stbv__floor_ordering;\n\nstatic int STBV_CDECL point_compare(const void* p, const void* q)\n{\n    stbv__floor_ordering* a = (stbv__floor_ordering*)p;\n    stbv__floor_ordering* b = (stbv__floor_ordering*)q;\n    return a->x < b->x ? -1 : a->x > b->x;\n}\n\n//\n/////////////////////// END LEAF SETUP FUNCTIONS //////////////////////////\n\n\n#if defined(STB_VORBIS_NO_STDIO)\n#define USE_MEMORY(z)    TRUE\n#else\n#define USE_MEMORY(z)    ((z)->stream)\n#endif\n\nstatic uint8 get8(vorb* z)\n{\n    if (USE_MEMORY(z)) {\n        if (z->stream >= z->stream_end) { z->eof = TRUE; return 0; }\n        return *z->stream++;\n    }\n\n#ifndef STB_VORBIS_NO_STDIO\n    {\n        int c = fgetc(z->f);\n        if (c == EOF) { z->eof = TRUE; return 0; }\n        return c;\n    }\n#endif\n}\n\nstatic uint32 get32(vorb* f)\n{\n    uint32 x;\n    x = get8(f);\n    x += get8(f) << 8;\n    x += get8(f) << 16;\n    x += (uint32)get8(f) << 24;\n    return x;\n}\n\nstatic int getn(vorb* z, uint8* data, int n)\n{\n    if (USE_MEMORY(z)) {\n        if (z->stream + n > z->stream_end) { z->eof = 1; return 0; }\n        MemCopy(data, z->stream, n);\n        z->stream += n;\n        return 1;\n    }\n\n#ifndef STB_VORBIS_NO_STDIO\n    if (fread(data, n, 1, z->f) == 1)\n        return 1;\n    else {\n        z->eof = 1;\n        return 0;\n    }\n#endif\n}\n\nstatic void skip(vorb* z, int n)\n{\n    if (USE_MEMORY(z)) {\n        z->stream += n;\n        if (z->stream >= z->stream_end) z->eof = 1;\n        return;\n    }\n#ifndef STB_VORBIS_NO_STDIO\n    {\n        long x = ftell(z->f);\n        fseek(z->f, x + n, SEEK_SET);\n    }\n#endif\n}\n\nstatic int set_file_offset(stb_vorbis* f, unsigned int loc)\n{\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n    if (f->push_mode) return 0;\n#endif\n    f->eof = 0;\n    if (USE_MEMORY(f)) {\n        if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n            f->stream = f->stream_end;\n            f->eof = 1;\n            return 0;\n        }\n        else {\n            f->stream = f->stream_start + loc;\n            return 1;\n        }\n    }\n#ifndef STB_VORBIS_NO_STDIO\n    if (loc + f->f_start < loc || loc >= 0x80000000) {\n        loc = 0x7fffffff;\n        f->eof = 1;\n    }\n    else {\n        loc += f->f_start;\n    }\n    if (!fseek(f->f, loc, SEEK_SET))\n        return 1;\n    f->eof = 1;\n    fseek(f->f, f->f_start, SEEK_END);\n    return 0;\n#endif\n}\n\n\nstatic uint8 ogg_page_header[4] = { 0x4f, 0x67, 0x67, 0x53 };\n\nstatic int capture_pattern(vorb* f)\n{\n    if (0x4f != get8(f)) return FALSE;\n    if (0x67 != get8(f)) return FALSE;\n    if (0x67 != get8(f)) return FALSE;\n    if (0x53 != get8(f)) return FALSE;\n    return TRUE;\n}\n\n#define PAGEFLAG_continued_packet   1\n#define PAGEFLAG_first_page         2\n#define PAGEFLAG_last_page          4\n\nstatic int start_page_no_capturepattern(vorb* f)\n{\n    uint32 loc0, loc1, n;\n    if (f->first_decode && !IS_PUSH_MODE(f)) {\n        f->p_first.page_start = stb_vorbis_get_file_offset(f) - 4;\n    }\n    // stream structure version\n    if (0 != get8(f)) return error(f, VORBIS_invalid_stream_structure_version);\n    // header flag\n    f->page_flag = get8(f);\n    // absolute granule position\n    loc0 = get32(f);\n    loc1 = get32(f);\n    // @TODO: validate loc0,loc1 as valid positions?\n    // stream serial number -- vorbis doesn't interleave, so discard\n    get32(f);\n    //if (f->serial != get32(f)) return error(f, VORBIS_incorrect_stream_serial_number);\n    // page sequence number\n    n = get32(f);\n    f->last_page = n;\n    // CRC32\n    get32(f);\n    // page_segments\n    f->segment_count = get8(f);\n    if (!getn(f, f->segments, f->segment_count))\n        return error(f, VORBIS_unexpected_eof);\n    // assume we _don't_ know any the sample position of any segments\n    f->end_seg_with_known_loc = -2;\n    if (loc0 != ~0U || loc1 != ~0U) {\n        int i;\n        // determine which packet is the last one that will complete\n        for (i = f->segment_count - 1; i >= 0; --i)\n            if (f->segments[i] < 255)\n                break;\n        // 'i' is now the index of the _last_ segment of a packet that ends\n        if (i >= 0) {\n            f->end_seg_with_known_loc = i;\n            f->known_loc_for_packet = loc0;\n        }\n    }\n    if (f->first_decode) {\n        int i, len;\n        len = 0;\n        for (i = 0; i < f->segment_count; ++i)\n            len += f->segments[i];\n        len += 27 + f->segment_count;\n        f->p_first.page_end = f->p_first.page_start + len;\n        f->p_first.last_decoded_sample = loc0;\n    }\n    f->next_seg = 0;\n    return TRUE;\n}\n\nstatic int start_page(vorb* f)\n{\n    if (!capture_pattern(f)) return error(f, VORBIS_missing_capture_pattern);\n    return start_page_no_capturepattern(f);\n}\n\nstatic int start_packet(vorb* f)\n{\n    while (f->next_seg == -1) {\n        if (!start_page(f)) return FALSE;\n        if (f->page_flag & PAGEFLAG_continued_packet)\n            return error(f, VORBIS_continued_packet_flag_invalid);\n    }\n    f->last_seg = FALSE;\n    f->valid_bits = 0;\n    f->packet_bytes = 0;\n    f->bytes_in_seg = 0;\n    // f->next_seg is now valid\n    return TRUE;\n}\n\nstatic int maybe_start_packet(vorb* f)\n{\n    if (f->next_seg == -1) {\n        int x = get8(f);\n        if (f->eof) return FALSE; // EOF at page boundary is not an error!\n        if (0x4f != x) return error(f, VORBIS_missing_capture_pattern);\n        if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n        if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n        if (0x53 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n        if (!start_page_no_capturepattern(f)) return FALSE;\n        if (f->page_flag & PAGEFLAG_continued_packet) {\n            // set up enough state that we can read this packet if we want,\n            // e.g. during recovery\n            f->last_seg = FALSE;\n            f->bytes_in_seg = 0;\n            return error(f, VORBIS_continued_packet_flag_invalid);\n        }\n    }\n    return start_packet(f);\n}\n\nstatic int next_segment(vorb* f)\n{\n    int len;\n    if (f->last_seg) return 0;\n    if (f->next_seg == -1) {\n        f->last_seg_which = f->segment_count - 1; // in case start_page fails\n        if (!start_page(f)) { f->last_seg = 1; return 0; }\n        if (!(f->page_flag & PAGEFLAG_continued_packet)) return error(f, VORBIS_continued_packet_flag_invalid);\n    }\n    len = f->segments[f->next_seg++];\n    if (len < 255) {\n        f->last_seg = TRUE;\n        f->last_seg_which = f->next_seg - 1;\n    }\n    if (f->next_seg >= f->segment_count)\n        f->next_seg = -1;\n    VORBIS_ASSERT(f->bytes_in_seg == 0);\n    f->bytes_in_seg = len;\n    return len;\n}\n\n#define EOP    (-1)\n#define INVALID_BITS  (-1)\n\nstatic int get8_packet_raw(vorb* f)\n{\n    if (!f->bytes_in_seg) {  // CLANG!\n        if (f->last_seg) return EOP;\n        else if (!next_segment(f)) return EOP;\n    }\n    VORBIS_ASSERT(f->bytes_in_seg > 0);\n    --f->bytes_in_seg;\n    ++f->packet_bytes;\n    return get8(f);\n}\n\nstatic int get8_packet(vorb* f)\n{\n    int x = get8_packet_raw(f);\n    f->valid_bits = 0;\n    return x;\n}\n\nstatic int get32_packet(vorb* f)\n{\n    uint32 x;\n    x = get8_packet(f);\n    x += get8_packet(f) << 8;\n    x += get8_packet(f) << 16;\n    x += (uint32)get8_packet(f) << 24;\n    return x;\n}\n\nstatic void flush_packet(vorb* f)\n{\n    while (get8_packet_raw(f) != EOP);\n}\n\n// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important\n// as the huffman decoder?\nstatic uint32 get_bits(vorb* f, int n)\n{\n    uint32 z;\n\n    if (f->valid_bits < 0) return 0;\n    if (f->valid_bits < n) {\n        if (n > 24) {\n            // the accumulator technique below would not work correctly in this case\n            z = get_bits(f, 24);\n            z += get_bits(f, n - 24) << 24;\n            return z;\n        }\n        if (f->valid_bits == 0) f->acc = 0;\n        while (f->valid_bits < n) {\n            int z = get8_packet_raw(f);\n            if (z == EOP) {\n                f->valid_bits = INVALID_BITS;\n                return 0;\n            }\n            f->acc += z << f->valid_bits;\n            f->valid_bits += 8;\n        }\n    }\n\n    VORBIS_ASSERT(f->valid_bits >= n);\n    z = f->acc & ((1 << n) - 1);\n    f->acc >>= n;\n    f->valid_bits -= n;\n    return z;\n}\n\n// @OPTIMIZE: primary accumulator for huffman\n// expand the buffer to as many bits as possible without reading off end of packet\n// it might be nice to allow f->valid_bits and f->acc to be stored in registers,\n// e.g. cache them locally and decode locally\nstatic __forceinline void prep_huffman(vorb* f)\n{\n    if (f->valid_bits <= 24) {\n        if (f->valid_bits == 0) f->acc = 0;\n        do {\n            int z;\n            if (f->last_seg && !f->bytes_in_seg) return;\n            z = get8_packet_raw(f);\n            if (z == EOP) return;\n            f->acc += (unsigned)z << f->valid_bits;\n            f->valid_bits += 8;\n        } while (f->valid_bits <= 24);\n    }\n}\n\nenum\n{\n    VORBIS_packet_id = 1,\n    VORBIS_packet_comment = 3,\n    VORBIS_packet_setup = 5\n};\n\nstatic int codebook_decode_scalar_raw(vorb* f, Codebook* c)\n{\n    int i;\n    prep_huffman(f);\n\n    if (c->codewords == NULL && c->sorted_codewords == NULL)\n        return -1;\n\n    // cases to use binary search: sorted_codewords && !c->codewords\n    //                             sorted_codewords && c->entries > 8\n    if (c->entries > 8 ? c->sorted_codewords != NULL : !c->codewords) {\n        // binary search\n        uint32 code = bit_reverse(f->acc);\n        int x = 0, n = c->sorted_entries, len;\n\n        while (n > 1) {\n            // invariant: sc[x] <= code < sc[x+n]\n            int m = x + (n >> 1);\n            if (c->sorted_codewords[m] <= code) {\n                x = m;\n                n -= (n >> 1);\n            }\n            else {\n                n >>= 1;\n            }\n        }\n        // x is now the sorted index\n        if (!c->sparse) x = c->sorted_values[x];\n        // x is now sorted index if sparse, or symbol otherwise\n        len = c->codeword_lengths[x];\n        if (f->valid_bits >= len) {\n            f->acc >>= len;\n            f->valid_bits -= len;\n            return x;\n        }\n\n        f->valid_bits = 0;\n        return -1;\n    }\n\n    // if small, linear search\n    VORBIS_ASSERT(!c->sparse);\n    for (i = 0; i < c->entries; ++i) {\n        if (c->codeword_lengths[i] == NO_CODE) continue;\n        if (c->codewords[i] == (f->acc & ((1 << c->codeword_lengths[i]) - 1))) {\n            if (f->valid_bits >= c->codeword_lengths[i]) {\n                f->acc >>= c->codeword_lengths[i];\n                f->valid_bits -= c->codeword_lengths[i];\n                return i;\n            }\n            f->valid_bits = 0;\n            return -1;\n        }\n    }\n\n    error(f, VORBIS_invalid_stream);\n    f->valid_bits = 0;\n    return -1;\n}\n\n#ifndef STB_VORBIS_NO_INLINE_DECODE\n\n#define DECODE_RAW(var, f,c)                                  \\\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)        \\\n      prep_huffman(f);                                        \\\n   var = f->acc & FAST_HUFFMAN_TABLE_MASK;                    \\\n   var = c->fast_huffman[var];                                \\\n   if (var >= 0) {                                            \\\n      int n = c->codeword_lengths[var];                       \\\n      f->acc >>= n;                                           \\\n      f->valid_bits -= n;                                     \\\n      if (f->valid_bits < 0) { f->valid_bits = 0; var = -1; } \\\n   } else {                                                   \\\n      var = codebook_decode_scalar_raw(f,c);                  \\\n   }\n\n#else\n\nstatic int codebook_decode_scalar(vorb* f, Codebook* c)\n{\n    int i;\n    if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)\n        prep_huffman(f);\n    // fast huffman table lookup\n    i = f->acc & FAST_HUFFMAN_TABLE_MASK;\n    i = c->fast_huffman[i];\n    if (i >= 0) {\n        f->acc >>= c->codeword_lengths[i];\n        f->valid_bits -= c->codeword_lengths[i];\n        if (f->valid_bits < 0) { f->valid_bits = 0; return -1; }\n        return i;\n    }\n    return codebook_decode_scalar_raw(f, c);\n}\n\n#define DECODE_RAW(var,f,c)    var = codebook_decode_scalar(f,c);\n\n#endif\n\n#define DECODE(var,f,c)                                       \\\n   DECODE_RAW(var,f,c)                                        \\\n   if (c->sparse) var = c->sorted_values[var];\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n#define DECODE_VQ(var,f,c)   DECODE_RAW(var,f,c)\n#else\n#define DECODE_VQ(var,f,c)   DECODE(var,f,c)\n#endif\n\n\n\n\n\n\n// CODEBOOK_ELEMENT_FAST is an optimization for the CODEBOOK_FLOATS case\n// where we avoid one addition\n#define CODEBOOK_ELEMENT(c,off)          (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_FAST(c,off)     (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_BASE(c)         (0)\n\nstatic int codebook_decode_start(vorb* f, Codebook* c)\n{\n    int z = -1;\n\n    // type 0 is only legal in a scalar context\n    if (c->lookup_type == 0)\n        error(f, VORBIS_invalid_stream);\n    else {\n        DECODE_VQ(z, f, c);\n        if (c->sparse) { VORBIS_ASSERT(z < c->sorted_entries); }\n        if (z < 0) {  // check for EOP\n            if (!f->bytes_in_seg)\n                if (f->last_seg)\n                    return z;\n            error(f, VORBIS_invalid_stream);\n        }\n    }\n    return z;\n}\n\nstatic int codebook_decode(vorb* f, Codebook* c, float* output, int len)\n{\n    int i, z = codebook_decode_start(f, c);\n    if (z < 0) return FALSE;\n    if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n    if (c->lookup_type == 1) {\n        float last = CODEBOOK_ELEMENT_BASE(c);\n        int div = 1;\n        for (i = 0; i < len; ++i) {\n            int off = (z / div) % c->lookup_values;\n            float val = CODEBOOK_ELEMENT_FAST(c, off) + last;\n            output[i] += val;\n            if (c->sequence_p) last = val + c->minimum_value;\n            div *= c->lookup_values;\n        }\n        return TRUE;\n    }\n#endif\n\n    z *= c->dimensions;\n    if (c->sequence_p) {\n        float last = CODEBOOK_ELEMENT_BASE(c);\n        for (i = 0; i < len; ++i) {\n            float val = CODEBOOK_ELEMENT_FAST(c, z + i) + last;\n            output[i] += val;\n            last = val + c->minimum_value;\n        }\n    }\n    else {\n        float last = CODEBOOK_ELEMENT_BASE(c);\n        for (i = 0; i < len; ++i) {\n            output[i] += CODEBOOK_ELEMENT_FAST(c, z + i) + last;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic int codebook_decode_step(vorb* f, Codebook* c, float* output, int len, int step)\n{\n    int i, z = codebook_decode_start(f, c);\n    float last = CODEBOOK_ELEMENT_BASE(c);\n    if (z < 0) return FALSE;\n    if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n    if (c->lookup_type == 1) {\n        int div = 1;\n        for (i = 0; i < len; ++i) {\n            int off = (z / div) % c->lookup_values;\n            float val = CODEBOOK_ELEMENT_FAST(c, off) + last;\n            output[i * step] += val;\n            if (c->sequence_p) last = val;\n            div *= c->lookup_values;\n        }\n        return TRUE;\n    }\n#endif\n\n    z *= c->dimensions;\n    for (i = 0; i < len; ++i) {\n        float val = CODEBOOK_ELEMENT_FAST(c, z + i) + last;\n        output[i * step] += val;\n        if (c->sequence_p) last = val;\n    }\n\n    return TRUE;\n}\n\nstatic int codebook_decode_deinterleave_repeat(vorb* f, Codebook* c, float** outputs, int ch, int* c_inter_p, int* p_inter_p, int len, int total_decode)\n{\n    int c_inter = *c_inter_p;\n    int p_inter = *p_inter_p;\n    int i, z, effective = c->dimensions;\n\n    // type 0 is only legal in a scalar context\n    if (c->lookup_type == 0)   return error(f, VORBIS_invalid_stream);\n\n    while (total_decode > 0) {\n        float last = CODEBOOK_ELEMENT_BASE(c);\n        DECODE_VQ(z, f, c);\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        VORBIS_ASSERT(!c->sparse || z < c->sorted_entries);\n#endif\n        if (z < 0) {\n            if (!f->bytes_in_seg)\n                if (f->last_seg) return FALSE;\n            return error(f, VORBIS_invalid_stream);\n        }\n\n        // if this will take us off the end of the buffers, stop short!\n        // we check by computing the length of the virtual interleaved\n        // buffer (len*ch), our current offset within it (p_inter*ch)+(c_inter),\n        // and the length we'll be using (effective)\n        if (c_inter + p_inter * ch + effective > len * ch) {\n            effective = len * ch - (p_inter * ch - c_inter);\n        }\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        if (c->lookup_type == 1) {\n            int div = 1;\n            for (i = 0; i < effective; ++i) {\n                int off = (z / div) % c->lookup_values;\n                float val = CODEBOOK_ELEMENT_FAST(c, off) + last;\n                if (outputs[c_inter])\n                    outputs[c_inter][p_inter] += val;\n                if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n                if (c->sequence_p) last = val;\n                div *= c->lookup_values;\n            }\n        }\n        else\n#endif\n        {\n            z *= c->dimensions;\n            if (c->sequence_p) {\n                for (i = 0; i < effective; ++i) {\n                    float val = CODEBOOK_ELEMENT_FAST(c, z + i) + last;\n                    if (outputs[c_inter])\n                        outputs[c_inter][p_inter] += val;\n                    if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n                    last = val;\n                }\n            }\n            else {\n                for (i = 0; i < effective; ++i) {\n                    float val = CODEBOOK_ELEMENT_FAST(c, z + i) + last;\n                    if (outputs[c_inter])\n                        outputs[c_inter][p_inter] += val;\n                    if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n                }\n            }\n        }\n\n        total_decode -= effective;\n    }\n    *c_inter_p = c_inter;\n    *p_inter_p = p_inter;\n    return TRUE;\n}\n\nstatic int predict_point(int x, int x0, int x1, int y0, int y1)\n{\n    int dy = y1 - y0;\n    int adx = x1 - x0;\n    // @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?\n    int err = MathAbsI(dy) * (x - x0);\n    int off = err / adx;\n    return dy < 0 ? y0 - off : y0 + off;\n}\n\n// the following table is block-copied from the specification\nstatic float inverse_db_table[256] =\n{\n  1.0649863e-07f, 1.1341951e-07f, 1.2079015e-07f, 1.2863978e-07f,\n  1.3699951e-07f, 1.4590251e-07f, 1.5538408e-07f, 1.6548181e-07f,\n  1.7623575e-07f, 1.8768855e-07f, 1.9988561e-07f, 2.1287530e-07f,\n  2.2670913e-07f, 2.4144197e-07f, 2.5713223e-07f, 2.7384213e-07f,\n  2.9163793e-07f, 3.1059021e-07f, 3.3077411e-07f, 3.5226968e-07f,\n  3.7516214e-07f, 3.9954229e-07f, 4.2550680e-07f, 4.5315863e-07f,\n  4.8260743e-07f, 5.1396998e-07f, 5.4737065e-07f, 5.8294187e-07f,\n  6.2082472e-07f, 6.6116941e-07f, 7.0413592e-07f, 7.4989464e-07f,\n  7.9862701e-07f, 8.5052630e-07f, 9.0579828e-07f, 9.6466216e-07f,\n  1.0273513e-06f, 1.0941144e-06f, 1.1652161e-06f, 1.2409384e-06f,\n  1.3215816e-06f, 1.4074654e-06f, 1.4989305e-06f, 1.5963394e-06f,\n  1.7000785e-06f, 1.8105592e-06f, 1.9282195e-06f, 2.0535261e-06f,\n  2.1869758e-06f, 2.3290978e-06f, 2.4804557e-06f, 2.6416497e-06f,\n  2.8133190e-06f, 2.9961443e-06f, 3.1908506e-06f, 3.3982101e-06f,\n  3.6190449e-06f, 3.8542308e-06f, 4.1047004e-06f, 4.3714470e-06f,\n  4.6555282e-06f, 4.9580707e-06f, 5.2802740e-06f, 5.6234160e-06f,\n  5.9888572e-06f, 6.3780469e-06f, 6.7925283e-06f, 7.2339451e-06f,\n  7.7040476e-06f, 8.2047000e-06f, 8.7378876e-06f, 9.3057248e-06f,\n  9.9104632e-06f, 1.0554501e-05f, 1.1240392e-05f, 1.1970856e-05f,\n  1.2748789e-05f, 1.3577278e-05f, 1.4459606e-05f, 1.5399272e-05f,\n  1.6400004e-05f, 1.7465768e-05f, 1.8600792e-05f, 1.9809576e-05f,\n  2.1096914e-05f, 2.2467911e-05f, 2.3928002e-05f, 2.5482978e-05f,\n  2.7139006e-05f, 2.8902651e-05f, 3.0780908e-05f, 3.2781225e-05f,\n  3.4911534e-05f, 3.7180282e-05f, 3.9596466e-05f, 4.2169667e-05f,\n  4.4910090e-05f, 4.7828601e-05f, 5.0936773e-05f, 5.4246931e-05f,\n  5.7772202e-05f, 6.1526565e-05f, 6.5524908e-05f, 6.9783085e-05f,\n  7.4317983e-05f, 7.9147585e-05f, 8.4291040e-05f, 8.9768747e-05f,\n  9.5602426e-05f, 0.00010181521f, 0.00010843174f, 0.00011547824f,\n  0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f,\n  0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f,\n  0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f,\n  0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f,\n  0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f,\n  0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f,\n  0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f,\n  0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f,\n  0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f,\n  0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f,\n  0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f,\n  0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f,\n  0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f,\n  0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f,\n  0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f,\n  0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f,\n  0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f,\n  0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f,\n  0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f,\n  0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f,\n  0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f,\n  0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f,\n  0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f,\n  0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f,\n  0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f,\n  0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f,\n  0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f,\n  0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f,\n  0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f,\n  0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f,\n  0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f,\n  0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f,\n  0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f,\n  0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f,\n  0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f,\n  0.82788260f,    0.88168307f,    0.9389798f,     1.0f\n};\n\n\n// @OPTIMIZE: if you want to replace this bresenham line-drawing routine,\n// note that you must produce bit-identical output to decode correctly;\n// this specific sequence of operations is specified in the spec (it's\n// drawing integer-quantized frequency-space lines that the encoder\n// expects to be exactly the same)\n//     ... also, isn't the whole point of Bresenham's algorithm to NOT\n// have to divide in the setup? sigh.\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n#define LINE_OP(a,b)   a *= b\n#else\n#define LINE_OP(a,b)   a = b\n#endif\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n#define DIVTAB_NUMER   32\n#define DIVTAB_DENOM   64\nint8 integer_divide_table[DIVTAB_NUMER][DIVTAB_DENOM]; // 2KB\n#endif\n\nstatic __forceinline void draw_line(float* output, int x0, int y0, int x1, int y1, int n)\n{\n    int dy = y1 - y0;\n    int adx = x1 - x0;\n    int ady = MathAbsI(dy);\n    int base;\n    int x = x0, y = y0;\n    int err = 0;\n    int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n    if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n        if (dy < 0) {\n            base = -integer_divide_table[ady][adx];\n            sy = base - 1;\n        }\n        else {\n            base = integer_divide_table[ady][adx];\n            sy = base + 1;\n        }\n    }\n    else {\n        base = dy / adx;\n        if (dy < 0)\n            sy = base - 1;\n        else\n            sy = base + 1;\n    }\n#else\n    base = dy / adx;\n    if (dy < 0)\n        sy = base - 1;\n    else\n        sy = base + 1;\n#endif\n    ady -= MathAbsI(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n        LINE_OP(output[x], inverse_db_table[y & 255]);\n        for (++x; x < x1; ++x) {\n            err += ady;\n            if (err >= adx) {\n                err -= adx;\n                y += sy;\n            }\n            else\n                y += base;\n            LINE_OP(output[x], inverse_db_table[y & 255]);\n        }\n    }\n}\n\nstatic int residue_decode(vorb* f, Codebook* book, float* target, int offset, int n, int rtype)\n{\n    int k;\n    if (rtype == 0) {\n        int step = n / book->dimensions;\n        for (k = 0; k < step; ++k)\n            if (!codebook_decode_step(f, book, target + offset + k, n - offset - k, step))\n                return FALSE;\n    }\n    else {\n        for (k = 0; k < n; ) {\n            if (!codebook_decode(f, book, target + offset, n - k))\n                return FALSE;\n            k += book->dimensions;\n            offset += book->dimensions;\n        }\n    }\n    return TRUE;\n}\n\n// n is 1/2 of the blocksize --\n// specification: \"Correct per-vector decode length is [n]/2\"\nstatic void decode_residue(vorb* f, float* residue_buffers[], int ch, int n, int rn, uint8* do_not_decode)\n{\n    int i, j, pass;\n    Residue* r = f->residue_config + rn;\n    int rtype = f->residue_types[rn];\n    int c = r->classbook;\n    int classwords = f->codebooks[c].dimensions;\n    unsigned int actual_size = rtype == 2 ? n * 2 : n;\n    unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);\n    unsigned int limit_r_end = (r->end < actual_size ? r->end : actual_size);\n    int n_read = limit_r_end - limit_r_begin;\n    int part_read = n_read / r->part_size;\n    int temp_alloc_point = temp_alloc_save(f);\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n    uint8*** part_classdata = (uint8***)temp_block_array(f, f->channels, part_read * sizeof(**part_classdata));\n#else\n    int** classifications = (int**)temp_block_array(f, f->channels, part_read * sizeof(**classifications));\n#endif\n\n    CHECK(f);\n\n    for (i = 0; i < ch; ++i)\n        if (!do_not_decode[i])\n            MemSet(residue_buffers[i], 0, sizeof(float) * n);\n\n    if (rtype == 2 && ch != 1) {\n        for (j = 0; j < ch; ++j)\n            if (!do_not_decode[j])\n                break;\n        if (j == ch)\n            goto done;\n\n        for (pass = 0; pass < 8; ++pass) {\n            int pcount = 0, class_set = 0;\n            if (ch == 2) {\n                while (pcount < part_read) {\n                    int z = r->begin + pcount * r->part_size;\n                    int c_inter = (z & 1), p_inter = z >> 1;\n                    if (pass == 0) {\n                        Codebook* c = f->codebooks + r->classbook;\n                        int q;\n                        DECODE(q, f, c);\n                        if (q == EOP) goto done;\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                        part_classdata[0][class_set] = r->classdata[q];\n#else\n                        for (i = classwords - 1; i >= 0; --i) {\n                            classifications[0][i + pcount] = q % r->classifications;\n                            q /= r->classifications;\n                        }\n#endif\n                    }\n                    for (i = 0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                        int z = r->begin + pcount * r->part_size;\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                        int c = part_classdata[0][class_set][i];\n#else\n                        int c = classifications[0][pcount];\n#endif\n                        int b = r->residue_books[c][pass];\n                        if (b >= 0) {\n                            Codebook* book = f->codebooks + b;\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n                            if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                                goto done;\n#else\n                            // saves 1%\n                            if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                                goto done;\n#endif\n                        }\n                        else {\n                            z += r->part_size;\n                            c_inter = z & 1;\n                            p_inter = z >> 1;\n                        }\n                    }\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                    ++class_set;\n#endif\n                }\n            }\n            else if (ch > 2) {\n                while (pcount < part_read) {\n                    int z = r->begin + pcount * r->part_size;\n                    int c_inter = z % ch, p_inter = z / ch;\n                    if (pass == 0) {\n                        Codebook* c = f->codebooks + r->classbook;\n                        int q;\n                        DECODE(q, f, c);\n                        if (q == EOP) goto done;\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                        part_classdata[0][class_set] = r->classdata[q];\n#else\n                        for (i = classwords - 1; i >= 0; --i) {\n                            classifications[0][i + pcount] = q % r->classifications;\n                            q /= r->classifications;\n                        }\n#endif\n                    }\n                    for (i = 0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                        int z = r->begin + pcount * r->part_size;\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                        int c = part_classdata[0][class_set][i];\n#else\n                        int c = classifications[0][pcount];\n#endif\n                        int b = r->residue_books[c][pass];\n                        if (b >= 0) {\n                            Codebook* book = f->codebooks + b;\n                            if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                                goto done;\n                        }\n                        else {\n                            z += r->part_size;\n                            c_inter = z % ch;\n                            p_inter = z / ch;\n                        }\n                    }\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                    ++class_set;\n#endif\n                }\n            }\n        }\n        goto done;\n    }\n    CHECK(f);\n\n    for (pass = 0; pass < 8; ++pass) {\n        int pcount = 0, class_set = 0;\n        while (pcount < part_read) {\n            if (pass == 0) {\n                for (j = 0; j < ch; ++j) {\n                    if (!do_not_decode[j]) {\n                        Codebook* c = f->codebooks + r->classbook;\n                        int temp;\n                        DECODE(temp, f, c);\n                        if (temp == EOP) goto done;\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                        part_classdata[j][class_set] = r->classdata[temp];\n#else\n                        for (i = classwords - 1; i >= 0; --i) {\n                            classifications[j][i + pcount] = temp % r->classifications;\n                            temp /= r->classifications;\n                        }\n#endif\n                    }\n                }\n            }\n            for (i = 0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                for (j = 0; j < ch; ++j) {\n                    if (!do_not_decode[j]) {\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                        int c = part_classdata[j][class_set][i];\n#else\n                        int c = classifications[j][pcount];\n#endif\n                        int b = r->residue_books[c][pass];\n                        if (b >= 0) {\n                            float* target = residue_buffers[j];\n                            int offset = r->begin + pcount * r->part_size;\n                            int n = r->part_size;\n                            Codebook* book = f->codebooks + b;\n                            if (!residue_decode(f, book, target, offset, n, rtype))\n                                goto done;\n                        }\n                    }\n                }\n            }\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n            ++class_set;\n#endif\n        }\n    }\ndone:\n    CHECK(f);\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n    temp_free(f, part_classdata);\n#else\n    temp_free(f, classifications);\n#endif\n    temp_alloc_restore(f, temp_alloc_point);\n}\n\n\n#if 0\n// slow way for debugging\nvoid inverse_mdct_slow(float* buffer, int n)\n{\n    int i, j;\n    int n2 = n >> 1;\n    float* x = (float*)malloc(sizeof(*x) * n2);\n    memcpy(x, buffer, sizeof(*x) * n2);\n    for (i = 0; i < n; ++i) {\n        float acc = 0;\n        for (j = 0; j < n2; ++j)\n            // formula from paper:\n            //acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n            // formula from wikipedia\n            //acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n            // these are equivalent, except the formula from the paper inverts the multiplier!\n            // however, what actually works is NO MULTIPLIER!?!\n            //acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n            acc += x[j] * (float)cos(M_PI / 2 / n * (2 * i + 1 + n / 2.0) * (2 * j + 1));\n        buffer[i] = acc;\n    }\n    free(x);\n}\n#elif 0\n// same as above, but just barely able to run in real time on modern machines\nvoid inverse_mdct_slow(float* buffer, int n, vorb* f, int blocktype)\n{\n    float mcos[16384];\n    int i, j;\n    int n2 = n >> 1, nmask = (n << 2) - 1;\n    float* x = (float*)malloc(sizeof(*x) * n2);\n    memcpy(x, buffer, sizeof(*x) * n2);\n    for (i = 0; i < 4 * n; ++i)\n        mcos[i] = (float)cos(M_PI / 2 * i / n);\n\n    for (i = 0; i < n; ++i) {\n        float acc = 0;\n        for (j = 0; j < n2; ++j)\n            acc += x[j] * mcos[(2 * i + 1 + n2) * (2 * j + 1) & nmask];\n        buffer[i] = acc;\n    }\n    free(x);\n}\n#elif 0\n// transform to use a slow dct-iv; this is STILL basically trivial,\n// but only requires half as many ops\nvoid dct_iv_slow(float* buffer, int n)\n{\n    float mcos[16384];\n    float x[2048];\n    int i, j;\n    int n2 = n >> 1, nmask = (n << 3) - 1;\n    memcpy(x, buffer, sizeof(*x) * n);\n    for (i = 0; i < 8 * n; ++i)\n        mcos[i] = (float)cos(M_PI / 4 * i / n);\n    for (i = 0; i < n; ++i) {\n        float acc = 0;\n        for (j = 0; j < n; ++j)\n            acc += x[j] * mcos[((2 * i + 1) * (2 * j + 1)) & nmask];\n        buffer[i] = acc;\n    }\n}\n\nvoid inverse_mdct_slow(float* buffer, int n, vorb* f, int blocktype)\n{\n    int i, n4 = n >> 2, n2 = n >> 1, n3_4 = n - n4;\n    float temp[4096];\n\n    memcpy(temp, buffer, n2 * sizeof(float));\n    dct_iv_slow(temp, n2);  // returns -c'-d, a-b'\n\n    for (i = 0; i < n4; ++i) buffer[i] = temp[i + n4];            // a-b'\n    for (; i < n3_4; ++i) buffer[i] = -temp[n3_4 - i - 1];   // b-a', c+d'\n    for (; i < n; ++i) buffer[i] = -temp[i - n3_4];       // c'+d\n}\n#endif\n\n#ifndef LIBVORBIS_MDCT\n#define LIBVORBIS_MDCT 0\n#endif\n\n#if LIBVORBIS_MDCT\n// directly call the vorbis MDCT using an interface documented\n// by Jeff Roberts... useful for performance comparison\ntypedef struct\n{\n    int n;\n    int log2n;\n\n    float* trig;\n    int* bitrev;\n\n    float scale;\n} mdct_lookup;\n\nvoid mdct_init(mdct_lookup* lookup, int n);\nvoid mdct_clear(mdct_lookup* l);\nvoid mdct_backward(mdct_lookup* init, float* in, float* out);\n\nmdct_lookup M1, M2;\n\nvoid inverse_mdct(float* buffer, int n, vorb* f, int blocktype)\n{\n    mdct_lookup* M;\n    if (M1.n == n) M = &M1;\n    else if (M2.n == n) M = &M2;\n    else if (M1.n == 0) { mdct_init(&M1, n); M = &M1; }\n    else {\n        if (M2.n) __asm int 3;\n        mdct_init(&M2, n);\n        M = &M2;\n    }\n\n    mdct_backward(M, buffer, buffer);\n}\n#endif\n\n\n// the following were split out into separate functions while optimizing;\n// they could be pushed back up but eh. __forceinline showed no change;\n// they're probably already being inlined.\nstatic void imdct_step3_iter0_loop(int n, float* e, int i_off, int k_off, float* A)\n{\n    float* ee0 = e + i_off;\n    float* ee2 = ee0 + k_off;\n    int i;\n\n    VORBIS_ASSERT((n & 3) == 0);\n    for (i = (n >> 2); i > 0; --i) {\n        float k00_20, k01_21;\n        k00_20 = ee0[0] - ee2[0];\n        k01_21 = ee0[-1] - ee2[-1];\n        ee0[0] += ee2[0];//ee0[ 0] = ee0[ 0] + ee2[ 0];\n        ee0[-1] += ee2[-1];//ee0[-1] = ee0[-1] + ee2[-1];\n        ee2[0] = k00_20 * A[0] - k01_21 * A[1];\n        ee2[-1] = k01_21 * A[0] + k00_20 * A[1];\n        A += 8;\n\n        k00_20 = ee0[-2] - ee2[-2];\n        k01_21 = ee0[-3] - ee2[-3];\n        ee0[-2] += ee2[-2];//ee0[-2] = ee0[-2] + ee2[-2];\n        ee0[-3] += ee2[-3];//ee0[-3] = ee0[-3] + ee2[-3];\n        ee2[-2] = k00_20 * A[0] - k01_21 * A[1];\n        ee2[-3] = k01_21 * A[0] + k00_20 * A[1];\n        A += 8;\n\n        k00_20 = ee0[-4] - ee2[-4];\n        k01_21 = ee0[-5] - ee2[-5];\n        ee0[-4] += ee2[-4];//ee0[-4] = ee0[-4] + ee2[-4];\n        ee0[-5] += ee2[-5];//ee0[-5] = ee0[-5] + ee2[-5];\n        ee2[-4] = k00_20 * A[0] - k01_21 * A[1];\n        ee2[-5] = k01_21 * A[0] + k00_20 * A[1];\n        A += 8;\n\n        k00_20 = ee0[-6] - ee2[-6];\n        k01_21 = ee0[-7] - ee2[-7];\n        ee0[-6] += ee2[-6];//ee0[-6] = ee0[-6] + ee2[-6];\n        ee0[-7] += ee2[-7];//ee0[-7] = ee0[-7] + ee2[-7];\n        ee2[-6] = k00_20 * A[0] - k01_21 * A[1];\n        ee2[-7] = k01_21 * A[0] + k00_20 * A[1];\n        A += 8;\n        ee0 -= 8;\n        ee2 -= 8;\n    }\n}\n\nstatic void imdct_step3_inner_r_loop(int lim, float* e, int d0, int k_off, float* A, int k1)\n{\n    int i;\n    float k00_20, k01_21;\n\n    float* e0 = e + d0;\n    float* e2 = e0 + k_off;\n\n    for (i = lim >> 2; i > 0; --i) {\n        k00_20 = e0[-0] - e2[-0];\n        k01_21 = e0[-1] - e2[-1];\n        e0[-0] += e2[-0];//e0[-0] = e0[-0] + e2[-0];\n        e0[-1] += e2[-1];//e0[-1] = e0[-1] + e2[-1];\n        e2[-0] = (k00_20)*A[0] - (k01_21)*A[1];\n        e2[-1] = (k01_21)*A[0] + (k00_20)*A[1];\n\n        A += k1;\n\n        k00_20 = e0[-2] - e2[-2];\n        k01_21 = e0[-3] - e2[-3];\n        e0[-2] += e2[-2];//e0[-2] = e0[-2] + e2[-2];\n        e0[-3] += e2[-3];//e0[-3] = e0[-3] + e2[-3];\n        e2[-2] = (k00_20)*A[0] - (k01_21)*A[1];\n        e2[-3] = (k01_21)*A[0] + (k00_20)*A[1];\n\n        A += k1;\n\n        k00_20 = e0[-4] - e2[-4];\n        k01_21 = e0[-5] - e2[-5];\n        e0[-4] += e2[-4];//e0[-4] = e0[-4] + e2[-4];\n        e0[-5] += e2[-5];//e0[-5] = e0[-5] + e2[-5];\n        e2[-4] = (k00_20)*A[0] - (k01_21)*A[1];\n        e2[-5] = (k01_21)*A[0] + (k00_20)*A[1];\n\n        A += k1;\n\n        k00_20 = e0[-6] - e2[-6];\n        k01_21 = e0[-7] - e2[-7];\n        e0[-6] += e2[-6];//e0[-6] = e0[-6] + e2[-6];\n        e0[-7] += e2[-7];//e0[-7] = e0[-7] + e2[-7];\n        e2[-6] = (k00_20)*A[0] - (k01_21)*A[1];\n        e2[-7] = (k01_21)*A[0] + (k00_20)*A[1];\n\n        e0 -= 8;\n        e2 -= 8;\n\n        A += k1;\n    }\n}\n\nstatic void imdct_step3_inner_s_loop(int n, float* e, int i_off, int k_off, float* A, int a_off, int k0)\n{\n    int i;\n    float A0 = A[0];\n    float A1 = A[0 + 1];\n    float A2 = A[0 + a_off];\n    float A3 = A[0 + a_off + 1];\n    float A4 = A[0 + a_off * 2 + 0];\n    float A5 = A[0 + a_off * 2 + 1];\n    float A6 = A[0 + a_off * 3 + 0];\n    float A7 = A[0 + a_off * 3 + 1];\n\n    float k00, k11;\n\n    float* ee0 = e + i_off;\n    float* ee2 = ee0 + k_off;\n\n    for (i = n; i > 0; --i) {\n        k00 = ee0[0] - ee2[0];\n        k11 = ee0[-1] - ee2[-1];\n        ee0[0] = ee0[0] + ee2[0];\n        ee0[-1] = ee0[-1] + ee2[-1];\n        ee2[0] = (k00)*A0 - (k11)*A1;\n        ee2[-1] = (k11)*A0 + (k00)*A1;\n\n        k00 = ee0[-2] - ee2[-2];\n        k11 = ee0[-3] - ee2[-3];\n        ee0[-2] = ee0[-2] + ee2[-2];\n        ee0[-3] = ee0[-3] + ee2[-3];\n        ee2[-2] = (k00)*A2 - (k11)*A3;\n        ee2[-3] = (k11)*A2 + (k00)*A3;\n\n        k00 = ee0[-4] - ee2[-4];\n        k11 = ee0[-5] - ee2[-5];\n        ee0[-4] = ee0[-4] + ee2[-4];\n        ee0[-5] = ee0[-5] + ee2[-5];\n        ee2[-4] = (k00)*A4 - (k11)*A5;\n        ee2[-5] = (k11)*A4 + (k00)*A5;\n\n        k00 = ee0[-6] - ee2[-6];\n        k11 = ee0[-7] - ee2[-7];\n        ee0[-6] = ee0[-6] + ee2[-6];\n        ee0[-7] = ee0[-7] + ee2[-7];\n        ee2[-6] = (k00)*A6 - (k11)*A7;\n        ee2[-7] = (k11)*A6 + (k00)*A7;\n\n        ee0 -= k0;\n        ee2 -= k0;\n    }\n}\n\nstatic __forceinline void iter_54(float* z)\n{\n    float k00, k11, k22, k33;\n    float y0, y1, y2, y3;\n\n    k00 = z[0] - z[-4];\n    y0 = z[0] + z[-4];\n    y2 = z[-2] + z[-6];\n    k22 = z[-2] - z[-6];\n\n    z[-0] = y0 + y2;      // z0 + z4 + z2 + z6\n    z[-2] = y0 - y2;      // z0 + z4 - z2 - z6\n\n    // done with y0,y2\n\n    k33 = z[-3] - z[-7];\n\n    z[-4] = k00 + k33;    // z0 - z4 + z3 - z7\n    z[-6] = k00 - k33;    // z0 - z4 - z3 + z7\n\n    // done with k33\n\n    k11 = z[-1] - z[-5];\n    y1 = z[-1] + z[-5];\n    y3 = z[-3] + z[-7];\n\n    z[-1] = y1 + y3;      // z1 + z5 + z3 + z7\n    z[-3] = y1 - y3;      // z1 + z5 - z3 - z7\n    z[-5] = k11 - k22;    // z1 - z5 + z2 - z6\n    z[-7] = k11 + k22;    // z1 - z5 - z2 + z6\n}\n\nstatic void imdct_step3_inner_s_loop_ld654(int n, float* e, int i_off, float* A, int base_n)\n{\n    int a_off = base_n >> 3;\n    float A2 = A[0 + a_off];\n    float* z = e + i_off;\n    float* base = z - 16 * n;\n\n    while (z > base) {\n        float k00, k11;\n        float l00, l11;\n\n        k00 = z[-0] - z[-8];\n        k11 = z[-1] - z[-9];\n        l00 = z[-2] - z[-10];\n        l11 = z[-3] - z[-11];\n        z[-0] = z[-0] + z[-8];\n        z[-1] = z[-1] + z[-9];\n        z[-2] = z[-2] + z[-10];\n        z[-3] = z[-3] + z[-11];\n        z[-8] = k00;\n        z[-9] = k11;\n        z[-10] = (l00 + l11) * A2;\n        z[-11] = (l11 - l00) * A2;\n\n        k00 = z[-4] - z[-12];\n        k11 = z[-5] - z[-13];\n        l00 = z[-6] - z[-14];\n        l11 = z[-7] - z[-15];\n        z[-4] = z[-4] + z[-12];\n        z[-5] = z[-5] + z[-13];\n        z[-6] = z[-6] + z[-14];\n        z[-7] = z[-7] + z[-15];\n        z[-12] = k11;\n        z[-13] = -k00;\n        z[-14] = (l11 - l00) * A2;\n        z[-15] = (l00 + l11) * -A2;\n\n        iter_54(z);\n        iter_54(z - 8);\n        z -= 16;\n    }\n}\n\nstatic void inverse_mdct(float* buffer, int n, vorb* f, int blocktype)\n{\n    int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n    int ld;\n    // @OPTIMIZE: reduce register pressure by using fewer variables?\n    int save_point = temp_alloc_save(f);\n    float* buf2 = (float*)temp_alloc(f, n2 * sizeof(*buf2));\n    float* u = NULL, * v = NULL;\n    // twiddle factors\n    float* A = f->A[blocktype];\n\n    // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n    // See notes about bugs in that paper in less-optimal implementation 'inverse_mdct_old' after this function.\n\n    // kernel from paper\n\n\n    // merged:\n    //   copy and reflect spectral data\n    //   step 0\n\n    // note that it turns out that the items added together during\n    // this step are, in fact, being added to themselves (as reflected\n    // by step 0). inexplicable inefficiency! this became obvious\n    // once I combined the passes.\n\n    // so there's a missing 'times 2' here (for adding X to itself).\n    // this propagates through linearly to the end, where the numbers\n    // are 1/2 too small, and need to be compensated for.\n\n    {\n        float* d, * e, * AA, * e_stop;\n        d = &buf2[n2 - 2];\n        AA = A;\n        e = &buffer[0];\n        e_stop = &buffer[n2];\n        while (e != e_stop) {\n            d[1] = (e[0] * AA[0] - e[2] * AA[1]);\n            d[0] = (e[0] * AA[1] + e[2] * AA[0]);\n            d -= 2;\n            AA += 2;\n            e += 4;\n        }\n\n        e = &buffer[n2 - 3];\n        while (d >= buf2) {\n            d[1] = (-e[2] * AA[0] - -e[0] * AA[1]);\n            d[0] = (-e[2] * AA[1] + -e[0] * AA[0]);\n            d -= 2;\n            AA += 2;\n            e -= 4;\n        }\n    }\n\n    // now we use symbolic names for these, so that we can\n    // possibly swap their meaning as we change which operations\n    // are in place\n\n    u = buffer;\n    v = buf2;\n\n    // step 2    (paper output is w, now u)\n    // this could be in place, but the data ends up in the wrong\n    // place... _somebody_'s got to swap it, so this is nominated\n    {\n        float* AA = &A[n2 - 8];\n        float* d0, * d1, * e0, * e1;\n\n        e0 = &v[n4];\n        e1 = &v[0];\n\n        d0 = &u[n4];\n        d1 = &u[0];\n\n        while (AA >= A) {\n            float v40_20, v41_21;\n\n            v41_21 = e0[1] - e1[1];\n            v40_20 = e0[0] - e1[0];\n            d0[1] = e0[1] + e1[1];\n            d0[0] = e0[0] + e1[0];\n            d1[1] = v41_21 * AA[4] - v40_20 * AA[5];\n            d1[0] = v40_20 * AA[4] + v41_21 * AA[5];\n\n            v41_21 = e0[3] - e1[3];\n            v40_20 = e0[2] - e1[2];\n            d0[3] = e0[3] + e1[3];\n            d0[2] = e0[2] + e1[2];\n            d1[3] = v41_21 * AA[0] - v40_20 * AA[1];\n            d1[2] = v40_20 * AA[0] + v41_21 * AA[1];\n\n            AA -= 8;\n\n            d0 += 4;\n            d1 += 4;\n            e0 += 4;\n            e1 += 4;\n        }\n    }\n\n    // step 3\n    ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n\n    // optimized step 3:\n\n    // the original step3 loop can be nested r inside s or s inside r;\n    // it's written originally as s inside r, but this is dumb when r\n    // iterates many times, and s few. So I have two copies of it and\n    // switch between them halfway.\n\n    // this is iteration 0 of step 3\n    imdct_step3_iter0_loop(n >> 4, u, n2 - 1 - n4 * 0, -(n >> 3), A);\n    imdct_step3_iter0_loop(n >> 4, u, n2 - 1 - n4 * 1, -(n >> 3), A);\n\n    // this is iteration 1 of step 3\n    imdct_step3_inner_r_loop(n >> 5, u, n2 - 1 - n8 * 0, -(n >> 4), A, 16);\n    imdct_step3_inner_r_loop(n >> 5, u, n2 - 1 - n8 * 1, -(n >> 4), A, 16);\n    imdct_step3_inner_r_loop(n >> 5, u, n2 - 1 - n8 * 2, -(n >> 4), A, 16);\n    imdct_step3_inner_r_loop(n >> 5, u, n2 - 1 - n8 * 3, -(n >> 4), A, 16);\n\n    l = 2;\n    for (; l < (ld - 3) >> 1; ++l) {\n        int k0 = n >> (l + 2), k0_2 = k0 >> 1;\n        int lim = 1 << (l + 1);\n        int i;\n        for (i = 0; i < lim; ++i)\n            imdct_step3_inner_r_loop(n >> (l + 4), u, n2 - 1 - k0 * i, -k0_2, A, 1 << (l + 3));\n    }\n\n    for (; l < ld - 6; ++l) {\n        int k0 = n >> (l + 2), k1 = 1 << (l + 3), k0_2 = k0 >> 1;\n        int rlim = n >> (l + 6), r;\n        int lim = 1 << (l + 1);\n        int i_off;\n        float* A0 = A;\n        i_off = n2 - 1;\n        for (r = rlim; r > 0; --r) {\n            imdct_step3_inner_s_loop(lim, u, i_off, -k0_2, A0, k1, k0);\n            A0 += k1 * 4;\n            i_off -= 8;\n        }\n    }\n\n    // iterations with count:\n    //   ld-6,-5,-4 all interleaved together\n    //       the big win comes from getting rid of needless flops\n    //         due to the constants on pass 5 & 4 being all 1 and 0;\n    //       combining them to be simultaneous to improve cache made little difference\n    imdct_step3_inner_s_loop_ld654(n >> 5, u, n2 - 1, A, n);\n\n    // output is u\n\n    // step 4, 5, and 6\n    // cannot be in-place because of step 5\n    {\n        uint16* bitrev = f->bit_reverse[blocktype];\n        // weirdly, I'd have thought reading sequentially and writing\n        // erratically would have been better than vice-versa, but in\n        // fact that's not what my testing showed. (That is, with\n        // j = bitreverse(i), do you read i and write j, or read j and write i.)\n\n        float* d0 = &v[n4 - 4];\n        float* d1 = &v[n2 - 4];\n        while (d0 >= v) {\n            int k4;\n\n            k4 = bitrev[0];\n            d1[3] = u[k4 + 0];\n            d1[2] = u[k4 + 1];\n            d0[3] = u[k4 + 2];\n            d0[2] = u[k4 + 3];\n\n            k4 = bitrev[1];\n            d1[1] = u[k4 + 0];\n            d1[0] = u[k4 + 1];\n            d0[1] = u[k4 + 2];\n            d0[0] = u[k4 + 3];\n\n            d0 -= 4;\n            d1 -= 4;\n            bitrev += 2;\n        }\n    }\n    // (paper output is u, now v)\n\n\n    // data must be in buf2\n    VORBIS_ASSERT(v == buf2);\n\n    // step 7   (paper output is v, now v)\n    // this is now in place\n    {\n        float* C = f->C[blocktype];\n        float* d, * e;\n\n        d = v;\n        e = v + n2 - 4;\n\n        while (d < e) {\n            float a02, a11, b0, b1, b2, b3;\n\n            a02 = d[0] - e[2];\n            a11 = d[1] + e[3];\n\n            b0 = C[1] * a02 + C[0] * a11;\n            b1 = C[1] * a11 - C[0] * a02;\n\n            b2 = d[0] + e[2];\n            b3 = d[1] - e[3];\n\n            d[0] = b2 + b0;\n            d[1] = b3 + b1;\n            e[2] = b2 - b0;\n            e[3] = b1 - b3;\n\n            a02 = d[2] - e[0];\n            a11 = d[3] + e[1];\n\n            b0 = C[3] * a02 + C[2] * a11;\n            b1 = C[3] * a11 - C[2] * a02;\n\n            b2 = d[2] + e[0];\n            b3 = d[3] - e[1];\n\n            d[2] = b2 + b0;\n            d[3] = b3 + b1;\n            e[0] = b2 - b0;\n            e[1] = b1 - b3;\n\n            C += 4;\n            d += 4;\n            e -= 4;\n        }\n    }\n\n    // data must be in buf2\n\n\n    // step 8+decode   (paper output is X, now buffer)\n    // this generates pairs of data a la 8 and pushes them directly through\n    // the decode kernel (pushing rather than pulling) to avoid having\n    // to make another pass later\n\n    // this cannot POSSIBLY be in place, so we refer to the buffers directly\n\n    {\n        float* d0, * d1, * d2, * d3;\n\n        float* B = f->B[blocktype] + n2 - 8;\n        float* e = buf2 + n2 - 8;\n        d0 = &buffer[0];\n        d1 = &buffer[n2 - 4];\n        d2 = &buffer[n2];\n        d3 = &buffer[n - 4];\n        while (e >= v) {\n            float p0, p1, p2, p3;\n\n            p3 = e[6] * B[7] - e[7] * B[6];\n            p2 = -e[6] * B[6] - e[7] * B[7];\n\n            d0[0] = p3;\n            d1[3] = -p3;\n            d2[0] = p2;\n            d3[3] = p2;\n\n            p1 = e[4] * B[5] - e[5] * B[4];\n            p0 = -e[4] * B[4] - e[5] * B[5];\n\n            d0[1] = p1;\n            d1[2] = -p1;\n            d2[1] = p0;\n            d3[2] = p0;\n\n            p3 = e[2] * B[3] - e[3] * B[2];\n            p2 = -e[2] * B[2] - e[3] * B[3];\n\n            d0[2] = p3;\n            d1[1] = -p3;\n            d2[2] = p2;\n            d3[1] = p2;\n\n            p1 = e[0] * B[1] - e[1] * B[0];\n            p0 = -e[0] * B[0] - e[1] * B[1];\n\n            d0[3] = p1;\n            d1[0] = -p1;\n            d2[3] = p0;\n            d3[0] = p0;\n\n            B -= 8;\n            e -= 8;\n            d0 += 4;\n            d2 += 4;\n            d1 -= 4;\n            d3 -= 4;\n        }\n    }\n\n    temp_free(f, buf2);\n    temp_alloc_restore(f, save_point);\n}\n\n#if 0\n// this is the original version of the above code, if you want to optimize it from scratch\nvoid inverse_mdct_naive(float* buffer, int n)\n{\n    float s;\n    float A[1 << 12], B[1 << 12], C[1 << 11];\n    int i, k, k2, k4, n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n    int n3_4 = n - n4, ld;\n    // how can they claim this only uses N words?!\n    // oh, because they're only used sparsely, whoops\n    float u[1 << 13], X[1 << 13], v[1 << 13], w[1 << 13];\n    // set up twiddle factors\n\n    for (k = k2 = 0; k < n4; ++k, k2 += 2) {\n        A[k2] = (float)cos(4 * k * M_PI / n);\n        A[k2 + 1] = (float)-sin(4 * k * M_PI / n);\n        B[k2] = (float)cos((k2 + 1) * M_PI / n / 2);\n        B[k2 + 1] = (float)sin((k2 + 1) * M_PI / n / 2);\n    }\n    for (k = k2 = 0; k < n8; ++k, k2 += 2) {\n        C[k2] = (float)cos(2 * (k2 + 1) * M_PI / n);\n        C[k2 + 1] = (float)-sin(2 * (k2 + 1) * M_PI / n);\n    }\n\n    // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n    // Note there are bugs in that pseudocode, presumably due to them attempting\n    // to rename the arrays nicely rather than representing the way their actual\n    // implementation bounces buffers back and forth. As a result, even in the\n    // \"some formulars corrected\" version, a direct implementation fails. These\n    // are noted below as \"paper bug\".\n\n    // copy and reflect spectral data\n    for (k = 0; k < n2; ++k) u[k] = buffer[k];\n    for (; k < n; ++k) u[k] = -buffer[n - k - 1];\n    // kernel from paper\n    // step 1\n    for (k = k2 = k4 = 0; k < n4; k += 1, k2 += 2, k4 += 4) {\n        v[n - k4 - 1] = (u[k4] - u[n - k4 - 1]) * A[k2] - (u[k4 + 2] - u[n - k4 - 3]) * A[k2 + 1];\n        v[n - k4 - 3] = (u[k4] - u[n - k4 - 1]) * A[k2 + 1] + (u[k4 + 2] - u[n - k4 - 3]) * A[k2];\n    }\n    // step 2\n    for (k = k4 = 0; k < n8; k += 1, k4 += 4) {\n        w[n2 + 3 + k4] = v[n2 + 3 + k4] + v[k4 + 3];\n        w[n2 + 1 + k4] = v[n2 + 1 + k4] + v[k4 + 1];\n        w[k4 + 3] = (v[n2 + 3 + k4] - v[k4 + 3]) * A[n2 - 4 - k4] - (v[n2 + 1 + k4] - v[k4 + 1]) * A[n2 - 3 - k4];\n        w[k4 + 1] = (v[n2 + 1 + k4] - v[k4 + 1]) * A[n2 - 4 - k4] + (v[n2 + 3 + k4] - v[k4 + 3]) * A[n2 - 3 - k4];\n    }\n    // step 3\n    ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n    for (l = 0; l < ld - 3; ++l) {\n        int k0 = n >> (l + 2), k1 = 1 << (l + 3);\n        int rlim = n >> (l + 4), r4, r;\n        int s2lim = 1 << (l + 2), s2;\n        for (r = r4 = 0; r < rlim; r4 += 4, ++r) {\n            for (s2 = 0; s2 < s2lim; s2 += 2) {\n                u[n - 1 - k0 * s2 - r4] = w[n - 1 - k0 * s2 - r4] + w[n - 1 - k0 * (s2 + 1) - r4];\n                u[n - 3 - k0 * s2 - r4] = w[n - 3 - k0 * s2 - r4] + w[n - 3 - k0 * (s2 + 1) - r4];\n                u[n - 1 - k0 * (s2 + 1) - r4] = (w[n - 1 - k0 * s2 - r4] - w[n - 1 - k0 * (s2 + 1) - r4]) * A[r * k1]\n                    - (w[n - 3 - k0 * s2 - r4] - w[n - 3 - k0 * (s2 + 1) - r4]) * A[r * k1 + 1];\n                u[n - 3 - k0 * (s2 + 1) - r4] = (w[n - 3 - k0 * s2 - r4] - w[n - 3 - k0 * (s2 + 1) - r4]) * A[r * k1]\n                    + (w[n - 1 - k0 * s2 - r4] - w[n - 1 - k0 * (s2 + 1) - r4]) * A[r * k1 + 1];\n            }\n        }\n        if (l + 1 < ld - 3) {\n            // paper bug: ping-ponging of u&w here is omitted\n            memcpy(w, u, sizeof(u));\n        }\n    }\n\n    // step 4\n    for (i = 0; i < n8; ++i) {\n        int j = bit_reverse(i) >> (32 - ld + 3);\n        VORBIS_ASSERT(j < n8);\n        if (i == j) {\n            // paper bug: original code probably swapped in place; if copying,\n            //            need to directly copy in this case\n            int i8 = i << 3;\n            v[i8 + 1] = u[i8 + 1];\n            v[i8 + 3] = u[i8 + 3];\n            v[i8 + 5] = u[i8 + 5];\n            v[i8 + 7] = u[i8 + 7];\n        }\n        else if (i < j) {\n            int i8 = i << 3, j8 = j << 3;\n            v[j8 + 1] = u[i8 + 1], v[i8 + 1] = u[j8 + 1];\n            v[j8 + 3] = u[i8 + 3], v[i8 + 3] = u[j8 + 3];\n            v[j8 + 5] = u[i8 + 5], v[i8 + 5] = u[j8 + 5];\n            v[j8 + 7] = u[i8 + 7], v[i8 + 7] = u[j8 + 7];\n        }\n    }\n    // step 5\n    for (k = 0; k < n2; ++k) {\n        w[k] = v[k * 2 + 1];\n    }\n    // step 6\n    for (k = k2 = k4 = 0; k < n8; ++k, k2 += 2, k4 += 4) {\n        u[n - 1 - k2] = w[k4];\n        u[n - 2 - k2] = w[k4 + 1];\n        u[n3_4 - 1 - k2] = w[k4 + 2];\n        u[n3_4 - 2 - k2] = w[k4 + 3];\n    }\n    // step 7\n    for (k = k2 = 0; k < n8; ++k, k2 += 2) {\n        v[n2 + k2] = (u[n2 + k2] + u[n - 2 - k2] + C[k2 + 1] * (u[n2 + k2] - u[n - 2 - k2]) + C[k2] * (u[n2 + k2 + 1] + u[n - 2 - k2 + 1])) / 2;\n        v[n - 2 - k2] = (u[n2 + k2] + u[n - 2 - k2] - C[k2 + 1] * (u[n2 + k2] - u[n - 2 - k2]) - C[k2] * (u[n2 + k2 + 1] + u[n - 2 - k2 + 1])) / 2;\n        v[n2 + 1 + k2] = (u[n2 + 1 + k2] - u[n - 1 - k2] + C[k2 + 1] * (u[n2 + 1 + k2] + u[n - 1 - k2]) - C[k2] * (u[n2 + k2] - u[n - 2 - k2])) / 2;\n        v[n - 1 - k2] = (-u[n2 + 1 + k2] + u[n - 1 - k2] + C[k2 + 1] * (u[n2 + 1 + k2] + u[n - 1 - k2]) - C[k2] * (u[n2 + k2] - u[n - 2 - k2])) / 2;\n    }\n    // step 8\n    for (k = k2 = 0; k < n4; ++k, k2 += 2) {\n        X[k] = v[k2 + n2] * B[k2] + v[k2 + 1 + n2] * B[k2 + 1];\n        X[n2 - 1 - k] = v[k2 + n2] * B[k2 + 1] - v[k2 + 1 + n2] * B[k2];\n    }\n\n    // decode kernel to output\n    // determined the following value experimentally\n    // (by first figuring out what made inverse_mdct_slow work); then matching that here\n    // (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)\n    s = 0.5; // theoretically would be n4\n\n    // [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,\n    //     so it needs to use the \"old\" B values to behave correctly, or else\n    //     set s to 1.0 ]]]\n    for (i = 0; i < n4; ++i) buffer[i] = s * X[i + n4];\n    for (; i < n3_4; ++i) buffer[i] = -s * X[n3_4 - i - 1];\n    for (; i < n; ++i) buffer[i] = -s * X[i - n3_4];\n}\n#endif\n\nstatic float* get_window(vorb* f, int len)\n{\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n    return NULL;\n}\n\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\ntypedef int16 YTYPE;\n#else\ntypedef int YTYPE;\n#endif\nstatic int do_floor(vorb* f, Mapping* map, int i, int n, float* target, YTYPE* finalY, uint8* step2_flag)\n{\n    int n2 = n >> 1;\n    int s = map->chan[i].mux, floor;\n    floor = map->submap_floor[s];\n    if (f->floor_types[floor] == 0) {\n        return error(f, VORBIS_invalid_stream);\n    }\n    else {\n        Floor1* g = &f->floor_config[floor].floor1;\n        int j, q;\n        int lx = 0, ly = finalY[0] * g->floor1_multiplier;\n        for (q = 1; q < g->values; ++q) {\n            j = g->sorted_order[q];\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n            STBV_NOTUSED(step2_flag);\n            if (finalY[j] >= 0)\n#else\n            if (step2_flag[j])\n#endif\n            {\n                int hy = finalY[j] * g->floor1_multiplier;\n                int hx = g->Xlist[j];\n                if (lx != hx)\n                    draw_line(target, lx, ly, hx, hy, n2);\n                CHECK(f);\n                lx = hx, ly = hy;\n            }\n        }\n        if (lx < n2) {\n            // optimization of: draw_line(target, lx,ly, n,ly, n2);\n            for (j = lx; j < n2; ++j)\n                LINE_OP(target[j], inverse_db_table[ly]);\n            CHECK(f);\n        }\n    }\n    return TRUE;\n}\n\n// The meaning of \"left\" and \"right\"\n//\n// For a given frame:\n//     we compute samples from 0..n\n//     window_center is n/2\n//     we'll window and mix the samples from left_start to left_end with data from the previous frame\n//     all of the samples from left_end to right_start can be output without mixing; however,\n//        this interval is 0-length except when transitioning between short and long frames\n//     all of the samples from right_start to right_end need to be mixed with the next frame,\n//        which we don't have, so those get saved in a buffer\n//     frame N's right_end-right_start, the number of samples to mix with the next frame,\n//        has to be the same as frame N+1's left_end-left_start (which they are by\n//        construction)\n\nstatic int vorbis_decode_initial(vorb* f, int* p_left_start, int* p_left_end, int* p_right_start, int* p_right_end, int* mode)\n{\n    Mode* m;\n    int i, n, prev, next, window_center;\n    f->channel_buffer_start = f->channel_buffer_end = 0;\n\nretry:\n    if (f->eof) return FALSE;\n    if (!maybe_start_packet(f))\n        return FALSE;\n    // check packet type\n    if (get_bits(f, 1) != 0) {\n        if (IS_PUSH_MODE(f))\n            return error(f, VORBIS_bad_packet_type);\n        while (EOP != get8_packet(f));\n        goto retry;\n    }\n\n    if (f->alloc.alloc_buffer)\n        VORBIS_ASSERT(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n    i = get_bits(f, ilog(f->mode_count - 1));\n    if (i == EOP) return FALSE;\n    if (i >= f->mode_count) return FALSE;\n    *mode = i;\n    m = f->mode_config + i;\n    if (m->blockflag) {\n        n = f->blocksize_1;\n        prev = get_bits(f, 1);\n        next = get_bits(f, 1);\n    }\n    else {\n        prev = next = 0;\n        n = f->blocksize_0;\n    }\n\n    // WINDOWING\n\n    window_center = n >> 1;\n    if (m->blockflag && !prev) {\n        *p_left_start = (n - f->blocksize_0) >> 2;\n        *p_left_end = (n + f->blocksize_0) >> 2;\n    }\n    else {\n        *p_left_start = 0;\n        *p_left_end = window_center;\n    }\n    if (m->blockflag && !next) {\n        *p_right_start = (n * 3 - f->blocksize_0) >> 2;\n        *p_right_end = (n * 3 + f->blocksize_0) >> 2;\n    }\n    else {\n        *p_right_start = window_center;\n        *p_right_end = n;\n    }\n\n    return TRUE;\n}\n\nstatic int vorbis_decode_packet_rest(vorb* f, int* len, Mode* m, int left_start, int left_end, int right_start, int right_end, int* p_left)\n{\n    Mapping* map;\n    int i, j, k, n, n2;\n    int zero_channel[256];\n    int really_zero_channel[256];\n\n    // WINDOWING\n\n    STBV_NOTUSED(left_end);\n    n = f->blocksize[m->blockflag];\n    map = &f->mapping[m->mapping];\n\n    // FLOORS\n    n2 = n >> 1;\n\n    CHECK(f);\n\n    for (i = 0; i < f->channels; ++i) {\n        int s = map->chan[i].mux, floor;\n        zero_channel[i] = FALSE;\n        floor = map->submap_floor[s];\n        if (f->floor_types[floor] == 0) {\n            return error(f, VORBIS_invalid_stream);\n        }\n        else {\n            Floor1* g = &f->floor_config[floor].floor1;\n            if (get_bits(f, 1)) {\n                short* finalY;\n                uint8 step2_flag[256];\n                static int range_list[4] = { 256, 128, 86, 64 };\n                int range = range_list[g->floor1_multiplier - 1];\n                int offset = 2;\n                finalY = f->finalY[i];\n                finalY[0] = get_bits(f, ilog(range) - 1);\n                finalY[1] = get_bits(f, ilog(range) - 1);\n                for (j = 0; j < g->partitions; ++j) {\n                    int pclass = g->partition_class_list[j];\n                    int cdim = g->class_dimensions[pclass];\n                    int cbits = g->class_subclasses[pclass];\n                    int csub = (1 << cbits) - 1;\n                    int cval = 0;\n                    if (cbits) {\n                        Codebook* c = f->codebooks + g->class_masterbooks[pclass];\n                        DECODE(cval, f, c);\n                    }\n                    for (k = 0; k < cdim; ++k) {\n                        int book = g->subclass_books[pclass][cval & csub];\n                        cval = cval >> cbits;\n                        if (book >= 0) {\n                            int temp;\n                            Codebook* c = f->codebooks + book;\n                            DECODE(temp, f, c);\n                            finalY[offset++] = temp;\n                        }\n                        else\n                            finalY[offset++] = 0;\n                    }\n                }\n                if (f->valid_bits == INVALID_BITS) goto error; // behavior according to spec\n                step2_flag[0] = step2_flag[1] = 1;\n                for (j = 2; j < g->values; ++j) {\n                    int low, high, pred, highroom, lowroom, room, val;\n                    low = g->neighbors[j][0];\n                    high = g->neighbors[j][1];\n                    //neighbors(g->Xlist, j, &low, &high);\n                    pred = predict_point(g->Xlist[j], g->Xlist[low], g->Xlist[high], finalY[low], finalY[high]);\n                    val = finalY[j];\n                    highroom = range - pred;\n                    lowroom = pred;\n                    if (highroom < lowroom)\n                        room = highroom * 2;\n                    else\n                        room = lowroom * 2;\n                    if (val) {\n                        step2_flag[low] = step2_flag[high] = 1;\n                        step2_flag[j] = 1;\n                        if (val >= room)\n                            if (highroom > lowroom)\n                                finalY[j] = val - lowroom + pred;\n                            else\n                                finalY[j] = pred - val + highroom - 1;\n                        else\n                            if (val & 1)\n                                finalY[j] = pred - ((val + 1) >> 1);\n                            else\n                                finalY[j] = pred + (val >> 1);\n                    }\n                    else {\n                        step2_flag[j] = 0;\n                        finalY[j] = pred;\n                    }\n                }\n\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n                do_floor(f, map, i, n, f->floor_buffers[i], finalY, step2_flag);\n#else\n                // defer final floor computation until _after_ residue\n                for (j = 0; j < g->values; ++j) {\n                    if (!step2_flag[j])\n                        finalY[j] = -1;\n                }\n#endif\n            }\n            else {\n            error:\n                zero_channel[i] = TRUE;\n            }\n            // So we just defer everything else to later\n\n            // at this point we've decoded the floor into buffer\n        }\n    }\n    CHECK(f);\n    // at this point we've decoded all floors\n\n    if (f->alloc.alloc_buffer)\n        VORBIS_ASSERT(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n    // re-enable coupled channels if necessary\n    MemCopy(really_zero_channel, zero_channel, sizeof(really_zero_channel[0]) * f->channels);\n    for (i = 0; i < map->coupling_steps; ++i)\n        if (!zero_channel[map->chan[i].magnitude] || !zero_channel[map->chan[i].angle]) {\n            zero_channel[map->chan[i].magnitude] = zero_channel[map->chan[i].angle] = FALSE;\n        }\n\n    CHECK(f);\n    // RESIDUE DECODE\n    for (i = 0; i < map->submaps; ++i) {\n        float* residue_buffers[STB_VORBIS_MAX_CHANNELS];\n        int r;\n        uint8 do_not_decode[256];\n        int ch = 0;\n        for (j = 0; j < f->channels; ++j) {\n            if (map->chan[j].mux == i) {\n                if (zero_channel[j]) {\n                    do_not_decode[ch] = TRUE;\n                    residue_buffers[ch] = NULL;\n                }\n                else {\n                    do_not_decode[ch] = FALSE;\n                    residue_buffers[ch] = f->channel_buffers[j];\n                }\n                ++ch;\n            }\n        }\n        r = map->submap_residue[i];\n        decode_residue(f, residue_buffers, ch, n2, r, do_not_decode);\n    }\n\n    if (f->alloc.alloc_buffer)\n        VORBIS_ASSERT(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n    CHECK(f);\n\n    // INVERSE COUPLING\n    for (i = map->coupling_steps - 1; i >= 0; --i) {\n        int n2 = n >> 1;\n        float* m = f->channel_buffers[map->chan[i].magnitude];\n        float* a = f->channel_buffers[map->chan[i].angle];\n        for (j = 0; j < n2; ++j) {\n            float a2, m2;\n            if (m[j] > 0)\n                if (a[j] > 0)\n                    m2 = m[j], a2 = m[j] - a[j];\n                else\n                    a2 = m[j], m2 = m[j] + a[j];\n            else\n                if (a[j] > 0)\n                    m2 = m[j], a2 = m[j] + a[j];\n                else\n                    a2 = m[j], m2 = m[j] - a[j];\n            m[j] = m2;\n            a[j] = a2;\n        }\n    }\n    CHECK(f);\n\n    // finish decoding the floors\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n    for (i = 0; i < f->channels; ++i) {\n        if (really_zero_channel[i]) {\n            MemSet(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n        }\n        else {\n            do_floor(f, map, i, n, f->channel_buffers[i], f->finalY[i], NULL);\n        }\n    }\n#else\n    for (i = 0; i < f->channels; ++i) {\n        if (really_zero_channel[i]) {\n            memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n        }\n        else {\n            for (j = 0; j < n2; ++j)\n                f->channel_buffers[i][j] *= f->floor_buffers[i][j];\n        }\n    }\n#endif\n\n    // INVERSE MDCT\n    CHECK(f);\n    for (i = 0; i < f->channels; ++i)\n        inverse_mdct(f->channel_buffers[i], n, f, m->blockflag);\n    CHECK(f);\n\n    // this shouldn't be necessary, unless we exited on an error\n    // and want to flush to get to the next packet\n    flush_packet(f);\n\n    if (f->first_decode) {\n        // assume we start so first non-discarded sample is sample 0\n        // this isn't to spec, but spec would require us to read ahead\n        // and decode the size of all current frames--could be done,\n        // but presumably it's not a commonly used feature\n        f->current_loc = 0u - n2; // start of first frame is positioned for discard (NB this is an intentional unsigned overflow/wrap-around)\n        // we might have to discard samples \"from\" the next frame too,\n        // if we're lapping a large block then a small at the start?\n        f->discard_samples_deferred = n - right_end;\n        f->current_loc_valid = TRUE;\n        f->first_decode = FALSE;\n    }\n    else if (f->discard_samples_deferred) {\n        if (f->discard_samples_deferred >= right_start - left_start) {\n            f->discard_samples_deferred -= (right_start - left_start);\n            left_start = right_start;\n            *p_left = left_start;\n        }\n        else {\n            left_start += f->discard_samples_deferred;\n            *p_left = left_start;\n            f->discard_samples_deferred = 0;\n        }\n    }\n    else if (f->previous_length == 0 && f->current_loc_valid) {\n        // we're recovering from a seek... that means we're going to discard\n        // the samples from this packet even though we know our position from\n        // the last page header, so we need to update the position based on\n        // the discarded samples here\n        // but wait, the code below is going to add this in itself even\n        // on a discard, so we don't need to do it here...\n    }\n\n    // check if we have ogg information about the sample # for this packet\n    if (f->last_seg_which == f->end_seg_with_known_loc) {\n        // if we have a valid current loc, and this is final:\n        if (f->current_loc_valid && (f->page_flag & PAGEFLAG_last_page)) {\n            uint32 current_end = f->known_loc_for_packet;\n            // then let's infer the size of the (probably) short final frame\n            if (current_end < f->current_loc + (right_end - left_start)) {\n                if (current_end < f->current_loc) {\n                    // negative truncation, that's impossible!\n                    *len = 0;\n                }\n                else {\n                    *len = current_end - f->current_loc;\n                }\n                *len += left_start; // this doesn't seem right, but has no ill effect on my test files\n                if (*len > right_end) *len = right_end; // this should never happen\n                f->current_loc += *len;\n                return TRUE;\n            }\n        }\n        // otherwise, just set our sample loc\n        // guess that the ogg granule pos refers to the _middle_ of the\n        // last frame?\n        // set f->current_loc to the position of left_start\n        f->current_loc = f->known_loc_for_packet - (n2 - left_start);\n        f->current_loc_valid = TRUE;\n    }\n    if (f->current_loc_valid)\n        f->current_loc += (right_start - left_start);\n\n    if (f->alloc.alloc_buffer)\n        VORBIS_ASSERT(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n    *len = right_end;  // ignore samples after the window goes to 0\n    CHECK(f);\n\n    return TRUE;\n}\n\nstatic int vorbis_decode_packet(vorb* f, int* len, int* p_left, int* p_right)\n{\n    int mode, left_end, right_end;\n    if (!vorbis_decode_initial(f, p_left, &left_end, p_right, &right_end, &mode)) return 0;\n    return vorbis_decode_packet_rest(f, len, f->mode_config + mode, *p_left, left_end, *p_right, right_end, p_left);\n}\n\nstatic int vorbis_finish_frame(stb_vorbis* f, int len, int left, int right)\n{\n    int prev, i, j;\n    // we use right&left (the start of the right- and left-window sin()-regions)\n    // to determine how much to return, rather than inferring from the rules\n    // (same result, clearer code); 'left' indicates where our sin() window\n    // starts, therefore where the previous window's right edge starts, and\n    // therefore where to start mixing from the previous buffer. 'right'\n    // indicates where our sin() ending-window starts, therefore that's where\n    // we start saving, and where our returned-data ends.\n\n    // mixin from previous window\n    if (f->previous_length) {\n        int i, j, n = f->previous_length;\n        float* w = get_window(f, n);\n        if (w == NULL) return 0;\n        for (i = 0; i < f->channels; ++i) {\n            for (j = 0; j < n; ++j)\n                f->channel_buffers[i][left + j] =\n                f->channel_buffers[i][left + j] * w[j] +\n                f->previous_window[i][j] * w[n - 1 - j];\n        }\n    }\n\n    prev = f->previous_length;\n\n    // last half of this data becomes previous window\n    f->previous_length = len - right;\n\n    // @OPTIMIZE: could avoid this copy by double-buffering the\n    // output (flipping previous_window with channel_buffers), but\n    // then previous_window would have to be 2x as large, and\n    // channel_buffers couldn't be temp mem (although they're NOT\n    // currently temp mem, they could be (unless we want to level\n    // performance by spreading out the computation))\n    for (i = 0; i < f->channels; ++i)\n        for (j = 0; right + j < len; ++j)\n            f->previous_window[i][j] = f->channel_buffers[i][right + j];\n\n    if (!prev)\n        // there was no previous packet, so this data isn't valid...\n        // this isn't entirely true, only the would-have-overlapped data\n        // isn't valid, but this seems to be what the spec requires\n        return 0;\n\n    // truncate a short frame\n    if (len < right) right = len;\n\n    f->samples_output += right - left;\n\n    return right - left;\n}\n\nstatic int vorbis_pump_first_frame(stb_vorbis* f)\n{\n    int len, right, left, res;\n    res = vorbis_decode_packet(f, &len, &left, &right);\n    if (res)\n        vorbis_finish_frame(f, len, left, right);\n    return res;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\nstatic int is_whole_packet_present(stb_vorbis* f)\n{\n    // make sure that we have the packet available before continuing...\n    // this requires a full ogg parse, but we know we can fetch from f->stream\n\n    // instead of coding this out explicitly, we could save the current read state,\n    // read the next packet with get8() until end-of-packet, check f->eof, then\n    // reset the state? but that would be slower, esp. since we'd have over 256 bytes\n    // of state to restore (primarily the page segment table)\n\n    int s = f->next_seg, first = TRUE;\n    uint8* p = f->stream;\n\n    if (s != -1) { // if we're not starting the packet with a 'continue on next page' flag\n        for (; s < f->segment_count; ++s) {\n            p += f->segments[s];\n            if (f->segments[s] < 255)               // stop at first short segment\n                break;\n        }\n        // either this continues, or it ends it...\n        if (s == f->segment_count)\n            s = -1; // set 'crosses page' flag\n        if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n        first = FALSE;\n    }\n    for (; s == -1;) {\n        uint8* q;\n        int n;\n\n        // check that we have the page header ready\n        if (p + 26 >= f->stream_end)               return error(f, VORBIS_need_more_data);\n        // validate the page\n        if (memcmp(p, ogg_page_header, 4))         return error(f, VORBIS_invalid_stream);\n        if (p[4] != 0)                             return error(f, VORBIS_invalid_stream);\n        if (first) { // the first segment must NOT have 'continued_packet', later ones MUST\n            if (f->previous_length)\n                if ((p[5] & PAGEFLAG_continued_packet))  return error(f, VORBIS_invalid_stream);\n            // if no previous length, we're resynching, so we can come in on a continued-packet,\n            // which we'll just drop\n        }\n        else {\n            if (!(p[5] & PAGEFLAG_continued_packet)) return error(f, VORBIS_invalid_stream);\n        }\n        n = p[26]; // segment counts\n        q = p + 27;  // q points to segment table\n        p = q + n; // advance past header\n        // make sure we've read the segment table\n        if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n        for (s = 0; s < n; ++s) {\n            p += q[s];\n            if (q[s] < 255)\n                break;\n        }\n        if (s == n)\n            s = -1; // set 'crosses page' flag\n        if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n        first = FALSE;\n    }\n    return TRUE;\n}\n#endif // !STB_VORBIS_NO_PUSHDATA_API\n\nstatic int start_decoder(vorb* f)\n{\n    uint8 header[6], x, y;\n    int len, i, j, k, max_submaps = 0;\n    int longest_floorlist = 0;\n\n    // first page, first packet\n    f->first_decode = TRUE;\n\n    if (!start_page(f))                              return FALSE;\n    // validate page flag\n    if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n    if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n    if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n    // check for expected packet length\n    if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n    if (f->segments[0] != 30) {\n        // check for the Ogg skeleton fishead identifying header to refine our error\n        if (f->segments[0] == 64 &&\n            getn(f, header, 6) &&\n            header[0] == 'f' &&\n            header[1] == 'i' &&\n            header[2] == 's' &&\n            header[3] == 'h' &&\n            header[4] == 'e' &&\n            header[5] == 'a' &&\n            get8(f) == 'd' &&\n            get8(f) == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n        else\n            return error(f, VORBIS_invalid_first_page);\n    }\n\n    // read packet\n    // check packet header\n    if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n    if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n    // vorbis_version\n    if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n    f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n    if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n    f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n    get32(f); // bitrate_maximum\n    get32(f); // bitrate_nominal\n    get32(f); // bitrate_minimum\n    x = get8(f);\n    {\n        int log0, log1;\n        log0 = x & 15;\n        log1 = x >> 4;\n        f->blocksize_0 = 1 << log0;\n        f->blocksize_1 = 1 << log1;\n        if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n        if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n        if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n    }\n\n    // framing_flag\n    x = get8(f);\n    if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n    // second packet!\n    if (!start_page(f))                              return FALSE;\n\n    if (!start_packet(f))                            return FALSE;\n\n    if (!next_segment(f))                            return FALSE;\n\n    if (get8_packet(f) != VORBIS_packet_comment)            return error(f, VORBIS_invalid_setup);\n    for (i = 0; i < 6; ++i) header[i] = get8_packet(f);\n    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n    //file vendor\n    len = get32_packet(f);\n    f->vendor = (char*)setup_malloc(f, sizeof(char) * (len + 1));\n    if (f->vendor == NULL)                           return error(f, VORBIS_outofmem);\n    for (i = 0; i < len; ++i) {\n        f->vendor[i] = get8_packet(f);\n    }\n    f->vendor[len] = (char)'\\0';\n    //user comments\n    f->comment_list_length = get32_packet(f);\n    f->comment_list = NULL;\n    if (f->comment_list_length > 0)\n    {\n        f->comment_list = (char**)setup_malloc(f, sizeof(char*) * (f->comment_list_length));\n        if (f->comment_list == NULL)                  return error(f, VORBIS_outofmem);\n    }\n\n    for (i = 0; i < f->comment_list_length; ++i) {\n        len = get32_packet(f);\n        f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len + 1));\n        if (f->comment_list[i] == NULL)               return error(f, VORBIS_outofmem);\n\n        for (j = 0; j < len; ++j) {\n            f->comment_list[i][j] = get8_packet(f);\n        }\n        f->comment_list[i][len] = (char)'\\0';\n    }\n\n    // framing_flag\n    x = get8_packet(f);\n    if (!(x & 1))                                    return error(f, VORBIS_invalid_setup);\n\n\n    skip(f, f->bytes_in_seg);\n    f->bytes_in_seg = 0;\n\n    do {\n        len = next_segment(f);\n        skip(f, len);\n        f->bytes_in_seg = 0;\n    } while (len);\n\n    // third packet!\n    if (!start_packet(f))                            return FALSE;\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n    if (IS_PUSH_MODE(f)) {\n        if (!is_whole_packet_present(f)) {\n            // convert error in ogg header to write type\n            if (f->error == VORBIS_invalid_stream)\n                f->error = VORBIS_invalid_setup;\n            return FALSE;\n        }\n    }\n#endif\n\n    crc32_init(); // always init it, to avoid multithread race conditions\n\n    if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n    for (i = 0; i < 6; ++i) header[i] = get8_packet(f);\n    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n    // codebooks\n\n    f->codebook_count = get_bits(f, 8) + 1;\n    f->codebooks = (Codebook*)setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n    if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n    MemSet(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n    for (i = 0; i < f->codebook_count; ++i) {\n        uint32* values;\n        int ordered, sorted_count;\n        int total = 0;\n        uint8* lengths;\n        Codebook* c = f->codebooks + i;\n        CHECK(f);\n        x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n        x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n        x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n        x = get_bits(f, 8);\n        c->dimensions = (get_bits(f, 8) << 8) + x;\n        x = get_bits(f, 8);\n        y = get_bits(f, 8);\n        c->entries = (get_bits(f, 8) << 16) + (y << 8) + x;\n        ordered = get_bits(f, 1);\n        c->sparse = ordered ? 0 : get_bits(f, 1);\n\n        if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n        if (c->sparse)\n            lengths = (uint8*)setup_temp_malloc(f, c->entries);\n        else\n            lengths = c->codeword_lengths = (uint8*)setup_malloc(f, c->entries);\n\n        if (!lengths) return error(f, VORBIS_outofmem);\n\n        if (ordered) {\n            int current_entry = 0;\n            int current_length = get_bits(f, 5) + 1;\n            while (current_entry < c->entries) {\n                int limit = c->entries - current_entry;\n                int n = get_bits(f, ilog(limit));\n                if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n                if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n                MemSet(lengths + current_entry, current_length, n);\n                current_entry += n;\n                ++current_length;\n            }\n        }\n        else {\n            for (j = 0; j < c->entries; ++j) {\n                int present = c->sparse ? get_bits(f, 1) : 1;\n                if (present) {\n                    lengths[j] = get_bits(f, 5) + 1;\n                    ++total;\n                    if (lengths[j] == 32)\n                        return error(f, VORBIS_invalid_setup);\n                }\n                else {\n                    lengths[j] = NO_CODE;\n                }\n            }\n        }\n\n        if (c->sparse && total >= c->entries >> 2) {\n            // convert sparse items to non-sparse!\n            if (c->entries > (int)f->setup_temp_memory_required)\n                f->setup_temp_memory_required = c->entries;\n\n            c->codeword_lengths = (uint8*)setup_malloc(f, c->entries);\n            if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n            MemCopy(c->codeword_lengths, lengths, c->entries);\n            setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n            lengths = c->codeword_lengths;\n            c->sparse = 0;\n        }\n\n        // compute the size of the sorted tables\n        if (c->sparse) {\n            sorted_count = total;\n        }\n        else {\n            sorted_count = 0;\n#ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n            for (j = 0; j < c->entries; ++j)\n                if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n                    ++sorted_count;\n#endif\n        }\n\n        c->sorted_entries = sorted_count;\n        values = NULL;\n\n        CHECK(f);\n        if (!c->sparse) {\n            c->codewords = (uint32*)setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n        }\n        else {\n            unsigned int size;\n            if (c->sorted_entries) {\n                c->codeword_lengths = (uint8*)setup_malloc(f, c->sorted_entries);\n                if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n                c->codewords = (uint32*)setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n                if (!c->codewords)                  return error(f, VORBIS_outofmem);\n                values = (uint32*)setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n                if (!values)                        return error(f, VORBIS_outofmem);\n            }\n            size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n            if (size > f->setup_temp_memory_required)\n                f->setup_temp_memory_required = size;\n        }\n\n        if (!compute_codewords(c, lengths, c->entries, values)) {\n            if (c->sparse) setup_temp_free(f, values, 0);\n            return error(f, VORBIS_invalid_setup);\n        }\n\n        if (c->sorted_entries) {\n            // allocate an extra slot for sentinels\n            c->sorted_codewords = (uint32*)setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries + 1));\n            if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n            // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n            // so that we can catch that case without an extra if\n            c->sorted_values = (int*)setup_malloc(f, sizeof(*c->sorted_values) * (c->sorted_entries + 1));\n            if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n            ++c->sorted_values;\n            c->sorted_values[-1] = -1;\n            compute_sorted_huffman(c, lengths, values);\n        }\n\n        if (c->sparse) {\n            setup_temp_free(f, values, sizeof(*values) * c->sorted_entries);\n            setup_temp_free(f, c->codewords, sizeof(*c->codewords) * c->sorted_entries);\n            setup_temp_free(f, lengths, c->entries);\n            c->codewords = NULL;\n        }\n\n        compute_accelerated_huffman(c);\n\n        CHECK(f);\n        c->lookup_type = get_bits(f, 4);\n        if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n        if (c->lookup_type > 0) {\n            uint16* mults;\n            c->minimum_value = float32_unpack(get_bits(f, 32));\n            c->delta_value = float32_unpack(get_bits(f, 32));\n            c->value_bits = get_bits(f, 4) + 1;\n            c->sequence_p = get_bits(f, 1);\n            if (c->lookup_type == 1) {\n                int values = lookup1_values(c->entries, c->dimensions);\n                if (values < 0) return error(f, VORBIS_invalid_setup);\n                c->lookup_values = (uint32)values;\n            }\n            else {\n                c->lookup_values = c->entries * c->dimensions;\n            }\n            if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n            mults = (uint16*)setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n            if (mults == NULL) return error(f, VORBIS_outofmem);\n            for (j = 0; j < (int)c->lookup_values; ++j) {\n                int q = get_bits(f, c->value_bits);\n                if (q == EOP) { setup_temp_free(f, mults, sizeof(mults[0]) * c->lookup_values); return error(f, VORBIS_invalid_setup); }\n                mults[j] = q;\n            }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n            if (c->lookup_type == 1) {\n                int len, sparse = c->sparse;\n                float last = 0;\n                // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n                if (sparse) {\n                    if (c->sorted_entries == 0) goto skip;\n                    c->multiplicands = (codetype*)setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n                }\n                else\n                    c->multiplicands = (codetype*)setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries * c->dimensions);\n                if (c->multiplicands == NULL) { setup_temp_free(f, mults, sizeof(mults[0]) * c->lookup_values); return error(f, VORBIS_outofmem); }\n                len = sparse ? c->sorted_entries : c->entries;\n                for (j = 0; j < len; ++j) {\n                    unsigned int z = sparse ? c->sorted_values[j] : j;\n                    unsigned int div = 1;\n                    for (k = 0; k < c->dimensions; ++k) {\n                        int off = (z / div) % c->lookup_values;\n                        float val = mults[off] * c->delta_value + c->minimum_value + last;\n                        c->multiplicands[j * c->dimensions + k] = val;\n                        if (c->sequence_p)\n                            last = val;\n                        if (k + 1 < c->dimensions) {\n                            if (div > VORBIS_UINT_MAX / (unsigned int)c->lookup_values) {\n                                setup_temp_free(f, mults, sizeof(mults[0]) * c->lookup_values);\n                                return error(f, VORBIS_invalid_setup);\n                            }\n                            div *= c->lookup_values;\n                        }\n                    }\n                }\n                c->lookup_type = 2;\n            }\n            else\n#endif\n            {\n                float last = 0;\n                CHECK(f);\n                c->multiplicands = (codetype*)setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n                if (c->multiplicands == NULL) { setup_temp_free(f, mults, sizeof(mults[0]) * c->lookup_values); return error(f, VORBIS_outofmem); }\n                for (j = 0; j < (int)c->lookup_values; ++j) {\n                    float val = mults[j] * c->delta_value + c->minimum_value + last;\n                    c->multiplicands[j] = val;\n                    if (c->sequence_p)\n                        last = val;\n                }\n            }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n            skip : ;\n#endif\n            setup_temp_free(f, mults, sizeof(mults[0]) * c->lookup_values);\n\n            CHECK(f);\n        }\n        CHECK(f);\n    }\n\n    // time domain transfers (notused)\n\n    x = get_bits(f, 6) + 1;\n    for (i = 0; i < x; ++i) {\n        uint32 z = get_bits(f, 16);\n        if (z != 0) return error(f, VORBIS_invalid_setup);\n    }\n\n    // Floors\n    f->floor_count = get_bits(f, 6) + 1;\n    f->floor_config = (Floor*)setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n    if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n    for (i = 0; i < f->floor_count; ++i) {\n        f->floor_types[i] = get_bits(f, 16);\n        if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n        if (f->floor_types[i] == 0) {\n            Floor0* g = &f->floor_config[i].floor0;\n            g->order = get_bits(f, 8);\n            g->rate = get_bits(f, 16);\n            g->bark_map_size = get_bits(f, 16);\n            g->amplitude_bits = get_bits(f, 6);\n            g->amplitude_offset = get_bits(f, 8);\n            g->number_of_books = get_bits(f, 4) + 1;\n            for (j = 0; j < g->number_of_books; ++j)\n                g->book_list[j] = get_bits(f, 8);\n            return error(f, VORBIS_feature_not_supported);\n        }\n        else {\n            stbv__floor_ordering p[31 * 8 + 2];\n            Floor1* g = &f->floor_config[i].floor1;\n            int max_class = -1;\n            g->partitions = get_bits(f, 5);\n            for (j = 0; j < g->partitions; ++j) {\n                g->partition_class_list[j] = get_bits(f, 4);\n                if (g->partition_class_list[j] > max_class)\n                    max_class = g->partition_class_list[j];\n            }\n            for (j = 0; j <= max_class; ++j) {\n                g->class_dimensions[j] = get_bits(f, 3) + 1;\n                g->class_subclasses[j] = get_bits(f, 2);\n                if (g->class_subclasses[j]) {\n                    g->class_masterbooks[j] = get_bits(f, 8);\n                    if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n                }\n                for (k = 0; k < 1 << g->class_subclasses[j]; ++k) {\n                    g->subclass_books[j][k] = (int16)get_bits(f, 8) - 1;\n                    if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n                }\n            }\n            g->floor1_multiplier = get_bits(f, 2) + 1;\n            g->rangebits = get_bits(f, 4);\n            g->Xlist[0] = 0;\n            g->Xlist[1] = 1 << g->rangebits;\n            g->values = 2;\n            for (j = 0; j < g->partitions; ++j) {\n                int c = g->partition_class_list[j];\n                for (k = 0; k < g->class_dimensions[c]; ++k) {\n                    g->Xlist[g->values] = get_bits(f, g->rangebits);\n                    ++g->values;\n                }\n            }\n            // precompute the sorting\n            for (j = 0; j < g->values; ++j) {\n                p[j].x = g->Xlist[j];\n                p[j].id = j;\n            }\n            QSort(p, g->values, sizeof(p[0]), point_compare);\n            for (j = 0; j < g->values - 1; ++j)\n                if (p[j].x == p[j + 1].x)\n                    return error(f, VORBIS_invalid_setup);\n            for (j = 0; j < g->values; ++j)\n                g->sorted_order[j] = (uint8)p[j].id;\n            // precompute the neighbors\n            for (j = 2; j < g->values; ++j) {\n                int low = 0, hi = 0;\n                neighbors(g->Xlist, j, &low, &hi);\n                g->neighbors[j][0] = low;\n                g->neighbors[j][1] = hi;\n            }\n\n            if (g->values > longest_floorlist)\n                longest_floorlist = g->values;\n        }\n    }\n\n    // Residue\n    f->residue_count = get_bits(f, 6) + 1;\n    f->residue_config = (Residue*)setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n    if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n    MemSet(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n    for (i = 0; i < f->residue_count; ++i) {\n        uint8 residue_cascade[64];\n        Residue* r = f->residue_config + i;\n        f->residue_types[i] = get_bits(f, 16);\n        if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n        r->begin = get_bits(f, 24);\n        r->end = get_bits(f, 24);\n        if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n        r->part_size = get_bits(f, 24) + 1;\n        r->classifications = get_bits(f, 6) + 1;\n        r->classbook = get_bits(f, 8);\n        if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n        for (j = 0; j < r->classifications; ++j) {\n            uint8 high_bits = 0;\n            uint8 low_bits = get_bits(f, 3);\n            if (get_bits(f, 1))\n                high_bits = get_bits(f, 5);\n            residue_cascade[j] = high_bits * 8 + low_bits;\n        }\n        r->residue_books = (short(*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n        if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n        for (j = 0; j < r->classifications; ++j) {\n            for (k = 0; k < 8; ++k) {\n                if (residue_cascade[j] & (1 << k)) {\n                    r->residue_books[j][k] = get_bits(f, 8);\n                    if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n                }\n                else {\n                    r->residue_books[j][k] = -1;\n                }\n            }\n        }\n        // precompute the classifications[] array to avoid inner-loop mod/divide\n        // call it 'classdata' since we already have r->classifications\n        r->classdata = (uint8**)setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n        if (!r->classdata) return error(f, VORBIS_outofmem);\n        MemSet(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n        for (j = 0; j < f->codebooks[r->classbook].entries; ++j) {\n            int classwords = f->codebooks[r->classbook].dimensions;\n            int temp = j;\n            r->classdata[j] = (uint8*)setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n            if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n            for (k = classwords - 1; k >= 0; --k) {\n                r->classdata[j][k] = temp % r->classifications;\n                temp /= r->classifications;\n            }\n        }\n    }\n\n    f->mapping_count = get_bits(f, 6) + 1;\n    f->mapping = (Mapping*)setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n    if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n    MemSet(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n    for (i = 0; i < f->mapping_count; ++i) {\n        Mapping* m = f->mapping + i;\n        int mapping_type = get_bits(f, 16);\n        if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n        m->chan = (MappingChannel*)setup_malloc(f, f->channels * sizeof(*m->chan));\n        if (m->chan == NULL) return error(f, VORBIS_outofmem);\n        if (get_bits(f, 1))\n            m->submaps = get_bits(f, 4) + 1;\n        else\n            m->submaps = 1;\n        if (m->submaps > max_submaps)\n            max_submaps = m->submaps;\n        if (get_bits(f, 1)) {\n            m->coupling_steps = get_bits(f, 8) + 1;\n            if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n            for (k = 0; k < m->coupling_steps; ++k) {\n                m->chan[k].magnitude = get_bits(f, ilog(f->channels - 1));\n                m->chan[k].angle = get_bits(f, ilog(f->channels - 1));\n                if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n                if (m->chan[k].angle >= f->channels)        return error(f, VORBIS_invalid_setup);\n                if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n            }\n        }\n        else\n            m->coupling_steps = 0;\n\n        // reserved field\n        if (get_bits(f, 2)) return error(f, VORBIS_invalid_setup);\n        if (m->submaps > 1) {\n            for (j = 0; j < f->channels; ++j) {\n                m->chan[j].mux = get_bits(f, 4);\n                if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n            }\n        }\n        else\n            // @SPECIFICATION: this case is missing from the spec\n            for (j = 0; j < f->channels; ++j)\n                m->chan[j].mux = 0;\n\n        for (j = 0; j < m->submaps; ++j) {\n            get_bits(f, 8); // discard\n            m->submap_floor[j] = get_bits(f, 8);\n            m->submap_residue[j] = get_bits(f, 8);\n            if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n            if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n        }\n    }\n\n    // Modes\n    f->mode_count = get_bits(f, 6) + 1;\n    for (i = 0; i < f->mode_count; ++i) {\n        Mode* m = f->mode_config + i;\n        m->blockflag = get_bits(f, 1);\n        m->windowtype = get_bits(f, 16);\n        m->transformtype = get_bits(f, 16);\n        m->mapping = get_bits(f, 8);\n        if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n        if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n        if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n    }\n\n    flush_packet(f);\n\n    f->previous_length = 0;\n\n    for (i = 0; i < f->channels; ++i) {\n        f->channel_buffers[i] = (float*)setup_malloc(f, sizeof(float) * f->blocksize_1);\n        f->previous_window[i] = (float*)setup_malloc(f, sizeof(float) * f->blocksize_1 / 2);\n        f->finalY[i] = (int16*)setup_malloc(f, sizeof(int16) * longest_floorlist);\n        if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n        MemSet(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n        f->floor_buffers[i] = (float*)setup_malloc(f, sizeof(float) * f->blocksize_1 / 2);\n        if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n#endif\n    }\n\n    if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n    if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n    f->blocksize[0] = f->blocksize_0;\n    f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n    if (integer_divide_table[1][1] == 0)\n        for (i = 0; i < DIVTAB_NUMER; ++i)\n            for (j = 1; j < DIVTAB_DENOM; ++j)\n                integer_divide_table[i][j] = i / j;\n#endif\n\n    // compute how much temporary memory is needed\n\n    // 1.\n    {\n        uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n        uint32 classify_mem;\n        int i, max_part_read = 0;\n        for (i = 0; i < f->residue_count; ++i) {\n            Residue* r = f->residue_config + i;\n            unsigned int actual_size = f->blocksize_1 / 2;\n            unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n            unsigned int limit_r_end = r->end < actual_size ? r->end : actual_size;\n            int n_read = limit_r_end - limit_r_begin;\n            int part_read = n_read / r->part_size;\n            if (part_read > max_part_read)\n                max_part_read = part_read;\n        }\n#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n        classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8*));\n#else\n        classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int*));\n#endif\n\n        // maximum reasonable partition size is f->blocksize_1\n\n        f->temp_memory_required = classify_mem;\n        if (imdct_mem > f->temp_memory_required)\n            f->temp_memory_required = imdct_mem;\n    }\n\n\n    if (f->alloc.alloc_buffer) {\n        VORBIS_ASSERT(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n        // check if there's enough temp memory so we don't error later\n        if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned)f->temp_offset)\n            return error(f, VORBIS_outofmem);\n    }\n\n    // @TODO: stb_vorbis_seek_start expects first_audio_page_offset to point to a page\n    // without PAGEFLAG_continued_packet, so this either points to the first page, or\n    // the page after the end of the headers. It might be cleaner to point to a page\n    // in the middle of the headers, when that's the page where the first audio packet\n    // starts, but we'd have to also correctly skip the end of any continued packet in\n    // stb_vorbis_seek_start.\n    if (f->next_seg == -1) {\n        f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n    }\n    else {\n        f->first_audio_page_offset = 0;\n    }\n\n    return TRUE;\n}\n\nstatic void vorbis_deinit(stb_vorbis* p)\n{\n    int i, j;\n\n    setup_free(p, p->vendor);\n    for (i = 0; i < p->comment_list_length; ++i) {\n        setup_free(p, p->comment_list[i]);\n    }\n    setup_free(p, p->comment_list);\n\n    if (p->residue_config) {\n        for (i = 0; i < p->residue_count; ++i) {\n            Residue* r = p->residue_config + i;\n            if (r->classdata) {\n                for (j = 0; j < p->codebooks[r->classbook].entries; ++j)\n                    setup_free(p, r->classdata[j]);\n                setup_free(p, r->classdata);\n            }\n            setup_free(p, r->residue_books);\n        }\n    }\n\n    if (p->codebooks) {\n        CHECK(p);\n        for (i = 0; i < p->codebook_count; ++i) {\n            Codebook* c = p->codebooks + i;\n            setup_free(p, c->codeword_lengths);\n            setup_free(p, c->multiplicands);\n            setup_free(p, c->codewords);\n            setup_free(p, c->sorted_codewords);\n            // c->sorted_values[-1] is the first entry in the array\n            setup_free(p, c->sorted_values ? c->sorted_values - 1 : NULL);\n        }\n        setup_free(p, p->codebooks);\n    }\n    setup_free(p, p->floor_config);\n    setup_free(p, p->residue_config);\n    if (p->mapping) {\n        for (i = 0; i < p->mapping_count; ++i)\n            setup_free(p, p->mapping[i].chan);\n        setup_free(p, p->mapping);\n    }\n    CHECK(p);\n    for (i = 0; i < p->channels && i < STB_VORBIS_MAX_CHANNELS; ++i) {\n        setup_free(p, p->channel_buffers[i]);\n        setup_free(p, p->previous_window[i]);\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n        setup_free(p, p->floor_buffers[i]);\n#endif\n        setup_free(p, p->finalY[i]);\n    }\n    for (i = 0; i < 2; ++i) {\n        setup_free(p, p->A[i]);\n        setup_free(p, p->B[i]);\n        setup_free(p, p->C[i]);\n        setup_free(p, p->window[i]);\n        setup_free(p, p->bit_reverse[i]);\n    }\n#ifndef STB_VORBIS_NO_STDIO\n    if (p->close_on_free) fclose(p->f);\n#endif\n}\n\nvoid stb_vorbis_close(stb_vorbis* p)\n{\n    if (p == NULL) return;\n    vorbis_deinit(p);\n    setup_free(p, p);\n}\n\nstatic void vorbis_init(stb_vorbis* p, const stb_vorbis_alloc* z)\n{\n    MemSet(p, 0, sizeof(*p)); // NULL out all malloc'd pointers to start\n    if (z) {\n        p->alloc = *z;\n        p->alloc.alloc_buffer_length_in_bytes &= ~7;\n        p->temp_offset = p->alloc.alloc_buffer_length_in_bytes;\n    }\n    p->eof = 0;\n    p->error = VORBIS__no_error;\n    p->stream = NULL;\n    p->codebooks = NULL;\n    p->page_crc_tests = -1;\n#ifndef STB_VORBIS_NO_STDIO\n    p->close_on_free = FALSE;\n    p->f = NULL;\n#endif\n}\n\nint stb_vorbis_get_sample_offset(stb_vorbis* f)\n{\n    if (f->current_loc_valid)\n        return f->current_loc;\n    else\n        return -1;\n}\n\nstb_vorbis_info stb_vorbis_get_info(stb_vorbis* f)\n{\n    stb_vorbis_info d;\n    d.channels = f->channels;\n    d.sample_rate = f->sample_rate;\n    d.setup_memory_required = f->setup_memory_required;\n    d.setup_temp_memory_required = f->setup_temp_memory_required;\n    d.temp_memory_required = f->temp_memory_required;\n    d.max_frame_size = f->blocksize_1 >> 1;\n    return d;\n}\n\nstb_vorbis_comment stb_vorbis_get_comment(stb_vorbis* f)\n{\n    stb_vorbis_comment d;\n    d.vendor = f->vendor;\n    d.comment_list_length = f->comment_list_length;\n    d.comment_list = f->comment_list;\n    return d;\n}\n\nint stb_vorbis_get_error(stb_vorbis* f)\n{\n    int e = f->error;\n    f->error = VORBIS__no_error;\n    return e;\n}\n\nstatic stb_vorbis* vorbis_alloc(stb_vorbis* f)\n{\n    stb_vorbis* p = (stb_vorbis*)setup_malloc(f, sizeof(*p));\n    return p;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\nvoid stb_vorbis_flush_pushdata(stb_vorbis* f)\n{\n    f->previous_length = 0;\n    f->page_crc_tests = 0;\n    f->discard_samples_deferred = 0;\n    f->current_loc_valid = FALSE;\n    f->first_decode = FALSE;\n    f->samples_output = 0;\n    f->channel_buffer_start = 0;\n    f->channel_buffer_end = 0;\n}\n\nstatic int vorbis_search_for_page_pushdata(vorb* f, uint8* data, int data_len)\n{\n    int i, n;\n    for (i = 0; i < f->page_crc_tests; ++i)\n        f->scan[i].bytes_done = 0;\n\n    // if we have room for more scans, search for them first, because\n    // they may cause us to stop early if their header is incomplete\n    if (f->page_crc_tests < STB_VORBIS_PUSHDATA_CRC_COUNT) {\n        if (data_len < 4) return 0;\n        data_len -= 3; // need to look for 4-byte sequence, so don't miss\n        // one that straddles a boundary\n        for (i = 0; i < data_len; ++i) {\n            if (data[i] == 0x4f) {\n                if (0 == memcmp(data + i, ogg_page_header, 4)) {\n                    int j, len;\n                    uint32 crc;\n                    // make sure we have the whole page header\n                    if (i + 26 >= data_len || i + 27 + data[i + 26] >= data_len) {\n                        // only read up to this page start, so hopefully we'll\n                        // have the whole page header start next time\n                        data_len = i;\n                        break;\n                    }\n                    // ok, we have it all; compute the length of the page\n                    len = 27 + data[i + 26];\n                    for (j = 0; j < data[i + 26]; ++j)\n                        len += data[i + 27 + j];\n                    // scan everything up to the embedded crc (which we must 0)\n                    crc = 0;\n                    for (j = 0; j < 22; ++j)\n                        crc = crc32_update(crc, data[i + j]);\n                    // now process 4 0-bytes\n                    for (; j < 26; ++j)\n                        crc = crc32_update(crc, 0);\n                    // len is the total number of bytes we need to scan\n                    n = f->page_crc_tests++;\n                    f->scan[n].bytes_left = len - j;\n                    f->scan[n].crc_so_far = crc;\n                    f->scan[n].goal_crc = data[i + 22] + (data[i + 23] << 8) + (data[i + 24] << 16) + (data[i + 25] << 24);\n                    // if the last frame on a page is continued to the next, then\n                    // we can't recover the sample_loc immediately\n                    if (data[i + 27 + data[i + 26] - 1] == 255)\n                        f->scan[n].sample_loc = ~0;\n                    else\n                        f->scan[n].sample_loc = data[i + 6] + (data[i + 7] << 8) + (data[i + 8] << 16) + (data[i + 9] << 24);\n                    f->scan[n].bytes_done = i + j;\n                    if (f->page_crc_tests == STB_VORBIS_PUSHDATA_CRC_COUNT)\n                        break;\n                    // keep going if we still have room for more\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < f->page_crc_tests;) {\n        uint32 crc;\n        int j;\n        int n = f->scan[i].bytes_done;\n        int m = f->scan[i].bytes_left;\n        if (m > data_len - n) m = data_len - n;\n        // m is the bytes to scan in the current chunk\n        crc = f->scan[i].crc_so_far;\n        for (j = 0; j < m; ++j)\n            crc = crc32_update(crc, data[n + j]);\n        f->scan[i].bytes_left -= m;\n        f->scan[i].crc_so_far = crc;\n        if (f->scan[i].bytes_left == 0) {\n            // does it match?\n            if (f->scan[i].crc_so_far == f->scan[i].goal_crc) {\n                // Houston, we have page\n                data_len = n + m; // consumption amount is wherever that scan ended\n                f->page_crc_tests = -1; // drop out of page scan mode\n                f->previous_length = 0; // decode-but-don't-output one frame\n                f->next_seg = -1;       // start a new page\n                f->current_loc = f->scan[i].sample_loc; // set the current sample location\n                // to the amount we'd have decoded had we decoded this page\n                f->current_loc_valid = f->current_loc != ~0U;\n                return data_len;\n            }\n            // delete entry\n            f->scan[i] = f->scan[--f->page_crc_tests];\n        }\n        else {\n            ++i;\n        }\n    }\n\n    return data_len;\n}\n\n// return value: number of bytes we used\nint stb_vorbis_decode_frame_pushdata(\n    stb_vorbis* f,                   // the file we're decoding\n    const uint8* data, int data_len, // the memory available for decoding\n    int* channels,                   // place to write number of float * buffers\n    float*** output,                 // place to write float ** array of float * buffers\n    int* samples                     // place to write number of output samples\n)\n{\n    int i;\n    int len, right, left;\n\n    if (!IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n    if (f->page_crc_tests >= 0) {\n        *samples = 0;\n        return vorbis_search_for_page_pushdata(f, (uint8*)data, data_len);\n    }\n\n    f->stream = (uint8*)data;\n    f->stream_end = (uint8*)data + data_len;\n    f->error = VORBIS__no_error;\n\n    // check that we have the entire packet in memory\n    if (!is_whole_packet_present(f)) {\n        *samples = 0;\n        return 0;\n    }\n\n    if (!vorbis_decode_packet(f, &len, &left, &right)) {\n        // save the actual error we encountered\n        enum STBVorbisError error = f->error;\n        if (error == VORBIS_bad_packet_type) {\n            // flush and resynch\n            f->error = VORBIS__no_error;\n            while (get8_packet(f) != EOP)\n                if (f->eof) break;\n            *samples = 0;\n            return (int)(f->stream - data);\n        }\n        if (error == VORBIS_continued_packet_flag_invalid) {\n            if (f->previous_length == 0) {\n                // we may be resynching, in which case it's ok to hit one\n                // of these; just discard the packet\n                f->error = VORBIS__no_error;\n                while (get8_packet(f) != EOP)\n                    if (f->eof) break;\n                *samples = 0;\n                return (int)(f->stream - data);\n            }\n        }\n        // if we get an error while parsing, what to do?\n        // well, it DEFINITELY won't work to continue from where we are!\n        stb_vorbis_flush_pushdata(f);\n        // restore the error that actually made us bail\n        f->error = error;\n        *samples = 0;\n        return 1;\n    }\n\n    // success!\n    len = vorbis_finish_frame(f, len, left, right);\n    for (i = 0; i < f->channels; ++i)\n        f->outputs[i] = f->channel_buffers[i] + left;\n\n    if (channels) *channels = f->channels;\n    *samples = len;\n    *output = f->outputs;\n    return (int)(f->stream - data);\n}\n\nstb_vorbis* stb_vorbis_open_pushdata(\n    const unsigned char* data, int data_len, // the memory available for decoding\n    int* data_used,              // only defined if result is not NULL\n    int* error, const stb_vorbis_alloc* alloc)\n{\n    stb_vorbis* f, p;\n    vorbis_init(&p, alloc);\n    p.stream = (uint8*)data;\n    p.stream_end = (uint8*)data + data_len;\n    p.push_mode = TRUE;\n    if (!start_decoder(&p)) {\n        if (p.eof)\n            *error = VORBIS_need_more_data;\n        else\n            *error = p.error;\n        vorbis_deinit(&p);\n        return NULL;\n    }\n    f = vorbis_alloc(&p);\n    if (f) {\n        *f = p;\n        *data_used = (int)(f->stream - data);\n        *error = 0;\n        return f;\n    }\n    else {\n        vorbis_deinit(&p);\n        return NULL;\n    }\n}\n#endif // STB_VORBIS_NO_PUSHDATA_API\n\nunsigned int stb_vorbis_get_file_offset(stb_vorbis* f)\n{\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n    if (f->push_mode) return 0;\n#endif\n    if (USE_MEMORY(f)) return (unsigned int)(f->stream - f->stream_start);\n#ifndef STB_VORBIS_NO_STDIO\n    return (unsigned int)(ftell(f->f) - f->f_start);\n#endif\n}\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n//\n// DATA-PULLING API\n//\n\nstatic uint32 vorbis_find_page(stb_vorbis* f, uint32* end, uint32* last)\n{\n    for (;;) {\n        int n;\n        if (f->eof) return 0;\n        n = get8(f);\n        if (n == 0x4f) { // page header candidate\n            unsigned int retry_loc = stb_vorbis_get_file_offset(f);\n            int i;\n            // check if we're off the end of a file_section stream\n            if (retry_loc - 25 > f->stream_len)\n                return 0;\n            // check the rest of the header\n            for (i = 1; i < 4; ++i)\n                if (get8(f) != ogg_page_header[i])\n                    break;\n            if (f->eof) return 0;\n            if (i == 4) {\n                uint8 header[27];\n                uint32 i, crc, goal, len;\n                for (i = 0; i < 4; ++i)\n                    header[i] = ogg_page_header[i];\n                for (; i < 27; ++i)\n                    header[i] = get8(f);\n                if (f->eof) return 0;\n                if (header[4] != 0) goto invalid;\n                goal = header[22] + (header[23] << 8) + (header[24] << 16) + ((uint32)header[25] << 24);\n                for (i = 22; i < 26; ++i)\n                    header[i] = 0;\n                crc = 0;\n                for (i = 0; i < 27; ++i)\n                    crc = crc32_update(crc, header[i]);\n                len = 0;\n                for (i = 0; i < header[26]; ++i) {\n                    int s = get8(f);\n                    crc = crc32_update(crc, s);\n                    len += s;\n                }\n                if (len && f->eof) return 0;\n                for (i = 0; i < len; ++i)\n                    crc = crc32_update(crc, get8(f));\n                // finished parsing probable page\n                if (crc == goal) {\n                    // we could now check that it's either got the last\n                    // page flag set, OR it's followed by the capture\n                    // pattern, but I guess TECHNICALLY you could have\n                    // a file with garbage between each ogg page and recover\n                    // from it automatically? So even though that paranoia\n                    // might decrease the chance of an invalid decode by\n                    // another 2^32, not worth it since it would hose those\n                    // invalid-but-useful files?\n                    if (end)\n                        *end = stb_vorbis_get_file_offset(f);\n                    if (last) {\n                        if (header[5] & 0x04)\n                            *last = 1;\n                        else\n                            *last = 0;\n                    }\n                    set_file_offset(f, retry_loc - 1);\n                    return 1;\n                }\n            }\n        invalid:\n            // not a valid page, so rewind and look for next one\n            set_file_offset(f, retry_loc);\n        }\n    }\n}\n\n\n#define SAMPLE_unknown  0xffffffff\n\n// seeking is implemented with a binary search, which narrows down the range to\n// 64K, before using a linear search (because finding the synchronization\n// pattern can be expensive, and the chance we'd find the end page again is\n// relatively high for small ranges)\n//\n// two initial interpolation-style probes are used at the start of the search\n// to try to bound either side of the binary search sensibly, while still\n// working in O(log n) time if they fail.\n\nstatic int get_seek_page_info(stb_vorbis* f, ProbedPage* z)\n{\n    uint8 header[27], lacing[255];\n    int i, len;\n\n    // record where the page starts\n    z->page_start = stb_vorbis_get_file_offset(f);\n\n    // parse the header\n    getn(f, header, 27);\n    if (header[0] != 'O' || header[1] != 'g' || header[2] != 'g' || header[3] != 'S')\n        return 0;\n    getn(f, lacing, header[26]);\n\n    // determine the length of the payload\n    len = 0;\n    for (i = 0; i < header[26]; ++i)\n        len += lacing[i];\n\n    // this implies where the page ends\n    z->page_end = z->page_start + 27 + header[26] + len;\n\n    // read the last-decoded sample out of the data\n    z->last_decoded_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);\n\n    // restore file state to where we were\n    set_file_offset(f, z->page_start);\n    return 1;\n}\n\n// rarely used function to seek back to the preceding page while finding the\n// start of a packet\nstatic int go_to_page_before(stb_vorbis* f, unsigned int limit_offset)\n{\n    unsigned int previous_safe, end;\n\n    // now we want to seek back 64K from the limit\n    if (limit_offset >= 65536 && limit_offset - 65536 >= f->first_audio_page_offset)\n        previous_safe = limit_offset - 65536;\n    else\n        previous_safe = f->first_audio_page_offset;\n\n    set_file_offset(f, previous_safe);\n\n    while (vorbis_find_page(f, &end, NULL)) {\n        if (end >= limit_offset && stb_vorbis_get_file_offset(f) < limit_offset)\n            return 1;\n        set_file_offset(f, end);\n    }\n\n    return 0;\n}\n\n// implements the search logic for finding a page and starting decoding. if\n// the function succeeds, current_loc_valid will be true and current_loc will\n// be less than or equal to the provided sample number (the closer the\n// better).\nstatic int seek_to_sample_coarse(stb_vorbis* f, uint32 sample_number)\n{\n    ProbedPage left, right, mid;\n    int i, start_seg_with_known_loc, end_pos, page_start;\n    uint32 delta, stream_length, padding, last_sample_limit;\n    double offset = 0.0, bytes_per_sample = 0.0;\n    int probe = 0;\n\n    // find the last page and validate the target sample\n    stream_length = stb_vorbis_stream_length_in_samples(f);\n    if (stream_length == 0)            return error(f, VORBIS_seek_without_length);\n    if (sample_number > stream_length) return error(f, VORBIS_seek_invalid);\n\n    // this is the maximum difference between the window-center (which is the\n    // actual granule position value), and the right-start (which the spec\n    // indicates should be the granule position (give or take one)).\n    padding = ((f->blocksize_1 - f->blocksize_0) >> 2);\n    if (sample_number < padding)\n        last_sample_limit = 0;\n    else\n        last_sample_limit = sample_number - padding;\n\n    left = f->p_first;\n    while (left.last_decoded_sample == ~0U) {\n        // (untested) the first page does not have a 'last_decoded_sample'\n        set_file_offset(f, left.page_end);\n        if (!get_seek_page_info(f, &left)) goto error;\n    }\n\n    right = f->p_last;\n    VORBIS_ASSERT(right.last_decoded_sample != ~0U);\n\n    // starting from the start is handled differently\n    if (last_sample_limit <= left.last_decoded_sample) {\n        if (stb_vorbis_seek_start(f)) {\n            if (f->current_loc > sample_number)\n                return error(f, VORBIS_seek_failed);\n            return 1;\n        }\n        return 0;\n    }\n\n    while (left.page_end != right.page_start) {\n        VORBIS_ASSERT(left.page_end < right.page_start);\n        // search range in bytes\n        delta = right.page_start - left.page_end;\n        if (delta <= 65536) {\n            // there's only 64K left to search - handle it linearly\n            set_file_offset(f, left.page_end);\n        }\n        else {\n            if (probe < 2) {\n                if (probe == 0) {\n                    // first probe (interpolate)\n                    double data_bytes = right.page_end - left.page_start;\n                    bytes_per_sample = data_bytes / right.last_decoded_sample;\n                    offset = left.page_start + bytes_per_sample * (last_sample_limit - left.last_decoded_sample);\n                }\n                else {\n                    // second probe (try to bound the other side)\n                    double error = ((double)last_sample_limit - mid.last_decoded_sample) * bytes_per_sample;\n                    if (error >= 0 && error < 8000) error = 8000;\n                    if (error <  0 && error > -8000) error = -8000;\n                    offset += error * 2;\n                }\n\n                // ensure the offset is valid\n                if (offset < left.page_end)\n                    offset = left.page_end;\n                if (offset > right.page_start - 65536)\n                    offset = right.page_start - 65536;\n\n                set_file_offset(f, (unsigned int)offset);\n            }\n            else {\n                // binary search for large ranges (offset by 32K to ensure\n                // we don't hit the right page)\n                set_file_offset(f, left.page_end + (delta / 2) - 32768);\n            }\n\n            if (!vorbis_find_page(f, NULL, NULL)) goto error;\n        }\n\n        for (;;) {\n            if (!get_seek_page_info(f, &mid)) goto error;\n            if (mid.last_decoded_sample != ~0U) break;\n            // (untested) no frames end on this page\n            set_file_offset(f, mid.page_end);\n            VORBIS_ASSERT(mid.page_start < right.page_start);\n        }\n\n        // if we've just found the last page again then we're in a tricky file,\n        // and we're close enough (if it wasn't an interpolation probe).\n        if (mid.page_start == right.page_start) {\n            if (probe >= 2 || delta <= 65536)\n                break;\n        }\n        else {\n            if (last_sample_limit < mid.last_decoded_sample)\n                right = mid;\n            else\n                left = mid;\n        }\n\n        ++probe;\n    }\n\n    // seek back to start of the last packet\n    page_start = left.page_start;\n    set_file_offset(f, page_start);\n    if (!start_page(f)) return error(f, VORBIS_seek_failed);\n    end_pos = f->end_seg_with_known_loc;\n    VORBIS_ASSERT(end_pos >= 0);\n\n    for (;;) {\n        for (i = end_pos; i > 0; --i)\n            if (f->segments[i - 1] != 255)\n                break;\n\n        start_seg_with_known_loc = i;\n\n        if (start_seg_with_known_loc > 0 || !(f->page_flag & PAGEFLAG_continued_packet))\n            break;\n\n        // (untested) the final packet begins on an earlier page\n        if (!go_to_page_before(f, page_start))\n            goto error;\n\n        page_start = stb_vorbis_get_file_offset(f);\n        if (!start_page(f)) goto error;\n        end_pos = f->segment_count - 1;\n    }\n\n    // prepare to start decoding\n    f->current_loc_valid = FALSE;\n    f->last_seg = FALSE;\n    f->valid_bits = 0;\n    f->packet_bytes = 0;\n    f->bytes_in_seg = 0;\n    f->previous_length = 0;\n    f->next_seg = start_seg_with_known_loc;\n\n    for (i = 0; i < start_seg_with_known_loc; i++)\n        skip(f, f->segments[i]);\n\n    // start decoding (optimizable - this frame is generally discarded)\n    if (!vorbis_pump_first_frame(f))\n        return 0;\n    if (f->current_loc > sample_number)\n        return error(f, VORBIS_seek_failed);\n    return 1;\n\nerror:\n    // try to restore the file to a valid state\n    stb_vorbis_seek_start(f);\n    return error(f, VORBIS_seek_failed);\n}\n\n// the same as vorbis_decode_initial, but without advancing\nstatic int peek_decode_initial(vorb* f, int* p_left_start, int* p_left_end, int* p_right_start, int* p_right_end, int* mode)\n{\n    int bits_read, bytes_read;\n\n    if (!vorbis_decode_initial(f, p_left_start, p_left_end, p_right_start, p_right_end, mode))\n        return 0;\n\n    // either 1 or 2 bytes were read, figure out which so we can rewind\n    bits_read = 1 + ilog(f->mode_count - 1);\n    if (f->mode_config[*mode].blockflag)\n        bits_read += 2;\n    bytes_read = (bits_read + 7) / 8;\n\n    f->bytes_in_seg += bytes_read;\n    f->packet_bytes -= bytes_read;\n    skip(f, -bytes_read);\n    if (f->next_seg == -1)\n        f->next_seg = f->segment_count - 1;\n    else\n        f->next_seg--;\n    f->valid_bits = 0;\n\n    return 1;\n}\n\nint stb_vorbis_seek_frame(stb_vorbis* f, unsigned int sample_number)\n{\n    uint32 max_frame_samples;\n\n    if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n    // fast page-level search\n    if (!seek_to_sample_coarse(f, sample_number))\n        return 0;\n\n    VORBIS_ASSERT(f->current_loc_valid);\n    VORBIS_ASSERT(f->current_loc <= sample_number);\n\n    // linear search for the relevant packet\n    max_frame_samples = (f->blocksize_1 * 3 - f->blocksize_0) >> 2;\n    while (f->current_loc < sample_number) {\n        int left_start, left_end, right_start, right_end, mode, frame_samples;\n        if (!peek_decode_initial(f, &left_start, &left_end, &right_start, &right_end, &mode))\n            return error(f, VORBIS_seek_failed);\n        // calculate the number of samples returned by the next frame\n        frame_samples = right_start - left_start;\n        if (f->current_loc + frame_samples > sample_number) {\n            return 1; // the next frame will contain the sample\n        }\n        else if (f->current_loc + frame_samples + max_frame_samples > sample_number) {\n            // there's a chance the frame after this could contain the sample\n            vorbis_pump_first_frame(f);\n        }\n        else {\n            // this frame is too early to be relevant\n            f->current_loc += frame_samples;\n            f->previous_length = 0;\n            maybe_start_packet(f);\n            flush_packet(f);\n        }\n    }\n    // the next frame should start with the sample\n    if (f->current_loc != sample_number) return error(f, VORBIS_seek_failed);\n    return 1;\n}\n\nint stb_vorbis_seek(stb_vorbis* f, unsigned int sample_number)\n{\n    if (!stb_vorbis_seek_frame(f, sample_number))\n        return 0;\n\n    if (sample_number != f->current_loc) {\n        int n;\n        uint32 frame_start = f->current_loc;\n        stb_vorbis_get_frame_float(f, &n, NULL);\n        VORBIS_ASSERT(sample_number > frame_start);\n        VORBIS_ASSERT(f->channel_buffer_start + (int)(sample_number - frame_start) <= f->channel_buffer_end);\n        f->channel_buffer_start += (sample_number - frame_start);\n    }\n\n    return 1;\n}\n\nint stb_vorbis_seek_start(stb_vorbis* f)\n{\n    if (IS_PUSH_MODE(f)) { return error(f, VORBIS_invalid_api_mixing); }\n    set_file_offset(f, f->first_audio_page_offset);\n    f->previous_length = 0;\n    f->first_decode = TRUE;\n    f->next_seg = -1;\n    return vorbis_pump_first_frame(f);\n}\n\nunsigned int stb_vorbis_stream_length_in_samples(stb_vorbis* f)\n{\n    unsigned int restore_offset, previous_safe;\n    unsigned int end, last_page_loc;\n\n    if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n    if (!f->total_samples) {\n        unsigned int last;\n        uint32 lo, hi;\n        char header[6];\n\n        // first, store the current decode position so we can restore it\n        restore_offset = stb_vorbis_get_file_offset(f);\n\n        // now we want to seek back 64K from the end (the last page must\n        // be at most a little less than 64K, but let's allow a little slop)\n        if (f->stream_len >= 65536 && f->stream_len - 65536 >= f->first_audio_page_offset)\n            previous_safe = f->stream_len - 65536;\n        else\n            previous_safe = f->first_audio_page_offset;\n\n        set_file_offset(f, previous_safe);\n        // previous_safe is now our candidate 'earliest known place that seeking\n        // to will lead to the final page'\n\n        if (!vorbis_find_page(f, &end, &last)) {\n            // if we can't find a page, we're hosed!\n            f->error = VORBIS_cant_find_last_page;\n            f->total_samples = 0xffffffff;\n            goto done;\n        }\n\n        // check if there are more pages\n        last_page_loc = stb_vorbis_get_file_offset(f);\n\n        // stop when the last_page flag is set, not when we reach eof;\n        // this allows us to stop short of a 'file_section' end without\n        // explicitly checking the length of the section\n        while (!last) {\n            set_file_offset(f, end);\n            if (!vorbis_find_page(f, &end, &last)) {\n                // the last page we found didn't have the 'last page' flag\n                // set. whoops!\n                break;\n            }\n            //previous_safe = last_page_loc+1; // NOTE: not used after this point, but note for debugging\n            last_page_loc = stb_vorbis_get_file_offset(f);\n        }\n\n        set_file_offset(f, last_page_loc);\n\n        // parse the header\n        getn(f, (unsigned char*)header, 6);\n        // extract the absolute granule position\n        lo = get32(f);\n        hi = get32(f);\n        if (lo == 0xffffffff && hi == 0xffffffff) {\n            f->error = VORBIS_cant_find_last_page;\n            f->total_samples = SAMPLE_unknown;\n            goto done;\n        }\n        if (hi)\n            lo = 0xfffffffe; // saturate\n        f->total_samples = lo;\n\n        f->p_last.page_start = last_page_loc;\n        f->p_last.page_end = end;\n        f->p_last.last_decoded_sample = lo;\n\n    done:\n        set_file_offset(f, restore_offset);\n    }\n    return f->total_samples == SAMPLE_unknown ? 0 : f->total_samples;\n}\n\nfloat stb_vorbis_stream_length_in_seconds(stb_vorbis* f)\n{\n    return stb_vorbis_stream_length_in_samples(f) / (float)f->sample_rate;\n}\n\n\n\nint stb_vorbis_get_frame_float(stb_vorbis* f, int* channels, float*** output)\n{\n    int len, right, left, i;\n    if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n    if (!vorbis_decode_packet(f, &len, &left, &right)) {\n        f->channel_buffer_start = f->channel_buffer_end = 0;\n        return 0;\n    }\n\n    len = vorbis_finish_frame(f, len, left, right);\n    for (i = 0; i < f->channels; ++i)\n        f->outputs[i] = f->channel_buffers[i] + left;\n\n    f->channel_buffer_start = left;\n    f->channel_buffer_end = left + len;\n\n    if (channels) *channels = f->channels;\n    if (output)   *output = f->outputs;\n    return len;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\n\nstb_vorbis* stb_vorbis_open_file_section(FILE* file, int close_on_free, int* error, const stb_vorbis_alloc* alloc, unsigned int length)\n{\n    stb_vorbis* f, p;\n    vorbis_init(&p, alloc);\n    p.f = file;\n    p.f_start = (uint32)ftell(file);\n    p.stream_len = length;\n    p.close_on_free = close_on_free;\n    if (start_decoder(&p)) {\n        f = vorbis_alloc(&p);\n        if (f) {\n            *f = p;\n            vorbis_pump_first_frame(f);\n            return f;\n        }\n    }\n    if (error) *error = p.error;\n    vorbis_deinit(&p);\n    return NULL;\n}\n\nstb_vorbis* stb_vorbis_open_file(FILE* file, int close_on_free, int* error, const stb_vorbis_alloc* alloc)\n{\n    unsigned int len, start;\n    start = (unsigned int)ftell(file);\n    fseek(file, 0, SEEK_END);\n    len = (unsigned int)(ftell(file) - start);\n    fseek(file, start, SEEK_SET);\n    return stb_vorbis_open_file_section(file, close_on_free, error, alloc, len);\n}\n\nstb_vorbis* stb_vorbis_open_filename(const char* filename, int* error, const stb_vorbis_alloc* alloc)\n{\n    FILE* f;\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n    if (0 != fopen_s(&f, filename, \"rb\"))\n        f = NULL;\n#else\n    f = fopen(filename, \"rb\");\n#endif\n    if (f)\n        return stb_vorbis_open_file(f, TRUE, error, alloc);\n    if (error) *error = VORBIS_file_open_failure;\n    return NULL;\n}\n#endif // STB_VORBIS_NO_STDIO\n\nstb_vorbis* stb_vorbis_open_memory(const unsigned char* data, int len, int* error, const stb_vorbis_alloc* alloc)\n{\n    stb_vorbis* f, p;\n    if (!data) {\n        if (error) *error = VORBIS_unexpected_eof;\n        return NULL;\n    }\n    vorbis_init(&p, alloc);\n    p.stream = (uint8*)data;\n    p.stream_end = (uint8*)data + len;\n    p.stream_start = (uint8*)p.stream;\n    p.stream_len = len;\n    p.push_mode = FALSE;\n    if (start_decoder(&p)) {\n        f = vorbis_alloc(&p);\n        if (f) {\n            *f = p;\n            vorbis_pump_first_frame(f);\n            if (error) *error = VORBIS__no_error;\n            return f;\n        }\n    }\n    if (error) *error = p.error;\n    vorbis_deinit(&p);\n    return NULL;\n}\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#define PLAYBACK_MONO     1\n#define PLAYBACK_LEFT     2\n#define PLAYBACK_RIGHT    4\n\n#define L  (PLAYBACK_LEFT  | PLAYBACK_MONO)\n#define C  (PLAYBACK_LEFT  | PLAYBACK_RIGHT | PLAYBACK_MONO)\n#define R  (PLAYBACK_RIGHT | PLAYBACK_MONO)\n\nstatic int8 channel_position[7][6] =\n{\n   { 0 },\n   { C },\n   { L, R },\n   { L, C, R },\n   { L, R, L, R },\n   { L, C, R, L, R },\n   { L, C, R, L, R, C },\n};\n\n\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\ntypedef union {\n    float f;\n    int i;\n} float_conv;\ntypedef char stb_vorbis_float_size_test[sizeof(float) == 4 && sizeof(int) == 4];\n#define FASTDEF(x) float_conv x\n// add (1<<23) to convert to int, then divide by 2^SHIFT, then add 0.5/2^SHIFT to round\n#define MAGIC(SHIFT) (1.5f * (1 << (23-SHIFT)) + 0.5f/(1 << SHIFT))\n#define ADDEND(SHIFT) (((150-SHIFT) << 23) + (1 << 22))\n#define FAST_SCALED_FLOAT_TO_INT(temp,x,s) (temp.f = (x) + MAGIC(s), temp.i - ADDEND(s))\n#define check_endianness()\n#else\n#define FAST_SCALED_FLOAT_TO_INT(temp,x,s) ((int) ((x) * (1 << (s))))\n#define check_endianness()\n#define FASTDEF(x)\n#endif\n\nstatic void copy_samples(short* dest, float* src, int len)\n{\n    int i;\n    check_endianness();\n    for (i = 0; i < len; ++i) {\n        FASTDEF(temp);\n        int v = FAST_SCALED_FLOAT_TO_INT(temp, src[i], 15);\n        if ((unsigned int)(v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n        dest[i] = v;\n    }\n}\n\nstatic void compute_samples(int mask, short* output, int num_c, float** data, int d_offset, int len)\n{\n#define STB_BUFFER_SIZE  32\n    float buffer[STB_BUFFER_SIZE];\n    int i, j, o, n = STB_BUFFER_SIZE;\n    check_endianness();\n    for (o = 0; o < len; o += STB_BUFFER_SIZE) {\n        MemSet(buffer, 0, sizeof(buffer));\n        if (o + n > len) n = len - o;\n        for (j = 0; j < num_c; ++j) {\n            if (channel_position[num_c][j] & mask) {\n                for (i = 0; i < n; ++i)\n                    buffer[i] += data[j][d_offset + o + i];\n            }\n        }\n        for (i = 0; i < n; ++i) {\n            FASTDEF(temp);\n            int v = FAST_SCALED_FLOAT_TO_INT(temp, buffer[i], 15);\n            if ((unsigned int)(v + 32768) > 65535)\n                v = v < 0 ? -32768 : 32767;\n            output[o + i] = v;\n        }\n    }\n#undef STB_BUFFER_SIZE\n}\n\nstatic void compute_stereo_samples(short* output, int num_c, float** data, int d_offset, int len)\n{\n#define STB_BUFFER_SIZE  32\n    float buffer[STB_BUFFER_SIZE];\n    int i, j, o, n = STB_BUFFER_SIZE >> 1;\n    // o is the offset in the source data\n    check_endianness();\n    for (o = 0; o < len; o += STB_BUFFER_SIZE >> 1) {\n        // o2 is the offset in the output data\n        int o2 = o << 1;\n        MemSet(buffer, 0, sizeof(buffer));\n        if (o + n > len) n = len - o;\n        for (j = 0; j < num_c; ++j) {\n            int m = channel_position[num_c][j] & (PLAYBACK_LEFT | PLAYBACK_RIGHT);\n            if (m == (PLAYBACK_LEFT | PLAYBACK_RIGHT)) {\n                for (i = 0; i < n; ++i) {\n                    buffer[i * 2 + 0] += data[j][d_offset + o + i];\n                    buffer[i * 2 + 1] += data[j][d_offset + o + i];\n                }\n            }\n            else if (m == PLAYBACK_LEFT) {\n                for (i = 0; i < n; ++i) {\n                    buffer[i * 2 + 0] += data[j][d_offset + o + i];\n                }\n            }\n            else if (m == PLAYBACK_RIGHT) {\n                for (i = 0; i < n; ++i) {\n                    buffer[i * 2 + 1] += data[j][d_offset + o + i];\n                }\n            }\n        }\n        for (i = 0; i < (n << 1); ++i) {\n            FASTDEF(temp);\n            int v = FAST_SCALED_FLOAT_TO_INT(temp, buffer[i], 15);\n            if ((unsigned int)(v + 32768) > 65535)\n                v = v < 0 ? -32768 : 32767;\n            output[o2 + i] = v;\n        }\n    }\n#undef STB_BUFFER_SIZE\n}\n\nstatic void convert_samples_short(int buf_c, short** buffer, int b_offset, int data_c, float** data, int d_offset, int samples)\n{\n    int i;\n    if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n        static int channel_selector[3][2] = { {0}, {PLAYBACK_MONO}, {PLAYBACK_LEFT, PLAYBACK_RIGHT} };\n        for (i = 0; i < buf_c; ++i)\n            compute_samples(channel_selector[buf_c][i], buffer[i] + b_offset, data_c, data, d_offset, samples);\n    }\n    else {\n        int limit = buf_c < data_c ? buf_c : data_c;\n        for (i = 0; i < limit; ++i)\n            copy_samples(buffer[i] + b_offset, data[i] + d_offset, samples);\n        for (; i < buf_c; ++i)\n            MemSet(buffer[i] + b_offset, 0, sizeof(short) * samples);\n    }\n}\n\nint stb_vorbis_get_frame_short(stb_vorbis* f, int num_c, short** buffer, int num_samples)\n{\n    float** output = NULL;\n    int len = stb_vorbis_get_frame_float(f, NULL, &output);\n    if (len > num_samples) len = num_samples;\n    if (len)\n        convert_samples_short(num_c, buffer, 0, f->channels, output, 0, len);\n    return len;\n}\n\nstatic void convert_channels_short_interleaved(int buf_c, short* buffer, int data_c, float** data, int d_offset, int len)\n{\n    int i;\n    check_endianness();\n    if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n        VORBIS_ASSERT(buf_c == 2);\n        for (i = 0; i < buf_c; ++i)\n            compute_stereo_samples(buffer, data_c, data, d_offset, len);\n    }\n    else {\n        int limit = buf_c < data_c ? buf_c : data_c;\n        int j;\n        for (j = 0; j < len; ++j) {\n            for (i = 0; i < limit; ++i) {\n                FASTDEF(temp);\n                float f = data[i][d_offset + j];\n                int v = FAST_SCALED_FLOAT_TO_INT(temp, f, 15);//data[i][d_offset+j],15);\n                if ((unsigned int)(v + 32768) > 65535)\n                    v = v < 0 ? -32768 : 32767;\n                *buffer++ = v;\n            }\n            for (; i < buf_c; ++i)\n                *buffer++ = 0;\n        }\n    }\n}\n\nint stb_vorbis_get_frame_short_interleaved(stb_vorbis* f, int num_c, short* buffer, int num_shorts)\n{\n    float** output;\n    int len;\n    if (num_c == 1) return stb_vorbis_get_frame_short(f, num_c, &buffer, num_shorts);\n    len = stb_vorbis_get_frame_float(f, NULL, &output);\n    if (len) {\n        if (len * num_c > num_shorts) len = num_shorts / num_c;\n        convert_channels_short_interleaved(num_c, buffer, f->channels, output, 0, len);\n    }\n    return len;\n}\n\nint stb_vorbis_get_samples_short_interleaved(stb_vorbis* f, int channels, short* buffer, int num_shorts)\n{\n    float** outputs;\n    int len = num_shorts / channels;\n    int n = 0;\n    while (n < len) {\n        int k = f->channel_buffer_end - f->channel_buffer_start;\n        if (n + k >= len) k = len - n;\n        if (k)\n            convert_channels_short_interleaved(channels, buffer, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n        buffer += k * channels;\n        n += k;\n        f->channel_buffer_start += k;\n        if (n == len) break;\n        if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n    }\n    return n;\n}\n\nint stb_vorbis_get_samples_short(stb_vorbis* f, int channels, short** buffer, int len)\n{\n    float** outputs;\n    int n = 0;\n    while (n < len) {\n        int k = f->channel_buffer_end - f->channel_buffer_start;\n        if (n + k >= len) k = len - n;\n        if (k)\n            convert_samples_short(channels, buffer, n, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n        n += k;\n        f->channel_buffer_start += k;\n        if (n == len) break;\n        if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n    }\n    return n;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\nint stb_vorbis_decode_filename(const char* filename, int* channels, int* sample_rate, short** output)\n{\n    int data_len, offset, total, limit, error;\n    short* data;\n    stb_vorbis* v = stb_vorbis_open_filename(filename, &error, NULL);\n    if (v == NULL) return -1;\n    limit = v->channels * 4096;\n    *channels = v->channels;\n    if (sample_rate)\n        *sample_rate = v->sample_rate;\n    offset = data_len = 0;\n    total = limit;\n    data = (short*)malloc(total * sizeof(*data));\n    if (data == NULL) {\n        stb_vorbis_close(v);\n        return -2;\n    }\n    for (;;) {\n        int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data + offset, total - offset);\n        if (n == 0) break;\n        data_len += n;\n        offset += n * v->channels;\n        if (offset + limit > total) {\n            short* data2;\n            total *= 2;\n            data2 = (short*)realloc(data, total * sizeof(*data));\n            if (data2 == NULL) {\n                free(data);\n                stb_vorbis_close(v);\n                return -2;\n            }\n            data = data2;\n        }\n    }\n    *output = data;\n    stb_vorbis_close(v);\n    return data_len;\n}\n#endif // NO_STDIO\n\nint stb_vorbis_decode_memory(const uint8* mem, int len, int* channels, int* sample_rate, short** output)\n{\n    int data_len, offset, total, limit, error;\n    short* data;\n    stb_vorbis* v = stb_vorbis_open_memory(mem, len, &error, NULL);\n    if (v == NULL) return -1;\n    limit = v->channels * 4096;\n    *channels = v->channels;\n    if (sample_rate)\n        *sample_rate = v->sample_rate;\n    offset = data_len = 0;\n    total = limit;\n    data = (short*)MemAlloc(total * sizeof(*data));\n    if (data == NULL) {\n        stb_vorbis_close(v);\n        return -2;\n    }\n    for (;;) {\n        int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data + offset, total - offset);\n        if (n == 0) break;\n        data_len += n;\n        offset += n * v->channels;\n        if (offset + limit > total) {\n            short* data2;\n            total *= 2;\n            data2 = (short*)MemRealloc(data, total * sizeof(*data));\n            if (data2 == NULL) {\n                MemRelease(data);\n                stb_vorbis_close(v);\n                return -2;\n            }\n            data = data2;\n        }\n    }\n    *output = data;\n    stb_vorbis_close(v);\n    return data_len;\n}\n#endif // STB_VORBIS_NO_INTEGER_CONVERSION\n\nint stb_vorbis_get_samples_float_interleaved(stb_vorbis* f, int channels, float* buffer, int num_floats)\n{\n    float** outputs;\n    int len = num_floats / channels;\n    int n = 0;\n    int z = f->channels;\n    if (z > channels) z = channels;\n    while (n < len) {\n        int i, j;\n        int k = f->channel_buffer_end - f->channel_buffer_start;\n        if (n + k >= len) k = len - n;\n        for (j = 0; j < k; ++j) {\n            for (i = 0; i < z; ++i)\n                *buffer++ = f->channel_buffers[i][f->channel_buffer_start + j];\n            for (; i < channels; ++i)\n                *buffer++ = 0;\n        }\n        n += k;\n        f->channel_buffer_start += k;\n        if (n == len)\n            break;\n        if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n            break;\n    }\n    return n;\n}\n\nint stb_vorbis_get_samples_float(stb_vorbis* f, int channels, float** buffer, int num_samples)\n{\n    float** outputs;\n    int n = 0;\n    int z = f->channels;\n    if (z > channels) z = channels;\n    while (n < num_samples) {\n        int i;\n        int k = f->channel_buffer_end - f->channel_buffer_start;\n        if (n + k >= num_samples) k = num_samples - n;\n        if (k) {\n            for (i = 0; i < z; ++i)\n                MemCopy(buffer[i] + n, f->channel_buffers[i] + f->channel_buffer_start, sizeof(float) * k);\n            for (; i < channels; ++i)\n                MemSet(buffer[i] + n, 0, sizeof(float) * k);\n        }\n        n += k;\n        f->channel_buffer_start += k;\n        if (n == num_samples)\n            break;\n        if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n            break;\n    }\n    return n;\n}\n#endif // STB_VORBIS_NO_PULLDATA_API\n\n/* Version history\n    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13222, -13223\n                           found with Mayhem by ForAllSecure\n    1.16    - 2019-03-04 - fix warnings\n    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n    1.14    - 2018-02-11 - delete bogus dealloca usage\n    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n    1.11    - 2017-07-23 - fix MinGW compilation\n    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n    1.09    - 2016-04-04 - back out 'avoid discarding last frame' fix from previous version\n    1.08    - 2016-04-02 - fixed multiple warnings; fix setup memory leaks;\n                           avoid discarding last frame of audio data\n    1.07    - 2015-01-16 - fixed some warnings, fix mingw, const-correct API\n                           some more crash fixes when out of memory or with corrupt files\n    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n                           some crash fixes when out of memory or with corrupt files\n    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n    1.04    - 2014-08-27 - fix missing const-correct case in API\n    1.03    - 2014-08-07 - Warning fixes\n    1.02    - 2014-07-09 - Declare qsort compare function _cdecl on windows\n    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float\n    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in multichannel\n                           (API change) report sample rate for decode-full-file funcs\n    0.99995 - use union instead of pointer-cast for fast-float-to-int to avoid alias-optimization problem\n    0.99994 - change fast-float-to-int to work in single-precision FPU mode, remove endian-dependence\n    0.99993 - remove VORBIS_ASSERT that fired on legal files with empty tables\n    0.99992 - rewind-to-start\n    0.99991 - bugfix to stb_vorbis_get_samples_short by Bernhard Wodo\n    0.9999 - (should have been 0.99990) fix no-CRT support, compiling as C++\n    0.9998 - add a full-decode function with a memory source\n    0.9997 - fix a bug in the read-from-FILE case in 0.9996 addition\n    0.9996 - query length of vorbis stream in samples/seconds\n    0.9995 - bugfix to another optimization that only happened in certain files\n    0.9994 - bugfix to one of the optimizations that caused significant (but inaudible?) errors\n    0.9993 - performance improvements; runs in 99% to 104% of time of reference implementation\n    0.9992 - performance improvement of IMDCT; now performs close to reference implementation\n    0.9991 - performance improvement of IMDCT\n    0.999 - (should have been 0.9990) performance improvement of IMDCT\n    0.998 - no-CRT support from Casey Muratori\n    0.997 - bugfixes for bugs found by Terje Mathisen\n    0.996 - bugfix: fast-huffman decode initialized incorrectly for sparse codebooks; fixing gives 10% speedup - found by Terje Mathisen\n    0.995 - bugfix: fix to 'effective' overrun detection - found by Terje Mathisen\n    0.994 - bugfix: garbage decode on final VQ symbol of a non-multiple - found by Terje Mathisen\n    0.993 - bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) - found by Terje Mathisen\n    0.992 - fixes for MinGW warning\n    0.991 - turn fast-float-conversion on by default\n    0.990 - fix push-mode seek recovery if you seek into the headers\n    0.98b - fix to bad release of 0.98\n    0.98 - fix push-mode seek recovery; robustify float-to-int and support non-fast mode\n    0.97 - builds under c++ (typecasting, don't use 'class' keyword)\n    0.96 - somehow MY 0.95 was right, but the web one was wrong, so here's my 0.95 rereleased as 0.96, fixes a typo in the clamping code\n    0.95 - clamping code for 16-bit functions\n    0.94 - not publically released\n    0.93 - fixed all-zero-floor case (was decoding garbage)\n    0.92 - fixed a memory leak\n    0.91 - conditional compiles to omit parts of the API and the infrastructure to support them: STB_VORBIS_NO_PULLDATA_API, STB_VORBIS_NO_PUSHDATA_API, STB_VORBIS_NO_STDIO, STB_VORBIS_NO_INTEGER_CONVERSION\n    0.90 - first public release\n*/\n\n#endif // STB_VORBIS_HEADER_ONLY\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","/*\n * fast_obj\n *\n * Version 1.2\n *\n * MIT License\n *\n * Copyright (c) 2018-2021 Richard Knight\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n#ifndef FAST_OBJ_HDR\n#define FAST_OBJ_HDR\n\n#define FAST_OBJ_VERSION_MAJOR  1\n#define FAST_OBJ_VERSION_MINOR  2\n#define FAST_OBJ_VERSION        ((FAST_OBJ_VERSION_MAJOR << 8) | FAST_OBJ_VERSION_MINOR)\n\ntypedef struct\n{\n    /* Texture name from .mtl file */\n    char*                       name;\n\n    /* Resolved path to texture */\n    char*                       path;\n\n} fastObjTexture;\n\n\ntypedef struct\n{\n    /* Material name */\n    char*                       name;\n\n    /* Parameters */\n    float                       Ka[3];  /* Ambient */\n    float                       Kd[3];  /* Diffuse */\n    float                       Ks[3];  /* Specular */\n    float                       Ke[3];  /* Emission */\n    float                       Kt[3];  /* Transmittance */\n    float                       Ns;     /* Shininess */\n    float                       Ni;     /* Index of refraction */\n    float                       Tf[3];  /* Transmission filter */\n    float                       d;      /* Disolve (alpha) */\n    int                         illum;  /* Illumination model */\n\n    /* Texture maps */\n    fastObjTexture              map_Ka;\n    fastObjTexture              map_Kd;\n    fastObjTexture              map_Ks;\n    fastObjTexture              map_Ke;\n    fastObjTexture              map_Kt;\n    fastObjTexture              map_Ns;\n    fastObjTexture              map_Ni;\n    fastObjTexture              map_d;\n    fastObjTexture              map_bump;\n\n} fastObjMaterial;\n\n/* Allows user override to bigger indexable array */\n#ifndef FAST_OBJ_UINT_TYPE\n#define FAST_OBJ_UINT_TYPE unsigned int\n#endif\n\ntypedef FAST_OBJ_UINT_TYPE fastObjUInt;\n\ntypedef struct\n{\n    fastObjUInt                 p;\n    fastObjUInt                 t;\n    fastObjUInt                 n;\n\n} fastObjIndex;\n\n\ntypedef struct\n{\n    /* Group name */\n    char*                       name;\n\n    /* Number of faces */\n    unsigned int                face_count;\n\n    /* First face in fastObjMesh face_* arrays */\n    unsigned int                face_offset;\n\n    /* First index in fastObjMesh indices array */\n    unsigned int                index_offset;\n\n} fastObjGroup;\n\n\ntypedef struct\n{\n    /* Vertex data */\n    unsigned int                position_count;\n    float*                      positions;\n\n    unsigned int                texcoord_count;\n    float*                      texcoords;\n\n    unsigned int                normal_count;\n    float*                      normals;\n\n    /* Face data: one element for each face */\n    unsigned int                face_count;\n    unsigned int*               face_vertices;\n    unsigned int*               face_materials;\n\n    /* Index data: one element for each face vertex */\n    unsigned int                index_count;\n    fastObjIndex*               indices;\n\n    /* Materials */\n    unsigned int                material_count;\n    fastObjMaterial*            materials;\n\n    /* Mesh objects ('o' tag in .obj file) */\n    unsigned int                object_count;\n    fastObjGroup*               objects;\n\n    /* Mesh groups ('g' tag in .obj file) */\n    unsigned int                group_count;\n    fastObjGroup*               groups;\n\n} fastObjMesh;\n\ntypedef struct\n{\n    int x;\n} fastObjCallbacks;\n\nfastObjMesh*                    fast_obj_parse_from_memory(const char* buffer, unsigned int bufferSize);\nvoid                            fast_obj_destroy(fastObjMesh* mesh);\n\n#endif\n\n\n#ifdef FAST_OBJ_IMPLEMENTATION\n\n#ifndef FAST_OBJ_REALLOC\n#define FAST_OBJ_REALLOC        realloc\n#endif\n\n#ifndef FAST_OBJ_FREE\n#define FAST_OBJ_FREE           free\n#endif\n\n#ifdef _WIN32\n#define FAST_OBJ_SEPARATOR      '\\\\'\n#define FAST_OBJ_OTHER_SEP      '/'\n#else\n#define FAST_OBJ_SEPARATOR      '/'\n#define FAST_OBJ_OTHER_SEP      '\\\\'\n#endif\n\n\n/* Size of buffer to read into */\n#define BUFFER_SIZE             65536\n\n/* Max supported power when parsing float */\n#define MAX_POWER               20\n\ntypedef struct\n{\n    /* Final mesh */\n    fastObjMesh*                mesh;\n\n    /* Current object/group */\n    fastObjGroup                object;\n    fastObjGroup                group;\n\n    /* Current material index */\n    unsigned int                material;\n\n    /* Current line in file */\n    unsigned int                line;\n\n    /* Base path for materials/textures */\n    char*                       base;\n\n} fastObjData;\n\n\nstatic const\ndouble POWER_10_POS[MAX_POWER] =\n{\n    1.0e0,  1.0e1,  1.0e2,  1.0e3,  1.0e4,  1.0e5,  1.0e6,  1.0e7,  1.0e8,  1.0e9,\n    1.0e10, 1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15, 1.0e16, 1.0e17, 1.0e18, 1.0e19,\n};\n\nstatic const\ndouble POWER_10_NEG[MAX_POWER] =\n{\n    1.0e0,   1.0e-1,  1.0e-2,  1.0e-3,  1.0e-4,  1.0e-5,  1.0e-6,  1.0e-7,  1.0e-8,  1.0e-9,\n    1.0e-10, 1.0e-11, 1.0e-12, 1.0e-13, 1.0e-14, 1.0e-15, 1.0e-16, 1.0e-17, 1.0e-18, 1.0e-19,\n};\n\n\nstatic void* memory_realloc(void* ptr, unsigned int bytes)\n{\n    return FAST_OBJ_REALLOC(ptr, bytes);\n}\n\n\nstatic\nvoid memory_dealloc(void* ptr)\n{\n    if (ptr != 0) {\n        FAST_OBJ_FREE(ptr);\n    }\n}\n\n\n#define array_clean(_arr)       ((_arr) ? memory_dealloc(_array_header(_arr)), 0 : 0)\n#define array_push(_arr, _val)  (_array_mgrow(_arr, 1) ? ((_arr)[_array_size(_arr)++] = (_val), _array_size(_arr) - 1) : 0)\n#define array_size(_arr)        ((_arr) ? _array_size(_arr) : 0)\n#define array_capacity(_arr)    ((_arr) ? _array_capacity(_arr) : 0)\n#define array_empty(_arr)       (array_size(_arr) == 0)\n\n#define _array_header(_arr)     ((fastObjUInt*)(_arr)-2)\n#define _array_size(_arr)       (_array_header(_arr)[0])\n#define _array_capacity(_arr)   (_array_header(_arr)[1])\n#define _array_ngrow(_arr, _n)  ((_arr) == 0 || (_array_size(_arr) + (_n) >= _array_capacity(_arr)))\n#define _array_mgrow(_arr, _n)  (_array_ngrow(_arr, _n) ? (_array_grow(_arr, _n) != 0) : 1)\n#define _array_grow(_arr, _n)   (*((void**)&(_arr)) = array_realloc(_arr, _n, sizeof(*(_arr))))\n\n\nstatic void* array_realloc(void* ptr, fastObjUInt n, fastObjUInt b)\n{\n    fastObjUInt sz = array_size(ptr);\n    fastObjUInt nsz = sz + n;\n    fastObjUInt cap = array_capacity(ptr);\n    fastObjUInt ncap = 3 * cap / 2;\n    fastObjUInt* r;\n\n\n    if (ncap < nsz)\n        ncap = nsz;\n    ncap = (ncap + 15) & ~15u;\n\n    r = (fastObjUInt*)(memory_realloc(ptr ? _array_header(ptr) : 0, b * ncap + 2 * sizeof(fastObjUInt)));\n    if (!r)\n        return 0;\n\n    r[0] = sz;\n    r[1] = ncap;\n\n    return (r + 2);\n}\n\nstatic\nchar* string_copy(const char* s, const char* e)\n{\n    unsigned int n;\n    char*  p;\n        \n    n = (unsigned int)(e - s);\n    p = (char*)(memory_realloc(0, n + 1));\n    if (p)\n    {\n        memcpy(p, s, n);\n        p[n] = '\\0';\n    }\n\n    return p;\n}\n\n\nstatic\nchar* string_substr(const char* s, unsigned int a, unsigned int b)\n{\n    return string_copy(s + a, s + b);\n}\n\nstatic \nunsigned int string_length(const char* str) {\n    const char* s;\n\tfor (s = str; *s; ++s);\n\treturn(s - str);\n}\n\nstatic\nchar* string_concat(const char* a, const char* s, const char* e)\n{\n    unsigned int an;\n    unsigned int sn;\n    char*  p;\n        \n    an = a ? string_length(a) : 0;\n    sn = (unsigned int)(e - s);\n    p = (char*)(memory_realloc(0, an + sn + 1));\n    if (p)\n    {\n        if (a)\n            memcpy(p, a, an);\n        memcpy(p + an, s, sn);\n        p[an + sn] = '\\0';\n    }\n\n    return p;\n}\n\n\nstatic\nint string_equal(const char* a, const char* s, const char* e)\n{\n    unsigned int an = string_length(a);\n    unsigned int sn = (unsigned int)(e - s);\n\n    return an == sn && memcmp(a, s, an) == 0;\n}\n\n\nstatic\nvoid string_fix_separators(char* s)\n{\n    while (*s)\n    {\n        if (*s == FAST_OBJ_OTHER_SEP)\n            *s = FAST_OBJ_SEPARATOR;\n        s++;\n    }\n}\n\n\nstatic\nint is_whitespace(char c)\n{\n    return (c == ' ' || c == '\\t' || c == '\\r');\n}\n\nstatic\nint is_end_of_name(char c)\n{\n    return (c == '\\t' || c == '\\r' || c == '\\n');\n}\n\nstatic\nint is_newline(char c)\n{\n    return (c == '\\n');\n}\n\n\nstatic\nint is_digit(char c)\n{\n    return (c >= '0' && c <= '9');\n}\n\n\nstatic\nint is_exponent(char c)\n{\n    return (c == 'e' || c == 'E');\n}\n\n\nstatic\nconst char* skip_whitespace(const char* ptr)\n{\n    while (is_whitespace(*ptr))\n        ptr++;\n\n    return ptr;\n}\n\n\nstatic\nconst char* skip_line(const char* ptr)\n{\n    while (!is_newline(*ptr++))\n        ;\n\n    return ptr;\n}\n\n\nstatic\nfastObjGroup object_default(void)\n{\n    fastObjGroup object;\n\n    object.name         = 0;\n    object.face_count   = 0;\n    object.face_offset  = 0;\n    object.index_offset = 0;\n\n    return object;\n}\n\n\nstatic\nvoid object_clean(fastObjGroup* object)\n{\n    memory_dealloc(object->name);\n}\n\n\nstatic\nvoid flush_object(fastObjData* data)\n{\n    /* Add object if not empty */\n    if (data->object.face_count > 0)\n        array_push(data->mesh->objects, data->object);\n    else\n        object_clean(&data->object);\n\n    /* Reset for more data */\n    data->object = object_default();\n    data->object.face_offset  = array_size(data->mesh->face_vertices);\n    data->object.index_offset = array_size(data->mesh->indices);\n}\n\n\n\nstatic\nfastObjGroup group_default(void)\n{\n    fastObjGroup group;\n\n    group.name         = 0;\n    group.face_count   = 0;\n    group.face_offset  = 0;\n    group.index_offset = 0;\n\n    return group;\n}\n\n\nstatic\nvoid group_clean(fastObjGroup* group)\n{\n    memory_dealloc(group->name);\n}\n\n\nstatic\nvoid flush_group(fastObjData* data)\n{\n    /* Add group if not empty */\n    if (data->group.face_count > 0)\n        array_push(data->mesh->groups, data->group);\n    else\n        group_clean(&data->group);\n\n    /* Reset for more data */\n    data->group = group_default();\n    data->group.face_offset  = array_size(data->mesh->face_vertices);\n    data->group.index_offset = array_size(data->mesh->indices);\n}\n\n\nstatic\nconst char* parse_int(const char* ptr, int* val)\n{\n    int sign;\n    int num;\n\n\n    if (*ptr == '-')\n    {\n        sign = -1;\n        ptr++;\n    }\n    else\n    {\n        sign = +1;\n    }\n\n    num = 0;\n    while (is_digit(*ptr))\n        num = 10 * num + (*ptr++ - '0');\n\n    *val = sign * num;\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_float(const char* ptr, float* val)\n{\n    double        sign;\n    double        num;\n    double        fra;\n    double        div;\n    unsigned int  eval;\n    const double* powers;\n\n\n    ptr = skip_whitespace(ptr);\n\n    switch (*ptr)\n    {\n    case '+':\n        sign = 1.0;\n        ptr++;\n        break;\n\n    case '-':\n        sign = -1.0;\n        ptr++;\n        break;\n\n    default:\n        sign = 1.0;\n        break;\n    }\n\n\n    num = 0.0;\n    while (is_digit(*ptr))\n        num = 10.0 * num + (double)(*ptr++ - '0');\n\n    if (*ptr == '.')\n        ptr++;\n\n    fra = 0.0;\n    div = 1.0;\n\n    while (is_digit(*ptr))\n    {\n        fra  = 10.0 * fra + (double)(*ptr++ - '0');\n        div *= 10.0;\n    }\n\n    num += fra / div;\n\n    if (is_exponent(*ptr))\n    {\n        ptr++;\n\n        switch (*ptr)\n        {\n        case '+':\n            powers = POWER_10_POS;\n            ptr++;\n            break;\n\n        case '-':\n            powers = POWER_10_NEG;\n            ptr++;\n            break;\n\n        default:\n            powers = POWER_10_POS;\n            break;\n        }\n\n        eval = 0;\n        while (is_digit(*ptr))\n            eval = 10 * eval + (*ptr++ - '0');\n\n        num *= (eval >= MAX_POWER) ? 0.0 : powers[eval];\n    }\n\n    *val = (float)(sign * num);\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_vertex(fastObjData* data, const char* ptr)\n{\n    unsigned int ii;\n    float        v;\n\n\n    for (ii = 0; ii < 3; ii++)\n    {\n        ptr = parse_float(ptr, &v);\n        array_push(data->mesh->positions, v);\n    }\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_texcoord(fastObjData* data, const char* ptr)\n{\n    unsigned int ii;\n    float        v;\n\n\n    for (ii = 0; ii < 2; ii++)\n    {\n        ptr = parse_float(ptr, &v);\n        array_push(data->mesh->texcoords, v);\n    }\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_normal(fastObjData* data, const char* ptr)\n{\n    unsigned int ii;\n    float        v;\n\n\n    for (ii = 0; ii < 3; ii++)\n    {\n        ptr = parse_float(ptr, &v);\n        array_push(data->mesh->normals, v);\n    }\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_face(fastObjData* data, const char* ptr)\n{\n    unsigned int count;\n    fastObjIndex vn;\n    int          v;\n    int          t;\n    int          n;\n\n\n    ptr = skip_whitespace(ptr);\n\n    count = 0;\n    while (!is_newline(*ptr))\n    {\n        v = 0;\n        t = 0;\n        n = 0;\n\n        ptr = parse_int(ptr, &v);\n        if (*ptr == '/')\n        {\n            ptr++;\n            if (*ptr != '/')\n                ptr = parse_int(ptr, &t);\n\n            if (*ptr == '/')\n            {\n                ptr++;\n                ptr = parse_int(ptr, &n);\n            }\n        }\n\n        if (v < 0)\n            vn.p = (array_size(data->mesh->positions) / 3) - (fastObjUInt)(-v);\n        else\n            vn.p = (fastObjUInt)(v);\n\n        if (t < 0)\n            vn.t = (array_size(data->mesh->texcoords) / 2) - (fastObjUInt)(-t);\n        else if (t > 0)\n            vn.t = (fastObjUInt)(t);\n        else\n            vn.t = 0;\n\n        if (n < 0)\n            vn.n = (array_size(data->mesh->normals) / 3) - (fastObjUInt)(-n);\n        else if (n > 0)\n            vn.n = (fastObjUInt)(n);\n        else\n            vn.n = 0;\n\n        array_push(data->mesh->indices, vn);\n        count++;\n\n        ptr = skip_whitespace(ptr);\n    }\n\n    array_push(data->mesh->face_vertices, count);\n    array_push(data->mesh->face_materials, data->material);\n\n    data->group.face_count++;\n    data->object.face_count++;\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_object(fastObjData* data, const char* ptr)\n{\n    const char* s;\n    const char* e;\n\n\n    ptr = skip_whitespace(ptr);\n\n    s = ptr;\n    while (!is_end_of_name(*ptr))\n        ptr++;\n\n    e = ptr;\n\n    flush_object(data);\n    data->object.name = string_copy(s, e);\n\n    return ptr;\n}\n\n\nstatic\nconst char* parse_group(fastObjData* data, const char* ptr)\n{\n    const char* s;\n    const char* e;\n\n\n    ptr = skip_whitespace(ptr);\n\n    s = ptr;\n    while (!is_end_of_name(*ptr))\n        ptr++;\n\n    e = ptr;\n\n    flush_group(data);\n    data->group.name = string_copy(s, e);\n\n    return ptr;\n}\n\n\nstatic\nfastObjTexture map_default(void)\n{\n    fastObjTexture map;\n\n    map.name = 0;\n    map.path = 0;\n\n    return map;\n}\n\n\nstatic\nfastObjMaterial mtl_default(void)\n{\n    fastObjMaterial mtl;\n\n    mtl.name = 0;\n\n    mtl.Ka[0] = 0.0;\n    mtl.Ka[1] = 0.0;\n    mtl.Ka[2] = 0.0;\n    mtl.Kd[0] = 1.0;\n    mtl.Kd[1] = 1.0;\n    mtl.Kd[2] = 1.0;\n    mtl.Ks[0] = 0.0;\n    mtl.Ks[1] = 0.0;\n    mtl.Ks[2] = 0.0;\n    mtl.Ke[0] = 0.0;\n    mtl.Ke[1] = 0.0;\n    mtl.Ke[2] = 0.0;\n    mtl.Kt[0] = 0.0;\n    mtl.Kt[1] = 0.0;\n    mtl.Kt[2] = 0.0;\n    mtl.Ns    = 1.0;\n    mtl.Ni    = 1.0;\n    mtl.Tf[0] = 1.0;\n    mtl.Tf[1] = 1.0;\n    mtl.Tf[2] = 1.0;\n    mtl.d     = 1.0;\n    mtl.illum = 1;\n\n    mtl.map_Ka   = map_default();\n    mtl.map_Kd   = map_default();\n    mtl.map_Ks   = map_default();\n    mtl.map_Ke   = map_default();\n    mtl.map_Kt   = map_default();\n    mtl.map_Ns   = map_default();\n    mtl.map_Ni   = map_default();\n    mtl.map_d    = map_default();\n    mtl.map_bump = map_default();\n\n    return mtl;\n}\n\n\nstatic\nconst char* parse_usemtl(fastObjData* data, const char* ptr)\n{\n    const char*      s;\n    const char*      e;\n    unsigned int     idx;\n    fastObjMaterial* mtl;\n\n\n    ptr = skip_whitespace(ptr);\n\n    /* Parse the material name */\n    s = ptr;\n    while (!is_end_of_name(*ptr))\n        ptr++;\n\n    e = ptr;\n\n    /* Find an existing material with the same name */\n    idx = 0;\n    while (idx < array_size(data->mesh->materials))\n    {\n        mtl = &data->mesh->materials[idx];\n        if (mtl->name && string_equal(mtl->name, s, e))\n            break;\n\n        idx++;\n    }\n\n    /* If doesn't exists, create a default one with this name\n    Note: this case happens when OBJ doesn't have its MTL */\n    if (idx == array_size(data->mesh->materials))\n    {\n        fastObjMaterial new_mtl = mtl_default();\n        new_mtl.name = string_copy(s, e);\n        array_push(data->mesh->materials, new_mtl);\n    }\n\n    data->material = idx;\n\n    return ptr;\n}\n\n\nstatic\nvoid map_clean(fastObjTexture* map)\n{\n    memory_dealloc(map->name);\n    memory_dealloc(map->path);\n}\n\n\nstatic\nvoid mtl_clean(fastObjMaterial* mtl)\n{\n    map_clean(&mtl->map_Ka);\n    map_clean(&mtl->map_Kd);\n    map_clean(&mtl->map_Ks);\n    map_clean(&mtl->map_Ke);\n    map_clean(&mtl->map_Kt);\n    map_clean(&mtl->map_Ns);\n    map_clean(&mtl->map_Ni);\n    map_clean(&mtl->map_d);\n    map_clean(&mtl->map_bump);\n\n    memory_dealloc(mtl->name);\n}\n\n\nstatic\nconst char* read_mtl_int(const char* p, int* v)\n{\n    return parse_int(p, v);\n}\n\n\nstatic\nconst char* read_mtl_single(const char* p, float* v)\n{\n    return parse_float(p, v);\n}\n\n\nstatic\nconst char* read_mtl_triple(const char* p, float v[3])\n{\n    p = read_mtl_single(p, &v[0]);\n    p = read_mtl_single(p, &v[1]);\n    p = read_mtl_single(p, &v[2]);\n\n    return p;\n}\n\n\nstatic\nconst char* read_map(fastObjData* data, const char* ptr, fastObjTexture* map)\n{\n    const char* s;\n    const char* e;\n    char*       name;\n    char*       path;\n\n    ptr = skip_whitespace(ptr);\n\n    /* Don't support options at present */\n    if (*ptr == '-')\n        return ptr;\n\n\n    /* Read name */\n    s = ptr;\n    while (!is_end_of_name(*ptr))\n        ptr++;\n\n    e = ptr;\n\n    name = string_copy(s, e);\n\n    path = string_concat(data->base, s, e);\n    string_fix_separators(path);\n\n    map->name = name;\n    map->path = path;\n\n    return e;\n}\n\n\nstatic\nint read_mtllib(fastObjData* data, void* file, const fastObjCallbacks* callbacks, void* user_data)\n{\n    unsigned long   n;\n    const char*     s;\n    char*           contents;\n    unsigned int          l;\n    const char*     p;\n    const char*     e;\n    int             found_d;\n    fastObjMaterial mtl;\n\n    return 0;\n}\n\n\nstatic\nconst char* parse_mtllib(fastObjData* data, const char* ptr, const fastObjCallbacks* callbacks, void* user_data)\n{\n    const char* s;\n    const char* e;\n    char*       lib;\n    void*       file;\n\n\n    ptr = skip_whitespace(ptr);\n\n    s = ptr;\n    while (!is_end_of_name(*ptr))\n        ptr++;\n\n    e = ptr;\n\n    lib = string_concat(data->base, s, e);\n    if (lib)\n    {\n        string_fix_separators(lib);\n\n        file = 0;\n        read_mtllib(data, file, callbacks, user_data);\n\n        memory_dealloc(lib);\n    }\n\n    return ptr;\n}\n\n\nstatic\nvoid parse_buffer(fastObjData* data, const char* ptr, const char* end, const fastObjCallbacks* callbacks, void* user_data)\n{\n    const char* p;\n    \n    \n    p = ptr;\n    while (p != end)\n    {\n        p = skip_whitespace(p);\n\n        switch (*p)\n        {\n        case 'v':\n            p++;\n\n            switch (*p++)\n            {\n            case ' ':\n            case '\\t':\n                p = parse_vertex(data, p);\n                break;\n\n            case 't':\n                p = parse_texcoord(data, p);\n                break;\n\n            case 'n':\n                p = parse_normal(data, p);\n                break;\n\n            default:\n                p--; /* roll p++ back in case *p was a newline */\n            }\n            break;\n\n        case 'f':\n            p++;\n\n            switch (*p++)\n            {\n            case ' ':\n            case '\\t':\n                p = parse_face(data, p);\n                break;\n\n            default:\n                p--; /* roll p++ back in case *p was a newline */\n            }\n            break;\n\n        case 'o':\n            p++;\n\n            switch (*p++)\n            {\n            case ' ':\n            case '\\t':\n                p = parse_object(data, p);\n                break;\n\n            default:\n                p--; /* roll p++ back in case *p was a newline */\n            }\n            break;\n\n        case 'g':\n            p++;\n\n            switch (*p++)\n            {\n            case ' ':\n            case '\\t':\n                p = parse_group(data, p);\n                break;\n\n            default:\n                p--; /* roll p++ back in case *p was a newline */\n            }\n            break;\n\n        case 'm':\n            p++;\n            if (p[0] == 't' &&\n                p[1] == 'l' &&\n                p[2] == 'l' &&\n                p[3] == 'i' &&\n                p[4] == 'b' &&\n                is_whitespace(p[5]))\n                p = parse_mtllib(data, p + 5, callbacks, user_data);\n            break;\n\n        case 'u':\n            p++;\n            if (p[0] == 's' &&\n                p[1] == 'e' &&\n                p[2] == 'm' &&\n                p[3] == 't' &&\n                p[4] == 'l' &&\n                is_whitespace(p[5]))\n                p = parse_usemtl(data, p + 5);\n            break;\n\n        case '#':\n            break;\n        }\n\n        p = skip_line(p);\n\n        data->line++;\n    }\n}\n\n\nvoid fast_obj_destroy(fastObjMesh* m)\n{\n    unsigned int ii;\n\n\n    for (ii = 0; ii < array_size(m->objects); ii++)\n        object_clean(&m->objects[ii]);\n\n    for (ii = 0; ii < array_size(m->groups); ii++)\n        group_clean(&m->groups[ii]);\n\n    for (ii = 0; ii < array_size(m->materials); ii++)\n        mtl_clean(&m->materials[ii]);\n\n    array_clean(m->positions);\n    array_clean(m->texcoords);\n    array_clean(m->normals);\n    array_clean(m->face_vertices);\n    array_clean(m->face_materials);\n    array_clean(m->indices);\n    array_clean(m->objects);\n    array_clean(m->groups);\n    array_clean(m->materials);\n\n    memory_dealloc(m);\n}\n\nfastObjMesh* fast_obj_parse_from_memory(const char* buffer, unsigned int bufferSize)\n{\n    fastObjData  data;\n    fastObjMesh* m;\n    char*        start;\n    char*        end;\n    char*        last;\n    fastObjUInt  read;\n    fastObjUInt  bytes;\n\n\n    /* Empty mesh */\n    m = (fastObjMesh*)(memory_realloc(0, sizeof(fastObjMesh)));\n    if (!m)\n        return 0;\n\n    m->positions      = 0;\n    m->texcoords      = 0;\n    m->normals        = 0;\n    m->face_vertices  = 0;\n    m->face_materials = 0;\n    m->indices        = 0;\n    m->materials      = 0;\n    m->objects        = 0;\n    m->groups         = 0;\n\n\n    /* Add dummy position/texcoord/normal */\n    array_push(m->positions, 0.0f);\n    array_push(m->positions, 0.0f);\n    array_push(m->positions, 0.0f);\n\n    array_push(m->texcoords, 0.0f);\n    array_push(m->texcoords, 0.0f);\n\n    array_push(m->normals, 0.0f);\n    array_push(m->normals, 0.0f);\n    array_push(m->normals, 1.0f);\n\n\n    /* Data needed during parsing */\n    data.mesh     = m;\n    data.object   = object_default();\n    data.group    = group_default();\n    data.material = 0;\n    data.line     = 1;\n    data.base     = 0;\n\n\n    /* Parse! */\n    parse_buffer(&data, buffer, buffer + bufferSize, 0, 0);\n\n    /* Flush final object/group */\n    flush_object(&data);\n    object_clean(&data.object);\n\n    flush_group(&data);\n    group_clean(&data.group);\n\n    m->position_count = array_size(m->positions) / 3;\n    m->texcoord_count = array_size(m->texcoords) / 2;\n    m->normal_count   = array_size(m->normals) / 3;\n    m->face_count     = array_size(m->face_vertices);\n    m->index_count    = array_size(m->indices);\n    m->material_count = array_size(m->materials);\n    m->object_count   = array_size(m->objects);\n    m->group_count    = array_size(m->groups);\n\n    return m;\n}\n\n#endif\n","#ifndef _H_VEC3_\n#define _H_VEC3_\n\n#define VEC3_EPSILON 0.000001f\n\nstruct vec3 {\n\tunion {\n\t\tstruct {\n\t\t\tfloat x;\n\t\t\tfloat y;\n\t\t\tfloat z;\n\t\t};\n\t\tfloat v[3];\n\t};\n\tinline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n\tinline vec3(float _x, float _y, float _z) :\n\t\tx(_x), y(_y), z(_z) { }\n\tinline vec3(float* fv) :\n\t\tx(fv[0]), y(fv[1]), z(fv[2]) { }\n};\n\nvec3 operator+(const vec3& l, const vec3& r);\nvec3 operator-(const vec3& l, const vec3& r);\nvec3 operator*(const vec3& v, float f);\nvec3 operator*(const vec3& l, const vec3& r);\nfloat dot(const vec3& l, const vec3& r);\nfloat lenSq(const vec3& v);\nfloat len(const vec3& v);\nvoid normalize(vec3& v);\nvec3 normalized(const vec3& v);\nfloat angle(const vec3& l, const vec3& r);\nvec3 project(const vec3& a, const vec3& b);\nvec3 reject(const vec3& a, const vec3& b);\nvec3 reflect(const vec3& a, const vec3& b);\nvec3 cross(const vec3& l, const vec3& r);\nvec3 lerp(const vec3& s, const vec3& e, float t);\nvec3 slerp(const vec3& s, const vec3& e, float t);\nvec3 nlerp(const vec3& s, const vec3& e, float t);\nbool operator==(const vec3& l, const vec3& r);\nbool operator!=(const vec3& l, const vec3& r);\n\n#endif\n","#ifndef _H_WINDOW_\n#define _H_WINDOW_\n\n#ifndef WINDOW_HEAP_SIZE\n#define WINDOW_HEAP_SIZE 142595760\n#endif\n\n#ifndef WINDOW_MAX_TOUCHES\n#define WINDOW_MAX_TOUCHES 5\n#endif\n\ntypedef unsigned int u32;\ntypedef int i32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(i32) == 4, \"i32 should be a 4 byte type\");\n\n#define KeyboardCodeLeftMouse         1  //  \n#define KeyboardCodeRightMouse        2  //  \n#define KeyboardCodeBackspace         3  //  Backspace\n#define KeyboardCodeMiddleMouse       4  //  \n#define KeyboardCodeReturn            5  //  Enter\n#define KeyboardCodeShift             6  //  Shift \n#define KeyboardCodeControl           7  //  Control key\n#define KeyboardCodeAlt              8  //  Alt key\n#define KeyboardCodeCapslock          9  //  Capslock\n#define KeyboardCodeEscape           10  //  Escape\n#define KeyboardCodeSpace            11  //  Spacebar\n#define KeyboardCodeLeft             12  //  Left arrow\n#define KeyboardCodeUp               13  //  Up arrow\n#define KeyboardCodeRight            14  //  Right arrow\n#define KeyboardCodeDown             15  //  Down arrow\n#define KeyboardCodeDelete           16  //  Delete key\n#define KeyboardCode0                17  //  Key 0\n#define KeyboardCode1                18  //  Key 1\n#define KeyboardCode2                19  //  Key 2\n#define KeyboardCode3                20  //  Key 3\n#define KeyboardCode4                21  //  Key 4\n#define KeyboardCode5                22  //  Key 5\n#define KeyboardCode6                23  //  Key 6\n#define KeyboardCode7                24  //  Key 7\n#define KeyboardCode8                25  //  Key 8\n#define KeyboardCode9                26  //  Key 9\n#define KeyboardCodeA                27  //  Key A\n#define KeyboardCodeB                28  //  Key B\n#define KeyboardCodeC                29  //  Key C\n#define KeyboardCodeD                30  //  Key D\n#define KeyboardCodeE                31  //  Key E\n#define KeyboardCodeF                32  //  Key F\n#define KeyboardCodeG                33  //  Key G\n#define KeyboardCodeH                34  //  Key H\n#define KeyboardCodeI                35  //  Key I\n#define KeyboardCodeJ                36  //  Key J\n#define KeyboardCodeK                37  //  Key K\n#define KeyboardCodeL                38  //  Key L\n#define KeyboardCodeM                39  //  Key M\n#define KeyboardCodeN                40  //  Key N\n#define KeyboardCodeO                41  //  Key O\n#define KeyboardCodeP                42  //  Key P\n#define KeyboardCodeQ                43  //  Key Q\n#define KeyboardCodeR                44  //  Key R\n#define KeyboardCodeS                45  //  Key S\n#define KeyboardCodeT                46  //  Key T\n#define KeyboardCodeU                47  //  Key U\n#define KeyboardCodeV                48  //  Key V\n#define KeyboardCodeW                49  //  Key W\n#define KeyboardCodeX                50  //  Key X\n#define KeyboardCodeY                51  //  Key Y\n#define KeyboardCodeZ                52  //  Key Z\n#define KeyboardCodeSemicolon        53  //  ;:\n#define KeyboardCodeColon            53  //  ;:\n#define KeyboardCodePlus             54  //  +=\n#define KeyboardCodeEquals           54  //  +=\n#define KeyboardCodeComma            55  //  ,<\n#define KeyboardCodeLess             55  //  ,<\n#define KeyboardCodeMinus            56  //  -_\n#define KeyboardCodeUnderscore       56  //  -_\n#define KeyboardCodePeriod           57  //  .>\n#define KeyboardCodeGreater          57  //  .>\n#define KeyboardCodeSlash            58  //  /?\n#define KeyboardCodeQuestionmark     58  //  /?\n#define KeyboardCodeTilde            59  //  ~`\n#define KeyboardCodeTick             59  //  ~`\n#define KeyboardCodeLBracket         60  //  [{\n#define KeyboardCodeLBrace           60  //  [{\n#define KeyboardCodeBackslash        61  //  \\|\n#define KeyboardCodeCarray           61  //  \\|\n#define KeyboardCodeRbracket         62  //  ]}\n#define KeyboardCodeRBrace           62  //  ]}\n#define KeyboardCodeQoute            63  //  \"'\n#define KeyboardCodeTab              64  //  Tab\n\nextern \"C\" u32 AsciiToScancode(char val);\nextern \"C\" char ScanCodeToAscii(u32 scanCode, bool shift);\n\nextern \"C\" bool KeyboardDown(u32 scanCode);\nextern \"C\" bool KeyboardPrevDown(u32 scanCode);\n\ninline bool KeyboardUp(u32 scanCode) {\n    return !KeyboardDown(scanCode);\n}\n\ninline bool KeyboardPrevUp(u32 scanCode) {\n    return !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardPressed(u32 scanCode) {\n    return KeyboardDown(scanCode) && !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardReleased(u32 scanCode) {\n    return !KeyboardDown(scanCode) && KeyboardPrevDown(scanCode);\n}\n\n// Mouse API\n#define MouseButtonLeft         KeyboardCodeLeftMouse\n#define MouseButtonMiddle       KeyboardCodeMiddleMouse\n#define MouseButtonRight        KeyboardCodeRightMouse\n\nextern \"C\" u32 MouseGetX();\nextern \"C\" u32 MouseGetY();\nextern \"C\" i32 MouseGetScroll();\nextern \"C\" bool MouseDown(u32 button);\n\nextern \"C\" u32 MousePrevX();\nextern \"C\" u32 MousePrevY();\nextern \"C\" i32 MousePrevScroll();\nextern \"C\" bool MousePrevDown(u32 button);\n\ninline bool MouseUp(u32 button) {\n    return !MouseDown(button);\n}\n\ninline bool MousePrevUp(u32 button) {\n    return !MousePrevDown(button);\n}\n\ninline bool MousePressed(u32 button) {\n    return MouseDown(button) && !MousePrevDown(button);\n}\n\ninline bool MouseReleased(u32 button) {\n    return !MouseDown(button) && MousePrevDown(button);\n}\n\n// Touch API\nextern \"C\" u32 TouchGetMaxContacts();\nextern \"C\" u32 TouchGetNumContacts();\n\nextern \"C\" u32 TouchGetX(u32 touchIndex);\nextern \"C\" u32 TouchGetY(u32 touchIndex);\nextern \"C\" bool TouchIsActive(u32 touchIndex);\n\nextern \"C\" u32 TouchGetPrevX(u32 touchIndex);\nextern \"C\" u32 TouchGetPrevY(u32 touchIndex);\nextern \"C\" bool TouchWasActive(u32 touchIndex);\n\ninline bool TouchPressed(u32 touchIndex) {\n    return TouchIsActive(touchIndex) && !TouchWasActive(touchIndex);\n}\n\ninline bool TouchReleased(u32 touchIndex) {\n    return !TouchIsActive(touchIndex) && TouchWasActive(touchIndex);\n}\n\n// Window API\n// The following functions need to be declared. Initialize returns the userdata pointer that is passed to the other functions.\n/*#define WasmExport __attribute__ (( visibility( \"default\" ) )) extern \"C\"\nWasmExport void* Initialize();\nWasmExport void Update(float dt, void* userData);\nWasmExport void Render(unsigned int x, unsigned int y, unsigned int w, unsigned int h, float dpi, void* userData);\nWasmExport void Shutdown(void* userData);*/\n\nextern \"C\" void WindowUpdateTitle(const char* newTitle);\n\n#endif","#ifndef _H_MATH_\n#define _H_MATH_\n\n#ifdef __cplusplus\n#define c_func extern \"C\"\n#else\n#define c_func \n#endif\n\nc_func float  MathRound(float x);\nc_func float  MathCeil(float x);\nc_func float  MathFloor(float x);\nc_func float  MathSin(float x);\nc_func float  MathCos(float x);\nc_func float  MathACos(float x);\nc_func float  MathTan(float x);\nc_func float  MathSqrt(float x);\nc_func float  MathExp(float x);\nc_func float  MathLog(float x);\nc_func float  MathPow(float x, float y);\nc_func double MathLdexp(double x, int exp);\nc_func float  MathRandom();\n\ninline float RadToDeg(float rad) {\n    return rad * 57.2958f;\n}\n\ninline float DegToRad(float deg) {\n    return deg * 0.0174533f;\n}\n\ninline float MathTrunc(float d) { \n    if (d > 0) { // Floor\n        return MathFloor(d);\n    }\n    // else { // Ceil\n    return MathCeil(d);\n}\n\ninline float MathFmod(float x, float y) {\n  return x - MathTrunc(x / y) * y;\n}\n\ninline float MathAbsF(float f) {\n    if (f < 0.0f) {\n        return -f;\n    }\n    return f;\n}\n\ninline float MathAbsI(int f) {\n    if (f < 0) {\n        return -f;\n    }\n    return f;\n}\n\ninline float MathMaxF(float a, float b) {\n    if (b > a) {\n        return b;\n    }\n    return a;\n}\n\n\n#endif"],"mappings":"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"}