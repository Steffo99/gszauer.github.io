<!DOCTYPE html>
<html lang="en">

  <head>
    <title>NLERP Test</title>

<script type="text/javascript">
function V3_Normalize(quat) {
	const lengthSq = quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2];
	
	const length = Math.sqrt(lengthSq);
	const invLength = 1.0 / length;

	return [
		quat[0] * invLength,
		quat[1] * invLength,
		quat[2] * invLength,
	]
}

function Q_AngleAxis(degreesNum, axisVec3) {
	const radians = degreesNum * 0.0174533; // TODO: Probably get a more accurate number?
	const axis = V3_Normalize(axisVec3);

	const halfCos = Math.cos(radians * 0.5);
	const halfSin = Math.sin(radians * 0.5);

	return [
		axis[0] * halfSin,
		axis[1] * halfSin,
		axis[2] * halfSin,
		halfCos
	];
}

function Q_Add(leftQuat, rightQuat) {
	return [
		leftQuat[0] + rightQuat[0],
		leftQuat[1] + rightQuat[1],
		leftQuat[2] + rightQuat[2],
		leftQuat[3] + rightQuat[3]
	]
}

function Q_Sub(leftQuat, rightQuat) {
	return [
		leftQuat[0] - rightQuat[0],
		leftQuat[1] - rightQuat[1],
		leftQuat[2] - rightQuat[2],
		leftQuat[3] - rightQuat[3]
	]
}

function Q_Scale(quat, numFloat) {
	return [
		quat[0] * numFloat,
		quat[1] * numFloat,
		quat[2] * numFloat,
		quat[3] * numFloat
	]
}

function Q_Normalize(quat) {
	const lengthSq = quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2] + quat[3] * quat[3];
	
	const length = Math.sqrt(lengthSq);
	const invLength = 1.0 / length;

	return [
		quat[0] * invLength,
		quat[1] * invLength,
		quat[2] * invLength,
		quat[3] * invLength
	]
}

function Q_Dot(a, b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]; 
}

function Q_Inv(q) {
	return [
		-q[0],
		-q[1],
		-q[2],
		q[3]
	]
}

function f(a) {
	return Number(a).toFixed(5)
}

function Q_Equals(leftQuat, rightQuat) {
	const epsilonFloatOptional = 0.0001;


	const l1 = Math.abs(leftQuat[0] - rightQuat[0]) <= epsilonFloatOptional
	const l2 = Math.abs(leftQuat[1] - rightQuat[1]) <= epsilonFloatOptional
	const l3 = Math.abs(leftQuat[2] - rightQuat[2]) <= epsilonFloatOptional
	const l4 = Math.abs(leftQuat[3] - rightQuat[3]) <= epsilonFloatOptional

	const r1 = Math.abs(leftQuat[0] + rightQuat[0]) <= epsilonFloatOptional
	const r2 = Math.abs(leftQuat[1] + rightQuat[1]) <= epsilonFloatOptional
	const r3 = Math.abs(leftQuat[2] + rightQuat[2]) <= epsilonFloatOptional
	const r4 = Math.abs(leftQuat[3] + rightQuat[3]) <= epsilonFloatOptional

	const left = l1 && l2 && l3 && l4
	const right = r1 && r2 && r3 && r4

	const result = left || right

	return result
}

function V3_Equals(leftQuat, rightQuat) {
	const epsilonFloatOptional = 0.0001;

	const l1 = Math.abs(leftQuat[0] - rightQuat[0]) <= epsilonFloatOptional
	const l2 = Math.abs(leftQuat[1] - rightQuat[1]) <= epsilonFloatOptional
	const l3 = Math.abs(leftQuat[2] - rightQuat[2]) <= epsilonFloatOptional

	const r1 = Math.abs(leftQuat[0] + rightQuat[0]) <= epsilonFloatOptional
	const r2 = Math.abs(leftQuat[1] + rightQuat[1]) <= epsilonFloatOptional
	const r3 = Math.abs(leftQuat[2] + rightQuat[2]) <= epsilonFloatOptional

	const left = l1 && l2 && l3 
	const right = r1 && r2 && r3 

	const result = left || right

	return result
}

function V3_Add(v1, v2) {
	return [
		v1[0] + v2[0],
		v1[1] + v2[1],
		v1[2] + v2[2]
	]
}

function V3_Dot(v1, v2) {
	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

function V3_Scale(v, s) {
	return [
		v[0] * s,
		v[1] * s,
		v[2] * s
	]
}

function V3_Cross(v1, v2) {
	const result = [
		v1[1] * v2[2] - v1[2] * v2[1],
		v1[2] * v2[0] - v1[0] * v2[2],
		v1[0] * v2[1] - v1[1] * v2[0]
	];
	return result;
}

function Q_Mul_V3(quaternion, vector3) {
	const qVector = [quaternion[0], quaternion[1], quaternion[2]];
	const qScalar = quaternion[3];

	return V3_Add(
		V3_Add(
			V3_Scale(qVector, 2.0 * V3_Dot(qVector, vector3)),
			V3_Scale(vector3, qScalar * qScalar - V3_Dot(qVector, qVector))
		),
		V3_Scale(V3_Cross(qVector, vector3), 2.0 * qScalar)
	);
}

function Nlerp_Test(a, b, t) {
	console.log("(" + f(a[3]) + ", (" + f(a[0]) + ", " + f(a[1]) + ", " + f(a[2]) + ")) -> " +
	            "(" + f(b[3]) + ", (" + f(b[0]) + ", " + f(b[1]) + ", " + f(b[2]) + ")): " + f(t));
	const dot = Q_Dot(a, b);

	if (dot < 0.0) {
		console.log("!!!!!!!!!!!!!!!!!!!!!!! Dot < 0, TODO: Test")
		b = Q_Inv(b); // TODO: Test when this triggers!
	}

	const r1 = Q_Add(a, Q_Scale(Q_Sub(b, a), t)); // (or a + (b-a)*t)
	//console.log("a + (b - a) * t: (" + result[3] + ", (" + result[0] + ", " + result[1] + ", " + result[2] + "))");
	
	const r2 = Q_Normalize(r1)
	console.log("|a + (b - a) * t|:     (" + f(r2[3]) + ", (" + f(r2[0]) + ", " + f(r2[1]) + ", " + f(r2[2]) + "))");

	const r3 = Q_Add(Q_Scale(a, t), Q_Scale(b, 1.0 - t));
	//console.log("a * t + b * (1 - t): (" + result[3] + ", (" + result[0] + ", " + result[1] + ", " + result[2] + "))");
	
	const r4 = Q_Normalize(r3);	
	console.log("|a * t + b * (1 - t)|: (" + f(r4[3]) + ", (" + f(r4[0]) + ", " + f(r4[1]) + ", " + f(r4[2]) + "))");

	if (Q_Equals(r2, r4)) {
		console.log("true, Normalized results are the same");
	}
	else {
		console.log("false Normalized results are NOT the same");
	}
	console.log("---------------------------------------------------------------------------");
	console.log();
}

const x = Q_AngleAxis(90, [1, 0, 0])
const y = Q_AngleAxis(90, [0, 1, 0])
const z = Q_AngleAxis(90, [0, 1, 0])

Nlerp_Test(x, y, 0);
Nlerp_Test(x, y, 0.25);
Nlerp_Test(x, y, 0.5);
Nlerp_Test(x, y, 0.75);
Nlerp_Test(x, y, 1);
</script>

  </head>

<body onload="main();">
	<div>
		<canvas id="glCanvas" width="640" height="480"></canvas>
	</div>
	<div>
		<input type="range" min="0" max="200" value="100" style="width: 640px;" id="myRange" oninput="UpdateSimulation(this.value)" onchange="UpdateSimulation(this.value)">
	</div>
	<div>
		<input type="range" min="0" max="200" value="100" style="width: 640px;" id="myRange2" oninput="UpdateCamera(this.value)" onchange="UpdateCamera(this.value)">
	</div>
</body>

<script type="text/javascript">

function Slerp(q1, q2, t) {
	var dotproduct = Q_Dot(q1, q2);
	var lambda = t;// / 2.0;

	var theta = Math.acos(dotproduct);
	if (theta < 0.0) theta = -theta;
	
	var st = Math.sin(theta);
	var sut = Math.sin(lambda*theta);
	var sout = Math.sin((1.0-lambda)*theta);
	var coeff1 = sout/st;
	var coeff2 = sut/st;

	var result = Q_Normalize([
		coeff1*q1[0] + coeff2*q2[0],
		coeff1*q1[1] + coeff2*q2[1],
		coeff1*q1[2] + coeff2*q2[2],
		coeff1*q1[3] + coeff2*q2[3]
	]);

	return result;
}

function Nlerp1(a, b, t) {
	const dot = Q_Dot(a, b);

	if (dot < 0.0) {
		console.log("!!!!!!!!!!!!!!!!!!!!!!! Dot < 0, TODO: Test")
		b = Q_Inv(b); // TODO: Test when this triggers!
	}

	const r1 = Q_Add(a, Q_Scale(Q_Sub(b, a), t));
	const r2 = Q_Normalize(r1); // NLERP 1

	return r2;
}

function Nlerp2(a, b, t) {
	const dot = Q_Dot(a, b);

	if (dot < 0.0) {
		console.log("!!!!!!!!!!!!!!!!!!!!!!! Dot < 0, TODO: Test")
		b = Q_Inv(b); // TODO: Test when this triggers!
	}

	const r3 = Q_Add(Q_Scale(a, 1.0 - t), Q_Scale(b, t));
	const r4 = Q_Normalize(r3); // NLERP 2

	return r4;
}

function UpdateCamera(interpVal) {
	var t = interpVal / 200.0
	t = t * 360
	t = t * 0.0174533;

	var v = global_state.camPos;
	var k = [0,1,0]

	var cos = Math.cos(t)
	var sin = Math.sin(t)

	var vprime = V3_Add(
	V3_Add(V3_Scale(v, cos),
		   V3_Scale(V3_Cross(k, v), sin)),
	       V3_Scale(k, V3_Dot(k, v) * (1.0 - cos))
    );

	global_state.view = LookAt(vprime, global_state.camTarget, [0, 1, 0]);
	DrawScene();
}

function UpdateSimulation(interpVal) {
	var a = global_state.q1;
	var b = global_state.q2;
	var t = interpVal / 200.0

	if (t < 0) t = 0;
	if (t > 1) t = 1;

	const result_n1 = Nlerp1(a, b, t);
	const result_n2 = Nlerp2(a, b, t)
	const result_s = Slerp(a, b, t);

	const forward = [0, 0, 1];

	UpdateQuaternionVisual(global_state.visual_nlerp1, result_n1, forward)
	UpdateQuaternionVisual(global_state.visual_nlerp2, result_n2, forward)
	UpdateQuaternionVisual(global_state.visual_slerp, result_s, forward)

	DrawScene();
}

var global_state = {
	camPos: [-3, 4, 3],
	camTarget: [0, 0, 0],

	q1: [0,0,0,1],
	q2: [0,0,0,1],

	lineRenderer: null,
	gl: null,

	view: null,
	projection: null,

	visual_nlerp1: null,
	visual_nlerp2: null,
	visual_slerp: null
}

function MakeQuaternionVisual(lr, color) {
	const null_line = [
		0, 0, 0,
		0, 0, 0
	]

	return {
		quaternion: [0, 0, 0, 1],
		draw_normal: LR_MakeLine(lr, null_line, false),
		draw_plane:  LR_MakeLine(lr, null_line, true),
		draw_vector: LR_MakeLine(lr, null_line, false),
		normal_color: {
			r: color[0] * 0.5,
			g: color[1] * 0.5,
			b: color[2] * 0.5
		},
		plane_color: {
			r: color[0] * 0.5,
			g: color[1] * 0.5,
			b: color[2] * 0.5
		},
		vector_color: {
			r: color[0],
			g: color[1],
			b: color[2]
		}
	};
}

function UpdateQuaternionVisual(visualObject, quat, vector) {
	visualObject.quaternion = [quat[0], quat[1], quat[2], quat[3]]

	const n = V3_Normalize([quat[0], quat[1], quat[2]]);
	LR_UpdateLine(visualObject.draw_normal, [-n[0], -n[1], -n[2], n[0], n[1], n[2]]);

	LR_UpdateLine(visualObject.draw_plane, MakeDiskArray(n, 0.5))

	const v = Q_Mul_V3(quat, vector);
	LR_UpdateLine(visualObject.draw_vector, [0, 0, 0, v[0], v[1], v[2]]);
}

function DrawQuaternionVisual(visualObject, view, proj) {
	LR_DrawLine(visualObject.draw_normal, view, proj, visualObject.normal_color);
	LR_DrawLine(visualObject.draw_plane, view, proj, visualObject.plane_color);
	LR_DrawLine(visualObject.draw_vector, view, proj, visualObject.vector_color);
}

function main() {
	global_state.q1 = Q_AngleAxis(90, [1, 0, 0]) // TODO: Read these from input
	global_state.q2 = Q_AngleAxis(-90, [0, 1, 0])

	//global_state.q1 = Q_AngleAxis(90, [1, 0, 0]) // TODO: Read these from input
	//global_state.q2 = Q_AngleAxis(-90, [1, 0, 0])

	var gl = SetupWebGL();
    global_state.gl = gl;

	if (!gl) {
		return;
	}

	global_state.lineRenderer = LR_Init(gl);
	const lr = global_state.lineRenderer;

	const null_line = [
		0, 0, 0,
		0, 0, 0
	]

	global_state.visual_nlerp1 = MakeQuaternionVisual(lr, [1, 0, 0]);
	global_state.visual_nlerp2 = MakeQuaternionVisual(lr, [0, 1, 0]);
	global_state.visual_slerp = MakeQuaternionVisual(lr, [0, 0, 1]);

	// TODO: Call update camera
	global_state.projection = PerspectiveMatrix(60, 0.1, 500, global_state.gl.canvas.clientWidth / global_state.gl.canvas.clientHeight);
	global_state.view = LookAt(global_state.camPos, global_state.camTarget, [0, 1, 0]);
	// TODO: Call update simulation

	DrawScene();
}

function DrawScene() {
	global_state.gl.clear(global_state.gl.COLOR_BUFFER_BIT | global_state.gl.DEPTH_BUFFER_BIT);
	const view = global_state.view 
	const proj = global_state.projection

	DrawQuaternionVisual(global_state.visual_nlerp1, view, proj);
	DrawQuaternionVisual(global_state.visual_nlerp2, view, proj);
	DrawQuaternionVisual(global_state.visual_slerp, view, proj);
}

function SetupWebGL() {
	const canvas = document.querySelector("#glCanvas");
	const gl = canvas.getContext("webgl");

	if (!gl) {
		alert("Can't initialize Web GL! Consider this page broken!")
		return null
	}

	gl.clearColor(0.4, 0.5, 0.6, 1.0);

	gl.clearDepth(1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);

	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);

	return gl;
}

function PerspectiveMatrix(fov, zNear, zFar, aspect) {
	const tanHalfFov = Math.tan((fov * 0.5) * 0.0174533);
	const fovY = 1.0 / tanHalfFov; 
	const fovX = fovY / aspect; 
	const _33 = -(zFar / (zFar - zNear))
	const _43 = -((zFar * zNear) / (zFar - zNear));

	const result = [
		fovX, 0,    0,   0,
		0,    fovY, 0,   0,
		0,    0,    _33, -1,
		0,    0,    _43,   0
	];

	return result;
}

function LookAt(eye, at, up) {
	const zAxis = V3_Normalize([
		eye[0] - at[0],
		eye[1] - at[1],
		eye[2] - at[2]
	]);
	const xAxis = V3_Normalize(V3_Cross(zAxis, up));
	const yAxis = V3_Cross(xAxis, zAxis);

	const result = [
		xAxis[0], yAxis[0], zAxis[0], 0,
		xAxis[1], yAxis[1], zAxis[1], 0,
		xAxis[2], yAxis[2], zAxis[2], 0,
		-(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]), 
		-(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]),
		-(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]),
		1
	];

	return result;
}

function MakeDiskArray(normal, radius, centerPoint) {
	var point = centerPoint
	if (typeof centerPoint == "undefined" || centerPoint == null) {
		point = [0, 0, 0]
	} 

	const verts = [];
	normal = V3_Normalize(normal);

	const zero = [0, 0, 0]
	var perp = V3_Cross(normal, [0, 1, 0])
	if (V3_Equals(perp, zero)) {
		perp = V3_Cross(normal, [0, 0, 1])
		if (V3_Equals(perp, zero)) {
			perp = V3_Cross(normal, [1, 0, 0])
		}
	}

	var forward = V3_Cross(V3_Normalize(perp), normal)
	var right = V3_Cross(normal, forward);

	var v = right;
	var k = V3_Normalize(normal)

	for (var i = 0; i < 360; ++i) {
		var cos = Math.cos(i * 0.0174533)
		var sin = Math.sin(i * 0.0174533)

		// v' = (1 - cos)(v dot n)n + cos v + sin(n cross v)

		const p1 = V3_Scale(k, V3_Dot(k, v) * (1.0 - cos))
		const p2 = V3_Scale(v, cos)
		const p3 = V3_Scale(V3_Cross(k, v), sin)

		var vprime = 
		V3_Add(
			V3_Add(
				p1,
				p2
			),
		    p3
	    );

	    vprime = V3_Scale(V3_Normalize(vprime), radius)

	    verts.push(point[0] + vprime[0])
		verts.push(point[1] + vprime[1])
		verts.push(point[2] + vprime[2]);
	}

	return verts;
}

/* Line Renderer API
----------------
LineRenderer LR_Init(OpenGLContext gl)
LineObject LR_MakeLine(LineRenderer renderer, float[] lineArray, bool loop)
void LR_UpdateLine(LineObject object, float[] lineArray, bool loop)
void LR_DrawLine(LineObject object, Mat4 projection, Mat4 view, float[] color)
----------------
*/

function LR_Init(gl) {
	var lineRendererObject = {
		shader: null,
		gl: null
	}

	lineRendererObject.gl = gl;

	// Setup vertex Shader
	const vSource = `
		precision highp float;
		attribute vec3 position;

		uniform mat4 modelMatrix;
		uniform mat4 viewMatrix;
		uniform mat4 projectionMatrix;
		uniform vec4 renderColor;

		varying vec4 color; 

		void main() {
			color = renderColor;

			gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1);
		}
	`;	

	const vertex = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertex, vSource);
	gl.compileShader(vertex);

	if (!gl.getShaderParameter(vertex, gl.COMPILE_STATUS)) {
		alert("Can't compile vertex shader: " + gl.getShaderInfoLog(vertex));
		gl.deleteShader(vertex);
		return null;
	}

	// Setup fragment shader
	const fSource = `
		precision highp float;
		varying vec4 color; 

		void main() {
			gl_FragColor = color;
		}
	`;

	const fragment = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragment, fSource);
	gl.compileShader(fragment);

	if (!gl.getShaderParameter(fragment, gl.COMPILE_STATUS)) {
		alert("Can't compile fragment shader: " + gl.getShaderInfoLog(fragment));
		gl.deleteShader(fragment);
		return null;
	}

	// Setup actual program
	const program = gl.createProgram();
	gl.attachShader(program, vertex);
	gl.attachShader(program, fragment);
	gl.linkProgram(program);

	gl.deleteShader(vertex);
	gl.deleteShader(fragment);

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		alert("Can't link the shader: " + gl.getProgramInfoLog(program));
		return null;
	}

	lineRendererObject.shader = {
		id : program,
		attribs : {
			position: gl.getAttribLocation(program, "position")		
		},
		uniforms : {
			model: gl.getUniformLocation(program, "modelMatrix"),
			view: gl.getUniformLocation(program, "viewMatrix"),
			projection: gl.getUniformLocation(program, "projectionMatrix"),
			color: gl.getUniformLocation(program, "renderColor")
		}
	};

	return lineRendererObject;
}

function LR_MakeLine(lineRenderer, lineArray, loop) {
	if (typeof loop == "undefined" || loop == null) {
		loop = false
	}
	const gl = lineRenderer.gl;

	var arrayBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, arrayBuffer);

	var lineObject = {
		bufferId: arrayBuffer,
		count: lineArray.length / 3,
		numComponents: 3,
		type: gl.FLOAT,
		stride: 0,
		offset: 0,
		looping: loop,
		renderer: lineRenderer
	}
	
	LR_UpdateLine(lineObject, lineArray);

	return lineObject;
}

function LR_UpdateLine(lineObject, lineArray, loop) {
	if (typeof lineObject == "undefined" || lineObject == null) {
		console.log("Could not find line object");
	}
	else if (typeof lineObject.renderer == "undefined" || lineObject.renderer == null) {
		console.log("Could not find line renderer");
	}

	const gl = lineObject.renderer.gl;

	gl.bindBuffer(gl.ARRAY_BUFFER, lineObject.bufferId);
	lineObject.count =  lineArray.length / 3;

	if (typeof loop != "undefined" && loop != null) {
		lineObject.looping = loop;
	}

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineArray), gl.DYNAMIC_DRAW);
}

function LR_DrawLine(lineObject, projectionMatrix, viewMatrix, color) {
	if (typeof color == "undefined" || color == null) {
		color = {r:0,g:0,b:0}
	}
	else if (Array.isArray(color)) {
		color = {r:color[0],g:color[1],b:color[2]}
	}

	const gl = lineObject.renderer.gl;
	const shader = lineObject.renderer.shader;

	const modelMatrix = [
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]
	gl.bindBuffer(global_state.gl.ARRAY_BUFFER, lineObject.bufferId);
	gl.vertexAttribPointer(shader.attribs.position, lineObject.numComponents, lineObject.type, false, lineObject.stride, lineObject.offset);
	gl.enableVertexAttribArray(shader.attribs.position);

	gl.useProgram(shader.id);

	gl.uniformMatrix4fv(shader.uniforms.projection, false, global_state.projection);
	gl.uniformMatrix4fv(shader.uniforms.view, false, global_state.view);
	gl.uniformMatrix4fv(shader.uniforms.model, false, modelMatrix);
	gl.uniform4f(shader.uniforms.color, color.r, color.g, color.b, 1.0);

	const offset = 0;
	gl.drawArrays(lineObject.looping? global_state.gl.LINE_LOOP : global_state.gl.LINES, offset, lineObject.count)
}

</script>

</html>